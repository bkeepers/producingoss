<chapter id="social-infrastructure">

<title>Soziale und Politische Infrastruktur</title>

<simplesect>

<para>Die erste Frage, die Leute über freie Software fragen ist für
gewöhnlich "Wie funktioniert es? Was hält ein Projekt am laufen? Wer
trifft die Entscheidungen?" Ich bin immer unzufrieden mit den faden
Antworten über Meritokratie, der Geist der Zusammenarbeit, Code der
für sich selber spricht, usw. Tatsache ist, dass die Frage nicht so
leicht zu beantworten ist. Meritokratie, Zusammenarbeit und laufender
Code sind alle ein Teil davon, aber sie tragen wenig dazu bei, zu
erklären, wie Projekte wirklich auf einer täglichen basis laufen, und
sagen nichts darüber aus wie Konflikte gelöst werden.</para>

<para>Diese Kapitel versucht die Gemeinsamen strukturellen Grundsteine
welche erfolgreiche Projekte aufzuzeigen. Mit "erfolgreich, meine ich
nicht nur im sinne technischer Qualität, sondern auch was die 
betriebliche Gesundheit und Überlebensfähigkeit angeht. Die
betriebliche Gesundheit ist die andauernde Fähigkeit des Projekts neue
Code Beiträge und Entwickler aufzunehmen, sowie auf neue Bug Meldungen
reagieren zu können. Überlebensfähigkeit ist die Fähigkeit des 
Projekts, unabhängig von irgend einem Beteiligten oder Sponsor
fortbestehen zu können&mdash;betrachten Sie es als die 
Wahrscheinlichkeit, dass das Projekt weiter gehen würde selbst wenn
alle Gründungsmitglieder ihre Sachen packen würden und sich anderen
Sachen widmen würden. Technischer Erfolg ist nicht schwer zu erreichen,
aber ohne eine robusten Entwicklerbasis, kann ein Projekt vielleicht
nicht mit dem Wachstum welches anfänglicher Erfolg bringt, oder dem
Verlust charismatischer Individuen, zurechtkommen.</para>

<para>Es gibt verschiedene Wege diesen Art Erfolg zu erreichen. Manche
beinhalten eine formale Struktur der Regierung, womit Debatten
aufgelöst werden, neue Entwickler eingeladen werden (manchmal auch
ausgeladen), neue Funktionen geplant werden, usw. Andere beinhalten
weniger formelle Strukturen, aber bewusstere Zurückhaltung, um eine
Atmosphäre der Fairness herzustellen, auf das sich Leute verlassen
können als eine so gut wie echte Regierungsform. Beide Wege führen
zum gleichen Ergebnis: Das Gefühl einer beständigen Institution, 
welches von Gewohnheiten und Abläufen unterstützt werden, die alle
Beteiligten wohl verstehen. Diese Eigenschaften sind noch wichtiger
bei selbst organisierenden Systemen als bei zentral verwalteten, da
bei selbst organisierenden Systemen, jeder sich darüber im klaren ist,
das ein paar faule Äpfel die gesamte Obstschale verderben, zumindest
eine Zeit lang.</para>

<sect1 id="forkability">
<title>Forkability</title>

<para>Der Fork (de. Gabel im sinne von Aufspaltund)
Die unabdingbare Zutat, welche Entwickler in einem freien Software
Projekt zusammenbindet, und Sie Bereitwillig macht wenn Kompromisse 
nötig einzugehen, ist die <firstterm>Forkbarkeit</firstterm> des Codes:
Die Möglichkeit von jedem, eine Kopie des Quellcodes zu nehmen und ein
konkurierendes Projekt anzufangen, bekannt als <firstterm>Fork
</firstterm>. Das paradoxe daran ist, dass die <emphasis>Möglichkeit
</emphasis> eines Forks in freien Software Projekten für gewöhnlich 
ein viel größerer Antrieb ist, als wirkliche Forks welche sehr selten
sind. Da ein Fork schlecht für alle ist (aus Gründen, die in <xref 
linkend="forks"/><phrase output="printed"> im Kapitel <xref 
linkend="managing-volunteers"/></phrase> detaliert untersucht werden),
sind mehr Beteiligte dazu bereit Kompromisse einzugehen, wenn die
Gefahr eines Forks besteht.</para>

<para>Forks, oder vielmehr potentielle Forks, sind der Grund, dass es
keine wirklichen Diktatoren in freien Software Projekten gibt. Das mag
sich nach einer Überraschenden Behauptung anhören, wenn man bedenkt wie
gängig es ist das jemand ein "Diktator" oder "Tyrann" in einem 
beliebeigen Open Source Projekt genannt wird. Diese Art der Tyrannei 
ist aber besonders, recht unterschiedlich von dem gewöhnlichen 
Verständniss des Wortes. Stellen Sie sich einen König vor, dessen
Untergebenen sein Königreich jederzeit kopieren können und dort regieren
könnten wie sie es für angemessen halten. Würde solch ein König nicht
wesentlich anders regieren, als einer dessen Untergebenen an ihn
gebunden wären, egal was er tut?</para>

<para>Desshalb sind selbst Projekte die nicht formal wie Demokratieen
organisiert sind, in der Praxis, demokratieen, wenn es sich um wichtige
Entscheidungen dreht. Nachbildbarkeit impliziert auch Forkbarkeit;
Forkbarkeit imliziert Konsens. Es mag sein, das jeder dazu bereit ist
auf einen Anführer zu verweisen (das bekannteste Beispiel mag Linus
Torvalds bei der Entwicklung des Linux Kernels sein), aber nur 
desshalb, weil sie es sich so <emphasis>ausgesucht</emphasis> haben, 
auf eine komplett nicht zynische oder unheimliche Art. Der Diktator
hat keinen magischen Einfluss auf das Projekt. Eine 
Schlüsseleigenschaft aller Open Source Lizenzen ist, dass sie keiner
einzelnen Partei, bezüglich Entscheidungen wie Code geändert oder 
benutzt werden kann, mehr Macht geben als einer anderen. Wenn der
Diktator plötzlich anfangen würde schlechte Entscheidugen zu treffen,
gäbe es unruhe, letzendlich gefolgt von einem Aufstand und einem Fork.
So weit kommt es aber meißtens nicht, da der Diktator vorher 
Kompromisse eingeht.</para>

<para>Nur weil die Forkbarkeit eine obere Grenze vorgibt, wieviel
Macht jeder einzelne ausüben kann, bedeutet es aber nicht, dass es
nicht wesentliche Unterschiede gibt, wie Projekte regiert werden.
Sie wollen nicht, dass jede Entscheidung auf die Frage hinausläuft,
wer bereit ist einen Fork zu machen. Das würde sehr schnell ermüdend
werden, und Energie von echter Arbeit wegreißen. Die nächsten beiden
Abschnitte untersuchen, die verschiedenen Wege Projekte so zu 
organisieren, dass die meisten Entscheidungen reibungslos verlaufen.
Diese beiden Beispiele sind etwas idealisierte Grenzfälle; viele
Projekte fallen irgendwo zwischen ihnen.</para>

</sect1>

</simplesect>

<!-- ======================== SECTION ============================== -->
<sect1 id="benevolant-dictator">
<title>Gütige Diktatoren</title>

<para>Das Modell des <firstterm>gütigen Diktators</firstterm> ist genau
das, wonach es sich anhört: Die letztendliche Entscheidungsgewalt liegt 
bei einer Person, welcher, von dem, aufgrund seiner Persönlichkeit und 
Erfahrung, erwartet wird, dass er es weise benutzt.</para>

<para>Auch wenn der Begriff "gütige Diktator" im Englischen bekannt als
"benevolent dictator" und dort der standardmäßige Begriff für diese 
Rolle ist, wäre es besser ihn als einen von der Gemeinschaft 
anerkannten Vermittler oder Richter zu betrachten. Im Allgemeinen,
treffen gütige Diktatoren nicht alle Entscheidungen oder auch nur die
meisten Entscheidungen. Es ist sowieso unwahrscheinlich, dass eine
Person genug Kentnisse haben könnte, um in einem gesamten Projekt
durchweg gute Entscheidungen treffen zu können. hochwertige Entwickler
werden sich nicht lange am Projekt beteiligen, wenn sie nicht zumindest
einen Stück weit, Einfluß auf die Richtung des Projekts haben. 
Desshalb diktieren gütige Diktatoren nicht besonders viel. Statt 
dessen, lassen sie wann immer Möglich die Sachen sich von alleine 
durch Diskussionen oder Erprobung erledigen. Sie nehmen selber an 
diesen Diskussionen teil, aber als gewöhnliche Entwickler, oftmals
verweisen sie auf einen Zuständigen für bestimmte Bereiche die mehr
Kentnisse haben. Nur wenn es klar ist, dass es kein Konsens erreicht
werden kann, und das der größte Teil der Gruppe von jemandem
<emphasis>will</emphasis>, dass die Entscheidung Geleitet wird, damit
die Entwicklung weiter gehen kann, sprechen sie ein Machtwort und
sagen "So wird das jetzt gemacht". Der Widerwille Entscheidungen
durch Gebote zu treffen ist eine Wesenszug welche praktisch alle
erfolgreichen gütigen Diktatoren teilen; es ist eines der Gründe, 
warum sie es schaffen diese Rolle zu behalten.</para>

<sect2 id="benevolant-dictator-qualifications">
<title>Wer kann ein gütiger Diktator sein?</title>

<para>Ein gütiger Diktator erfordert eine Reihe von Wesenszügen. Es
bedarf erstens eine fein sinigges Gespür für den eigenen Einfluss im
Projekt, welche wiederum Zurückhaltung mit sich bringt. In den frühen
Phasen einer Diskussion, sollte man nicht seine Meinungen und 
Folgerungen mit einer solchen sicherheit ausdrücken, dass andere das
Gefühl bekommen, dass es sinnlos ist zu widersprechen. Menschen 
sollten die freiheit haben ihre Ideen auszudrücken, selbst blöde Ideen.
Es ist natürlich unvermeidlich, dass der gütige Diktator von Zeit zu 
Zeit eine blöde Idee abgeben wird, und die Rolle erfordert desshalb
auch die Fähigkeit zu erkennen und zu würdigen, dass man eine falsche
Entscheidung getroffen hat&mdash;wobei das ein Wesenszug ist welches
<emphasis>alle</emphasis> gut Entwickler aufweisen sollten, 
insbesondere wenn sie lange beim Projekt bleiben. Der Unterschied ist
aber, dass der gütige Diktator ohne sich über die Langzeitschäden an
ihrem Ruf all zu viele Sorgen machen zu müssen. Entwickler die nicht
so lang beteiligt sind, können sich weniger sicher fühlen, also sollte
der gütige Diktator seine Kritiken oder entgegengesetzten 
Entscheidungen mit etwas Gespür für das Gewicht seiner Worte, wowohl
technisch als auch psychologisch.</para>

<para>Der gütige Diktator muss <emphasis>nicht</emphasis> die besten
technischen Fähigkeiten von allen im Projekt haben. Er muss lediglich
gut genug sein, am Code selber zu arbeiten, und einen Kommentar zu
einer Änderung welches unter betrachtung steht, verstehen zu können,
das ist aber auch schon alles. Die Position des gütigen Diktators kann
man sich weder aneignen, noch behalten mittels einschüchternen
Programmierfähigkeiten. <emphasis>Wirklich</emphasis> wichtig ist
Erfahrung und einen übergreifendes Gefühl für Desing&mdash;nicht
unbedingt die Fähigkeit gutes Design auf Kommando zu produzieren,
sondern die Fähigkeit sie zu erkennen, unabhängig von der Quelle.</para>

<para>Es ist verbreitet, dass der gütige Diktator auch der Gründer des
Projekts ist, was aber eher ein Zusammenhang als eine Ursache ist. Die
Qualitäten die einen ermöglichen ein Projekt erfolgreich anzufangen
&mdash;technische Kompetenz, die Fähigeit andere überzeugen zu können
mit zu machen, usw.&mdash;sind genau die gleichen Qualitäten welche
jeder gütiger Diktator besitzen müsste. Natürlich haben die Gründer
sozusagen automatisch ein gewisses Betriebsalter, was genug sein kann
um eine gütige Diktatur, für alle Beteiligten, als den Weg des 
geringsten Widerstands erscheinen zu lassen.</para>

<para>Denken Sie daran, dass das Potential eines Forks in beiden
Richtungen geht. Ein gütiger Diktator kann genau so gut wie jeder 
andere einen Fork machen kann, und gelegentlich ist das auch passiert,
als sie das Gefühl bekamen, dass die Richtung in der sie das Projekt
führen wollten eine andere war, als die Mehrheit der anderen 
Entwickler. Aufgrund der Forkbarkeit, macht es keinen Unterschied,
ob der gütige Diktator root (de. Administrator) Zugriff auf die 
Hauptserver des Projekts hat oder nicht. Leute reden machnachmal vom
Zugriff auf die Server als ob es die ultimative Quelle von Macht in
einem Projekt wäre, tatsächlich ist es aber bedeutungslos. Die 
Fähigkeit die commit Passwörter von Beteiligten hinzuzufügen oder zu
entfernen, beeinflusst nur die Kopie des Projekts welches auf dem 
Server liegt. Anhaltender Missbrauch dieser Macht, ob von dem gütigen
Diktator oder jemand anderem, würde einfach zum Umzug der Entwicklung
auf einen anderen Server führen.</para>

</sect2>

<para>Ob Ihr Projekt einen gütigen Diktator haben sollte oder besser
laufen würde mit einem zentralisierten System, hängt größtenteils 
davon ab, wer für die Rolle verfügbar ist. Als Faustregel kann man
nehmen, dass wenn es einfach offensichtlich für jeden ist, wer der
gütige Diktator sein sollte, dann ist das der richtige Weg. Wenn
aber kein Kanidat gleich offentsichtlich ist, dann sollte das Projekt
wahrscheinlich ein zentralisiertes System für Entscheidungen, wie im
nächsten Abschnitt beschrieben nehmen.</para>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="consensus-democracy">
<title>Konsens basierte Demokratie</title>

<para>Mit zunehmenden alter des Projekts, neigt man dazu weg von dem
Modell des gütigen Diktators wegzugehen, hin zu offeneren 
demokratischen Systemen. Das ist nicht zwangsläufig aufgrund von
Unzufriedenheit mit einem bestimmte gütigen Diktator. Es ist einfach
nur, dass ein Regierungssystem welches auf eine Gruppe basiert,
"evolutionär stabiler" ist, um mal eine Metapher aus der Biologie zu
entleihen. Immer dann, wann ein gütiger Diktator zurücktritt, oder
versucht die Entscheidungsgewalt gleichmäßiger zu verteilen, ist das
eine Gelegenheit für die Gruppe, sich auf ein neues nicht 
diktatorisches System zu einigen&mdash;sozusagen eine Verfassung 
einführen. Die Gruppe wird vielleicht nicht beim ersten oder zweiten
Mal diese Gelegenheit wahrnehmen, leztendlich werden sie es aber;
sobald sie es tun, ist es unwahrscheinlich, dass es jehmals rückgängig
gemacht wird. Das lässt sich durch Vernunft erklären: Wenn eine Gruppe
bestehend aus N Personen in einer bestimmten Person, würde das 
bedeuten, dass N&nbsp;-&nbsp;1 Personen jeder sich damit einverstanden
erklären würde, seinen eigenen Einfluss zu verringern. Menschen wollen
das im allgemeinen. Selbst wenn sie es täten, wäre die entstandene
Diktatur trotzdem nur bedingt: Ein von der Gruppe gesalbter gütiger
Diktator, kann genau so gut von der Gruppe wieder abgesetzt werden.
Sobald ein Projekt von der Führung durch einer einzelnen charismatischen
Person, hin zu einem formaleren, System basierend auf der Gruppe, geht
es selten zurück.</para>

<para>Die Einzelheiten wie diese Systeme funktionieren varieren zwar
erheblich, es gibt aber zwei Gemeinsamkeiten: Erstens, die Gruppe
funktioniert meistens mittels Konsens; zweitens, es gibt eine formale
Einrichtung zur Abstimmung gibt, auf der man zurückgreifen kann, wenn
Konsens nicht erreicht werden kann.</para>

<para><firstterm>Konsens</firstterm> beduetet lediglich eine 
Vereinbarung mit der jeder leben kann. Es ist kein mehrdeutiger 
Zustand: eine Gruppe had Konsens erreicht, wenn jemand vorschlägt,
dass es erreicht wurde und keiner widerspricht, und welche Tätigkeiten
als Folge daraus durchgeführt würden, wenn sie nicht schon 
offensichtlich sind.</para>

<para>Die meisten Unterhaltungen in einem Projekt sind über technische
Themen, wie der richtige Weg einen Bug zu beheben, ob eine neue 
Funktion hinzugefügt werden soll oder nicht, wie streng man 
Schnittstellen dokumentieren soll, usw. Regierungen basierend auf
Konsens funktionieren desshalb gut, da sie nahtlos mit der technischen
Diskussion selst verläuft. Bis zum ende der Diskussion, gibt es oft
eine allgemeine Übereinstimung darüber welchen kurs zu nehmen. Für
gewöhnlich schreibt jemand eine abschließende Nachricht was auch
gleichzeitig eine Zusammenfassung der Entscheidungen und ein
impliziter Konsens Vorschlag. Das gibt eine letzte Möglichkeit
für jemand anderes zu sagen "Warte, dazu habe ich nicht zugestimmt.
Wir müssen das noch ein wenig kleinhacken".</para>

<para>For small, uncontroversial decisions, the proposal of consensus
is implicit.  For example, when a developer spontaneously commits a
bugfix, the commit itself is a proposal of consensus: "I assume we all
agree that this bug needs to be fixed, and that this is the way to fix
it."  Of course, the developer does not actually say that; she just
commits the fix, and the others in the project do not bother to state
their agreement, because silence is consent.  If someone commits a
change that turns out <emphasis>not</emphasis> to have consensus, the
result is simply for the project to discuss the change as though it
had not already been committed.  The reason this works is the topic of
the next section.</para>

<sect2 id="version-control-relaxation">
<title>Version Control Means You Can Relax</title>

<para>The fact that the project's source code is kept under version
control means that most decisions can be easily unmade.  The most
common way this happens is that someone commits a change mistakenly
thinking everyone would be happy with it, only to be met with
objections after the fact.  It is typical for such objections to start
out with an obligatory apology for having missed out on prior
discussion, though this may be omitted if the objector finds no record
of such a discussion in the mailing list archives.  Either way, there
is no reason for the tone of the discussion to be different after the
change has been committed than before.  Any change can be reverted, at
least until dependent changes are introduced (i.e., new code that
would break if the original change were suddenly removed).  The
version control system gives the project a way to undo the effects of
bad or hasty judgement.  This, in turn, frees people to trust their
instincts about how much feedback is necessary before doing
something.</para>

<para>This also means that the process of establishing consensus need
not be very formal.  Most projects handle it by feel.  Minor changes
can go in with no discussion, or with minimal discussion followed by a
few nods of agreement.  For more significant changes, especially ones
with the potential to destabilize a lot of code, people should wait a
day or two before assuming there is consensus, the rationale being
that no one should be marginalized in an important conversation simply
because he didn't check email frequently enough.</para>

<para>Thus, when someone is confident he knows what needs to be done,
he should just go ahead and do it.  This applies not only to software
fixes, but to web site updates, documentation changes, and anything
else unlikely to be controversial.  Usually there will be only a few
instances where an action needs to be undone, and these can be handled on
a case-by-case basis.  Of course, one shouldn't encourage people to be
headstrong.  There is still a psychological difference between a
decision under discussion and one that has already taken effect, even
if it is technically reversible.  People always feel that momentum is
allied to action, and will be slightly more reluctant to revert a
change than to prevent it in the first place.  If a developer abuses
this fact by committing potentially controversial changes too quickly,
however, people can and should complain, and hold that developer to a
stricter standard until things improve.</para>

</sect2>

<sect2 id="voting">
<title>When Consensus Cannot Be Reached, Vote</title>

<para>Inevitably, some debates just won't consense.  When all other
means of breaking a deadlock fail, the solution is to vote.  But
before a vote can be taken, there must be a clear set of choices on
the ballot.  Here, again, the normal process of technical discussion
blends serendipitously with the project's decision-making procedures.
The kinds of questions that come to a vote often involve complex,
multifaceted issues.  In any such complex discussion, there are
usually one or two people playing the role of <firstterm>honest
broker</firstterm>: posting periodic summaries of the various
arguments and keeping track of where the core points of disagreement
(and agreement) lie.  These summaries help everyone measure how much
progress has been made, and remind everyone of what issues remain to
be addressed.  Those same summaries can serve as prototypes for a
ballot sheet, should a vote become necessary.  If the honest brokers
have been doing their job well, they will be able to credibly call for
a vote when the time comes, and the group will be willing to use a
ballot sheet based on their summary of the issues.  The brokers
themselves may be participants in the debate; it is not necessary for
them to remain above the fray, as long as they can understand and
fairly represent others' views, and not let their partisan sentiments
prevent them from summarizing the state of the debate in a neutral
fashion.</para>

<para>The actual content of the ballot is usually not controversial.
By the time matters reach a vote, the disagreement has usually boiled
down to a few key issues, with recognizable labels and brief
descriptions.  Occasionally a developer will object to the form of the
ballot itself.  Sometimes his concern is legitimate, for example,
that an important choice was left off or not described accurately.
But other times a developer may be merely trying to stave off the
inevitable, perhaps knowing that the vote probably won't go his way.
See <xref linkend="difficult-people"/><phrase output="printed">
in <xref linkend="communications"/></phrase> for how to deal with
this sort of obstructionism.</para>

<para>Remember to specify the voting system, as there are many
different kinds, and people might make wrong assumptions about which
procedure is being used.  A good choice in most cases is
<firstterm>approval voting</firstterm>, whereby each voter can vote
for as many of the choices on the ballot as he likes.  Approval
voting is simple to explain and to count, and unlike some other
methods, it only involves one round of voting.  See <ulink
url="http://en.wikipedia.org/wiki/Voting_system#List_of_systems"/> for
more details about approval voting and other voting systems, but try
to avoid getting into a long debate about which voting system to use
(because, of course, you will then find yourself in a debate about
which voting system to use to decide the voting system!).  One reason
approval voting is a good choice is that it's very hard for anyone to
object to&mdash;it's about as fair as a voting system can be.</para>

<para>Finally, conduct votes in public.  There is no need for secrecy
or anonymity in a vote on matters that have been debated publicly
anyway.  Have each participant post her votes to the project mailing
list, so that any observer can tally and check the results for
herself, and so that everything is recorded in the archives.</para>

</sect2>

<sect2 id="when-to-vote">
<title>When To Vote</title>

<para>The hardest thing about voting is determining when to do it.  In
general, taking a vote should be very rare&mdash;a last resort for
when all other options have failed.  Don't think of voting as a great
way to resolve debates.  It isn't.  It ends discussion, and thereby
ends creative thinking about the problem.  As long as discussion
continues, there is the possibility that someone will come up with a
new solution everyone likes.  This happens surprisingly often: a
lively debate can produce a new way of thinking about the problem, and
lead to a proposal that eventually satisfies everyone.  Even when no
new proposal arises, it's still usually better to broker a compromise
than to hold a vote.  After a compromise, everyone is a little bit
unhappy, whereas after a vote, some people are unhappy while others
are happy.  From a political standpoint, the former sitation is
preferable: at least each person can feel he extracted a price for his
unhappiness.  He may be dissatisfied, but so is everyone else.</para>

<para>Voting's main advantage is that it finally settles a question so
everyone can move on.  But it settles it by a head count, instead of
by rational dialogue leading everyone to the same conclusion.  The
more experienced people are with open source projects, the less eager
I find them to be to settle questions by vote.  Instead they will try
to explore previously unconsidered solutions, or compromise more
severely than they'd originally planned.  Various techniques are
available to prevent a premature vote.  The most obvious is simply to
say "I don't think we're ready for a vote yet," and explain why not.
Another is to ask for an informal (non-binding) show of hands.  If the
response clearly tends toward one side or another, this will make some
people suddenly more willing to compromise, obviating the need for a
formal vote.  But the most effective way is simply to offer a new
solution, or a new viewpoint on an old suggestion, so that people
re-engage with the issues instead of merely repeating the same
arguments.</para>

<para>In certain rare cases, everyone may agree that all the
compromise solutions are worse than any of the non-compromise ones.
When that happens, voting is less objectionable, both because it is
more likely to lead to a superior solution and because people will not
be overly unhappy no matter how it turns out.  Even then, the vote
should not be rushed.  The discussion leading up to a vote is what
educates the electorate, so stopping that discussion early can lower
the quality of the result.</para>

<para>(Note that this advice to be reluctant to call votes does not
apply to the change-inclusion voting described in
<xref linkend="stabilizing-a-release"/><phrase output="printed">
in <xref linkend="development-cycle"/></phrase>.  There, voting
is more of a communications mechanism, a means of registering one's
involvement in the change review process so that everyone can tell how
much review a given change has received.)</para>

</sect2>

<sect2 id="electorate">
<title>Who Votes?</title>

<para>Having a voting system raises the question of electorate: who
gets to vote?  This has the potential to be a sensitive issue, because
it forces the project to officially recognize some people as being
more involved, or as having better judgement, than others.</para>

<para>The best solution is to simply take an existing distinction,
commit access, and attach voting privileges to it.  In projects that
offer both full and partial commit access, the question of whether
partial committers can vote largely depends on the process by which
partial commit access is granted.  If the project hands it out
liberally, for example as a way of maintaining many third-party
contributed tools in the repository, then it should be made clear that
partial commit access is really just about committing, not voting.
The reverse implication naturally holds as well: since full committers
<emphasis>will</emphasis> have voting privileges, they must be chosen
not only as programmers, but as members of the electorate.  If someone
shows disruptive or obstructionist tendencies on the mailing list, the
group should be very cautious about making him a committer, even if
the person is technically skilled.</para>

<para>The voting system itself should be used to choose new
committers, both full and partial.  But here is one of the rare
instances where secrecy is appropriate.  You can't have votes about
potential committers posted to a public mailing list, because the
candidate's feelings (and reputation) could be hurt.  Instead, the
usual way is that an existing committer posts to a private mailing
list consisting only of the other committers, proposing that someone
be granted commit access.  The other committers speak their minds
freely, knowing the discussion is private.  Often there will be no
disagreement, and therefore no vote necessary.  After waiting a few
days to make sure every committer has had a chance to respond, the
proposer mails the candidate and offers him commit access.  If there
is disagreement, discussion ensues as for any other question, possibly
resulting in a vote.  For this process to be open and frank, the mere
fact that the discussion is taking place at all should be secret.  If
the person under consideration knew it was going on, and then were
never offered commit access, he could conclude that he had lost
the vote, and would likely feel hurt.  Of course, if someone
explicitly asks for commit access, then there is no choice but to
consider the proposal and explicitly accept or reject him.  If the
latter, then it should be done as politely as possible, with a clear
explanation: "We liked your patches, but haven't seen enough of them
yet," or "We appreciate all your patches, but they required
considerable adjustments before they could be applied, so we don't
feel comfortable giving you commit access yet.  We hope that this will
change over time, though."  Remember, what you're saying could come as
a blow, depending on the person's level of confidence.  Try to see it
from their point of view as you write the mail.</para>

<para>Because adding a new committer is more consequential than most
other one-time decisions, some projects have special requirements for
the vote.  For example, they may require that the proposal receive at
least <emphasis>n</emphasis> positive votes and no negative votes, or
that a supermajority vote in favor.  The exact parameters are not
important; the main idea is to get the group to be careful about
adding new committers.  Similar, or even stricter, special requirements
can apply to votes to <emphasis>remove</emphasis> a committer, though
hopefully that will never be necessary.  See <xref
linkend="committers"/><phrase output="printed"> in
<xref linkend="managing-volunteers"/></phrase> for more on the
non-voting aspects of adding and removing committers.</para>

</sect2>

<sect2 id="polls">
<title>Polls Versus Votes</title>

<para>For certain kinds of votes, it may be useful to expand the
electorate. For example, if the developers simply can't figure out
whether a given interface choice matches the way people actually use
the software, one solution is to ask to all the subscribers of the
project's mailing lists to vote.  These are really
<firstterm>polls</firstterm> rather than votes, but the developers may
choose to treat the result as binding.  As with any poll, be sure to
make it clear to the participants that there's a write-in option: if
someone thinks of a better option not offered in the poll questions,
her response may turn out to be the most important result of the
poll.</para>

</sect2>

<sect2 id="veto">
<title>Vetoes</title>

<para>Some projects allow a special kind of vote known as a
<firstterm>veto</firstterm>.  A veto is a way for a developer to put a
halt to a hasty or ill-considered change, at least long enough for
everyone to discuss it more.  Think of a veto as somewhere between a
very strong objection and a filibuster.  Its exact meaning varies from
one project to another.  Some projects make it very difficult to
override a veto; others allow them to be overridden by regular
majority vote, perhaps after an enforced delay for more discussion.
Any veto should be accompanied by a thorough explanation; a veto
without such an explanation should be considered invalid on
arrival.</para>

<para>With vetoes comes the problem of veto abuse.  Sometimes
developers are too eager to raise the stakes by casting a veto, when
really all that was called for was more discussion.  You can prevent
veto abuse by being very reluctant to use vetoes yourself, and by
gently calling it out when someone else uses her veto too often.  If
necessary, you can also remind the group that vetoes are binding for
only as long as the group agrees they are&mdash;after all, if a
clear majority of developers wants X, then X is going to happen one
way or another.  Either the vetoing developer will back down, or the
group will decide to weaken the meaning of a veto.</para>

<para>You may see people write "-1" to express a veto.  This usage
comes from the Apache Software Foundation, which has a highly
structured voting and veto process, described at <ulink
url="http://www.apache.org/foundation/voting.html"/>.  The Apache
standards have spread to other projects, and you will see their
conventions used to varying degrees in a lot of places in the open
source world.  Technically, "-1" does not always indicate a formal
veto even according to the Apache standards, but informally it is
usually taken to mean a veto, or at least a very strong
objection.</para>

<para>Like votes, vetoes can apply retroactively.  It's not okay to
object to a veto on the grounds that the change in question has
already been committed, or the action taken (unless it's something
irrevocable, like putting out a press release).  On the other hand, a
veto that arrives weeks or months late isn't likely to be taken very
seriously, nor should it be.</para>

</sect2>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="written-rules">
<title>Writing It All Down</title>

<para>At some point, the number of conventions and agreements floating
around in your project may become so great that you need to record it
somewhere.  In order to give such a document legitimacy, make it clear
that it is based on mailing list discussions and on agreements already
in effect.  As you compose it, refer to the relevant threads in the
mailing list archives, and whenever there's a point you're not sure
about, ask again.  The document should not contain any surprises: it
is not the source of the agreements, it is merely a description of
them.  Of course, if it is successful, people will start citing it as
a source of authority in itself, but that just means it reflects the
overall will of the group accurately.</para>

<para>This is the document alluded to in <xref
linkend="developer-guidelines"/><phrase output="printed"> in
<xref linkend="getting-started"/></phrase>.  Naturally, when the
project is very young, you will have to lay down guidelines without
the benefit of a long project history to draw on.  But as the
development community matures, you can adjust the language to reflect
the way things actually turn out.</para>

<para>Don't try to be comprehensive.  No document can capture
everything people need to know about participating in a project.  Many
of the conventions a project evolves remain forever unspoken, never
mentioned explicitly, yet adhered to by all.  Other things are simply
too obvious to be mentioned, and would only distract from important
but non-obvious material.  For example, there's no point writing
guidelines like "Be polite and respectful to others on the mailing
lists, and don't start flame wars," or "Write clean, readable bug-free
code."  Of course these things are desirable, but since there's no
conceivable universe in which they might <emphasis>not</emphasis> be
desirable, they are not worth mentioning.  If people are being rude on
the mailing list, or writing buggy code, they're not going to stop
just because the project guidelines said to.  Such situations need to
be dealt with as they arise, not by blanket admonitions to be good.
On the other hand, if the project has specific guidelines about
<emphasis>how</emphasis> to write good code, such as rules about
documenting every API in a certain format, then those guidelines
should be written down as completely as possible.</para>

<para>A good way to determine what to include is to base the document
on the questions that newcomers ask most often, and on the complaints
experienced developers make most often.  This doesn't necessarily mean
it should turn into a FAQ sheet&mdash;it probably needs a more
coherent narrative structure than FAQs can offer.  But it should
follow the same reality-based principle of addressing the issues that
actually arise, rather than those you anticipate might arise.</para>

<para>If the project is a benevolent dictatorship, or has officers
endowed with special powers (president, chair, whatever), then the
document is also a good opportunity to codify succession procedures.
Sometimes this can be as simple as naming specific people as
replacements in case the BD suddenly leaves the project for any
reason.  Generally, if there is a BD, only the BD can get away with
naming a successor.  If there are elected officers, then the
nomination and election procedure that was used to choose them in the
first place should be described in the document.  If there was no
procedure originally, then get consensus on a procedure on the mailing
lists <emphasis>before</emphasis> writing about it.  People can
sometimes be touchy about hierarchical structures, so the subject
needs to be approached with sensitivity.</para>

<para>Perhaps the most important thing is to make it clear that the
rules can be reconsidered.  If the conventions described in the
document start to hamper the project, remind everyone that it is
supposed to be a living reflection of the group's intentions, not a
source of frustration and blockage.  If someone makes a habit of
inappropriately asking for rules to be reconsidered every time the
rules get in her way, you don't always need to debate it with
her&mdash;sometimes silence is the best tactic.  If other people
agree with the complaints, they'll chime in, and it will be obvious
that something needs to change.  If no one else agrees, then the
person won't get much response, and the rules will stay as they
are.</para>

<para>Two good examples of project guidelines are the Subversion
<filename>hacking.html</filename> file, at <ulink
url="http://svn.collab.net/repos/svn/trunk/www/hacking.html"/>, and the Apache
Software Foundation governance documents, at <ulink
url="http://www.apache.org/foundation/how-it-works.html"/> and <ulink
url="http://www.apache.org/foundation/voting.html"/>.  The ASF is
really a collection of software projects, legally organized as a
nonprofit corporation, so its documents tend to describe governance
procedures more than development conventions.  They're still worth
reading, though, because they represent the accumulated experience of
a lot of open source projects.</para>

</sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
