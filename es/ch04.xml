<chapter id="social-infrastructure">

<title>Infraestructura Sociopolítica</title>

<simplesect>

<para>Las primeras preguntas que la gente se hace sobre el software libre son &quot;¿Cómo funciona?  ¿Cómo se mantiene el proyecto?  ¿Quién toma las decisiones?  Siempre quedo insatisfecho con respuestas conciliadoras sobre la estima del mérito, el espíritu de cooperación, el código que se expresa por si mismo, etc. El caso es que sobre esto no hay una respuesta fácil.  La meritocracia, la cooperación, y un código que funciona son partes de ella, pero aportan muy poco para explicar como funciona realmente un proyecto en el andar de todos los días, y nada dice sobre cómo se resuelven los conflictos.</para>

<para>Este capítulo trata de mostrar la estructura subyacente que los proyectos exitosos tienen en comun.  Me refiero con el término &quot;exitosos&quot; no solamente a la calidad técnica, sino también a la salud operacional y la capacidad de sobrevivencia.  La salud operacional es la capacidad efectiva del proyecto de incorporar las contribuciones de nuevos códigos y nuevos desarrolladores, y de asumir la responsabilidad de los informes de errores que ingresan.  Capacidad de sobrevivencia es la posibilidad de que el proyecto exista independientemente de algún participante o suspiciante en particular&mdash; tómelo como la posibilidad que tiene el proyecto para contiuar aún cuando alguno de sus miembros fundadores tuviera que pasar a ocuparse de otras cosas.  El éxito técnico no es difícil de alcanzar, pero sin una base robusta de desarrollo y un fundamento social, un proyecto puede resultar incapaz de manejar el crecimiento que el éxito inicial aporta, o la ausencia de algún individuo carismático.</para>

<para>Hay varias maneras de alcanzar este tipo de éxito.  Algunas suponen una estructura formal de supervisión, por la que se resuelven los debates, se aceptan (o rechazan) nuevos desarrolladores, se planifican nuevas características, etc.  Otras requieren menos estructura formal, pero más aplicación en conciencia, para producir una atmósfera de armonía en la que la gente puede confiar como una forma<foreignphrase>de facto</foreignphrase> de supervisión.  Ambos caminos llevan al mismo resultado: un sentido de permanencia institucional, ayudado por los hábitos y procedimientos que son bien comprendidos por todos los que participan.  Estas características son todavía más importantes en los sistemas que se organizan a si mismos que en aquellos que están controlados centralmente, porque en los sistemas que se organizan a si mismos, cada uno es conciente que unas pocas manzanas pueden arruinar todo el cajón, al menos por un tiempo.</para>

<sect1 id="forkability">
<title>Forkability</title>

<para>El ingrediente indispensable que une a los desarrolladores en un proyecto de software libre, y que los lleva a comprometerse cuando es necesario es la <firstterm>&quot;forkabilidad&quot;</firstterm> del código:  la capacidad de cada uno de tomar una copia del código fuente y usarlo para abrir un proyecto que compita con el original, evento que se conoce como <firstterm>&quot;fork&quot;</firstterm>. Lo que aparece como paradójico aquí es que <emphasis>la posibilidad</emphasis> de los &quot;forks&quot; es una fueza mucho mayor en los proyectos de software libre que los &quot;forks&quot; reales, los que son muy raros.   Puesto que un &quot;fork&quot; es malo para todos (por razones que se examinan en detalle en <xref linkend="forks"/><phrase output="printed"> en <xref linkend="managing-volunteers"/></phrase>), cuanto más seria sea la amenaza de un &quot;fork&quot;, tanto mas son las personas que se comprometen a evitarlo.</para>

<para>Los &quot;forks&quot;, o más bien la posibilidad de que se produzca un &quot;fork&quot;, es la razón por la cual no hay verdaderos dictadores en los proyectos de software libre.  Esto puede ser una expresión sorprendente, considerando que es muy común oir que alguien es llamado el &quot;dictador&quot; o el &quot;tirano&quot; en algún proyecto de fuente abierta.  Pero esta tiranía es especial, muy diferente de lo que comunmente se entiende por esa palabra.  Imaginaos un rey cuyos súbditos pudieran copiar todo su reino en cualquier momento y transladarse a la copia para governarla como creen que corresponde.  ¿No sería el gobierno de ese rey muy diferente de otro cuyos súbditos están obligados a permanecer bajo su gobierno, sin importar lo que él haga?</para>

<para>Por esta razón aún aquellos proyectos que no están organizados formalmente como democracias, son en la práctica democracias en el momento en que se toman las decisiones importantes.  La replicabilidad incluye a la &quot;forkability&quot;; &quot;forkability&quot; incluye al consenso.  Podría bien darse el caso de que todos quieran apoyarse en un lider (el ejemplo más famoso es el de Linus Torvalds durante el desarrollo del kernel de Linux), pero esto es porque ellos <emphasis>así lo eligen</emphasis>, de una manera ajena a todo cinicismo y en una forma no siniestra.  El dictador no tiene un dominio mágico sobre el proyecto.  Una propiedad de todas las licencias de fuente abierta es que no se le da a una parte más poder que a cualquier otra para decidir cómo se debe usar o cambiar el código.  Si el dictador de repente comenzara a tomar malas decisiones, se produciría una agitación, seguida eventualmente por un levantamiento y por un &quot;fork&quot;.  Exepto que, por supuesto, muy rara vez las cosas llegan tan lejos, porque antes el dictador busca soluciones de compromiso.</para>

<para>Pero, sólo porque la forkability pone un límite al abuso de poder que uno puede ejercer en un proyecto, eso no quiere decir que no hayan diferencias importantes en el modo como se gobiernan los proyectos.  Nadie desea que en todas las decisiones se llegue a la pregunta de última instancia de quien está considerando un fork.  Eso pasaría rápidamente a ser muy cansador, restando energía necesaria para el trabajo efectivo.  Las dos secciones que siguen examinan los modos de organizar los proyectos para que la mayoría de las decisiones se tomen naturalmente.  Estos dos ejemplos son los casos extremos idealizados; muchos proyectos quedan de alguna manera incluídos entre esos casos.</para>

</sect1>

</simplesect>

<!-- ======================== SECTION ============================== -->
<sect1 id="benevolent-dictator">
<title>Dictadores Benevolentes</title>

<para>El modelo de un <firstterm>dictador benevolente</firstterm> es precisamente lo que se describe así: La autoridad final de la toma de decisiones reside en una persona, de quien se espera que, por la fuerza de su personalidad o experiencia, la use sabiamente.</para> 

<para>Auque el término estándar de esta función es &quot;dictador benévolo&quot; (o <firstterm>DB</firstterm>), sería mejor que lo imaginemos como un &quot;árbitro aprobado por la comunidad&quot; o un &quot;juez&quot;.  En general, los dictadores benevolentes no toman realmente las decisiones, ni siquiera la mayoría de las decisiones.  No es probable que una persona pueda tener todo el conocimiento para tomar decisiones buenas y coherentes en todas las áreas de un proyecto, y además, los desarrolladors de calidad no se acercarán a no ser que tengan alguna influencia en la dirección del proyecto.  Por lo que los dictadores benevolentes no tienen mucho para mandonear.  Por el contrario, dejan que las cosas funcionen por sí solas por el intercambio de ideas y la experimentación, siempre que eso sea posible.  Ellos mismos participan en esas discusiones, como un desarrollador cualquiera, a menudo delegando a un administrador de area que tenga mas conocimiento.  Solamente cuando queda claro que no se puede alcanzar un consenso, y cuando la mayoría del grupo <emphasis>desea</emphasis> que alguien guíe la decisión para que el desarrollo pueda seguir adelante, pisan firme y dicen: &quot;Esta es la forma que tiene que ser&quot;.  Una característica compartida por casi todos los dictadores benevolentes exitosos es que tienen un rechazo a tomar decisiones con un &quot;así tiene que ser&quot;; esta es una de las razones por la permanecen en la función.</para>

<sect2 id="benevolent-dictator-qualifications">
<title>¿Quién puede ser un Buen Dictador Benevolente?</title>

<para>Ser un DB requiere una combinación de características.  Se necesita, antes que nada, una cierta delicadeza para juzgar su propia influencia en el proyecto, lo que a su vez lleva a sujetar los primeros impulsos.  En los primeros pasos de una discusión uno no debe expresar opiniones y conclusiones con tanta seguridad que los otros sientan que es inútil opinar en contra. La gente debe sentirse libre de ventilar sus ideas, aunque sean tontas.  Es inevitable que el DB sugiera alguna idea tonta de vez en cuando, y por lo tanto esta función requiere la disponibilidad de reconocer cuando uno haya tomado una mala decisión&mdash; si bien es ésta una característica sencilla que <emphasis>cualquier</emphasis> buen desarrollador debe tener, especialmente si permanece en el proyecto por mucho tiempo.  Pero la diferencia es que el DB puede darse el lujo de equivocarse de vez en cuando sin tener que lamentar daños permanentes en su credibilidad.  Los desarrolladores más jóvenes pueden no tener tanta seguridad, y por eso los DB deben expresar sus críticas o decisiones en contra con mucha delicadeza para contrapesar la fuerza psicológica y técnica que tienen sus palabras.</para>

<para>El DB <emphasis>no</emphasis> necesita tener una habilidad técnica superior que supere a todos los que están en el proyecto.  Tiene que saber lo suficiente como para trabajar en el código, y entender y comentar cualquier cambio en consideración, y eso es todo.  La posición del DB no se adquiere ni mantiene en virtud a una habilidad de codificar intimidatoria. Lo que <emphasis>si</emphasis> es importante es la experiencia y un sentido general del diseño &mdash;no necesariamente la habilidad de producir un buen diseño a pedido, pero si la habilidad de reconocer el buen diseño, provenga de donde proveniere.</para>

<para>Es común que un dictador benevolente sea el fundador del proyecto, pero esto es más una correlación que una causa.  El tipo de cualidades que permite poner en marcha con éxito un proyecto son exáctamente las cualidades que cualquier DB debe tener&mdash; competencia técnica, habilidad de persuadir para que otro se una, etc.&mdash;.  Y por supuesto, los fundadores se inician con una cierta senioridad automática, que puede ser suficiente a menudo para que el dictador benevolente aparezca por el camino de menor resistencia para todos aquellos a quienes les incumbe.</para>

<para>Recordar que la amenaza de un fork vale para los dos sentidos.  Un DB puede hacer un fork de un proyecto tan facilmente como cualquier otro, y ocasionalmente lo han hecho, cuando sienten que la dirección que está tomando el proyecto es diferente de donde la mayoría de los desarrolladores quieren ir.  Por causa de la forkabilidad, poco importa si el dictador benevolente tiene privilegios de root (que corresponden al administrador del sistema) en el servidor principal del proyecto.  A veces la gente se refiere al control del servidor como si fuera la mayor fuente de poder en un proyecto, pero de hecho es irrelevante.  La posibilidad de agregar o quitar las palabras clave para hacer commit en un servidor afecta solo a la copia del proyecto que reside en el servidor.  Un abuso constante de ese poder, sea por el DB o por cualquier otro, va a terminar simplemente con un cambio del desarrollo en un servidor diferente.</para>

</sect2>

<para>Si el proyecto tendrá un dictador benevolente o si va a funcionar mejor con un sistema menos centralizado, depende ampliamente de quién es el que va a cumplir con esa función.  Por lo general es algo muy obvio desde el comienzo saber quién va a ser el DB, y entonces todo se encamina en ese sentido. Pero si no hay un candidoto obvio para el DB, puede ser que el proyecto se incline a usar un proceso descentralizado de tomas de decisión, como se va a describir en la prósima sección.</para>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="consensus-democracy">
<title>Democracia basada en el Consenso</title>

<para>A medida que el proyecto avanza, se tiende a pasar del modelo del dictador benevolente a los sistemas más abiertaente democráticos.  Este paso no se produce necesariamente por la insatisfacción causada por un DB. Es que el gobierno basado en el grupo llega a ser estable en su evolución, para usar así una metáfora biológica.  Siempre que un dictador benevolente se baja o intenta difundir la responsablidad de tomar decisiones entre todos por igual, se da la oportunidad para que el grupo se asiente en un nuevo sistema no-dictatorial&mdash;estableciendo una constitución, por así decirlo.  Puede ser que el grupo no aprovecha la primera oportunidad, ni quizás tampoco la segunda, pero en algún momento lo hará; y una vez hecho, es muy difícil que esta decisión se vuelva atrás.  Y el sentido comun lo explica: si un grupo de N individuos tuviera que investir una persona con poderes especiales, eso significaría que N&nbsp;-&nbsp;1 personas tuvieron que aceptar que sus influencias individuales se disminuyan.  Normalmente la gente no quiere hacer cosas como esa.  Y si las hiciera, todavía la dictadura que de allí resulte sería condicional: el grupo que unge a un DB, es claramente el grupo que puede deponer al DB. Por lo tanto, una vez que el proyecto a pasado de un liderazgo carismático individual a un sistema más formal basado en el grupo, muy rara vez vuelve para atrás.</para>

<para>Los detalles de cómo funcionan esos sistemas varían ampliamente, pero hay en ellos dos elementos comunes: uno, el grupo funciona por consencio la mayoría del tiempo; dos, hay un mecanismo formal de votaciones para los casos en que el consenso no puede alcanzarse.</para>

<para><firstterm>Consenso</firstterm> significa solamente un acuerdo que todos aceptan de una vez por todas.  No es un estado ambiguo: un grupo alcanza el consenso en un asunto particular cuando alguien expresa que se ha alcanzado un consenso y nadie contradice esa afirmación. La persona que propone el consenso debe, por cierto, dejar en claro cual es el consenso alcanzado, y que acciones deben tomarse en consecuencia de él, si es que ésto no resulta obvio.</para>

<para>La mayoría de las conversaciones de un proyecto son sobre los asuntos técnicos, como el modo correcto de corregir algún error, la conveniencia o no de agregar un asunto, la forma estricta como un documento se enlaza, etc. Un gobierno basado en el consenso funciona bien porque se entrelaza con la discusión técnica y se confunde con ella silenciosamente.  Al terminar una discusión, generalmente hay acuerdo sobre cual es el camino a seguir.  Alguien hace una intervención conclusiva, que es al mismo tiempo un resumen de lo que se ha ido decidiendo y queda como una propuesta implídica de consenso.  This provides a last chance for someone else to say &quot;Wait, I didn&apos;t agree to that.  We need to hash this out some more.&quot;</para>

<para>For small, uncontroversial decisions, the proposal of consensus is implicit.  For example, when a developer spontaneously commits a bugfix, the commit itself is a proposal of consensus: &quot;I assume we all agree that this bug needs to be fixed, and that this is the way to fix it.&quot;  Of course, the developer does not actually say that; she just commits the fix, and the others in the project do not bother to state their agreement, because silence is consent.  If someone commits a change that turns out <emphasis>not</emphasis> to have consensus, the result is simply for the project to discuss the change as though it had not already been committed.  The reason this works is the topic of the next section.</para>

<sect2 id="version-control-relaxation">
<title>Version Control Means You Can Relax</title>

<para>The fact that the project&apos;s source code is kept under version control means that most decisions can be easily unmade.  The most common way this happens is that someone commits a change mistakenly thinking everyone would be happy with it, only to be met with objections after the fact.  It is typical for such objections to start out with an obligatory apology for having missed out on prior discussion, though this may be omitted if the objector finds no record of such a discussion in the mailing list archives.  Either way, there is no reason for the tone of the discussion to be different after the change has been committed than before.  Any change can be reverted, at least until dependent changes are introduced (i.e., new code that would break if the original change were suddenly removed).  The version control system gives the project a way to undo the effects of bad or hasty judgement.  This, in turn, frees people to trust their instincts about how much feedback is necessary before doing something.</para>

<para>This also means that the process of establishing consensus need not be very formal.  Most projects handle it by feel.  Minor changes can go in with no discussion, or with minimal discussion followed by a few nods of agreement.  For more significant changes, especially ones with the potential to destabilize a lot of code, people should wait a day or two before assuming there is consensus, the rationale being that no one should be marginalized in an important conversation simply because he didn&apos;t check email frequently enough.</para>

<para>Thus, when someone is confident he knows what needs to be done, he should just go ahead and do it.  This applies not only to software fixes, but to web site updates, documentation changes, and anything else unlikely to be controversial.  Usually there will be only a few instances where an action needs to be undone, and these can be handled on a case-by-case basis.  Of course, one shouldn&apos;t encourage people to be headstrong.  There is still a psychological difference between a decision under discussion and one that has already taken effect, even if it is technically reversible.  People always feel that momentum is allied to action, and will be slightly more reluctant to revert a change than to prevent it in the first place.  If a developer abuses this fact by committing potentially controversial changes too quickly, however, people can and should complain, and hold that developer to a stricter standard until things improve.</para>

</sect2>

<sect2 id="voting">
<title>When Consensus Cannot Be Reached, Vote</title>

<para>Inevitably, some debates just won&apos;t consense.  When all other means of breaking a deadlock fail, the solution is to vote.  But before a vote can be taken, there must be a clear set of choices on the ballot.  Here, again, the normal process of technical discussion blends serendipitously with the project&apos;s decision-making procedures. The kinds of questions that come to a vote often involve complex, multifaceted issues.  In any such complex discussion, there are usually one or two people playing the role of <firstterm>honest broker</firstterm>: posting periodic summaries of the various arguments and keeping track of where the core points of disagreement (and agreement) lie.  These summaries help everyone measure how much progress has been made, and remind everyone of what issues remain to be addressed.  Those same summaries can serve as prototypes for a ballot sheet, should a vote become necessary.  If the honest brokers have been doing their job well, they will be able to credibly call for a vote when the time comes, and the group will be willing to use a ballot sheet based on their summary of the issues.  The brokers themselves may be participants in the debate; it is not necessary for them to remain above the fray, as long as they can understand and fairly represent others&apos; views, and not let their partisan sentiments prevent them from summarizing the state of the debate in a neutral fashion.</para>

<para>The actual content of the ballot is usually not controversial. By the time matters reach a vote, the disagreement has usually boiled down to a few key issues, with recognizable labels and brief descriptions.  Occasionally a developer will object to the form of the ballot itself.  Sometimes his concern is legitimate, for example, that an important choice was left off or not described accurately. But other times a developer may be merely trying to stave off the inevitable, perhaps knowing that the vote probably won&apos;t go his way. Ver<xref linkend="difficult-people"/><phrase output="printed">
en <xref linkend="communications"/></phrase> for how to deal with this sort of obstructionism.</para>

<para>Remember to specify the voting system, as there are many different kinds, and people might make wrong assumptions about which procedure is being used.  A good choice in most cases is <firstterm>approval voting</firstterm>, whereby each voter can vote for as many of the choices on the ballot as he likes.  Approval voting is simple to explain and to count, and unlike some other methods, it only involves one round of voting.  See <ulink url="http://en.wikipedia.org/wiki/Voting_system#List_of_systems"/> for more details about approval voting and other voting systems, but try to avoid getting into a long debate about which voting system to use (because, of course, you will then find yourself in a debate about which voting system to use to decide the voting system!).  One reason approval voting is a good choice is that it&apos;s very hard for anyone to object to&mdash;it&apos;s about as fair as a voting system can be.</para>

<para>Finally, conduct votes in public.  There is no need for secrecy or anonymity in a vote on matters that have been debated publicly anyway.  Have each participant post her votes to the project mailing list, so that any observer can tally and check the results for herself, and so that everything is recorded in the archives.</para>

</sect2>

<sect2 id="when-to-vote">
<title>When To Vote</title>

<para>The hardest thing about voting is determining when to do it.  In general, taking a vote should be very rare&mdash;a last resort for when all other options have failed.  Don&apos;t think of voting as a great way to resolve debates.  It isn&apos;t.  It ends discussion, and thereby ends creative thinking about the problem.  As long as discussion continues, there is the possibility that someone will come up with a new solution everyone likes.  This happens surprisingly often: a lively debate can produce a new way of thinking about the problem, and lead to a proposal that eventually satisfies everyone.  Even when no new proposal arises, it&apos;s still usually better to broker a compromise than to hold a vote.  After a compromise, everyone is a little bit unhappy, whereas after a vote, some people are unhappy while others are happy.  From a political standpoint, the former sitation is preferable: at least each person can feel he extracted a price for his unhappiness.  He may be dissatisfied, but so is everyone else.</para>

<para>Voting&apos;s main advantage is that it finally settles a question so everyone can move on.  But it settles it by a head count, instead of by rational dialogue leading everyone to the same conclusion.  The more experienced people are with open source projects, the less eager I find them to be to settle questions by vote.  Instead they will try to explore previously unconsidered solutions, or compromise more severely than they&apos;d originally planned.  Various techniques are available to prevent a premature vote.  The most obvious is simply to say &quot;I don&apos;t think we&apos;re ready for a vote yet,&quot; and explain why not. Another is to ask for an informal (non-binding) show of hands.  If the response clearly tends toward one side or another, this will make some people suddenly more willing to compromise, obviating the need for a formal vote.  But the most effective way is simply to offer a new solution, or a new viewpoint on an old suggestion, so that people re-engage with the issues instead of merely repeating the same arguments.</para>

<para>In certain rare cases, everyone may agree that all the compromise solutions are worse than any of the non-compromise ones. When that happens, voting is less objectionable, both because it is more likely to lead to a superior solution and because people will not be overly unhappy no matter how it turns out.  Even then, the vote should not be rushed.  The discussion leading up to a vote is what educates the electorate, so stopping that discussion early can lower the quality of the result.</para>

<para>(Note that this advice to be reluctant to call votes does not apply to the change-inclusion voting described in <xref linkend="stabilizing-a-release"/><phrase output="printed">
en <xref linkend="development-cycle"/></phrase>.  There, voting is more of a communications mechanism, a means of registering one&apos;s involvement in the change review process so that everyone can tell how much review a given change has received.)</para>

</sect2>

<sect2 id="electorate">
<title>Who Votes?</title>

<para>Having a voting system raises the question of electorate: who gets to vote?  This has the potential to be a sensitive issue, because it forces the project to officially recognize some people as being more involved, or as having better judgement, than others.</para>

<para>The best solution is to simply take an existing distinction, commit access, and attach voting privileges to it.  In projects that offer both full and partial commit access, the question of whether partial committers can vote largely depends on the process by which partial commit access is granted.  If the project hands it out liberally, for example as a way of maintaining many third-party contributed tools in the repository, then it should be made clear that partial commit access is really just about committing, not voting. The reverse implication naturally holds as well: since full committers <emphasis>will</emphasis> have voting privileges, they must be chosen not only as programmers, but as members of the electorate.  If someone shows disruptive or obstructionist tendencies on the mailing list, the group should be very cautious about making him a committer, even if the person is technically skilled.</para>

<para>The voting system itself should be used to choose new committers, both full and partial.  But here is one of the rare instances where secrecy is appropriate.  You can&apos;t have votes about potential committers posted to a public mailing list, because the candidate&apos;s feelings (and reputation) could be hurt.  Instead, the usual way is that an existing committer posts to a private mailing list consisting only of the other committers, proposing that someone be granted commit access.  The other committers speak their minds freely, knowing the discussion is private.  Often there will be no disagreement, and therefore no vote necessary.  After waiting a few days to make sure every committer has had a chance to respond, the proposer mails the candidate and offers him commit access.  If there is disagreement, discussion ensues as for any other question, possibly resulting in a vote.  For this process to be open and frank, the mere fact that the discussion is taking place at all should be secret.  If the person under consideration knew it was going on, and then were never offered commit access, he could conclude that he had lost the vote, and would likely feel hurt.  Of course, if someone explicitly asks for commit access, then there is no choice but to consider the proposal and explicitly accept or reject him.  If the latter, then it should be done as politely as possible, with a clear explanation: &quot;We liked your patches, but haven&apos;t seen enough of them yet,&quot; or &quot;We appreciate all your patches, but they required considerable adjustments before they could be applied, so we don&apos;t feel comfortable giving you commit access yet.  We hope that this will change over time, though.&quot;  Remember, what you&apos;re saying could come as a blow, depending on the person&apos;s level of confidence.  Try to see it from their point of view as you write the mail.</para>

<para>Because adding a new committer is more consequential than most other one-time decisions, some projects have special requirements for the vote.  For example, they may require that the proposal receive at least <emphasis>n</emphasis> positive votes and no negative votes, or that a supermajority vote in favor.  The exact parameters are not important; the main idea is to get the group to be careful about adding new committers.  Similar, or even stricter, special requirements can apply to votes to <emphasis>remove</emphasis> a committer, though hopefully that will never be necessary.  Ver<xref linkend="committers"/><phrase output="printed"> en <xref linkend="managing-volunteers"/></phrase> for more on the non-voting aspects of adding and removing committers.</para>

</sect2>

<sect2 id="polls">
<title>Polls Versus Votes</title>

<para>For certain kinds of votes, it may be useful to expand the electorate. For example, if the developers simply can&apos;t figure out whether a given interface choice matches the way people actually use the software, one solution is to ask to all the subscribers of the project&apos;s mailing lists to vote.  These are really <firstterm>polls</firstterm> rather than votes, but the developers may choose to treat the result as binding.  As with any poll, be sure to make it clear to the participants that there&apos;s a write-in option: if someone thinks of a better option not offered in the poll questions, her response may turn out to be the most important result of the poll.</para>

</sect2>

<sect2 id="veto">
<title>Vetoes</title>

<para>Some projects allow a special kind of vote known as a <firstterm>veto</firstterm>.  A veto is a way for a developer to put a halt to a hasty or ill-considered change, at least long enough for everyone to discuss it more.  Think of a veto as somewhere between a very strong objection and a filibuster.  Its exact meaning varies from one project to another.  Some projects make it very difficult to override a veto; others allow them to be overridden by regular majority vote, perhaps after an enforced delay for more discussion. Any veto should be accompanied by a thorough explanation; a veto without such an explanation should be considered invalid on arrival.</para>

<para>With vetoes comes the problem of veto abuse.  Sometimes developers are too eager to raise the stakes by casting a veto, when really all that was called for was more discussion.  You can prevent veto abuse by being very reluctant to use vetoes yourself, and by gently calling it out when someone else uses her veto too often.  If necessary, you can also remind the group that vetoes are binding for only as long as the group agrees they are&mdash;after all, if a clear majority of developers wants X, then X is going to happen one way or another.  Either the vetoing developer will back down, or the group will decide to weaken the meaning of a veto.</para>

<para>You may see people write &quot;-1&quot; to express a veto.  This usage comes from the Apache Software Foundation, which has a highly structured voting and veto process, described at <ulink url="http://www.apache.org/foundation/voting.html"/>.  The Apache standards have spread to other projects, and you will see their conventions used to varying degrees in a lot of places in the open source world.  Technically, &quot;-1&quot; does not always indicate a formal veto even according to the Apache standards, but informally it is usually taken to mean a veto, or at least a very strong objection.</para>

<para>Like votes, vetoes can apply retroactively.  It&apos;s not okay to object to a veto on the grounds that the change in question has already been committed, or the action taken (unless it&apos;s something irrevocable, like putting out a press release).  On the other hand, a veto that arrives weeks or months late isn&apos;t likely to be taken very seriously, nor should it be.</para>

</sect2>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="written-rules">
<title>Writing It All Down</title>

<para>At some point, the number of conventions and agreements floating around in your project may become so great that you need to record it somewhere.  In order to give such a document legitimacy, make it clear that it is based on mailing list discussions and on agreements already in effect.  As you compose it, refer to the relevant threads in the mailing list archives, and whenever there&apos;s a point you&apos;re not sure about, ask again.  The document should not contain any surprises: it is not the source of the agreements, it is merely a description of them.  Of course, if it is successful, people will start citing it as a source of authority in itself, but that just means it reflects the overall will of the group accurately.</para>

<para>This is the document alluded to in <xref linkend="developer-guidelines"/><phrase output="printed"> en <xref linkend="getting-started"/></phrase>.  Naturally, when the project is very young, you will have to lay down guidelines without the benefit of a long project history to draw on.  But as the development community matures, you can adjust the language to reflect the way things actually turn out.</para>

<para>Don&apos;t try to be comprehensive.  No document can capture everything people need to know about participating in a project.  Many of the conventions a project evolves remain forever unspoken, never mentioned explicitly, yet adhered to by all.  Other things are simply too obvious to be mentioned, and would only distract from important but non-obvious material.  For example, there&apos;s no point writing guidelines like &quot;Be polite and respectful to others on the mailing lists, and don&apos;t start flame wars,&quot; or &quot;Write clean, readable bug-free code.&quot;  Of course these things are desirable, but since there&apos;s no conceivable universe in which they might <emphasis>not</emphasis> be desirable, they are not worth mentioning.  If people are being rude on the mailing list, or writing buggy code, they&apos;re not going to stop just because the project guidelines said to.  Such situations need to be dealt with as they arise, not by blanket admonitions to be good. On the other hand, if the project has specific guidelines about <emphasis>how</emphasis> to write good code, such as rules about documenting every API in a certain format, then those guidelines should be written down as completely as possible.</para>

<para>A good way to determine what to include is to base the document on the questions that newcomers ask most often, and on the complaints experienced developers make most often.  This doesn&apos;t necessarily mean it should turn into a FAQ sheet&mdash;it probably needs a more coherent narrative structure than FAQs can offer.  But it should follow the same reality-based principle of addressing the issues that actually arise, rather than those you anticipate might arise.</para>

<para>If the project is a benevolent dictatorship, or has officers endowed with special powers (president, chair, whatever), then the document is also a good opportunity to codify succession procedures. Sometimes this can be as simple as naming specific people as replacements in case the BD suddenly leaves the project for any reason.  Generally, if there is a BD, only the BD can get away with naming a successor.  If there are elected officers, then the nomination and election procedure that was used to choose them in the first place should be described in the document.  If there was no procedure originally, then get consensus on a procedure on the mailing lists <emphasis>before</emphasis> writing about it.  People can sometimes be touchy about hierarchical structures, so the subject needs to be approached with sensitivity.</para>

<para>Perhaps the most important thing is to make it clear that the rules can be reconsidered.  If the conventions described in the document start to hamper the project, remind everyone that it is supposed to be a living reflection of the group&apos;s intentions, not a source of frustration and blockage.  If someone makes a habit of inappropriately asking for rules to be reconsidered every time the rules get in her way, you don&apos;t always need to debate it with her&mdash;sometimes silence is the best tactic.  If other people agree with the complaints, they&apos;ll chime in, and it will be obvious that something needs to change.  If no one else agrees, then the person won&apos;t get much response, and the rules will stay as they are.</para>

<para>Two good examples of project guidelines are the Subversion
<filename>hacking.html</filename> file, at <ulink url="http://svn.collab.net/repos/svn/trunk/www/hacking.html"/>, and the Apache Software Foundation governance documents, at <ulink url="http://www.apache.org/foundation/how-it-works.html"/> and <ulink url="http://www.apache.org/foundation/voting.html"/>.  The ASF is really a collection of software projects, legally organized as a nonprofit corporation, so its documents tend to describe governance procedures more than development conventions.  They&apos;re still worth reading, though, because they represent the accumulated experience of a lot of open source projects.</para>

</sect1>

</chapter>

<!-- local variables:  sgml-parent-document: ("book.xml" "chapter") end: -->
