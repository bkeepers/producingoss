<chapter id="primeros-pasos">

<title>Primeros Pasos</title>

<simplesect>

<para>El clásico módelo de cómo los proyectos de software libre deben iniciar fue propuesto
por Eric Raymond, en un artículo ahora famoso sobre procesos de código abierto titulado
<citetitle>La catedral y el bazar</citetitle>. Él escribió:</para>

<blockquote>
	<para><emphasis>Todos los trabajos buenos en software comienzan tratando de paliar un problema personal del que los programa</emphasis></para>
	<para>(from <emphasis role="bold"><ulink
	url="http://www.catb.org/~esr/writings/cathedral-bazaar/"/>
	</emphasis>)</para>
</blockquote>

<para>Es de notar que Raymond no estaba diciendo que los proyectos código abierto no sólo suceden
cuando cierto individuo tiene una necesidad. En cambio, nos está diciendo que los 
<emphasis>buenos</emphasis> programas son resultado de que un programador tenga un interes personal
en ver el problema resulto. La relevancia de esto para el software libre ha sido que ésta necesidad
personal es lo que frecuentemente es la motivación para iniciar un proyecto de software libre.</para>

<para>Esto sigue siendo la manera en cómo muchos de los proyectos libres se inician, pero menos
ahora que en 1997, cuando Raymond esribió esas palabras. Hoy, tenemos el fenómeno de organizaciones
&mdash;incluidas corporaciones con fines de lucro&mdash;iniciando desde cero, proyectos Open Source
centralizados y a gran escala. El desarrollador solitario, tecleando algo de código para
resolver un problema local y luego dandose cuenta de que los resultados tienen un mayor
aplicación, sigue siendo la fuente de muchos software libre, pero esa no es la única historia.</para>

<para>De todas formas, el objetivo de Raymond sigue siendo profundo. La condición escencial
es que los productores de software libre tengan un interes directo en su éxito, porque ellos
mismos lo utilizan. Si el software no hace lo que se supone debería de hacer, la persona u
organización que lo han producido sentiran insatisfacción en su trabajo diario. Por ejemplo,
el proyecto OpenAdapter  (<ulink url="http://www.openadapter.org/"/>), el cual fue iniciado
por el banco de inversiones Dresdner Klienwort Wasserstein es un marco de trabajo para la
integración de sistemas de información financieros dispares, poco puede ser considerado como un
problema personal de un programador. Este afronta un problema institucional. Pero éste problema
surge directamente de la experiencia de la institución y sus socios, por lo cual si el proyecto
falla en aliviarlos, ellos lo sabrán. Este arreglo produce buenos programas porque el buclé
de críticas fluye en la dirección correcta. El programa no está siendo escrito para ser vendido
a alguien más para que sean ellos quienes resuelvan <emphasis>sus</emphasis> problemas. Está
siendo desarrollado para resolver su <emphasis>propio</emphasis> problema, luego compartiendolo
con todo el mundo a pesar de que el problema fuera una enfermedad y el software la medicina
el cual debe ser distribuido para erradicar la epidemia.</para>

<para>Este capítulo trata de cómo introducir un nuevo proyecto de software libre al mundo, pero
muchas de sus recomendaciones sonarán familiares a una organización sanitaria distribuyendo
medicinas. Los objetivos son muy simílares: quieres dejar claro lo que hace la medicina,
hacerla llegar a las manos de las personas correctas y asegurarte que aquellos quienes
la reciben saben como usarla. Pero con el software, tambien quieres incitar a algunos de los
receptores a unirse al esfuerzo de investigación para mejorar la medicina.</para>

<para>La distribución del software libre es una tarea a dos bandas. El programa necesita
usuarios y desarrolladores. Estas dos necesidades no tienen por que estar en conflicto, pero
si que añaden cierta complejidad a la presentación inicial de un proyecto. Alguna información
es útil para las dos audiencias, alguna sólo lo es para alguna u otra. Ambos tipos de información
deben suscribirse al principio de las presentaciones en éscala, esto es, el grado de detalle
con el que se presenta cada étapa debe corresponder directamente a la cantidad de tiempo y
esfuerzo puesto por el lector. Un mayor esfuerzo debe tener siempre una mayor recompensa.
Cuando los dos no se correlacionan conjuntamente, las personas pueden perder rapidamente su fé
y detener el esfuerzo.</para>

<para>El corolario a esto es:<emphasis>las apariencias importan</emphasis>. En particular,
los programadores, no desean creer esto. Su amor por la sustancia sobre la forma es casí
un punto de orgullo profesional. No es un accidente que tantos desarrolladores exhiban
una antipatía hacia los trabajos en marketing y en relaciones públicas o que diseñadores
gráficos profesionales usualmente se sientan horrorizados de lo que los desarrolladores ingenian.</para>

<para>Esto es penoso, ya que hay situaciones en las que la forma <emphasis>es<emphasis> la
sustancia y la presentación de proyectos es una de estas. Por ejemplo, lo primero que un visitante
aprende sobre un proyecto es como se ve su sitio web. Esta información es absorbida antes de que
el contenido en si sea comprendido&mdash;antes de que cualquier línea haya sido leida o enlaces
pulsados. Aunque parezca injusto, las personas no pueden evitar el formarse una opinión
inmediatamente despues de la primera impresión. La apariencia del sitio señala si se ha tomado
cuidado en la organización de la presentación del proyecto. Los humanos tenemos una antena
extremadamente sensible para detectar la inversión en el cuidado. Muchos de nosotros podemos
decir con sólo un vistazo si un sitio web ha sido ensamblado rapidamente o ha sido diseñado
con cuidado. Ésta es la primera pieza de información que el proyecto muestra y la impresión
que cree será asociada al resto del proyecto por asociación.</para>

<para>Aunque mucho de éste capítulo habla acerca del contenido con el que se deberia
iniciar el proyecto, recuerde que la presentación tambien importa. Ya que el sitio web
debe funcionar para dos tipos diferentes de visitantes&mdash;usuarios y desarrolladores&mdash;
hay que ser claro y directo. A pesar de que este no es el lugar para un tratado general acerca
de diseño web, un principio es suficientemente importante para merecer nuestra atención,
particularmente cuando sirve a multiples audiencias: la gente debe tener una ídea de a donde
lleva un enlace antes de pulsar en el. Por ejemplo, debe ser obvio que<empahsis>con sólo
ver el enlace</emphasis>a la documentación para los usuarios que los lleve a documentación
para los usuarios, sin mencionar la documentación para los desarrolladores. Dirigir un proyecto
se basa parcialmente en suministrar información, pero tambien en suministrar comodidad.
La mera presencia de ofrecer ciertos estándares, en lugares obvios, tranquiliza a usuarios
y desarrolladores quienes estan decidiendo si desean involucrarse. Dice que este proyecto
funciona, ha anticipado las preguntas que la gente puede hacer y ha hecho un esfuerzo
en responderlas sin la necesidad del más mínimo esfuerzo por parte del visitante. Al dar
ésta aura de preparación, el proyecto envia un mensaje: "Su tiempo no será malgastado si
se involucra", lo que es exactamente lo que la gente desea escuchar.</para>

<!-- ======================== subsection ============================== -->
<sect2 id="investiga">
<title>Primero investiga</title>

<para>Antes de iniciar un proyecto Open Source hay un importante advertencia:
</para>
<para>Siempre investiga si existe un proyecto que hace lo que deseas. Las posibilidades son
muy buenas de que cualquier problema que desees resolver ahora alguien más lo haya deseado 
resolver con anterioridad. Si han sido capaces de resolverlo y han liberado bajo una licencia libre 
entonces hoy, no será necesario reinventar la rueda. Existen excepciones claro: si deseas iniciar
un proyecto como experiencia educativa, el código pre-existente no es de ayuda o quizas el
proyecto que deseas iniciar es muy especializado y sabes que no existe la posibilidad de que
alguien más lo haya hecho ya. Pero generalmente, no hay necesidad en no investigar ya que las
ganancias pueden ser grandiosas. Si los buscadores más utilizados no muestran nada, intenta tus
busquedas en: <ulink url="http://freshmeat.net/"/>(un sitio sobre noticias de proyectos open source
y del cual hablaremos un poco más luego), en <ulink url="http://www.sourceforge.net/"/> y en
el directorio de proyectos de la Free Software Foundation 
<ulink url="http://directory.fsf.org/"/>.</para>

<para>Incluso si no se encuentra exactamente lo que estamos buscando, podria encontrar
algo parecido, a lo que tiene más sentido unirse a ese proyecto y añadir funcionalidad
en lugar de empezar desde cero por si mismo.</para>

</sect2>

</simplesect>


<!-- ========================== SECTION =========================== -->
<sect1 id="empezando-con-lo-que-se-tiene">
<title>Empezando con lo que se tiene</title>

<para>Has investigado, sin encontrar nada que realmente se adapte a tus necesidades, y decides
iniciar un nuevo proyecto.</para>

<para>¿Ahora qué?</para>

<para>Lo más difícil acerca de lanzar un proyecto de software libre es transformar una
visión privada a una pública. Tu y tu organización quizas sepan exactamente lo que deseas
pero expresar ese objetivo comprensivamente al resto del mundo tiene su trabajo. De hecho, es escencial, que te tomes tu tiempo para hacerlo. Tu y los otros fundadores deben decidir sobre qué va
realmente el proyecto&mdash;eso es, decidir sus limitaciones, lo que <emphasis>no podra</emphasis>
hacer como lo que sí&mdash;y escribir una declaración de objetivos. Ésta parte no suele ser
usualmente difícil, aunque puede revelar afirmaciones y desacuerdos sobre la naturaleza del
proyecto, lo cual está bien: mejor resolver esto ahora que luego. El próximo paso es empaquetar
el proyecto para el consumo público, y esto es, basicamente, trabajo puro y duro.</para>

<para>Lo que lo hace laborioso es porque consiste principalmente de organizar y documentar lo que
ya todo el mundo sabe&mdash;todos aquellos involucrados en el proyecto hasta ahora. Así que, para
las personas trabajando ya, no existen beneficios inmediatos. Estos no necesitan de un fichero
<filename>README</filename> que resuma el proyecto ni de un documento de diseño o manual de usuario.
No necesitan de un árbol de código cuidadosamente ordenado conforme a los estándares informales,
ampliamente utilizados para las distribuciones de fuentes. De cualquier forma como esté 
ordenado el código fuente estará bien, porque ya estaran acostumbrados de todas formas, y si el
código funciona, saben cómo usarlo. Ni siquiera importa si las afirmaciones fundamentales
sobre la arquitectura del proyecto siguen sin documentar, ya estan familiarizados con lo que
deben hacer.</para>

<para>En cambio, los recien llegados, necesitan de todas estas cosas. Afortunadamente, no las
necesitan todas a la vez. No es necesario proporcionar todos los recursos posibles antes de
tomar un proyecto público. Quizas en un mundo perfecto, todo nuevo proyecto open source
empezaria su vida con un riguroso documento de diseño, un manual de usuario completo (marcando
especialmente las características planeadas pero que aun no han sido implementadas), código
empaquetado hermosamente y portable, capaz de ejecutar en cualquier plataforma y así sucesivamente.
En realidad, cuidar de todos estos detalles consumiria demasiado tiempo, y de todas maneras,
es trabajo con el que podrian ayudar voluntarios una vez que el proyecto esté en marcha.</para>

<para>Por otro lado, lo que <emphasis>sí</emphasis> es necesario, es que se realice una
inversión apropiada en la presentación, de forma que los recien llegados puedan superar
el obstaculo inicial de no estar familiarizados con el proyecto. Pensemos en ello
como en el primer paso en un proceso de inicio (bootstrapping), llevar al proyecto a un tipo
de activación de energia mínima. He escuchado llamar a este umbral como
<firstterm>hacktivation energy</firstterm>: la cantidad de energia que debe aportar
un recien llegado antes de recibir algo a cambio. Mientras menor sea ésta energia, mejor.
La primera tarea es hacer descender ésta <emphasis>hacktivation energy</emphasis>a niveles
que animen a la gente a involucrarse.

<para>Cada una de las siguientes subsecciones, describen un aspecto importante de iniciar
un nuevo proyecto. Estan presentadas casí en el mismo orden en el que un nuevo visitante
las encontraria, aunque claro, el orden en el cual sean implementadas puede ser diferente.
Incluso pueden ser tratadas como una lista de tareas. Cuando se inicie un proyecto,
asegurese de revisar la lista y de que cada uno de los elementos sean cubiertos, o al
menos asegurar cierta comodidad con las posibles consecuencias de dejar alguna aparte.</para>

<!-- ======================== subsection ============================== -->
<sect2 id="escoger-un-nombre">
<title>Escuger un buen nombre</title>

<para>Pongase en la posición de alguien que acaba de escuchar acerca
de su proyecto, quizas por alguien quien fortuitamente tropezo con
el mientras buscaba por alguna aplicación para resolver un problema.
Lo primero que encontraran será el nombre del proyecto.</para>

<para>Un nombre genial no hará que automaticamente el proyecto tenga
exito, y un nombre malo no significa que éste acabado&mdash;bueno, 
en realidad un mal nombre probablemente podría hacer eso, pero empecemos
asumiendo que nadie está activamente intentando hacer que su proyecto
falle. De todos modos, un mal nombre puede desacelerar la adopción
del programa porque la gente no se lo tome seriamente o porque
simplemente les cuesta recordarlos.</para>

<para>Un buen nombre:

<itemizedlist>
	<listitem><para>Da cierta ídea de lo que el proyecto hace,
	o al menos está relacionado de una manera obvia, como si
	alguien conoce el nombre y sabe lo que hace, despues lo 
	recordaran rapidamente.</para>
	</listitem>
	
	<listitem><para>Es fácil de recordar. Veamos, no hay nada
	de falso en el heco de que el íngles se a convertido en
	el lenguaje por defecto de Internet: "fácil de recordar"
	significa "fácil para alguien que sepa leer en íngles
	de recordar." Nombres que son calambures dependientes 
	en la pronunciación de ingleses nativos, por ejemplo, seran opacos
	para muchos lectores no nativos en íngles. Si el calambur
	es particularmente llamativo y memorable, quizas sí valga
	la pena. Sólo recuerde que muchas personas al ver el nombre
	no lo escucharán en sus mentes de la misma manera que un
	íngles nativo lo haría.</para>
	</listitem>

	<listitem><para>No tiene el mismo nombre que otro proyecto
	y no infringe ninguna marca comercial. Esto sólo son
	buenos modales, como un buen sentido legal. No desea
	crear confusiones de identidad. Ya es bastante difícil
	mantenerse al día con todo lo que hay disponible en
	la red, sin tener diferentes cosas con el mismo nombre.</para> 

	<para>Los enlaces mencionados anteriormente en <xref linkend="investiga"/>
	son muy utiles en descubrir si algún otro proyecto
	ya tiene el mismo nombre en el que estabamos pensando.
	Podemos encontrar buscadores gratuitos de marcas registradas 
	en <ulink url="http://www.nameprotect.org/"/> y
	<ulink url="http://www.uspto.gov/"/>.</para>
	</listitem>

	<listitem><para>Está disponible como un nombre de dominio
            <systemitem>.com</systemitem>,
            <systemitem>.net</systemitem>, y
            <systemitem>.org</systemitem>.
	Hay que escoger alguno, probablemente <systemitem>.org</systemitem>,
	para promocionarse como el sitio oficial para el proyecto.
	Los otros dos deben reenviar allí simplemente para evitar
	que terceras partes creen una confusión de identidad sobre
	el nombre del proyecto. Incluso si piensa en hospedar el
	proyecto en otro sitio (vea <xref linkend="empezando-con-hospedaje-externo"/>)
	puede registrar los dominios específicos del proyecto y
	redireccionarlos a sitio del hospedaje. Ayuda mucho a los
	usuarios tener que recordar sólo un URL.</para>
	</listitem>
</itemizedlist>

</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="declaracion-objetivos">
<title>Tener los objetivos claros</title>

<para>Una vez que han encontrado el sitio del proyecto, lo siguiente
que la gente hace es buscar por una descripción rápida, una declaración
de objetivos, para poder decidir (en menos de 30 segundos) si estan o no
interesados en aprender más. Esto debe estar en un lugar prioritario
en la página principal, preferiblemente justo debajo del nombre del
proyecto.</para>

<para>La declaración de los objetivos debe ser concreta, limitada y
sobre todo, corta. Aquí tenemos un buen ejemplo, de <ulink
url="http://www.openoffice.org/"/>:</para>

	<blockquote>
	<para><emphasis>Crear, como una comunidad, una suite ofimática
	líder a nivel internacional, que funcione en las mayores plataformas
	y proporcionar acceso a toda la funcionalidad y datos a traves de API's
	basadas en componentes abiertos y un formato de ficheros basados en XML.
	</emphasis></para>

<para>En pocas palabras, han logrado la máxima puntuación, sobretodo
al basarse en los conocimientos previos de los lectores. Al decir
"<emphasis>como una comunidad</emphasis>", señalan que ninguna
corporación dominará el desarrollo. "<emphasis>Internacional</emphasis>"
significa que la aplicación permitira a personas con multiples lenguas
y localidades trabajar. "<emphasis>En las mayores plataformas</emphasis> 
significa que será portable a Unix, Macintosh y Windows. El resto señala
que las interfaces abiertas y formatos de ficheros faciles de comprender
son una parte importante de sus objetivos. De buenas a primeras, no 
intentan declarar ser una alternativa libre a Microsoft Office, aunque
seguramente la mayoria puede leer entre lineas. Aunque ésta declaración
de objetivos pueda parecer demasiado amplia a primera vista, el hecho es
que está bien circunscrita: las palabras "<emphasis>suite ofimática
</emphasis>" significan algo muy concreto para aquellos familiarizados
con este tipo de programas. Otra vez, el asumir sobre los conocimientos
previos del lector (en este caso probablemente de MS Office) permite 
mantener la declaración concisa.<para> 

<para>El ambito de una declaración de objetivos depende en gran
parte de quien la escriba, no sólo del programa que intenta describir.
Por ejemplo, tiene sentido para OpenOffice.org utilizar las palabras
"<emphasis>como una comunidad</emphasis>", porque el proyecto fue
iniciado, y sigue estando patrocinado, por Sun Microsystems. Al
incluir esas palabras, Sun esta indicado sensibilidad a preocupaciones
de que intente dominar el proceso de desarrollo. Con este tipo de cosas,
simplemente demostrar un conocimiento ambiguo del <emphasis>potencial
</emphasis> de un problema ayuda enormemente en evitar el problema
completamente.<!--This was hard--> Por otra parte, aquellos proyectos
que no son patrocinados por una sola corporación probablemente
no tengan que utilizar este lenguaje, despues de todo, el desarrollo
comunitario es la norma, así que normalmente no debería haber ninguna
razón para señalar esto como una parte de los objetivos.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="declara-libertad">
<title>Declara que el proyecto es libre</title>
<para>Aquellos que sigan interesados despues de leer la declaración de
obejtivos querran más detalles, quizas un poco de documentación para
usuarios o desarrolladores, y eventualmente querran descargar algo. Pero
antes que nada de esto, necesitaran estar seguros de que es open source.
</para>
<para><emphasis>La página principal debe poner claramente y sin ambiguedades
que el proyecto es open source</emphasis>. Esto puede parece obvio,
pero es sorprendete cuantos proyectos se olvidan de esto. He visto
sitios de proyectos de software libre donde la página principal no sólo
no decia bajo cual licencia libre se distribuia la aplicación sino
que nisiquiera declaraban que el software fuese libre. A veces, estas
piezas cruciales de información eran relegadas a la página de descargas o
a la página de los desarrolladores o a algún otro lugar el cual requería
más de un enlace para llegar. En casos extremos, la licencia no se mostraba
en niguna parte del sitio&mdash;la única forma de encontrarla era descargando
la aplicación e investigando dentro.</para>

<para>No cometais estos errores. Una omisión como ésta puede haceros
perder muchos desarrolladores y usuarios potenciales. Declarad desde
el principio, justo debajo de la declaración de objetivos, que el proyecto
es "software libre" u "open source", y mostrad la licencia exacta. Una guía rápida
para escoger una licencia se encuentra en <xref linkend="licencia-rapida"/>
<phrase output="printed">más adelante en éste capítulo</phrase>, y algunos
detalles sobre las licencias serán discutidos en <xref linkend="legal"/>.</para>

<para>Llegados a este punto, nuestro visitante hipotético ha determinado&mdash;
probablemente en un minuto o menos&mdash;que está interesado en utilizar,
digamos, al menos cinco minutos más investigando el proyecto. La próxima
parte describe qué debería encontrar durante esos cinco minutos.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="caracteristicas-y-requerimientos">
<title>Lista de características y requerimientos</title>

<para>Debería haber una breve lista de las características que el software
soporta (si algo aun no ha sido completado, se puede listar de todas formas,
pero señalando "<emphasis>planeado</emphasis>" o "<emphasis>en&nbsp;progreso</emphasis>")
y el tipo de entorno necesario para ejecutar la aplicación. Hay que pensar
en ésta lista como algo que dariamos a alguien que requiere un resúmen de
nuestro programa. Por ejemplo, la declaración de objetivos podría decir:</para>

	<blockquote>
	<para><emphasis>Crear un controlador y sistema de busqueda con una API, para
	ser utilizada por programadores suministrando servicios de busqueda
	para grandes colecciones de ficheros de texto.
	</emphasis></para>
	</blockquote>

<para>La lista de características y requerimientos daría detalles
que permitirian esclarecer el alcance de la declaración de objetivos:
</para>

  <blockquote>
    <para><emphasis>Características</emphasis></para>
    <itemizedlist>
      <listitem><para><emphasis>Busquedas en texto plano,
                HTML y XML</emphasis></para>
      </listitem>
      <listitem><para><emphasis>Busqueda de palabaras o frases</emphasis></para>
      </listitem>
      <listitem><para><emphasis>(planeado) Emparejando borroso (Fuzzy Matching)</emphasis></para>
      </listitem>
      <listitem><para><emphasis>(planeado) Actualización incremental de 
                indices</emphasis></para>
      </listitem>
      <listitem><para><emphasis>(planeado) Indexado de sitios web
                remotos</emphasis></para>
      </listitem>
    </itemizedlist>
    <para><emphasis>Requerimientos:</emphasis></para>
    <itemizedlist>
      <listitem><para><emphasis>Python 2.2 o mayor</emphasis></para>
      </listitem>
      <listitem><para><emphasis>Espacio en disco suficiente para contener los indices
                (aproximadamente 2x el tamaño original de los datos)</emphasis></para>
      </listitem>
    </itemizedlist>
  </blockquote>

<para>Con ésta información, los lectores podrán rapidamente
tener una ídea de si éste programa tiene alguna esperanza de
trabajar para ellos, y tambien pueden considerar involucrarse como
desarrolladores.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="estado-desarrollo">
<title>Estado del desarrollo</title>

<para>La gente siempre quiere saber cómo va un proyecto. Para proyectos nuevos,
desean saber la separación entre las promesas del proyecto y la realidad del momento. Para
proyectos maduros, desean saber cuan activamente es mantenido, cuan seguido sacan nuevas
versiones, la facilidad para reportar fallos, etc.</para>

<para>Para responder a estas dudas, se debe suministrar una página que muestre el estado
del desarrollo, listando los objetivos a corto plazo del proyecto y las necesidades (por
ejemplo, quizas se esten buscando desarrolladores con un expertos en un tema en párticular).
Ésta página tambien puede dar una historia de versiones anteriores, con listas de las
características, de manera que los visitantes obtengan una ídea de cómo el proyecto
define su "progreso" y de cuan rapidamente se hacen progresos de acuerdo a esas
definiciones.</para>
<para>No hay que asustarse por parecer no estar preparado y no caer en la tentación
de inflar el estado del desarrollo. Todos saben que el software evoluciona por etapas;
no hay que avergonzarse en decir "Esto es software alfa con fallos conocidos. Ejecuta, y
funciona algunas veces, así que uselo bajo su responsabilidad." Este lenguaje no asustará
el tipo de desarrolladores que son necesarios en esta etapa. En cuanto a los usuarios, una
de las peores cosas que un proyecto puede hacer es atraer usuarios antes de que el
software éste listo para estos. Una reputación por inestabilidad y fallos es muy díficil
de hacer desaparecer una vez adquirida. La paciencia da sus frutos a largo plazo; siempre
es mejor que el software sea <emphasis>más</emphasis> estable de lo que espera el usuario
ya que las sorpresas gratas producen la mejor públicidad boca a boca.</para>

<sidebar id="alfa-y-beta">
  <title>Alfa y Beta</title>
  <para>El término <firstterm>alfa</firstterm> usualmente significa la primera versión,
  con lo que los usuarios pueden realizar todos el trabajo teniendo todas la funcionalidad
  esperada, pero que se sabe tiene fallos. El principal proposito de el software alfa es 
  generar una respuesta, de forma que los desarrolladores sepán en qué trabajar. La próxima
  etapa, <firstterm>beta</firstterm>, significa que han sido resueltos todos los fallos
  más importantes arreglados, pero que aun no ha sido intesivamente probado como para 
  ser la versión oficial. El proposito de las betas es la de convertirse en la versión
  oficial, asumiendo que nuevos fallos no sean encontrados, o de suministrar un feedback
  para los desarrolladores para que logren la versión oficial más rápido. La diferencia
  entre alfa y beta es más una cuestión de juicio.</para>
</sidebar>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="descargas">
<title>Descargas</title>

<para>EL software debe poder ser descargable como código fuente en formatos estándares,
páquetes binarios (ejecutables) no son necesarios, a menos que el programa tenga requerimientos
muy complicados para su compilado o dependencias que hagan hacerlo funcionar sea muy laborioso
para la mayoria de las personas. (¡Aunque si es éste el caso, el proyecto va a tenerlo muy
difícil atrayendo programadores de todas maneras!)</para>

<para>El mecanismo de distribución debe de ser de lo más conveniento, estándar y sencillo posible.
Si se estuviese intentando erradicar una enfermedad, no distribuiria la medicina tal que requiriese
de una jeringuilla especial para administrarse. De igual manera, un programa debe ser conforme a métodos
de compilación e instalación estándares; entre más se desvie de estos estándares, mayor será la cantidad
de usuarios y desarrolladores potenciales que se den por vencidos y de abandonen el proyecto confundidos.</para>

<para>Esto parece obvio, pero muchos proyectos no se molestan en estandarizar sus procedimientos
de instalación hasta mucho despues, diciendose a si mismos que esto lo pueden hacer en cualquier momento:
<emphasis>"Ya resolveremos todas esas cosas cuando el código éste casí listo."</emphasis> De lo que no
nos se dan cuenta es de que al dejar al lado el trabajo aburrido de terminar los procedimientos de
compilado e instalación, en realidad estan ralentizando todo&mdash;porque desalentan a los programadores
que de otra manera habrían contribuido al código. Más dañino aun, no <emphasis>saben</emphasis> que estan
perdiendo a todos esos desarrolladores, porque el proceso es una acumulación de eventos que no suceden:
alguien visita un sutios web, descarga el programa, intenta compilarlo, falla, deja de intentarlo y abandona.
¿Quíen sabrá que ocurrio exceptuando a ésta persona? Nadie en el proyecto se dará cuenta que el interés y
la buena voluntad de alguien a sido silenciosamente malgastada.</para>

<para>Las tareas aburridas con un alto beneficio siempre deben ser hechos al principio y disminuyendo
de manera significativa las barreras de entrada a un proyecto utilizando buenos páquetes brindan
altos beneficios.</para>

<para>Cuando se lanza un páquete descargable, es vital que se le dé un número de versión único a éste lanzamiento,
de manera que la gente pueda comparar dos versiones cualquieras diferentes y saber cual reemplaza a cual. Una
discusión detallada sobre la numeración de versiones puede ser encontrada en <xref linkend="numeracion-versiones"/>,
y detalles sobre la estandarización de los procedimientos de compilado e instalación serán cubiertos
en <xref linkend="empaqutado"/><phrase output="printed">, ambos en <xref linkend="ciclo-desarrollo"/></phrase>.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="vc-and-bug-tracker-access">
<title>Control de versiones y acceso al Bug Tracker</title>

<para>Descargar páquetes con el código fuente está bien para aquellos que sólo desean instalar y utilizar un programa,
pero no es suficiente para aquellos que desean buscar fallos o añadir nuevas mejoras. Instantaneas nocturnas del
código fuente pueden ayudar, pero esto no es sufuciente para una prospera comunidad de desarrollo. Estas personas
necesitan de acceso en tiempo real a los últimos cambios, y la manera de proporcionarles esto es utilizando un sistema
de control de versiones (version control system). La presencia de fuentes controladas, accesibles anonimamente
es una señal de&mdash;para ambos, usuarios y programadores&mdash;que éste proyecto ésta haciendo un esfuerzo en
proporcionar todo lo necesario para que otros participen. Si no se puede ofrecer control de versiones desde
el principio, comunique la intención de montarlo pronto. La infraestructura de control de versiones es discutida
en detalle en <xref linkend="vc"/><phrase output="printed"> en <xref linkend="infraestructura-tecnica"/>
</phrase>.</para>

<para>Lo mismo se aplica para el seguimiento de errores del proyecto. La mayor importancia que se le dé a ésta
base de datos, lo mejor que parecerá el proyecto. Esto puede parecer contra intuitivo, pero hay que recordar
que el número de fallos registrados, en realidad depende en tres cosas: el número absoluto de errores presentes
en el programa, el número de usuarios utilizandolo y la conveniencia con la cual esos usuarios registran
nuevos fallos. De estos tres factores, los dos últimos son más significativos que el primero. Cualquier
aplicación con suficiente tamaño y complejidad tiene una cantidad arbitraria de fallos esperando a ser
encontrados. La verdadera cuestión es, cuan bien serán registrados y priorizados estos errores. Un proyecto
con una base de datos de fallos amplia y bien mantenida (errores importantes son atacados rapidamente,
fallos duplicados son unificados, etc.) generan una mejor impresión que un proyecto sin una o vacia.</para> 

<para>Claro está, que si un proyecto está empezando, que la base de datos de fallos
contenga algunos pocos, y no hay mucho que se pueda hacer al respecto. Pero si la página donde se indica
el estado del proyecto, enfátiza en la juventud del proyecto y si las personas mirando los fallos pueden
observar que muchos de estos han sido incluidos recientemente, pueden asumir que el proyecto tiene una
<emphasis>proporción</emphasis>saludable de entradas y no serán alarmados por el mínimo absoluto de
fallos registrados.</para>

<para>Hay que señalar que los bug trackers no sólo son usados para fallos en los programas pero tambien para
peticiones de mejoras, cambios en la documentación, tareas pendientes y mucho más. Los detalles de ejecutar
un sistema de seguimiento de fallos será cubierto en <xref linkend="bug-tracker"/><phrase output="printed"> en
<xref linkend="infraestructura-tecnica"/>, así que no vamos a entrar en detalles. Lo importante desde la perspectiva
de la presentación está en <emphasis>tener</emphasis>un bug tracker y asegurarse de que es visible desde la
página principal del proyecto.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="canales-de-comunicacion">
<title>Canales de comunicación</title>

<para>Usualmente los visitantes desean saber cómo pueden contactar con los seres humanos detras del proyecto.
Hay que suministrar direcciones de listas de correo, salas de chat, canales en IRC y cualquier otro foro
donde aquellos involucrados puedan ser contactados. Hay que dejar claro que los autores del proyecto
están suscritos a estas listas, de manera que la gente vea una forma de dar feedback a los desarrolladores. La
presencia de estos en las listas no implica obligación alguna de responder a todas las preguntas que se formulan
o de implementar todas las peticiones. A la larga, muchos de los usuarios probablemente nisiquiera se unan
a los fotos de todas maneras, pero estarán conformes con saber que <emphasis>podrian</emphasis>si fuese necesario.
</para>

<para>En la primeras etapas de cualquier proyecto, no existe la necesidad de que haya una diferenciación entre
los foros de los usuarios y los de los desarrolladores. Es mejor tener a todos los involucrados en el proyecto
hablando en conjunto en una sala. Dentro de los primeros en adoptar al proyecto, la distinción entre usuario
y desarrollador será muchas veces borrosa, hasta tal punto que la distinción se puede hacer, la proporción
de programadores y usuarios usualmente es mayor al principio que al final. Mientras que no se puede asumir
que todos quienes utilicen el programa es un programador que quiere modíficarlo, sí se puede asumir
que al menos está interesado en seguir las discusiones sobre el desarrollo y en obtener una visión de
la dirección del proyecto.</para>

<para>Ya que éste capítulo es sólo sobre iniciar un proyecto, es suficiente decir que al menos
estos foros de comunicación deben existir. Luego en <xref linkend="crecimiento"/><phrase output="printed">
en<xref linkend="comunicaciones"/></phrase>, examinaremos dónde y cómo montar estos foros, cómo deben
ser moderados o cualquier otro tipo de dirección y cómo separar los foros de usuarios de los foros
de los desarrolladores, cuando llegue el momento, sin crear un espacio infranqueable.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="pautas-de-desarrollo">
<title>Pautas de Desarrollo</title>

<para>Si alguien considera contribuir al proyecto, buscará por pautas de desarrollo. EStas pautas son más
sociales que técnicas: explican como los desarrolladores interactuan entre ellos y con los usuarios y 
ultimamente como hacer las cosas.</para>

<para>Este tema es tratado en detalle en <xref linkend="reglas-escritas"/><phrase output="printed"> en
<xref linkend="infraestructura-social"/></phrase>, pero los elementos básicos de unas pautas de desarrollo son:

<itemizedlist>
  <listitem><para>enlaces a los foros para la interacción de los desarrolladores
            </para> 
  </listitem>
  <listitem><para>instrucciones en cómo reportar fallos y enviar parches
            </para>
  </listitem>
  <listitem><para>alguna indicación de <emphasis>cómo</emphasis>
	    el desarrollo es usualmente llevado a cabo&mdash;es el
	    proyecto una dictadura benevolente, una democracia o algo más
            </para>
  </listitem>
</itemizedlist>

Ningún sentido peyorativo es intencional por lo de "dictadura" por cierto. Es perfectamente aceptable
ser un tirano donde un desarrollador en particular tiene el poder de veto sobre todos los cambios. Muchos
proyectos exitosos funcionan de ésta manera. Lo importante es que el proyecto sea consciente de esto y lo
comunique. Una tirania pretendiendo ser una democracia desalentara a las personas; una tirania que dice serlo
funcinará bien siempre que el tirano sea competente y de confianza.</para>

<para>Un ejemplo de unas pautas de desarrollos particularmente exhaustivas estan en 
<ulink url="http://svn.collab.net/repos/svn/trunk/www/hacking.html"/>
o en <ulink url="http://www.openoffice.org/dev_docs/guidelines.html"/> tenemos unas pautas más amplias
que se concentran más en la forma de gobierno y el espíritu de participación y menos en temas técnicos.</para>

<para>Proveer una introducción a la aplicación para los programadores es otro tema y será discutido en 
<xref linkend="documentacion-para-desarrolladores"/><phrase output="printed">más adelante en éste capítulo
</phrase>.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="documentacion">
<title>Documentación</title>

<para>La documentación es escencial. Debe haber <emphasis>algo</emphasis>
para que la gente lea, aunque sea algo rudimentario e incompleto. Esto
entra de lleno en la categoria antes referida y usualmente es la primera
área donde un proyecto falla. Conseguir una declaración de objetivos y
una lista de requerimientos, escoger una licencia, resumir el estado de
desarrollo&mdash;son todas tareas relativamente pequeñas que pueden ser
completadas y a las que usualmente no es necesario volver una vez
terminadas. La documentación, por otra parte, nunca está terminada
realmente, lo cual sea una de las razones por las cuales se tarde
al iniciarla.</para>

<para>La cuestion más insidiosa sobre la utilidad de la documentación
es que es inversamente proporcional para quienes la escriben y para
quienes la leen. Lo más importante de la documentación para un usuario
inicial es lo más básico: cómo configurar la aplicación, una introducción
de cómo funciona y quizas algunas guias para realizar las tareas
más comunes. Pero a la vez son estas cosas las más sabidas por 
aquellos quienes <emphasis>escriben</emphasis> la documentación&mdash;
tan bien sabidas que puede ser difícil para estos ver las cosas desde
el punto de vista de los lectores y dificultando listar los pasos
que (para los escritores) parecen tan obvios que no merecen especial
atención.</para>

<para>No existe una solución mágica para éste problema. Alguien debe
sentarse y escribir todo esto para luego presentarselo a un usuario
nuevo tipo y probar la calidad. Hay que utilizar un formato simple y
fácil de modíficar como HTLM, texto plano, Tex o alguna variante de
XML&mdash;algo que sea conveniente para mejoras rápidas, ligeras e
imprevisibles. Esto no es sólo para eliminar cualquier trabajo innecesario
a los escritores originales para realizar cambios incrementales, sino
que tambien para quienes se unan al proyecto despues y desean
trabajar en la documentación.</para>

<para>Una manera de asegurarse de que la documentación básica inicial
se hace es límitar su alcance. Al menos de ésta manera no parecera que
se está escribiendo una tarea sin fin. Una buena regla es seguir unos
criterios mínimos:</para>

<itemizedlist>
  <listitem><para>Avisar al lector claramente el nível técnico
            que se espera que tenga.</para>
  </listitem>
  <listitem><para>Describir clara y extensivamente cómo configurar
	    el programa y en alguna parte al inicio de la documentación
	    comunicarle al usuario cómo ejecutar algún tipo de prueba
	    de diagnostico o simple comando para confirmar que todo
	    funciona correctamente. La documentación inicial es a veces
	    más importante que la documentación de uso. 

            they've set things up correctly.  Startup
            documentation is in some ways more important than
            actual usage documentation.  The more effort someone has
            invested in installing and getting started with the
            software, the more persistent she'll be in figuring out
            advanced functionality that's not well-documented.
            When people abandon, they abandon early; therefore,
            it's the earliest stages, like installation, that need
            the most support.</para>
  </listitem>
  <listitem><para>Give one tutorial-style example of how to do a
            common task.  Obviously, many examples for many tasks
            would be even better, but if time is limited, pick one
            task and walk through it thoroughly.  Once someone
            sees that the software <emphasis>can</emphasis> be
            used for one thing, they'll start to explore what else
            it can do on their own&mdash;and, if you're lucky,
            start filling in the documentation themselves.  Which
            brings us to the next point...</para>
  </listitem>
  <listitem><para>Label the areas where the documentation is known
            to be incomplete.  By showing the readers that you are
            aware of its deficiencies, you align yourself with
            their point of view.  Your empathy reassures them that
            they don't face a struggle to convince the project of
            what's important.  These labels needn't represent
            promises to fill in the gaps by any particular date
           &mdash;it's equally legitimate to treat them as open
            requests for volunteer help.</para>
  </listitem>
</itemizedlist>

<para>The last point is of wider importance, actually, and can be
applied to the entire project, not just the documentation.  An
accurate accounting of known deficiencies is the norm in the open
source world.  You don't have to exaggerate the project's
shortcomings, just identify them scrupulously and dispassionately when
the context calls for it (whether in the documentation, in the bug
tracking database, or on a mailing list discussion).  No one will
treat this as defeatism on the part of the project, nor as a
commitment to solve the problems by a certain date, unless the project
makes such a commitment explicitly.  Since anyone who uses the
software will discover the deficiencies for themselves, it's much
better for them to be psychologically prepared&mdash;then the
project will look like it has a solid knowledge of how it's
doing.</para>

<sidebar id="starting-a-faq">
  <title>Maintaining a FAQ</title>

  <para>A <firstterm>FAQ</firstterm> ("Frequently Asked Questions"
  document) can be one of the best investments a project makes in
  terms of educational payoff.  FAQs are highly tuned to the questions
  users and developers actually ask&mdash;as opposed to the questions
  you might have <emphasis>expected</emphasis> them to ask&mdash;and
  therefore, a well-maintained FAQ tends to give those who consult it
  exactly what they're looking for.  The FAQ is often the first place
  users look when they encounter a problem, often even in preference
  to the official manual, and it's probably the document in your
  project most likely to be linked to from other sites.</para>

  <para>Unfortunately, you cannot make the FAQ at the start of the
  project.  Good FAQs are not written, they are grown.  They are by
  definition reactive documents, evolving over time in response to
  people's day-to-day usage of the software.  Since it's impossible to
  correctly anticipate the questions people will ask, it is impossible
  to sit down and write a useful FAQ from scratch.</para>

  <para>Therefore, don't waste your time trying to.  You may, however,
  find it useful to set up a mostly blank FAQ template, so there will
  be an obvious place for people to contribute questions and answers
  after the project is under way.  At this stage, the most important
  property is not completeness, but convenience: if the FAQ is easy to
  add to, people will add to it.  (Proper FAQ maintenance is a
  non-trivial and intriguing problem, and is discussed more in <xref
  linkend="faq-manager"/><phrase output="printed"> in
  <xref linkend="managing-volunteers"/></phrase>.)</para>
</sidebar>

<sect3 id="documentation-availability">
<title>Availability of documentation</title>

<para>Documentation should be available from two places: online
(directly from the web site), <emphasis>and</emphasis> in the
downloadable distribution of the software (see
<xref linkend="packaging"/><phrase output="printed"> in
<xref linkend="development-cycle"/></phrase>).  It needs to be
online, in browsable form, because people often read documentation
<emphasis>before</emphasis> downloading software for the first time,
as a way of helping them decide whether to download at all.  But it
should also accompany the software, on the principle that downloading
should supply (i.e., make locally accessible) everything one needs to
use the package.</para>

<para>For online documentation, make sure that there is a link that
brings up the <emphasis>entire</emphasis> documentation in one HTML
page (put a note like "monolithic" or "all-in-one" or "single large
page" next to the link, so people know that it might take a while to
load).  This is useful because people often want to search for a
specific word or phrase across the entire documentation.  Generally,
they already know what they're looking for; they just can't remember
what section it's in.  For such people, nothing is more frustrating
than encountering one HTML page for the table of contents, then a
different page for the introduction, then a different page for
installation instructions, etc.  When the pages are broken up like
that, their browser's search function is useless.  The separate-page
style is useful for those who already know what section they need, or
who want to read the entire documentation from front to back in
sequence.  But this is <emphasis>not</emphasis> the most common way
documentation is accessed.  Far more often, someone who is basically
familiar with the software is coming back to search for a specific
word or phrase.  To fail to provide them with a single, searchable
document would only make their lives harder.</para>

</sect3>

<sect3 id="developer-documentation">
<title>Developer documentation</title>

<para>Developer documentation is written to help programmers
understand the code, so they can repair and extend it.  This is
somewhat different from the <emphasis>developer guidelines</emphasis>
discussed earlier, which are more social than technical.  Developer
guidelines tell programmers how to get along with each other;
developer documentation tells them how to get along with the code
itself.  The two are often packaged together in one document for
convenience (as with the <ulink
url="http://svn.collab.net/repos/svn/trunk/www/hacking.html"/> example given
earlier), but they don't have to be.</para>

<para>Although developer documentation can be very helpful, there's no
reason to delay a release to do it.  As long as the original authors
are available (and willing) to answer questions about the code, that's
enough to start with.  In fact, having to answer the same questions
over and over is a common motivation for writing documentation.  But
even before it's written, determined contributors will still manage to
find their way around the code.  The force that drives people to spend
time learning a code base is that the code does something useful for
them.  If people have faith in that, they will take the time to figure
things out; if they don't have that faith, no amount of developer
documentation will get or keep them.</para>

<para>So if you have time to write documentation for only one
audience, write it for users.  All user documentation is, in effect,
developer documentation as well; any programmer who's going to work on
a piece of software will need to be familiar with how to use it.
Later, when you see programmers asking the same questions over and
over, take the time to write up some separate documents just for
them.</para>

<para>Some projects use wikis for their initial documentation, or even
as their primary documentation.  In my experience, this really only
works if the wiki is actively edited by a few people who agree on how
the documentation is to be organized and what sort of "voice" it
should have.  See
<xref linkend="wikis"/><phrase output="printed"> in
<xref linkend="technical-infrastructure"/></phrase> for
more.</para>

</sect3>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="example-output">
<title>Example Output and Screenshots</title>

<para>If the project involves a graphical user interface, or if it
produces graphical or otherwise distinctive output, put some samples
up on the project web site.  In the case of interface, this means
screenshots; for output, it might be screenshots or just files.  Both
cater to people's need for instant gratification: a single screenshot
can be more convincing than paragraphs of descriptive text and mailing
list chatter, because a screenshot is inarguable proof that the
software <emphasis>works</emphasis>.  It may be buggy, it may be hard
to install, it may be incompletely documented, but that screenshot is
still proof that if one puts in enough effort, one can get it to
run.</para>

<sidebar id="screenshots">
  <title>Screenshots</title>
  <para>Since screenshots can be daunting until you've actually made a
  few, here are basic instructions for making them.  Using the Gimp
  (<ulink url="http://www.gimp.org/"/>), open
  <guimenu>File</guimenu>-&gt;<guimenu>Acquire</guimenu>-&gt;<guimenu>Screenshot</guimenu>,
  choose <guimenuitem>Single&nbsp;Window</guimenuitem> or
  <guimenuitem>Whole&nbsp;Screen</guimenuitem>, then click
  <guimenuitem>OK</guimenuitem>.  Now your next mouse click will
  capture the window or screen clicked on as an image in the Gimp.
  Crop and resize the image as necessary, using the instructions at 
  <ulink url="http://www.gimp.org/tutorials/Lite_Quickies/#crop"/>.</para> 
</sidebar>
  
</sect2>

<para>There are many other things you could put on the project web
site, if you have the time, or if for one reason or another they are
especially appropriate: a news page, a project history page, a related
links page, a site-search feature, a donations link, etc.  None of
these are necessities at startup time, but keep them in mind for the
future.</para>

<sect2 id="starting-with-canned-hosting">
<title>Canned Hosting</title>

<para>There are a few sites that provide free hosting and
infrastructure for open source projects: a web area, version control,
a bug tracker, a download area, chat forums, regular backups, etc.
The details vary from site to site, but the same basic services are
offered at all of them.  By using one of these sites, you get a lot
for free; what you give up, obviously, is fine-grained control over
the user experience.  The hosting service decides what software the
site runs, and may control or at least influence the look and feel of
the project's web pages.</para>

<para>See
<xref linkend="canned-hosting"/><phrase output="printed"> in
<xref linkend="technical-infrastructure"/></phrase> for a more
detailed discussion of the advantages and disadvantages of canned
hosting, and a list of sites that offer it.</para>

</sect2>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="license-quickstart">
<title>Choosing a License and Applying It</title>

<para>This section is intended to be a very quick, very rough guide to
choosing a license.  Read <xref linkend="legal"/> to understand
the detailed legal implications of the different licenses, and how the
license you choose can affect people's ability to mix your software
with other free software.</para>

<para>There are a great many free software licenses to choose from.
Most of them we needn't consider here, as they were written to satisfy
the particular legal needs of some corporation or person, and wouldn't
be appropriate for your project.  We will restrict ourselves to just
the most commonly used licenses; in most cases, you will want to
choose one of them.</para>

<!-- ======================== subsection ============================== -->
<sect2 id="license-quickstart-non-gpl">
<title>The "Do Anything" Licenses</title>

<para>If you're comfortable with your project's code potentially being
used in proprietary programs, then use
an <firstterm>MIT/X-style</firstterm> license.  It is the simplest of
several minimal licenses that do little more than assert nominal
copyright (without actually restricting copying) and specify that the
code comes with no warranty.  See
<xref linkend="license-choosing-mit-x"/> for details.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="license-quickstart-gpl">
<title>The GPL</title>

<para>If you don't want your code to be used in proprietary programs,
use the GNU General Public License
(<ulink url="http://www.gnu.org/licenses/gpl.html"/>).  The GPL is
probably the most widely recognized free software license in the world
today.  This is in itself a big advantage, since many potential users
and contributors will already be familiar with it, and therefore won't
have to spend extra time to read and understand your license.  See
<xref linkend="license-choosing-gpl"/><phrase output="printed">
in <xref linkend="legal"/></phrase> for details.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="license-quickstart-applying">
<title>How to Apply a License to Your Software</title>

<para>Once you've chosen a license, you should state it on the
project's front page.  You don't need to include the actual text of
the license there; just give the name of the license, and make it link
to the full license text on another page.</para>

<para>This tells the public what license you
<emphasis>intend</emphasis> the software to be released under, but
it's not sufficient for legal purposes.  For that, the software itself
must contain the license.  The standard way to do this is to put the
full license text in a file called <filename>COPYING</filename> (or
<filename>LICENSE</filename>), and then put a short notice at the top
of each source file, naming the copyright date, holder, and license,
and saying where to find the full text of the license.</para>

<para>There are many variations on this pattern, so we'll look at just
one example here.  The GNU GPL says to put a notice like this at the
top of each source file:</para>

<screen>
Copyright (C) &lt;year&gt;  &lt;name of author&gt;

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
</screen>

<para>It does not say specifically that the copy of the license you
received along with the program is in the file
<filename>COPYING</filename>, but that's where it's usually put.  (You
could change the above notice to state that directly.)  This template
also gives a geographical address from which to request a copy of the
license.  Another common method is to give a link to a web page
containing the license.  Just use your judgement and point to wherever
you feel the most permanent copy of the license is maintained, which
might simply be somewhere on your project's web site.  In general, the
notice you put in each source file does not have to look exactly like
the one above, as long as it starts with the same notice of copyright
holder and date, states the name of the license, and makes it clear
where to view the full license.</para>

</sect2>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="setting-tone">
<title>Setting the Tone</title>

<para>So far we've covered one-time tasks you do during project setup:
picking a license, arranging the initial web site, etc.  But the most
important aspects of starting a new project are dynamic.  Choosing a
mailing list address is easy; ensuring that the list's conversations
remain on-topic and productive is another matter entirely.  If the
project is being opened up after years of closed, in-house
development, its development processes will change, and you will have
to prepare the existing developers for that change.</para>

<para>The first steps are the hardest, because precedents and
expectations for future conduct have not yet been set.  Stability in a
project does not come from formal policies, but from a shared,
hard-to-pin-down collective wisdom that develops over time.  There are
often written rules as well, but they tend to be essentially a
distillation of the intangible, ever-evolving agreements that really
guide the project.  The written policies do not define the project's
culture so much as describe it, and even then only
approximately.</para>

<para>There are a few reasons why things work out this way.  Growth
and high turnover are not as damaging to the accumulation of social
norms as one might think.  As long as change does not happen
<emphasis>too</emphasis> quickly, there is time for new arrivals to
learn how things are done, and after they learn, they will help
reinforce those ways themselves.  Consider how children's songs
survive the centuries.  There are children today singing roughly the
same rhymes as children did hundreds of years ago, even though there
are no children alive now who were alive then.  Younger children hear
the songs sung by older ones, and when they are older, they in turn
will sing them in front of other younger ones.  The children are not
engaging in a conscious program of transmission, of course, but the
reason the songs survive is nonetheless that they are transmitted
regularly and repeatedly.  The time scale of free software projects
may not be measured in centuries (we don't know yet), but the dynamics
of transmission are much the same.  The turnover rate is faster,
however, and must be compensated for by a more active and deliberate
transmission effort.</para>

<para>This effort is aided by the fact that people generally show up
expecting and looking for social norms.  That's just how humans are
built.  In any group unified by a common endeavor, people who join
instinctively search for behaviors that will mark them as part of the
group.  The goal of setting precedents early is to make those
"in-group" behaviors be ones that are useful to the project; for once
established, they will be largely self-perpetuating.</para>

<!-- todo: maybe say this:

     Point out how the sponsor's noble fair-mindedness and balanced
     judgement are not properties that can usefully be written down
     formally, because they wouldn't be believed.  They'd just look
     like propaganda anyway, so there's no point.  This is one of
     those areas where conduct and informal precedent is the *only*
     way to solidify a social norm.  And refer to the relevant parts
     of Chapter 5.
-->

<para>Following are some examples of specific things you can do to set
good precedents.  They're not meant as an exhaustive list, just as
illustrations of the idea that setting a collaborative mood early
helps a project tremendously.  Physically, every developer may be
working alone in a room by themselves, but you can do a lot to make
them <emphasis>feel</emphasis> like they're all working together in
the same room.  The more they feel this way, the more time they'll
want to spend on the project.  I chose these particular examples
because they came up in the Subversion project (<ulink
url="http://subversion.tigris.org/"/>),
which I participated in and observed from its very beginning.  But
they're not unique to Subversion; situations like these will come up
in most open source projects, and should be seen as opportunities to
start things off on the right foot.</para>

<!-- ======================== subsection ============================== -->
<sect2 id="avoid-private-discussions">
<title>Avoid Private Discussions</title>

<para>Even after you've taken the project public, you and the other
founders will often find yourselves wanting to settle difficult
questions by private communications among an inner circle.  This is
especially true in the early days of the project, when there are so
many important decisions to make, and, usually, few volunteers
qualified to make them.  All the obvious disadvantages of public list
discussions will loom palpably in front of you: the delay inherent in
email conversations, the need to leave sufficient time for consensus
to form, the hassle of dealing with naive volunteers who think they
understand all the issues but actually don't (every project has these;
sometimes they're next year's star contributors, sometimes they stay
naive forever), the person who can't understand why you only want to
solve problem X when it's obviously a subset of larger problem Y, and
so on.  The temptation to make decisions behind closed doors and
present them as <foreignphrase>faits accomplis</foreignphrase>, or at
least as the firm recommendations of a united and influential voting
block, will be great indeed.</para>

<para>Don't do it.</para>

<para>As slow and cumbersome as public discussions can be, they're
almost always preferable in the long run.  Making important decisions
in private is like spraying contributor repellant on your project.  No
serious volunteer would stick around for long in an environment where
a secret council makes all the big decisions.  Furthermore, public
discussion has beneficial side effects that will last beyond whatever
ephemeral technical question was at issue:

<itemizedlist>
  <listitem>
  <para>The discussion will help train and educate new developers.
        You never know how many eyes are watching the conversation;
        even if most people don't participate, many may be tracking
        silently, gleaning information about the software.</para>
  </listitem>
  <listitem>
  <para>The discussion will train <emphasis>you</emphasis> in the art
        of explaining technical issues to people who are not as
        familiar with the software as you are.  This is a skill that
        requires practice, and you can't get that practice by talking
        to people who already know what you know.</para>
  </listitem>
  <listitem>
  <para>The discussion and its conclusions will be available in public
        archives forever after, enabling future discussions to avoid
        retracing the same steps.  See
        <xref linkend="using-archives"/><phrase output="printed">
        in <xref linkend="communications"/></phrase>.</para>
  </listitem>
</itemizedlist>

</para>

<para>Finally, there is the possibility that someone on the list may
make a real contribution to the conversation, by coming up with an
idea you never anticipated.  It's hard to say how likely this is; it
just depends on the complexity of the code and degree of
specialization required.  But if anecdotal evidence may be permitted,
I would hazard that this is more likely than one would intuitively
expect.  In the Subversion project, we (the founders) believed we
faced a deep and complex set of problems, which we had been thinking
about hard for several months, and we frankly doubted that anyone on
the newly created mailing list was likely to make a real contribution
to the discussion.  So we took the lazy route and started batting some
technical ideas back and forth in private emails, until an observer of
the project<footnote><para>We haven't gotten to the section on
crediting yet, but just to practice what I'll later preach: the
observer's name was Brian Behlendorf, and it was he who pointed out
the general importance of keeping all discussions public unless there
was a specific need for privacy.</para></footnote> caught wind of what
was happening and asked for the discussion to be moved to the public
list.  Rolling our eyes a bit, we did&mdash;and were stunned by the
number of insightful comments and suggestions that quickly resulted.
In many cases people offered ideas that had never even occurred to us.
It turned out there were some <emphasis>very</emphasis> smart people
on that list; they'd just been waiting for the right bait.  It's true
that the ensuing discussions took longer than they would have if we
had kept the conversation private, but they were so much more
productive that it was well worth the extra time.</para>

<para>Without descending into hand-waving generalizations like "the
group is always smarter than the individual" (we've all met enough
groups to know better), it must be acknowledged that there are certain
activities at which groups excel.  Massive peer review is one of them;
generating large numbers of ideas quickly is another.  The quality of
the ideas depends on the quality of the thinking that went into them,
of course, but you won't know what kinds of thinkers are out there
until you stimulate them with a challenging problem.</para>

<para>Naturally, there are some discussions that must be had
privately; throughout this book we'll see examples of those.  But the
guiding principle should always be: <emphasis>If there's no reason for
it to be private, it should be public.</emphasis></para>

<para>Making this happen requires action.  It's not enough merely to
ensure that all your own posts go to the public list.  You also have
to nudge other people's unnecessarily private conversations to the
list too.  If someone tries to start a private discussion, and there's
no reason for it to be private, then it is incumbent on you to open
the appropriate meta-discussion immediately.  Don't even comment on
the original topic until you've either successfully steered the
conversation to a public place, or ascertained that privacy really was
needed.  If you do this consistently, people will catch on pretty
quickly and start to use the public forums by default.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="prevent-rudeness">
<title>Nip Rudeness in the Bud</title>

<para>From the very start of your project's public existence, you
should maintain a zero-tolerance policy toward rude or insulting
behavior in its forums.  Zero-tolerance does not mean technical
enforcement per se.  You don't have to remove people from the mailing
list when they flame another subscriber, or take away their commit
access because they made derogatory comments.  (In theory, you might
eventually have to resort to such actions, but only after all other
avenues have failed&mdash;which, by definition, isn't the case at the
start of the project.)  Zero-tolerance simply means never letting bad
behavior slide by unnoticed.  For example, when someone posts a
technical comment mixed together with an <foreignphrase>ad
hominem</foreignphrase> attack on some other developer in the project,
it is imperative that your response address the <foreignphrase>ad
hominem</foreignphrase> attack <emphasis>first</emphasis>, as a
separate issue unto itself, and only afterward move on to the
technical content.</para>

<para>It is unfortunately very easy, and all too typical, for
constructive discussions to lapse into destructive flame wars.
People will say things in email that they would never say
face-to-face.  The topics of discussion only amplify this effect: in
technical issues, people often feel there is a single right answer to
most questions, and that disagreement with that answer can only be
explained by ignorance or stupidity.  It's a short distance from
calling someone's technical proposal stupid to calling the person
themselves stupid.  In fact, it's often hard to tell where technical
debate leaves off and character attack begins, which is one reason why
drastic responses or punishments are not a good idea.  Instead, when
you think you see it happening, make a post that stresses the
importance of keeping the discussion friendly, without accusing anyone
of being deliberately poisonous.  Such "Nice Police" posts do have an
unfortunate tendency to sound like a kindergarten teacher lecturing a
class on good behavior:</para>

    <blockquote>
      <para><emphasis>First, let's please cut down on the
      (potentially) ad hominem comments; for example, calling J's
      design for the security layer "naive and ignorant of the basic
      principles of computer security."  That may be true or it may
      not, but in either case it's no way to have the discussion.  J
      made his proposal in good faith.  If it has deficiencies, point
      them out, and we'll fix them or get a new design.  I'm sure M
      meant no personal insult to J, but the phrasing was unfortunate,
      and we try to keep things constructive around here.
      </emphasis></para>

      <para><emphasis>Now, on to the proposal.  I think M was right
      in saying that...</emphasis></para>
    </blockquote>

<para>As stilted as such responses sound, they have a noticeable
effect.  If you consistently call out bad behavior, but don't demand
an apology or acknowledgment from the offending party, then you leave
people free to cool down and show their better side by behaving more
decorously next time&mdash;and they will.  One of the secrets of
doing this successfully is to never make the meta-discussion the main
topic.  It should always be an aside, a brief preface to the main
portion of your response.  Point out in passing that "we don't do
things that way around here," but then move on to the real content, so
that you're giving people something on-topic to respond to.  If
someone protests that they didn't deserve your rebuke, simply refuse
to be drawn into an argument about it.  Either don't respond (if you
think they're just letting off steam and don't require a response), or
say you're sorry if you overreacted and that it's hard to detect
nuance in email, then get back to the main topic.  Never, ever insist
on an acknowledgment, whether public or private, from someone that
they behaved inappropriately.  If they choose of their own volition to
post an apology, that's great, but demanding that they do so will only
cause resentment.</para>

<para>The overall goal is to make good etiquette be seen as one of the
"in-group" behaviors.  This helps the project, because developers can
be driven away (even from projects they like and want to support) by
flame wars.  You may not even know that they were driven away; someone
might lurk on the mailing list, see that it takes a thick skin to
participate in the project, and decide against getting involved at
all.  Keeping forums friendly is a long-term survival strategy, and
it's easier to do when the project is still small.  Once it's part of
the culture, you won't have to be the only person promoting it.  It
will be maintained by everyone.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="code-review">
<title>Practice Conspicuous Code Review</title>

<para>One of the best ways to foster a productive development
community is to get people looking at each others' code.  Some
technical infrastructure is required to do this effectively&mdash;in
particular, commit emails must be turned on; see
<xref linkend="commit-emails"/> for more details.  The effect of
commit emails is that every time someone commits a change to the
source code, an email goes out showing the log message and diffs for
the change (see <xref linkend="vc-vocabulary-diff"/>, in
<xref linkend="vc-vocabulary"/>).  <firstterm>Code review</firstterm>
is the practice of reviewing commit emails as they come in, looking
for bugs and possible improvements.<footnote><para>This is how code
review is usually done in open source projects, at any rate.  In more
centralized projects, "code review" can also mean multiple people
sitting down together and going over printouts of source code, looking
for specific problems and patterns.</para></footnote></para>

<para>Code review serves several purposes simultaneously.  It's the
most obvious example of peer review in the open source world, and
directly helps to maintain software quality.  Every bug that ships in
a piece of software got there by being committed and not detected;
therefore, the more eyes watch commits, the fewer bugs will ship.  But
code review also serves an indirect purpose: it confirms to people
that what they do matters, because one obviously wouldn't take time to
review a commit unless one cared about its effect.  People do their
best work when they know that others will take the time to evaluate
it.</para>

<para>Reviews should be public.  Even on occasions when I have been
sitting in the same physical room with developers, and one of us has
made a commit, we take care not to do the review verbally in the room,
but to send it to the development mailing list instead.  Everyone
benefits from seeing the review happen.  People follow the commentary
and sometimes find flaws in it, and even when they don't, it still
reminds them that review is an expected, regular activity, like
washing the dishes or mowing the lawn.</para>

<para>In the Subversion project, we did not at first make a regular
practice of code review.  There was no guarantee that every commit
would be reviewed, though one might sometimes look over a change if
one was particularly interested in that area of the code.  Bugs
slipped in that really could and should have been caught.  A developer
named Greg Stein, who knew the value of code review from past work,
decided that he was going to set an example by reviewing every line of
<emphasis>every single commit</emphasis> that went into the code
repository.  Each commit anyone made was soon followed by an email to
the developer's list from Greg, dissecting the commit, analyzing
possible problems, and occasionally praising a clever bit of code.  Right
away, he was catching bugs and non-optimal coding practices that would
otherwise have slipped by without ever being noticed.  Pointedly, he
never complained about being the only person reviewing every commit,
even though it took a fair amount of his time, but he did sing the
praises of code review whenever he had the chance.  Pretty soon, other
people, myself included, started reviewing commits regularly too.
What was our motivation?  It wasn't that Greg had consciously shamed
us into it.  But he had proven that reviewing code was a valuable way
to spend time, and that one could contribute as much to the project by
reviewing others' changes as by writing new code.  Once he
demonstrated that, it became expected behavior, to the point where any
commit that didn't get some reaction would cause the committer to
worry, and even ask on the list whether anyone had had a chance to
review it yet.  Later, Greg got a job that didn't leave him as much
time for Subversion, and had to stop doing regular reviews.  But by
then, the habit was so ingrained for the rest of us as to seem that it
had been going on since time immemorial.</para>

<para>Start doing reviews from very first commit.  The sorts of
problems that are easiest to catch by reviewing diffs are security
vulnerabilities, memory leaks, insufficient comments or API
documentation, off-by-one errors, caller/callee discipline mismatches,
and other problems that require a minimum of surrounding context to
spot.  However, even larger-scale issues such as failure to abstract
repeated patterns to a single location become spottable after one has
been doing reviews regularly, because the memory of past diffs informs
the review of present diffs.</para>

<!-- todo: Andrew Stellman suggested putting a checklist of what to
     look for in code review here.  That might be a good idea. -->

<para>Don't worry that you might not find anything to comment on, or
that you don't know enough about every area of the code.  There will
usually be something to say about almost every commit; even where you
don't find anything to question, you may find something to praise.
The important thing is to make it clear to every committer that what
they do is seen and understood.  Of course, code review does not
absolve programmers of the responsibility to review and test their
changes before committing; no one should depend on code review to
catch things he ought to have caught on his own.</para>

</sect2>

<!-- ======================== SECTION ============================== -->
<sect2 id="opening-closed-projects">
<title>When Opening a Formerly Closed Project, be Sensitive to the
Magnitude of the Change</title>

<para>If you're opening up an existing project, one that already has
active developers accustomed to working in a closed-source
environment, make sure everyone understands that a big change is
coming&mdash;and make sure that you understand how it's going to
feel from their point of view.</para>

<para>Try to imagine how the situation looks to them: formerly, all
code and design decisions were made with a group of other programmers
who knew the software more or less equally well, who all received the
same pressures from the same management, and who all know each others'
strengths and weaknesses.  Now you're asking them to expose their code
to the scrutiny of random strangers, who will form judgements based
only on the code, with no awareness of what business pressures may
have forced certain decisions.  These strangers will ask lots of
questions, questions that jolt the existing developers into realizing
that the documentation they slaved so hard over is
<emphasis>still</emphasis> inadequate (this is inevitable).  To top it
all off, the newcomers are unknown, faceless entities.  If one of your
developers already feels insecure about his skills, imagine how that
will be exacerbated when newcomers point out flaws in code he wrote,
and worse, do so in front of his colleagues.  Unless you have a team
of perfect coders, this is unavoidable&mdash;in fact, it will probably
happen to all of them at first.  This is not because they're bad
programmers; it's just that any program above a certain size has bugs,
and peer review will spot some of those bugs (see
<xref linkend="code-review"/><phrase output="printed"> earlier
in this chapter</phrase>).  At the same time, the newcomers
themselves won't be subject to much peer review at first, since they
can't contribute code until they're more familiar with the project.
To your developers, it may feel like all the criticism is incoming,
never outgoing.  Thus, there is the danger of a siege mentality taking
hold among the old hands.</para>

<para>The best way to prevent this is to warn everyone about what's
coming, explain it, tell them that the initial discomfort is perfectly
normal, and reassure them that it's going to get better.  Some of
these warnings should take place privately, before the project is
opened.  But you may also find it helpful to remind people on the
public lists that this is a new way of development for the project,
and that it will take some time to adjust.  The very best thing you
can do is lead by example.  If you don't see your developers answering
enough newbie questions, then just telling them to answer more isn't
going to help.  They may not have a good sense of what warrants a
response and what doesn't yet, or it could be that they don't have a
feel for how to prioritize coding work against the new burden of
external communications.  The way to get them to participate is to
participate yourself.  Be on the public mailing lists, and make sure
to answer some questions there.  When you don't have the
expertise to field a question, then visibly hand it off to a developer
who does&mdash;and watch to make sure he follows up with an answer,
or at least a response.  It will naturally be tempting for the
longtime developers to lapse into private discussions, since that's
what they're used to.  Make sure you're subscribed to the internal
mailing lists on which this might happen, so you can ask that such
discussions be moved to the public lists right away.</para>

<para>There are other, longer-term concerns with opening up formerly
closed projects.  <xref linkend="social-infrastructure"/> explores
techniques for mixing paid and unpaid developers successfully, and
<xref linkend="legal"/> discusses the necessity of legal diligence
when opening up a private code base that may contain software written
or "owned" by other parties.</para>

</sect2>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="announcing">
<title>Announcing</title>

<para>Once the project is presentable&mdash;not perfect, just
presentable&mdash;you're ready to announce it to the world.  This is
actually a very simple process: go to <ulink
url="http://freshmeat.net/"/>, click on
<guimenuitem>Submit</guimenuitem> in the top navigation bar, and fill
out a form announcing your new project.  Freshmeat is the place
everyone watches for new project announcements.  You only have to
catch a few eyes there for news of your project to spread by word of
mouth.</para>

<para>If you know of mailing lists or newsgroups where an announcement
of your project would be on-topic and of interest, then post there,
but be careful to make exactly <emphasis>one</emphasis> post per
forum, and to direct people to your project's own forums for follow-up
discussion (by setting the <systemitem>Reply-to</systemitem> header).
The posts should be short and get right to the point:</para>

<screen>
To: discuss@lists.example.org
Subject: [ANN] Scanley full-text indexer project
Reply-to: dev@scanley.org

This is a one-time post to announce the creation of the Scanley
project, an open source full-text indexer and search engine with a
rich API, for use by programmers in providing search services for
large collections of text files.  Scanley is now running code, is
under active development, and is looking for both developers and
testers.

Home page: http://www.scanley.org/

Features:
   - Searches plain text, HTML, and XML
   - Word or phrase searching
   - (planned) Fuzzy matching
   - (planned) Incremental updating of indexes
   - (planned) Indexing of remote web sites

Requirements:
   - Python 2.2 or higher
   - Enough disk space to hold the indexes (approximately 2x
     original data size)

For more information, please come to scanley.org.

Thank you,
-J. Random
</screen>

<para>(See <xref linkend="publicity"/><phrase output="printed">
in <xref linkend="communications"/></phrase> for advice on announcing
further releases and other project events.)</para>

<para>There is an ongoing debate in the free software world about
whether it is necessary to begin with running code, or whether a
project can benefit from being opened even during the
design/discussion stage.  I used to think starting with running code
was the most important factor, that it was what separated successful
projects from toys, and that serious developers would only be
attracted to software that did something concrete already.</para>

<para>This turned out not to be the case.  In the Subversion project,
projects from toys, and that serious developers would only be
attracted to software that did something concrete already.</para>

<para>This turned out not to be the case.  In the Subversion project,
we started with a design document, a core of interested and
well-connected developers, a lot of fanfare, and
<emphasis>no</emphasis> running code at all.  To my complete surprise,
the project acquired active participants right from the beginning, and
by the time we did have something running, there were quite a few
volunteer developers already deeply involved.  Subversion is not the
only example; the Mozilla project was also launched without running
code, and is now a successful and popular web browser.</para>

<para>In the face of such evidence, I have to back away from the
assertion that running code is absolutely necessary for launching a
project.  Running code is still the best foundation for success, and a
good rule of thumb would be to wait until you have it before
announcing your project.  However, there may be circumstances where
announcing earlier makes sense.  I do think that at least a
well-developed design document, or else some sort of code framework,
is necessary&mdash;of course it may be revised based on public
feedback, but there has to be something concrete, something more
tangible than just good intentions, for people to sink their teeth
into.</para>

<para>Whenever you announce, don't expect a horde of volunteers to
join the project immediately afterward.  Usually, the result of
announcing is that you get a few casual inquiries, a few more people
join your mailing lists, and aside from that, everything continues
pretty much as before.  But over time, you will notice a gradual
increase in participation from both new code contributors and users.
Announcement is merely the planting of a seed.  It can take a long
time for the news to spread.  If the project consistently rewards
those who get involved, the news <emphasis>will</emphasis> spread,
though, because people want to share when they've found something
good.  If all goes well, the dynamics of exponential communications
networks will slowly transform the project into a complex community,
where you don't necessarily know everyone's name and can no longer
follow every single conversation.  The next chapters are about working
in that environment.</para>

</sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->

