<chapter id="technical-infrastructure">

<!--
<title>Technical Infrastructure</title>
-->
<title>技術的な問題</title>

<simplesect>

<!--
<para>Free software projects rely on technologies that support the
selective capture and integration of information.  The more skilled
you are at using these technologies, and at persuading others to use
them, the more successful your project will be.  This only becomes
more true as the project grows.  Good information management is what
prevents open source projects from collapsing under the weight of
Brooks' Law<footnote><para>From his book <citetitle>The Mythical Man
Month</citetitle>, 1975.  See <ulink
url="http://en.wikipedia.org/wiki/The_Mythical_Man-Month"/> and <ulink
url="http://en.wikipedia.org/wiki/Brooks_Law"/>.</para></footnote>,
which states that adding manpower to a late software project makes it
later.  Fred Brooks observed that the complexity of a project
increases as the <emphasis>square</emphasis> of the number of
participants.  When only a few people are involved, everyone can easily
talk to everyone else, but when hundreds of people are involved, it is
no longer possible for each person to remain constantly aware of what
everyone else is doing.  If good free software project management is
about making everyone feel like they're all working together in the
same room, the obvious question is: what happens when everyone in a
crowded room tries to talk at once?</para>
-->
<para>
  フリーソフトウェアプロジェクトを運営していくには、
  さまざまな情報を取捨選択する技術が必要です。
  これらの技術を使いこなせばこなすほど、また周りの人に使わせれば使わせるほど、
  プロジェクトがうまくいく可能性が高くなります。
  プロジェクトの規模が大きくなればなるほど、この傾向は強まります。
  うまく情報を管理しないと、オープンソースプロジェクトは
  ブルックスの法則
  <footnote>
    <para>
      1975 年に出版された彼の著書 <citetitle>The Mythical Man Month</citetitle>
      (邦題:「人月の神話」) に登場した法則。
      <ulink url="http://en.wikipedia.org/wiki/The_Mythical_Man-Month"/> および
      <ulink url="http://en.wikipedia.org/wiki/Brooks_Law"/>
      (<ulink url="http://ja.wikipedia.org/wiki/%E3%83%96%E3%83%AB%E3%83%83%E3%82%AF%E3%82%B9%E3%81%AE%E6%B3%95%E5%89%87">
      日本語</ulink>) を参照してください。
    </para>
  </footnote>
  (プロジェクトの終盤になってから人を増やしたところで、
  かえってプロジェクトの完成が遅れてしまう) の罠に陥ってしまいます。
  Fred Brooks は、プロジェクトの複雑度はそれにかかわる関係者の数の
  <emphasis>２乗</emphasis>に比例するとしています。
  メンバーの数がほんの数人の時は、簡単にお互いの意思疎通ができます。
  しかしメンバーが数百人規模に膨れ上がると、
  もはや他のメンバーが何をしているのかをすべて把握することは不可能です。
  フリーソフトウェアプロジェクトを管理する秘訣は、
  お互いがまるでひとつの部屋に集まってともに働いているかのように感じさせることだといいます。
  では、もし混雑した部屋に詰め込まれたメンバーがみんないっせいに話し始めたら、
  どんなことになるでしょう?
</para>

<!--
<para>This problem is not new.  In non-metaphorical crowded rooms, the
solution is <firstterm>parliamentary procedure</firstterm>: formal
guidelines for how to have real-time discussions in large groups, how
to make sure important dissents are not lost in floods of "me-too"
comments, how to form subcommittees, how to recognize when decisions
are made, etc.  An important part of parliamentary procedure is
specifying how the group interacts with its information management
system.  Some remarks are made "for the record", others are not.  The
record itself is subject to direct manipulation, and is understood to
be not a literal transcript of what occurred, but a representation of
what the group is willing to <emphasis>agree</emphasis> occurred.  The
record is not monolithic, but takes different forms for different
purposes.  It comprises the minutes of individual meetings, the
complete collection of all minutes of all meetings, summaries, agendas
and their annotations, committee reports, reports from correspondents
not present, lists of action items, etc.</para>
-->
<para>
  これは、特に目新しい問題ではありません。
  たとえ話ではない実際の混雑した部屋では、このような場合の解決法は
  <firstterm>議会制</firstterm>、つまり大人数の集団で議論を行う際の手順を決めることです。
  重要な異議が「異議なし!」の大合唱にかき消されてしまわないようにしたり、
  いくつかの小委員会を構成したり、議決方法を定義したりといったことです。
  この制度で重要なのは、その集団が情報管理システムをどのように利用するかというところです。
  "正式に記録される" 情報もあれば、そうでないものもあります。
  記録自体は方向性を決めるためのものです。
  「何が起こったのか」を単に書き記したものではなく、
  その集団で何を <emphasis>合意</emphasis> しようとしているのかを表すものと考えます。
  記録は、目的によってさまざまな形式で行います。
  個別の打ち合わせの議事録、すべての打ち合わせの議事録をまとめたもの、
  その概要、議題、コメント、委員会の報告書、
  その場にいない通信員からの報告、宿題の一覧などが記録に含まれます。
</para>

<!--
<para>Because the Internet is not really a room, we don't have to
worry about replicating those parts of parliamentary procedure that
keep some people quiet while others are speaking.  But when it comes
to information management techniques, well-run open source projects
are parliamentary procedure on steroids.  Since almost all
communication in open source projects happens in writing, elaborate
systems have evolved for routing and labeling data appropriately; for
minimizing repetitions so as to avoid spurious divergences; for
storing and retrieving data; for correcting bad or obsolete
information; and for associating disparate bits of information with
each other as new connections are observed.  Active participants in
open source projects internalize many of these techniques, and will
often perform complex manual tasks to ensure that information is
routed correctly.  But the whole endeavor ultimately depends on
sophisticated software support.  As much as possible, the
communications media themselves should do the routing, labeling, and
recording, and should make the information available to humans in the
most convenient way possible.  In practice, of course, humans will
still need to intervene at many points in the process, and it's
important that the software make such interventions convenient too.
But in general, if the humans take care to label and route information
accurately on its first entry into the system, then the software
should be configured to make as much use of that metadata as
possible.</para>
-->
<para>
  インターネットは実際の部屋とは異なるので、
  「誰かが発言しているときは他のメンバーは静かにそれを聴く」
  というようなしきたりにこだわる必要はありません。情報管理技術を駆使すると、
  オープンソースプロジェクトにおける議論の手順はより効率的になります。
  オープンソースプロジェクトでは、ほぼすべてのやりとりは文字によって行われます。
  そこで、情報を振り分けたり適切なラベル付けをしたりするためのシステムが発達してきました。
  繰り返しを最小限に抑えて間違った方向に進みにくいようにしたり、
  データを保存して検索しやすくしたり、
  間違った情報や古びた情報を訂正したり、
  あちこちに散らばった情報をまとめてそれらのつながりを見出したりといった作業のためのシステムです。
  オープンソースプロジェクトに積極的にかかわっている人たちは、
  これらのテクニックを自然に身に着けており、
  情報が正しくいきわたるように複雑な手作業を行っていることもあります。
  しかし、プロジェクト全体で考えると、これらの作業にはソフトウェアのサポートが必要です。
  可能な限り、通信に使用するメディア自身が
  振り分けやラベル付け、内容の保存といった作業を行うべきです。
  そして、その情報は、人間が見やすい形式で利用可能にしておかなければなりません。
  もちろん、現実的にはまだそこまで全自動化されているわけではなく、
  途中で何らかの人手が必要となるでしょう。
  しかし一般論として、人間側で振り分けやラベル付けのための情報を一度提供したら、
  あとはソフトウェア側でそのめたデータを最大限に活用できるようにすべきです。
</para>

<!--
<para>The advice in this chapter is intensely practical, based on
experiences with specific software and usage patterns.  But the point
is not just to teach a particular collection of techniques.  It is
also to demonstrate, by means of many small examples, the overall
attitude that will best encourage good information management in your
project.  This attitude will involve a combination of technical skills
and people skills.  The technical skills are essential because
information management software always requires configuration, plus a
certain amount of ongoing maintenance and tweaking as new needs arise
(for example, see the discussion of how to handle project growth in
<xref linkend="bug-filtering"/><phrase output="printed"> later in
this chapter</phrase>).  The people skills are necessary
because the human community also requires maintenance: it's not always
immediately obvious how to use these tools to full advantage, and in
some cases projects have conflicting conventions (for example, see the
discussion of setting <systemitem>Reply-to</systemitem> headers on
outgoing mailing list posts, in <xref linkend="mailing-lists"/>).
Everyone involved with the project will need to be encouraged, at the
right times and in the right ways, to do their part to keep the
project's information well organized.  The more involved the
contributor, the more complex and specialized the techniques she can
be expected to learn.</para>
-->
<para>
  本章でのアドバイスは、実用的なものばかりです。
  どれも特定のソフトウェアやその使用例にもとづいたものです。
  とはいえ、単に特定のテクニックを教えるだけというつもりはありません。
  ちょっとした例をたくさんご覧いただくことで、
  あなたのプロジェクトにおける情報管理をよりよくするための
  一般的な方法を身につけていただくつもりです。
  これには、技術的なスキルだけでなく社会的なスキルも含まれます。
  技術的なスキルは必要不可欠です。というのも、
  情報管理用のソフトウェアは常に何らかの設定が必要となるからです。
  また、運用中にもある程度の保守作業が必要です
  (たとえば、大きく成長したプロジェクトをどのように扱うかについて、
  <phrase output="printed">本章の後半</phrase> の
  <xref linkend="bug-filtering"/> で取り上げています)。
  また、社会的なスキルも必須です。なぜなら、
  人間の集まりについても維持する必要があるからです。
  さまざまなツールを使用して利益を受ける方法は、
  すぐに明らかになるとは限りません。場合によってはその使用法をめぐって争いが起こるかもしれません
  (例として、メーリングリストから配送されるメールの
  <systemitem>Reply-to</systemitem> ヘッダの設定についての議論を
  <xref linkend="mailing-lists"/> で取り上げています)。
  プロジェクトに参加している人たちはみな、
  そのプロジェクトの情報をうまく管理するための方法を必要としています。
  プロジェクトに深くかかわればかかわるほど、
  学ばねばならないテクニックは複雑で専門的なものになります。
</para>

<!--
<para>Information management has no cut-and-dried solution.  There are
too many variables.  You may finally get everything configured just
the way you want it, and have most of the community participating, but
then project growth will make some of those practices unscalable.  Or
project growth may stabilize, and the developer and user communities
settle into a comfortable relationship with the technical
infrastructure, but then someone will come along and invent a whole
new information management service, and pretty soon newcomers will be
asking why your project doesn't use it&mdash;for example, this is
happening now to a lot of free software projects that predate the
invention of the wiki (see
<ulink url="http://en.wikipedia.org/wiki/Wiki"/>).  Many questions are
matters of judgement, involving tradeoffs between the convenience of
those producing information and the convenience of those consuming it,
or between the time required to configure information management
software and the benefit it brings to the project.</para>
-->
<para>
  情報管理には、月並みな解決策はありません。
  考慮すべき点があまりにも多すぎるのです。
  最終的に望みどおりの手段が見つかるかもしれません。
  コミュニティーの参加者のほとんどもその方法を利用してくれるかもしれません。
  しかし、プロジェクトがさらに成長したときに、
  その方法がそのまま使えるとは限りません。
  あるいは、プロジェクトの成長が安定し、
  開発者とユーザーの両方が現在の情報管理技術に慣れてきたときに、
  だれかがまったく新しい情報管理サービスを発明するかもしれません。
  新しくプロジェクトに参加したメンバーはきっとこう言うでしょう。
  「何であの便利なツールを使わないの?」
  Wiki (<ulink url="http://ja.wikipedia.org/wiki/Wiki"/> を参照してください)
  が登場しだした頃に、当時のプロジェクトの多くでまさにこれと同じことが起こりました。
  どのような手段を使用するかを決めるには、さまざまな判断材料があります。
  たとえば、情報を提供する側と情報を利用する側のどちらの利便性を優先させるかも
  判断材料のひとつとなるでしょう。あるいは、
  情報管理ソフトウェアの設定の難易度と、
  それがプロジェクトにもたらす利益とのトレードオフについても考える必要があります。
</para>

<!--
<para>Beware of the temptation to over-automate, that is, to automate
things that really require human attention.  Technical infrastructure
is important, but what makes a free software project work is
care&mdash;and intelligent expression of that care&mdash;by the humans
involved.  The technical infrastructure is mainly about giving humans
convenient ways to do that.</para>
-->
<para>
  あまりになんでもかんでも自動化しすぎないようにしましょう。
  実際、人手がかかわるべきところまで自動化してしまってはいけません。
  技術的な仕組みは重要ではありますが、
  フリーソフトウェアプロジェクトをうまく運営するために重要なのは、
  結局のところ人への気配り&mdash;決しておしつけがましくない気配りなのです。
  技術的な仕組みというのは、この気配りをうまく行うための手段に過ぎません。
</para>

</simplesect>


<!-- ======================== SECTION ============================== -->
<sect1 id="tools-needed">
<!--
<title>What a Project Needs</title>
-->
<title>プロジェクトに必要なもの</title>

<!--
<para>Most open source projects offer at least a minimum, standard set
of tools for managing information:</para>
-->
<para>
  ほとんどのオープンソースプロジェクトは、
  情報管理用のツールとして少なくとも以下のようなものを用意しています。
</para>

<variablelist>

<!--
   <varlistentry><term>Web site</term>
     <listitem>
     <para>Primarily a centralized, one-way conduit of
           information from the project out to the public.  The web
           site may also serve as an administrative interface for
           other project tools.</para>
     </listitem>
   </varlistentry>
-->
   <varlistentry><term>ウェブサイト</term>
     <listitem>
     <para>
       プロジェクトについての情報を、
       管理者側から一般に向けて公開する場所です。
       また、プロジェクトで使用するその他のツールについての
       管理用インターフェイスもここで提供します。
     </para>
     </listitem>
   </varlistentry>

<!--
   <varlistentry><term>Mailing lists</term>
     <listitem>
       <para>Usually the most active communications forum in the
             project, and the "medium of record."</para> 
     </listitem>
   </varlistentry>
-->
   <varlistentry><term>メーリングリスト</term>
     <listitem>
       <para>
         通常は、そのプロジェクトにおける最も活発な議論の場となります。
         また、議論の「記録媒体」としての意味合いもあります。
       </para> 
     </listitem>
   </varlistentry>

<!--
   <varlistentry><term>Version control</term>
     <listitem>
       <para>Enables developers to manage code changes conveniently,
             including reverting and "change porting".  Enables
             everyone to watch what's happening to the code.</para>
     </listitem>
   </varlistentry>
-->
   <varlistentry><term>バージョン管理システム</term>
     <listitem>
       <para>
         開発者が、コードの変更点を追いかけやすくするものです。
         変更内容を元に戻したり、他に移植したりすることもできます。
         これを見ると、コードに何が起こっているのかを誰もが知ることができます。
       </para>
     </listitem>
   </varlistentry>

<!--
   <varlistentry><term>Bug tracking</term>
     <listitem>
       <para>Enables developers to keep track of what they're working
             on, coordinate with each other, and plan releases.  Enables
             everyone to query the status of bugs and record
             information (e.g., reproduction recipes) about particular
             bugs.  Can be used for tracking not only bugs, but also
             tasks, releases, new features, etc.</para>
     </listitem>
   </varlistentry>
-->
   <varlistentry><term>バグ追跡システム</term>
     <listitem>
       <para>
         開発者が自分の作業内容を確認したり、
         他の開発者と作業を調整したり、リリース時期の予定をたてたりするために用います。
         特定のバグの状況や関連情報 (再現手順など)
         について、誰もが調べられるようになります。
         バグだけに限らず、やるべき作業やリリース時期、
         新機能の追加などについてもここで扱うことがあります。
       </para>
     </listitem>
   </varlistentry>

<!--
   <varlistentry><term>Discussion forums</term>
     <listitem>
       <para><remark>Basically, bulletin board systems.  These are not
             as widespread as one would expect, and where they are
             found, they're not used as much as one would expect.  Why?
             Are they worth mentioning at all?</remark></para>
     </listitem>
   </varlistentry>
-->

<!--
   <varlistentry><term>Real-time chat</term>
     <listitem>
       <para>A place for quick, lightweight discussions and
             question/answer exchanges.  Not always archived
             completely.</para>
     </listitem>
   </varlistentry>
-->
   <varlistentry><term>リアルタイムチャット</term>
     <listitem>
       <para>
         ちょっとした議論や質問のやり取りのための場です。
         議論の内容がアーカイブされないこともあります。
       </para>
     </listitem>
   </varlistentry>

</variablelist>

<!--
<para>Each tool in this set addresses a distinct need, but their functions
are also interrelated, and the tools must be made to work together.
Below we will examine how they can do so, and more importantly, how to
get people to use them.  The web site is not discussed until the end,
since it acts more as glue for the other components than as a tool
unto itself.</para>
-->
<para>
  ここであげたツールはどれも異なるニーズを満たすものではありますが、
  その機能には相関性があります。また、
  各種ツール群は協調して動作させなければなりません。これ以降では、
  その方法について考えます。また、より重要なこととして、
  メンバーにそれを使ってもらうためにはどうすればいいのかも説明します。
  ウェブサイトについての議論は後回しにします。というのもウェブサイトは、
  独立したツールというよりは
  他のツールを組み合わせるための接着剤のようなものだからです。
</para>

<!--
<para>You may be able to avoid a lot of the headache of choosing and
configuring these tools by using a <firstterm>canned
hosting</firstterm> site: a server that offers prepackaged,
templatized web areas with all the accompanying tools needed to run a
free software project.  See
<xref linkend="canned-hosting"/><phrase output="printed"> later
in this chapter</phrase> for a discussion of the advantages and
disadvantages of canned hosting.</para>
-->
<para>
  どんなツールを選択しようかといった問題に悩まされたくないという場合は、
  出来合いの <firstterm>ホスティング</firstterm> サイトを使用するといいでしょう。
  たいていはパッケージ化されたウェブサイトのテンプレートが用意されており、
  フリーソフトウェアプロジェクトの運営に必要なツールもひととおりそろっているはずです。
  <phrase output="printed">本章の後半</phrase>の
  <xref linkend="canned-hosting"/> で、
  ホスティングサイトの利点と欠点を取り上げます。
</para>

</sect1>


<!-- ========================== SECTION =========================== -->
<sect1 id="mailing-lists">
<!--
<title>Mailing Lists</title>
-->
<title>メーリングリスト</title>

<!--
<para>Mailing lists are the bread and butter of project
communications.  If a user is exposed to any forum besides the web
pages, it is most likely to be one of the project's mailing lists.
But before they experience the mailing list itself, they will
experience the mailing list interface&mdash;that is, the mechanism
by which they join ("subscribe to") the list.  This brings us to Rule
#1 of mailing lists:</para>
-->
<para>
  メーリングリストは、プロジェクト内でのコミュニケーションに必要不可欠なものです。
  ウェブページ以外にユーザーに見せるものがあるとすれば、
  まず最初はそのプロジェクトのメーリングリストとなるでしょう。
  しかし、メーリングリストに参加する前に、
  ユーザーはまずそのメーリングリストのインターフェイス
  (たとえば "メーリングリストに参加する" など)
  に出会うことになります。
  ここから、次の「メーリングリスト第一法則」が得られます。
</para>

<!--
<blockquote>
   <para><emphasis>Don't try to manage mailing lists by hand&mdash;get
   list management software.</emphasis></para>
</blockquote>
-->
<blockquote>
   <para><emphasis>
     メーリングリストの管理は、手作業で行うのではなく、
     専用のソフトウェアを使用すること。
   </emphasis></para>
</blockquote>

<!--
<para>It will be tempting to put this off.  Setting up mailing list
management software might seem like overkill at first.  Managing
small, low-traffic lists by hand will seem seductively easy: you just
set up a subscription address that forwards to you, and when someone
mails it, you add (or remove) their email address in some text file
that holds all the addresses on the list.  What could be
simpler?</para>
-->
<para>
  いきなりそんなことを言われても驚きますよね。
  メーリングリストの管理用にわざわざソフトウェアをセットアップするなんて、
  ちょっとやりすぎのように感じられるかもしれません。
  小規模で流量の少ないメーリングリストは手動で管理するほうが楽に見えます。
  参加申し込み用のアドレスをひとつ作成してそれをあなた宛てに転送されるようにしておき、
  届いたメールの内容を見て、アドレス一覧 (おそらく単なるテキストファイル)
  に追加したり削除したりするだけです。
  これ以上にシンプルなやりかたなんてないでしょう?
</para>

<!--
<para>The trick is that good mailing list management&mdash;which is
what people have come to expect&mdash;is not simple at all.  It's not
just about subscribing and unsubscribing users when they request.
It's also about moderating to prevent spam, offering the mailing list
in digest versus message-by-message form, providing standard list and
project information by means of auto-responders, and various other
things.  A human being monitoring a subscription address can supply
only a bare minimum of functionality, and even then not as reliably
and promptly as software could.</para>
-->
<para>
  みんなが満足するレベルでメーリングリストの管理を行うということは、
  思っているほど簡単なことではありません。
  メーリングリストの管理というのは、
  単にユーザーを登録したり削除したりするだけの話ではありません。
  スパムよけのために投稿内容をモデレートするようにしたり、
  複数の投稿をひとまとめにした形式でメールを配信するようにしたり、
  メーリングリストやプロジェクトに関する情報を自動返信するようにしたり
  といったさまざまな内容があります。
  参加用のアドレスを人手でチェックするというだけでは、
  最小限の機能しか提供することができません。
  そしてその最小限の機能でさえ、ソフトウェアに任せるのに比べると
  信頼性や即時性に欠けるものとなるでしょう。
</para>

<!--
<para>Modern list management software usually offers at least the
following features:</para>
-->
<para>
  いまどきのメーリングリスト管理用ソフトウェアなら、
  少なくとも次のような機能が搭載されているはずです。
</para>

<variablelist>

<!--
  <varlistentry><term>Both email- and web-based subscription</term>
    <listitem>
      <para>When a user subscribes to a list, she should
            <emphasis>promptly</emphasis> get an automated welcome
            message in reply, telling her what she has subscribed
            to, how to interact further with the mailing list
            software, and (most importantly) how to unsubscribe.  This
            automatic reply can be customized to contain
            project-specific information, of course, such as the
            project's web site, FAQ location, etc.</para>
    </listitem>
  </varlistentry>
-->
  <varlistentry><term>メールおよびウェブの両方からの参加受付</term>
    <listitem>
      <para>
        ユーザーがメーリングリストへの参加を申し込むと、
        <emphasis>すぐに</emphasis>自動返信のメッセージを受け取ります。
        そこには、参加しようとしているメーリングリストの情報や
        メーリングリストソフトウェアへの指示の出し方、そして
        (最も重要な項目として) リストからの退会のしかたなどが書かれています。
        この自動返信の内容はカスタマイズすることが可能です。
        ここにはプロジェクトのウェブサイトや
        FAQ の場所といった情報を含めることができます。
      </para>
    </listitem>
  </varlistentry>

<!--
  <varlistentry><term>Subscription in either digest mode or
                      message-by-message mode</term>
    <listitem>
      <para>In digest mode, the subscriber receives one email per day,
            containing all the list activity for that day.  For people
            who are following a list loosely, without participating,
            digest mode is often preferable, because it allows them to
            scan all the subjects at once and avoid the distraction
            of emails coming in at random times.</para>
    </listitem>
  </varlistentry>
-->
  <varlistentry>
    <term>一通ごとの配信かまとめての配信かの選択</term>
    <listitem>
      <para>
       ダイジェストモード (「まとめて配信」モード)
       にすると、参加者が受け取るメールは１日に１通となります。
       その日に投稿されたすべてのメールの内容が１通にまとめて送信されるわけです。
       積極的に参加するわけではないが、
       大まかな話の流れは追いかけておきたいといった人たちには
       ダイジェストモードがお勧めです。
       これを使用すると、頻繁にやってくるメールに気を散らされることなく
       その日のメールの内容をゆっくり見渡せるからです。
      </para>
    </listitem>
  </varlistentry>

<!--
  <varlistentry><term>Moderation features</term>
    <listitem>
      <para>To "moderate" is to check posts to make sure they are
            a)&nbsp;not&nbsp;spam, and b)&nbsp;on&nbsp;topic, before
            they go out to the entire list.  Moderation necessarily
            involves humans, but software can do a lot to make it
            easier.  There is more said about moderation
            later.</para>
    </listitem>
  </varlistentry>
-->
  <varlistentry><term>モデレート機能</term>
    <listitem>
      <para>
        「モデレート」とは、
        投稿の内容をいったんチェックし、
        a)&nbsp;スパムでないこと、そして
        b)&nbsp;メーリングリストで扱うのにふさわしい内容であること
        を確認してから一般向けに配信する作業のことです。
        モデレート処理は、必ずしも人間が行わなければならないというものではありません。
        ソフトウェアに任せることで、より簡単に行えるようになります。
        モデレートについては、後でもういちど取り上げます。
      </para>
    </listitem>
  </varlistentry>

<!--
  <varlistentry><term>Administrative interface</term>
    <listitem>
      <para>Among other things, this enables an administrator to go in
            and remove obsolete addresses easily.  This can become
            urgent when a recipient's address starts sending automatic
            "I am no longer at this address" replies back to the list
            in response to every list post.  (Some mailing list
            software can even detect this by itself and unsubscribe
            the person automatically.)</para>
    </listitem>
  </varlistentry>
-->
  <varlistentry><term>管理者用インターフェイス</term>
    <listitem>
      <para>
        これは特に、使われなくなったアドレスを簡単に削除するために有用です。
        メーリングリストの参加者のアドレスから
        「このアドレスはもう存在しません」といった自動返信メッセージが毎回届くようになったら、
        即刻対応しなければなりません
        (メーリングリストソフトウェアによっては、
        これを自動検出して該当者を自動的にメンバーから外すようにできるものもあります)。
      </para>
    </listitem>
  </varlistentry>

<!--
  <varlistentry><term>Header manipulation</term>
    <listitem>
      <para>Many people have sophisticated filtering and replying
            rules set up in their mail readers.  Mailing list software
            can add and manipulate certain standard headers for these
            people to take advantage of (more details below).</para>
    </listitem>
  </varlistentry>
-->
  <varlistentry><term>ヘッダの操作</term>
    <listitem>
      <para>
        多くの人は、メールソフトの仕分け機能などを活用していることでしょう。
        メーリングリストソフトウェアを使用すると、
        特定のヘッダをメールに付加することで
        これらの機能を使いやすいようにします
        (詳細は後で説明します)。
      </para>
    </listitem>
  </varlistentry>

<!--
  <varlistentry><term>Archiving</term>
    <listitem>
      <para>All posts to the managed lists are stored and made
            available on the web; alternatively, some mailing list
            software offers special interfaces for plugging in an
            external archiving tool such as MHonArc
            (<ulink url="http://www.mhonarc.org/"/>).  As
            <xref
            linkend="using-archives"/><phrase output="printed">
            in <xref linkend="communications"/></phrase>
            discusses, archiving is crucial.</para>
    </listitem>
  </varlistentry>
-->
  <varlistentry><term>アーカイブ処理</term>
    <listitem>
      <para>
        メーリングリストへのすべての投稿は、
        保存されたうえでウェブから閲覧可能になります。
        あるいは、メーリングリストソフトウェアによっては
        MHonArc (<ulink url="http://www.mhonarc.org/"/>)
        のような外部のアーカイブツールへのプラグインインターフェイスを持っているものもあります。
        <phrase output="printed"><xref linkend="communications"/></phrase>
        の <xref linkend="using-archives"/> で説明するように、
        アーカイブは重要な作業です。
      </para>
    </listitem>
  </varlistentry>

</variablelist>

<!--
<para>The point of all this is merely to emphasize that mailing list
management is a complex problem that has been given a lot of thought,
and mostly been solved.  You certainly don't need to become an expert
in it.  But you should be aware that there's always room to learn
more, and that list management will occupy your attention from time to
time in the course of running a free software project.  Below we'll
examine a few of the most common mailing list configuration
issues.</para>
-->
<para>
  このようにひとつひとつ挙げてみると、
  メーリングリストの管理というものが思いのほか複雑な作業であることがお分かりでしょう。
  そして、それらの作業の多くがソフトウェアで自動化できることもわかります。
  決してこれらのソフトウェアのエキスパートになる必要はありません。
  しかし、まだまだ常に学ぶ余地があるということ、
  そしてフリーソフトウェアプロジェクトを運営するにあたって
  メーリングリストの管理作業は避けて通れないものであることは心においておきましょう。
  これ以降では、メーリングリストの設定に関するよくある問題についてみていきます。
</para>

<!-- ========================== subsection =========================== -->
<sect2 id="spam-prevention">
<!--
<title>Spam Prevention</title>
-->
<title>スパム対策</title>

<!--
<para>Between when this sentence is written and when it is published,
the Internet-wide spam problem will probably double in
severity&mdash;or at least it will feel that way.  There was a time,
not so long ago, when one could run a mailing list without taking any
spam-prevention measures at all.  The occasional stray post would
still show up, but infrequently enough to be only a low-level
annoyance.  That era is gone forever.  Today, a mailing list that
takes no spam prevention measures will quickly be submerged in junk
emails, to the point of unusability.  Spam prevention is
mandatory.</para>
-->
<para>
  今、この文章を書いている時点と実際に本書が出版された時点を比べても、
  スパムに関する問題の深刻度は倍増していることでしょう。
  少なくとも、そう感じるくらいのレベルにはなっているはずです。
  つい最近までは、スパム対策をまったく行わなくても
  メーリングリストを普通に運営できていました。
  ごくまれに変な投稿が行われることもありましたが、気になるほどのものではなかったのです。
  しかし、そんな時代はとっくに終わってしまいました。
  現在では、スパム対策をまったくしていないメーリングリストは
  あっという間にゴミメールの山となってしまいます。
  そんなメーリングリストは使い物にならないでしょう。
  スパムは決して野放しにしてはいけません。
</para>

<!--
<para>We divide spam prevention into two categories: preventing spam
posts from appearing on your mailing lists, and preventing your
mailing list from being a source of new email addresses for spammers'
harvesters.  The former is more important, so we examine it
first.</para>
-->
<para>
  本書では、スパム対策を２種類に分けて考えます。
  ひとつはメーリングリストにスパムが配信されないようにすること。
  もうひとつは、メーリングリストの参加者のメールアドレスを
  スパム業者に収集されないようにすることです。
  前者の方がより大事なので、まずはそちらから考えていきましょう。
</para>

<sect3 id="spam-filtering">
<!--
<title>Filtering posts</title>
-->
<title>投稿のフィルタリング</title>

<!--
<para>There are three basic techniques for preventing spam posts, and
most mailing list software offers all three.  They are best used in
tandem:</para>
-->
<para>
  スパム投稿を防ぐ基本的な方法は、次の３つです。
  ほとんどのメーリングリストソフトウェアは、これらの機能をすべて提供しています。
  また、これらの方法は、どれかひとつだけを使うのではなく
  組み合わせて使うと有効です。
</para>

<orderedlist>

<!--
  <listitem><para><emphasis role="bold">Only auto-allow postings from
            list subscribers.</emphasis></para>

            <para>This is effective as far as it goes, and also
            involves very little administrative overhead, since it's
            usually just a matter of changing a setting in the mailing
            list software's configuration.  But note that posts which
            aren't automatically approved must not be simply
            discarded.  Instead, they should be passed along for
            moderation, for two reasons.  First, you want to allow
            non-subscribers to post.  A person with a question or
            suggestion should not need to subscribe to a mailing list
            just to make a single post there.  Second, even
            subscribers may sometimes post from an address other than
            the one by which they're subscribed.  Email addresses are
            not a reliable method of identifying people, and shouldn't
            be treated as such.</para>
            </listitem>
-->
  <listitem><para><emphasis role="bold">メーリングリストのメンバーからの投稿のみを自動配信する</emphasis></para>

            <para>
              これはある程度は有効で、管理者にはほとんど負担がかかりません。というのも、
              これを行うには単にメーリングリストソフトウェアの設定を変更するだけだからです。
              しかし、自動承認されなかった投稿を単に捨ててしまってはいけません。
              そうではなく、自動承認されなかった投稿は管理者がいったんチェックするようにしましょう。
              そうする理由は次の２つです。まず第一に、
              メーリングリストのメンバー以外からの投稿も受け付けたいからです。
              ちょっとした質問や提案がある人が、
              いちいちメーリングリストに参加しなければメールを投稿できないというのは不便です。
              もうひとつ、メーリングリストのメンバーであっても、
              登録しているアドレス以外のメールアドレスから投稿することがあるかもしれません。
              メールアドレスは、人を識別する手段としてはあまり信頼できるものではありません。
              メールアドレスにあまり頼りすぎないようにしましょう。
            </para>
            </listitem>

<!--
  <listitem><para><emphasis role="bold">Filter posts through
            spam-filtering software.</emphasis></para>

            <para>If the mailing list software makes it possible (most
            do), you can have posts filtered by spam-filtering
            software.  Automatic spam-filtering is not perfect, and
            never will be, since there is a never-ending arms race
            between spammers and filter writers.  However, it can
            greatly reduce the amount of spam that gets through to the
            moderation queue, and since the longer that queue is the
            more time humans must spend examining it, any amount of
            automated filtering is beneficial.</para>

            <para>There is not space here for detailed instructions
            on setting up spam filters.  You will have to consult
            your mailing list software's documentation for that (see
            <xref
            linkend="mailing-list-software"/><phrase
            output="printed"> later in this chapter</phrase>).  List
            software often comes with some built-in spam prevention
            features, but you may want to add some third-party
            filters.  I've had good experiences with these two:
            SpamAssassin
            (<ulink url="http://spamassassin.apache.org/"/>)
            and SpamProbe
            (<ulink url="http://spamprobe.sourceforge.net/"/>).  This
            is not a comment on the many other open source spam
            filters out there, some of which are apparently also quite
            good.  I just happen to have used those two myself and
            been satisfied with them.</para>
  </listitem>
-->
  <listitem><para><emphasis role="bold">
              投稿を、いったんスパムフィルタリングソフトウェアにかける
            </emphasis></para>

            <para>
              メーリングリストソフトウェアが対応していれば (ほとんどは対応しています)、
              投稿内容をスパムフィルタリングソフトウェアに渡すことができます。
              自動スパムフィルタリングは完璧なものではありません。
              また、今後も決して完璧なものにはならないでしょう。
              スパムの送信者とフィルタの作者との戦いは永遠に続くのです。
              しかし、フィルタリングソフトを使用することで、
              管理者が手作業で処理すべきスパムを激減させることができます。
              人手で処理すべき内容が多くなればなるほど、
              自動フィルタリングは有用です。
            </para>

            <para>
              ここでは、スパムフィルタの設定方法については説明しません。
              ご利用のメーリングリストソフトウェアのドキュメントを参照してください
              (<phrase output="printed">本章の後半の</phrase>
              <xref linkend="mailing-list-software"/> で詳しく説明します)。
              メーリングリストソフトウェアにはたいてい、
              自前のスパム対策機能が組み込まれています。
              しかし、サードパーティのフィルタを使いたいこともあるでしょう。
              私がよく利用しているのは、SpamAssassin
              (<ulink url="http://spamassassin.apache.org/"/>)
              と SpamProbe
              (<ulink url="http://spamprobe.sourceforge.net/"/>)
              です。もちろんこれら以外にも
              オープンソースのスパムフィルタはたくさんありますし、
              その中にはすばらしいものもあるでしょう。
              私はたまたまこの２つで満足しているので、
              他のものをあまり調べていないというだけのことです。
            </para>
  </listitem>

<!--
  <listitem><para><emphasis role="bold">Moderation.</emphasis></para>
            <para>For mails that aren't automatically allowed by
            virtue of being from a list subscriber, and which make it
            through the spam filtering software, if any, the last stage
            is <firstterm>moderation</firstterm>: the mail is routed
            to a special address, where a human examines it and
            confirms or rejects it.</para>

            <para>Confirming a post takes one of two forms: you can
            accept the post just this once, or you can tell the list
            software to allow this and all future posts from the same
            sender.  You almost always want to do the latter, in order
            to reduce the future moderation burden.  Details on how
            to confirm vary from system to system, but it's usually a
            matter of replying to a special address with the command
            "accept" (meaning accept just this one post) or "allow"
            (allow this and future posts).</para>

            <para>Rejecting is usually done by simply ignoring the
            moderation mail.  If the list software never receives
            confirmation that something is a valid post, then it won't
            pass that post on to the list, so simply dropping the
            moderation mail achieves the desired effect.  Sometimes
            you also have the option of responding with a "reject" or
            "deny" command, to automatically disapprove future mails
            from the same sender without even running them through
            moderation.  There is rarely any point doing this, since
            moderation is mostly about spam prevention, and spammers
            tend not to send from the same address twice anyway.</para>
            </listitem>
-->
  <listitem><para><emphasis role="bold">モデレートする</emphasis></para>
            <para>
              登録されているメールアドレスからの投稿ではないので
              自動配信はされませんでした。
              また、スパムフィルタを通した結果、スパムではないと判断されました。
              そのような投稿に対する最後の手段は
              <firstterm>モデレート</firstterm> です。
              メールの内容が特別なアドレスに送られ、
              人間がその内容をチェックしたうえで承認するか却下するかを決めるのです。
            </para>

            <para>
              投稿を承認する場合は、「その投稿だけを承認する」
              あるいは「その投稿を承認し、
              今後同じアドレスからの投稿があった場合は自動的に配信する」
              のいずれかの方式となります。
              ほとんどの場合は後者の方式をとることになるでしょう。
              そうすれば、将来のモデレートの負荷を下げることができます。
              投稿の承認方法は、システムによってことなります。
              よくある方式は、特別なアドレスに対してコマンドを返信することです。
              たとえば "accept" (この投稿だけを承認する)
              あるいは "allow" (この投稿および今後のすべての投稿を承認する)
              などのようになります。
            </para>

            <para>
              却下する場合は、通常は単に何もせずにモデレートメールを無視します。
              メーリングリストソフトウェアは、
              その投稿を承認するという確認を受け取らない限り
              投稿を配信することはありません。
              つまり、単にモデレートメールを無視しておけば
              それで用が満たされるのです。
              あるいは、"reject" や "deny"
              といったコマンドを明示的に返信することもあります。
              そうすると、同じアドレスから今後投稿があった場合に
              モデレート処理の前に自動的に却下してくれるようになります。
              しかし、そんなことをしてもあまり意味はないでしょう。
              モデレートの主要な目的はスパムの防止であり、
              スパマーが同じアドレスからメールを何度も送るなんてありえないでしょうから。
            </para>
            </listitem>
</orderedlist>

<!--
<para>Be sure to use moderation <emphasis>only</emphasis> for
filtering out spams and clearly off-topic messages, such as when
someone accidentally posts to the wrong mailing list.  The moderation
system will usually give you a way to respond directly to the sender,
but don't use that method to answer questions that really belong on
the mailing list itself, even if you know the answer off the top of
your head.  To do so would deprive the project's community of an
accurate picture of what sorts of questions people are asking, and
deprive them of a chance to answer questions themselves and/or see
answers from others.  Mailing list moderation is strictly about
keeping the list free of junk and off-topic emails, nothing
more.</para>
-->
<para>
  モデレートを乱用しすぎないようにしましょう。
  スパムを防ぐことと、まったく的外れな投稿
  (投稿するメーリングリストを間違えたなど)
  を防ぐこと<emphasis>だけ</emphasis>に限るべきです。
  モデレートシステムを使用すると、
  投稿者にだけ直接返信を返すことができますが、
  それを使ってメーリングリストに関する質問に答えてはいけません。
  たとえ即答できるようなものであったとしてもです。
  そんなことをすると、どんな質問があったのかがコミュニティーに伝わりません。
  また、その質問に対してより適切に答えられる人がコミュニティーにいたとしても、
  答えるチャンスがなくなってしまいます。他の人が答えた内容も見ることができません。
  メーリングリストのモデレートは、
  ゴミメールや場違いなメールばかりにすることを防ぐためのものでしかありません。
  それ以上の何者でもありません。
</para>

</sect3>

<sect3 id="address-hiding">
<!--
<title>Address hiding in archives</title>
-->
<title>アーカイブでのメールアドレスの処理</title>

<!--
<para>To prevent your mailing lists from being a source of addresses
for spammers, a common technique is for the archives to obscure
people's email addresses, for example by replacing</para>
-->
<para>
  メーリングリスト参加者のアドレスをスパマーに抜き取られないようにするには、
  アーカイブする際にメールアドレスをぼかすのが一般的です。
  たとえば、
</para>

    <blockquote>
      <para><literal>jrandom@somedomain.com</literal></para>
    </blockquote>

<!--
<para>with</para>
-->
<para>のようなアドレスを</para>

    <blockquote>
      <para><literal>jrandom_AT_somedomain.com</literal></para>
    </blockquote>

<!--
<para>or</para>
-->
<para>あるいは</para>

    <blockquote>
      <para><literal>jrandomNOSPAM@somedomain.com</literal></para>
    </blockquote>

<!--
<para>or some similarly obvious (to a human) encoding.  Since spam
address harvesters often work by crawling through web
pages&mdash;including your mailing list's online archives&mdash;and
looking for sequences containing "@", encoding the addresses is a way
of making people's email addresses invisible or useless to spammers.
This does nothing to prevent spam from being sent to the mailing list
itself, of course, but it does avoid increasing the amount of spam
sent directly to list users' personal addresses.</para>
-->
<para>
  あるいはそれと同様な (人間には理解できるような) 形式に変換します。
  ありがちなメールアドレス収集ソフトは、
  メーリングリストのアーカイブのウェブページを読み込んで
  "@" を含む文字列を探します。したがって、
  アドレスをこのように変換しておけば収集ソフト用の対策になります。
  これは、メーリングリストに直接送られてくるようなスパムには無意味です。
  そうではなく、リストの参加者のアドレスに直接スパムが送られるのを防ぐための仕組みです。
</para>

<!--
<para>Address hiding can be controversial.  Some people like it a lot,
and will be surprised if your archives don't do it automatically.
Other people think it's too much of an inconvenience (because humans
also have to translate the addresses back before using them).
Sometimes people assert that it's ineffective, because a harvester
could in theory compensate for any consistent encoding pattern.
However, note that there is empirical evidence that address hiding
<emphasis>is</emphasis> effective, see <ulink
url="http://www.cdt.org/speech/spam/030319spamreport.shtml"/>.</para>
-->
<para>
  このようにアドレスを隠すことには賛否両論があります。
  この機能を気に入っている人は、アーカイブではそうするのが当然だと思っており、
  もしそうなっていなければ非常に驚きます。
  しかし、中にはちょっとそれはやりすぎだと考える人もいます。
  いくら人間にとっては理解できる形式であるとはいえ、
  いったん頭の中で変換しないと正しいアドレスがわからないからです。
  また、まったく無意味だという人もいます。
  いくらしっかりした符号化を行ったとしても、
  アドレス収集ソフトはそれを理論上は理解できるはずだからです。
  しかし、アドレスの変換が有用であるということは実証されています。
  <ulink url="http://www.cdt.org/speech/spam/030319spamreport.shtml"/>
  を参照してください。
</para>

<!--
<para>Ideally, the list management software would leave the choice up
to each individual subscriber, either through a special yes/no header
or a setting in that subscriber's list account preferences.  However,
I don't know of any software which offers per-subscriber or per-post
choice in the matter, so for now the list manager must make a decision
for everyone (assuming the archiver offers the feature at all, which
is not always the case).  I lean very mildly toward turning
address hiding on.  Some people are very careful to avoid posting
their email addresses on web pages or anywhere else a spam harvester
might see it, and they would be disappointed to have all that care
thrown away by a mailing list archive; meanwhile, the inconvenience
address hiding imposes on archive users is very slight, since it's
trivial to transform an obscured address back to a valid one if you
need to reach the person.  But keep in mind that, in the end, it's
still an arms race: by the time you read this, harvesters might well
have evolved to the point where they can recognize most common forms
of hiding, and we'll have to think of something else.</para>
-->
<para>
  理想を言えば、このような処理は
  個々の好みで切り替えられるようにしておくべきでしょう。
  つまり、メーリングリストの参加者の個人設定ページで
  「自分のメールアドレスを符号化する/しない」
  を切り替えられるようにしておけばいいのです。
  しかし、そのように投稿者ごとや投稿ごとに設定を切り替えられる
  ソフトウェアを見たことはありません。現状では、
  メーリングリストの管理者が全員の設定を一括で決めなければならないのです
  (アーカイブツールがメールアドレスの変換処理に対応していることを
  前提としていますが、中にはその機能がないものもあります)。
  私は、個人的にはどちらかというと変換処理を行うほうが好きです。
  自分のメールアドレスをウェブページなどに表記する際に、
  アドレス収集用ソフト対策に非常に気を使っている人たちもいます。
  そのような人たちの努力が
  メーリングリストのアーカイブによって台無しになってしまうと、
  きっと非常に悲しむことでしょう。
  一方、アドレスが変換されていることによって
  アーカイブの利用者に多少不便を感じさせたとしても、
  そんなにたいしたものではないでしょう。
  しょせん、必要なたった一人のアドレスを正しい形式に戻すだけのことなのですから。
  ところで、メールアドレスの変換作業もまた、
  終わりのない戦いであることを覚えておきましょう。
  あなたがこれを読んでいる今まさにこの間にも、
  アドレス収集ソフトウェアは進化し続けています。
  ありがちなアドレス変換方法はすでに破られており、
  私たちはまた別の方法を考えなければならないのです。
</para>

</sect3>

</sect2>

<!-- ========================== subsection =========================== -->
<sect2 id="header-management">
<!--
<title>Identification and Header Management</title>
-->
<title>識別しやすいヘッダ</title>

<!--
<para>List subscribers often want to put mails from the list into a
project-specific folder, separate from their other mail.  Their
mail reading software can do this automatically by examining the mail's
<firstterm>headers</firstterm>.  The headers are the fields at the top
of the mail that indicate the sender, recipient, subject, date, and
various other things about the message.  Certain headers are
well known and effectively mandatory:</para>
-->
<para>
  メーリングリストの参加者の中には、メーリングリストに投稿されたメールを
  別のフォルダにわけて管理したいと考える人もいることでしょう。
  メールソフトの多くは、<firstterm>ヘッダ</firstterm>
  の内容によって自動的にメールを仕分ける機能を持っています。
  ヘッダとはメールの先頭にあるフィールドのことで、
  送信者や受信者、件名、日付、その他メッセージに関するさまざまな情報を保持しています。
  以下にあげるヘッダはよく知られているものであり、
  事実上必須であるといえます。
</para>

<screen>
From: ...
To: ...
Subject: ...
Date: ...
</screen>

<!--
<para>Others are optional, though still quite standard.  For example,
emails are not strictly required to have the</para>
-->
<para>
  その他にも標準的なヘッダはありますが、
  これらは省略してもかまいません。たとえば、
</para>

<screen>
Reply-to: sender@email.address.here
</screen>

<!--
<para>header, but most do, because it gives recipients a foolproof way
to reach the author (it is especially useful when the author had to
send from an address other than the one to which replies should be
directed).</para>
-->
<para>
  ヘッダは省略することもできます。しかし大半のメッセージにはこのヘッダがついています。
  なぜなら、これを使用すると送信元のアドレスを確実に知ることができるからです
  (ふだんメールを受け取っているアドレス以外からメールを送信する場合などに特に便利です)。
</para>

<!--
<para>Some mail reading software offers an easy-to-use interface for
filing mails based on patterns in the Subject header.  This leads
people to request that the mailing list add an automatic prefix to all
Subjects, so they can set their readers to look for that prefix and
automatically file the mails in the right folder.  The idea is that
the original author would write:</para>
-->
<para>
  メールソフトの中には、Subject ヘッダの内容をもとにした
  簡単な仕分け機能を持っているものもあります。
  このようなソフトを使っている人たちからは、
  メールの件名の先頭に自動的にプレフィックスをつけてほしい
  という要望があるかもしれません。それを利用すれば、
  簡単に仕分けを行えるからです。
  どういうことかというと、次のような件名のメール
</para>

<screen>
Subject: Making the 2.5 release.
</screen>

<!--
<para>but the mail would show up on the list looking like this:</para>
-->
<para>
  が投稿されたときに、実際にメーリングリストに配信されるメールは
  次のようになるということです。
</para>

<screen>
Subject: [discuss@lists.example.org] Making the 2.5 release.
</screen>

<!--
<para>Although most list management software offers the option to do
this, I strongly recommend against turning the option on.  The problem
it solves can easily be solved in much less obtrusive ways, and the
cost of eating space in the Subject field is far too high.
Experienced mailing list users typically scan the Subjects of the
day's incoming list mail to decide what to read and/or respond to.
Prepending the list's name to the Subject can push the right side of
the Subject off the screen, rendering it invisible.  This obscures
information that people depend on to decide what mails to open, thus
reducing the overall functionality of the mailing list for
everyone.</para>
-->
<para>
  多くのメーリングリスト管理用ソフトウェアにはこの機能がついていますが、
  このオプションは使わないことをお勧めします。
  このオプションによって解決できるであろう問題は、
  もっと控えめな方法で解決することができるものです。
  一方、件名欄が無意味に長くなってしまうという点は無視できません。
  メーリングリストに慣れたユーザーは、
  まずその日にやってきたメールの件名をざっと眺め、
  どれを読んでどれに返信するのかを判断するのです。
  件名の先頭にメーリングリストの名前をつけてしまうと、
  件名の後半が画面からはみ出てしまい、見えなくなってしまいます。
  どのメールを処理するのかを決めるための情報が少なくなってしまうわけで、
  結果としてメーリングリストの使い勝手が悪くなってしまいます。
</para>

<!--
<para>Instead of munging the Subject header, teach your users to take
advantage of the other standard headers, starting with the To header,
which should say the mailing list's name:</para>
-->
<para>
  Subject ヘッダに手を加えるのではなく、
  もっと別の方法で仕分けをする方法を教えてあげるようにしましょう。
  たとえば To ヘッダなどがお勧めです。
  これはメーリングリスト名そのものとなっています。
</para>

<screen>
To: &lt;discuss@lists.example.org&gt;
</screen>

<!--
<para>Any mail reader that can filter on Subject should be able to filter on
To just as easily.</para>
-->
<para>
  Subject による仕分けができるメールソフトなら、
  まず間違いなく To による仕分けもできるはずです。
</para>

<!--
<para>There are a few other optional-but-standard headers expected for
mailing lists.  Filtering on these is even more reliable than using
the "To" or "Cc" headers; since these headers are added to each post
by the mailing list management software itself, some users may be
counting on their presence:</para>
-->
<para>
  これ以外にも必須ではないけれどメーリングリストではよく使われているヘッダがいくつかあります。
  これらのヘッダをもとにして仕分けをしたほうが、"To" や "Cc"
  に頼るよりも確実です。以下のようなヘッダは
  メーリングリスト管理ソフトウェアが直接追加するので、
  これを使用した仕分けをしている人もいることでしょう。
</para>

<screen>
list-help: &lt;mailto:discuss-help@lists.example.org&gt;
list-unsubscribe: &lt;mailto:discuss-unsubscribe@lists.example.org&gt;
list-post: &lt;mailto:discuss@lists.example.org&gt;
Delivered-To: mailing list discuss@lists.example.org
Mailing-List: contact discuss-help@lists.example.org; run by ezmlm
</screen>

<!--
<para>For the most part, they are self-explanatory.  See <ulink
url="http://www.nisto.com/listspec/list-manager-intro.html"/> for more
explanation, or if you need the really detailed, formal specification,
see <ulink url="http://www.faqs.org/rfcs/rfc2369.html"/>.
</para>
-->
<para>
  これらのヘッダは、それぞれ文字通りの意味を持っています。
  詳しくは <ulink url="http://www.nisto.com/listspec/list-manager-intro.html"/>
  をご覧ください。あるいはもっと詳しい厳密な仕様が知りたいのなら、
  <ulink url="http://www.faqs.org/rfcs/rfc2369.html"/>
  を見るといいでしょう。
</para>

<!--
<para>Notice how these headers imply that if you have a mailing list
named "list", then you also have administrative addresses "list-help"
and "list-unsubscribe" available.  In addition to these, it is normal
to have "list-subscribe", for joining, and "list-owner", for reaching
the list administrators.  Depending on the list management software
you use, these and/or various other administrative addresses may be
set up; the documentation will have details.  Usually a complete
explanation of all these special addresses is mailed to each new user
as part of an automated "welcome mail" on subscribing.  You yourself
will probably get a copy of this welcome mail.  If you don't, then ask
someone else for a copy, so you know what your users are seeing when
they join the list.  Keep the copy handy so you can answer questions
about the mailing list functions, or better yet, put it on a web page
somewhere.  That way when people lose their own copy of the
instructions and post to ask "How do I unsubscribe from this list?",
you can just hand them the URL.</para>
-->
<para>
  これらのヘッダを見ると、"list" というメーリングリストの管理用アドレスとして
  "list-help" と "list-unsubscribe" があることが何となくわかるでしょう。
  これらに加えて、通常は参加用のアドレスとして "list-subscribe"、
  管理者への連絡用アドレスとして "list-owner" があるようです。
  使用するソフトウェアによっては、
  これら以外にもさまざまな管理用アドレスが設定されるかもしれません。
  詳細はドキュメントを参照してください。
  通常、これらの特別なアドレスの一覧は、
  メーリングリストへの参加時に自動送信される
  「ようこそ」メールにまとめられています。
  あなた自身もこのメールの内容を見ることができるでしょうが、
  もし見られないようなら、メーリングリストのメンバーの誰かに見せてもらってください。
  この「ようこそ」メールの内容は、常に手元においておきましょう。
  メーリングリストの使い方に関する問い合わせに答えたり、
  ウェブページに情報をのせたりする際に役立ちます。
  メーリングリストのメンバーから「退会するにはどうしたらいいのですか?」
  という質問を受けたら、そのウェブページの URL を教えてあげればいいのです。
</para>

<!--
<para>Some mailing list software offers an option to append
unsubscription instructions to the bottom of every post.  If that
option is available, turn it on.  It causes only a couple of extra
lines per message, in a harmless location, and it can save you a lot
of time, by cutting down on the number of people who mail you&mdash;or
worse, mail the list!&mdash;asking how to unsubscribe.</para>
-->
<para>
  中には、すべての投稿の末尾に退会用の手順を載せられるようになっているソフトウェアもあります。
  もしそのようなオプションがあるのなら、有効にしておきましょう。
  これは、メッセージの目立たない場所にほんの数行の内容を追加するだけです。
  たったそれだけで、あなたの手間は激減するでしょう。
  「退会方法を教えて!」というメールがあなた宛てに
  (もっとひどいことには、メーリングリスト宛てに!) 届くことも減ります。
</para>

</sect2>

<!-- ========================== subsection =========================== -->
<sect2 id="reply-to">
<!--
<title>The Great Reply-to Debate</title>
-->
<title>Reply-to はどうすべきか</title>

<!--
<para>Earlier, in <xref linkend="avoid-private-discussions"/>, I stressed the
importance of making sure discussions stay in public forums, and
talked about how active measures are sometimes needed to prevent
conversations from trailing off into private email threads;
furthermore, this chapter is all about setting up project
communications software to do as much of the work for you as possible.
Therefore, if the mailing list management software offers a way to
automatically cause discussions to stay on the list, you would think
turning that feature on would be the obvious choice.</para>
-->
<para>
  先ほど <xref linkend="avoid-private-discussions"/> で、
  議論は公開の場で行うということの重要性を強調しました。
  できるだけそのように心がけておかないと、
  議論はどんどん個人的なメールのやりとりに収束してしまいます。
  また、本章で扱っている内容は、
  ソフトウェアを用いていかにプロジェクト内のコミュニケーションを
  円滑にするかということです。
  もし議論をメーリングリスト上で続けされるような機能が
  メーリングリスト管理ソフトウェアに搭載されているのなら、
  それを使用しない手はありません。
</para>

<!--
<para>Well, not quite.  There is such a feature, but it has some
pretty severe disadvantages.  The question of whether or not to use it
is one of the hottest debates in mailing list
management&mdash;admittedly, not a controversy that's likely to make
the evening news in your city, but it can flare up from time to time
in free software projects.  Below, I will describe the feature, give
the major arguments on both sides, and make the best recommendation I
can.</para>
-->
<para>
  ……とは一概に言い切れないのです。
  実際そのような機能はあるのですが、
  無視できない問題点もいくつかあります。
  この機能を有効にするかどうかについては、
  メーリングリスト管理に関する議論の中でも最も白熱するものです。
  ７時のニュースで取り上げられるような内容ではありませんが、
  フリーソフトウェアプロジェクトにおいては何度となく議論されてきました。
  ここでは、まずその機能について説明し、
  双方の立場の主張を並べたうえで、
  個人的にお勧めの方式を示します。
</para>

<!--
<para>The feature itself is very simple: the mailing list software
can, if you wish, automatically set the Reply-to header on every post
to redirect replies to the mailing list.  That is, no matter what the
original sender puts in the Reply-to header (or even if they don't
include one at all), by the time the list subscribers see the post,
the header will contain the list address:</para>
-->
<para>
  機能そのものは非常にシンプルです。
  メーリングリストへのすべての投稿に対して自動で Reply-to
  ヘッダを設定し、返信先をメーリングリストのアドレスにするというものです。
  もとの送信者がどんな Reply-to ヘッダをつけていたとしても
  (あるいはつけていなかったとしても)、
  メーリングリストの参加者に配信されるときには
  Reply-to がメーリングリストのアドレスに変わっています。
</para>

<screen>
Reply-to: discuss@lists.example.org
</screen>

<!--
<para>On its face, this seems like a good thing.  Because virtually
all mail reading software pays attention to the Reply-to header, now
when anyone responds to a post, their response will be automatically
addressed to the entire list, not just to the sender of the message
being responded to.  Of course, the responder can still manually
change where the message goes, but the important thing is that
<emphasis>by default</emphasis> replies are directed to the list.
It's a perfect example of using technology to encourage
collaboration.</para>
-->
<para>
  一見これはよさげな機能に見えるかもしれません。
  たいていのメールソフトは Reply-to ヘッダの内容を考慮するので、
  投稿に対して返信しようとすると、
  自動的にメーリングリスト宛てに送信するようになります。
  もちろん返信する人の意思で宛先を変更することはできますが、
  <emphasis>デフォルトで</emphasis>
  メーリングリスト宛てになるということが大事なのです。
  テクノロジーの力で協調作業をやりやすくする。
  まさに完璧な例じゃないですか。
</para>

<!--
<para>Unfortunately, there are some disadvantages.  The first is known
as the <firstterm>Can't Find My Way Back Home</firstterm> problem:
sometimes the original sender will put their "real" email address in
the Reply-to field, because for one reason or another they send email
from a different address than where they receive it.  People who
always read and send from the same location don't have this problem,
and may be surprised that it even exists.  But for those who have
unusual email configurations, or who cannot control how the From
address on their mails looks (perhaps because they send from work and
do not have any influence over the IT department), using Reply-to may
be the only way they have to ensure that responses reach them.  When
such a person posts to a mailing list that he's not subscribed to, his
setting of Reply-to becomes essential information.  If the list
software overwrites it, he may never see the responses to his post.</para>
-->
<para>
  ところが残念なことに、この方法にはいくつか欠点があるのです。
  欠点としてまず最初にあげられるのが、いわゆる
  <firstterm>Can't Find My Way Back Home (おうちに帰れない)</firstterm>
  問題です。何らかの理由で普段とは異なるアドレスからメールを送信する際など、
  「本当の」アドレスを Reply-to フィールドに指定しておくこともあります。
  常に同じ場所でメールの読み書きを行うのなら、この問題は起こりません。
  もしかしたら、そんな問題があることにすら気づいていないかもしれません。
  しかし、普段とは異なる設定でメールを送信する人や
  メールの From アドレスを変更できない状況
  (職場から送信しており、IT 部門に対する権限がない状況)
  の人にとっては、返信を自分で受け取るための唯一の手段が Reply-to となるわけです。
  そのような人たちにとって、メーリングリストに参加しているのとは別のアドレスで投稿する際には
  Reply-to 設定は必要不可欠な情報となります。
  メーリングリストソフトウェアがそれを上書きしてしまうと、
  その人は自分の投稿に対する返信を見ることができなくなってしまいます。
</para>

<!--
<para>The second disadvantage has to do with expectations, and in my
opinion is the most powerful argument against Reply-to munging.  Most
experienced mail users are accustomed to two basic methods of
replying: <firstterm>reply-to-all</firstterm> and
<firstterm>reply-to-author</firstterm>.  All modern mail reading
software has separate keys for these two actions.  Users know that to
reply to everyone (that is, including the list), they should choose
reply-to-all, and to reply privately to the author, they should choose
reply-to-author.  Although you want to encourage people to reply to
the list whenever possible, there are certainly circumstances where a
private reply is the responder's prerogative&mdash;for example, they
may want to say something confidential to the author of the original
message, something that would be inappropriate on the public
list.</para>
-->
<para>
  もうひとつの問題は、期待に反する動作をしてしまうということです。
  個人的には、Reply-to の変更に反対する人が最も強く主張しているのがこの問題だと思います。
  メールの処理に慣れている人は、<firstterm>reply-to-all (全員に返信)</firstterm>
  と <firstterm>reply-to-author (送信者に対して返信)</firstterm>
  の２通りの返信方法を使い分けています。
  最近のメールソフトは、これらの操作に対して
  それぞれ別のショートカットキーを割り当てています。
  全員 (メーリングリストも含む) に返信したい場合は
  「全員に返信」を、そして送信者に対して個人的に返信したい場合は
  単なる「返信」を使えばいいということを知っているのです。
  あなたとしては返信は可能な限りメーリングリストに送信してほしいでしょうが、
  返信するほうには個人的に返信する権利があります。たとえば、
  元のメッセージに対して何か機密情報を含む内容を返信したい場合などは、
  それが公開のメーリングリストに流れてしまってはまずいでしょう。
</para>

<!--
<para>Now consider what happens when the list has overridden the
original sender's Reply-to.  The responder hits the reply-to-author
key, expecting to send a private message back to the original author.
Because that's the expected behavior, he may not bother to look
carefully at the recipient address in the new message.  He composes
his private, confidential message, one which perhaps says embarrassing
things about someone on the list, and hits the send key.
Unexpectedly, a few minutes later his message appears <emphasis>on the
mailing list!</emphasis> True, in theory he should have looked
carefully at the recipient field, and should not have assumed anything
about the Reply-to header.  But authors almost always set Reply-to to
their own personal address (or rather, their mail software sets it for
them), and many longtime email users have come to expect that.  In
fact, when a person deliberately sets Reply-to to some other address,
such as the list, he usually makes a point of mentioning this in the
body of the message, so people won't be surprised at what happens when
they reply.</para>
-->
<para>
  さて、メーリングリスト側で送信者の Reply-to
  設定を書き換えてしまったらどうなるのかを考えてみましょう。
  そのメールに対して「送信者に返信」のキーを押したとしたら、
  当然その人はそのメールが送信者に対してのみ届くものと期待することでしょう。
  ごく当たり前のことなので、いちいちあて先を確認することもないかもしれません。
  返信メールの中で個人的な内緒のメッセージ
  (もしかしたら他のメンバーの悪口かも……)
  を書き、送信ボタンを押します。
  予想に反して、数分後には彼の書いた返信が
  <emphasis>メーリングリストに</emphasis>流れることになるでしょう!
  ええ、もちろん送信前にあて先をしっかり確認しなかった彼が悪いのです……
  理屈上は。でも、普通は Reply-to は送信者のアドレスに設定されているもの
  (メールソフトがそう設定しているはず) なので、
  長年メールを使っている人ほどそう信じ込んでしまう傾向があります。
  実際、もし意図的に他のアドレス (たとえばメーリングリストなど)
  を Reply-to に設定した場合は、通常はそれをメッセージの中で明記するものです。
</para>

<!--
<para>Because of the possibly severe consequences of this unexpected
behavior, my own preference is to configure list management software
to never touch the Reply-to header.  This is one instance where using
technology to encourage collaboration has, it seems to me, potentially
dangerous side-effects.  However, there are also some powerful
arguments on the other side of this debate.  Whichever way you choose,
you will occasionally get people posting to your list asking why you
didn't choose the other way.  Since this is not something you ever
want as the main topic of discussion on your list, it might be good to
have a canned response ready, of the sort that's more likely to stop
discussion than encourage it.  Make sure you do
<emphasis>not</emphasis> insist that your decision, whichever it is,
is obviously the only right and sensible one (even if you think that's
the case).  Instead, point out that this is a very old debate, there
are good arguments on both sides, no choice is going to satisfy
all users, and therefore you just made the best decision you
could.  Politely ask that the subject not be revisited unless someone
has something genuinely new to say, then stay out of the thread and
hope it dies a natural death.</para>
-->
<para>
  この予期せぬ振る舞いの影響は無視できないため、
  個人的にはソフトウェア側での Reply-to ヘッダの変更は行わないことをお勧めします。
  確かにこの機能は共同作業の際には便利でしょうが、
  私にとってはその副作用の影響のほうが重大に感じます。
  しかし、もう一方の立場の人たちにもそれなりの言い分があります。
  どちらを選択したとしても、「どうして○○にしなかったの?」
  という質問がたびたびメーリングリストに投稿されることになるでしょう。
  これはきっと、そのメーリングリストで本来扱いたいと思っているテーマとは異なるはずです。
  そんな場合用に、この問題に関する議論をうまくしずめるような
  お決まりの返答を用意しておくといいでしょう。ここで大切なのは、
  あなたがどちらの設定を選んだとしても、<emphasis>決して</emphasis>
  それが唯一の正解なんだと主張しないようにすることです
  (たとえ内心ではそう思っていたとしても)。
  そうではなく、次のように説明するようにしましょう。
  「この問題については昔から議論が繰り返されています。
  どちらの立場の主張にもそれなりの言い分があり、
  みんなが納得するようにすることは困難です。
  だから、私は自分がよりよいと思う設定にしたのです。」
  そして、(まったくの新入りさんが質問してくる場合は別として)
  もうこの話題はメーリングリスト上で話すのはやめるよう丁寧にお願いし、
  あとはそのスレッドを放置しておきます。
  そうすれば、そのスレッドの議論は自然に収まるでしょう。
</para>

<!--
<para>Someone may suggest a vote to choose one way or the other.  You
can do that if you want, but I personally do not feel that counting
heads is a satisfactory solution in this case.  The penalty for
someone who is surprised by the behavior is so huge (accidentally
sending a private mail to a public list), and the inconvenience for
everyone else is fairly slight (occasionally having to remind someone
to respond to the whole list instead of just to you), that it's not
clear that the majority, even though they are the majority, should be
able to put the minority at such risk.</para>
-->
<para>
  もしかしたら、誰かが「どっちがいいか投票で決めよう」なんて言い出すかもしれません。
  あなたさえかまわなければそれでもいいのですが、
  個人的には、この問題は多数決で決めるような類のものではないと思います。
  予期せぬ挙動のせいで受ける被害 (個人的なメールを
  間違ってメーリングリストに送ってしまう) は甚大ですが、
  Reply-to を書き換えないことで参加者が受ける不利益はたかが知れています
  (たまに間違って個人宛に返信してしまった人に対して、
  メーリングリストに返信するよう伝えるくらいです)。
  個人的なメールをメーリングリストに送ってしまうような人は
  ほんの一握りかもしれません。でも、たとえそうであっても
  彼らにそのようなリスクを負わせることが許されるでしょうか?
</para>

<!--
<para>I have not addressed all aspects of this issue here, just the
ones that seemed of overriding importance.  For a full discussion, see
these two canonical documents, which are the ones people always cite
when they're having this debate:
-->
<para>
  この問題に関するすべての議論を取り上げることはしません。
  ここでは、最も重要だと思われるものだけを示しておきます。
  詳細な議論の内容は、以下の文書でご確認ください。
  どちらも、この問題が持ち上がるたびに多くの人が引用するものです。

<itemizedlist>
<!--
  <listitem>
     <para><emphasis role="bold">Leave Reply-to alone</emphasis>,
     <emphasis>by Chip Rosenthal</emphasis></para>
     <para><ulink
        url="http://www.unicom.com/pw/reply-to-harmful.html"/></para>
  </listitem>
-->
  <listitem>
     <para><emphasis role="bold">Reply-to はそのままにしておくべきだという主張</emphasis>,
     <emphasis>by Chip Rosenthal</emphasis></para>
     <para><ulink
        url="http://www.unicom.com/pw/reply-to-harmful.html"/>
        (<ulink url="http://arch.bluegate.org/reply-to-harmful.html">日本語</ulink>)
     </para>
  </listitem>
<!--
  <listitem>
     <para><emphasis role="bold">Set Reply-to to list</emphasis>,
     <emphasis>by Simon Hill</emphasis></para>
     <para><ulink
        url="http://www.metasystema.net/essays/reply-to.mhtml"/></para>
  </listitem>
-->
  <listitem>
     <para><emphasis role="bold">Reply-to をメーリングリスト宛に変更すべきだという主張</emphasis>,
     <emphasis>by Simon Hill</emphasis></para>
     <para><ulink
        url="http://www.metasystema.net/essays/reply-to.mhtml"/>
        (<ulink url="http://arch.bluegate.org/reply-to.html">日本語</ulink>)
     </para>
  </listitem>
</itemizedlist>

</para>

<!--
<para>Despite the mild preference indicated above, I do not feel there
is a "right" answer to this question, and happily participate in many
lists that <emphasis>do</emphasis> set Reply-to.  The most important
thing you can do is settle on one way or the other early, and try not
to get entangled in debates about it after that.</para>
-->
<para>
  先ほど私の個人的な好みを軽く述べましたが、決してそれが "正解"
  だと確信しているわけではありません。実際、私は Reply-to を
  <emphasis>書き換えている</emphasis> メーリングリストにも多数参加しています。
  大事なことは、どちらにするのかを早めに決めておくこと。
  そして、後々この件についての議論に巻き込まれないようにすることです。
</para>

<sect3 id="reply-fantasies">
<!--
<title>Two fantasies</title>
-->
<title>私のふたつの夢</title>

<!--
<para>Someday, someone will get the bright idea to implement a
<firstterm>reply-to-list</firstterm> key in a mail reader.  It would
use some of the custom list headers mentioned earlier to figure out
the address of the mailing list, and then address the reply directly
to the list only, leaving off any other recipient addresses, since
most are probably subscribed to the list anyway.  Eventually, other
mail readers will pick up the feature, and this whole debate will go
away.  (Actually, the <ulink url="http://www.mutt.org/">Mutt</ulink>
mail reader does offer this feature.<footnote><para>Shortly after this
book appeared, <ulink url="http://www.michaelbernstein.com/"
>Michael Bernstein</ulink> wrote me to say: "There are other email
clients that implement a reply-to-list function besides Mutt. For
example, Evolution has this function as a keyboard shortcut, but not a
button (Ctrl+L)."</para></footnote>)</para>
-->
<para>
  いつの日か、どこかの誰かが <firstterm>reply-to-list</firstterm>
  機能をメールソフトに組み込んでくれるかもしれません。これを使用すると、
  先ほど説明したメーリングリスト独特のヘッダの内容をうまく読み取り、
  メーリングリスト宛てに適切に返信してくれるのです。
  それ以外の相手にはメールは送られません。
  だってその人たちほほとんどはメーリングリストにも加入しているんですから。
  結局のところ、メールソフト側でこのような機能を実装してしまえば、
  こんな議論をせずにすむようになるわけです
  (実際、<ulink url="http://www.mutt.org/">Mutt</ulink>
  というメールソフトはこの機能を持っています
  <footnote>
    <para>
      本書の出版直後に <ulink url="http://www.michaelbernstein.com/">Michael
      Bernstein</ulink> が教えてくれました。"Mutt 以外にも、
      reply-to-list 機能を実装しているメールソフトがあります。
      たとえば Evolution では、キーボードショートカット
      (Ctrl+L) でこの機能を使用できます。でもボタンはありません。"
    </para>
  </footnote>
  )。
</para>

<!--
<para>An even better solution would be for Reply-to munging to be a
per-subscriber preference.  Those who want the list to set Reply-to
munged (either on others' posts or on their own posts) could ask for
that, and those who don't would ask for Reply-to to be left alone.
However, I don't know of any list management software that offers this
on a per-subscriber basis.  For now, we seem to be stuck with a global
setting.<footnote><para>Since I wrote that, I've learned that there is
at least one list management system that offers this
feature: <ulink url="http://siesta.unixbeard.net/">Siesta</ulink>.
See also this article about it:
<ulink url="http://www.perl.com/pub/a/2004/02/05/siesta.html"
/></para></footnote></para>
-->
<para>
  よりよい対応法は、Reply-to を変更するかしないかを
  各メンバーが個別に設定できるようにすることでしょう。
  メーリングリスト宛ての投稿は (自分の投稿も他人の投稿も含めて)
  Reply-to をメーリングリストのアドレスにしてほしいという人はそのオプションを指定し、
  Reply-to をそのままにしておいてほしい人はそのように指定します。
  残念ながら現時点では、
  これを各参加者ごとに設定できるメーリングリスト管理ソフトは存在しないようです。
  現状は、全員共通の設定で我慢するしかありません。
  <footnote>
    <para>
      その後、この機能をサポートするメーリングリスト管理ソフトがあることを知りました。
      <ulink url="http://siesta.unixbeard.net/">Siesta</ulink>
      というものです。
      <ulink url="http://www.perl.com/pub/a/2004/02/05/siesta.html"/>
      の記事も参考になるでしょう。
    </para>
  </footnote>
</para>

</sect3>

</sect2>

<!-- ========================== subsection =========================== -->
<sect2 id="archiving">
<!--
<title>Archiving</title>
-->
<title>アーカイブ</title>

<!--
<para>The technical details of setting up mailing list archiving are
specific to the software that's running the list, and are beyond the
scope of this book.  When choosing or configuring an archiver,
consider these qualities:</para>
-->
<para>
  メーリングリストのアーカイブを設定する技術的な方法は、
  使用するメーリングリスト管理ソフトによって異なるので、
  本書では詳しくは取り上げません。
  アーカイブツールを選択したり設定したりする際には、
  以下のような点に注意しましょう。
</para>

<variablelist>

<!--
  <varlistentry><term>Prompt updating</term>
    <listitem>
      <para>People will often want to refer to an archived post made
            within the last hour or two.  If possible, the archiver
            should archive each post instantaneously, so that by the
            time a post appears on the mailing list, it's already
            present in the archives.  If that option isn't available,
            then at least try to set the archiver to update itself
            every hour or so.  (By default, some archivers run their
            update processes once per night, but in practice that's
            far too much lag time for an active mailing list.)</para>
    </listitem>
  </varlistentry>
-->
  <varlistentry><term>迅速な更新</term>
    <listitem>
      <para>
        少なくとも、実際に投稿があってから１時間後くらいには
        その投稿がアーカイブされていてほしいものです。
        可能なら、実際に投稿があった瞬間にアーカイブ処理も同時に行なうべきです。
        そうすれば、その投稿がメンバーに配信されたときには既に
        アーカイブにも同じ内容が存在するということになります。
        それが無理だとしても、少なくとも１時間おきくらいの頻度でアーカイブの更新を行ないましょう
        (アーカイブソフトによっては、デフォルトでは
        １日に１回しかアーカイブを行なわないものもあります。
        しかし、メーリングリストのアーカイブ処理としては、
        事実上これでは使い物にならないでしょう)。
      </para>
    </listitem>
  </varlistentry>

<!--
  <varlistentry><term>Referential stability</term>
-->
  <varlistentry><term>参照の永続性</term>
    <listitem>
<!--
      <para>Once a message is archived at a particular URL, it should
            remain accessible at that exact same URL forever, or as
            close to forever as possible.  Even if the archives are
            rebuilt, restored from backup, or otherwise fixed, any
            URLs that have already been made publicly available
            should remain the same.  Stable references make it
            possible for Internet search engines to index the
            archives, which is a major boon to users looking for
            answers.  Stable references are also important because
            mailing list posts and threads are often linked to from
            the bug tracker (see
            <xref
            linkend="bug-tracker"/><phrase output="printed">
            later in this chapter</phrase>) or
            from other project documents.</para>
-->
      <para>
        メッセージがいったんある URL にアーカイブされたら、
        その後ずっと同じ URL でそのアーカイブにアクセスできるようにすべきです。
        アーカイブを再構築したりバックアップから復旧したり、
        あるいはその他何らかの修正を加えたときにも、
        いったん公開した URL はそのまま変わらないことが望ましいでしょう。
        同じ URL を保つようにしておけば、サーチエンジンに捕捉されやすくなります。
        これは、利用者にとって大きな利点となるでしょう。
        URL を保ち続けるよう心がけるもうひとつの理由としては、
        メーリングリストの投稿やスレッドがバグ追跡システム
        (<phrase output="printed">本章の後半</phrase>の
        <xref linkend="bug-tracker"/> を参照してください)
        や他のプロジェクトのドキュメントからリンクされることが多いということもあります。
      </para>

<!--
      <para>Ideally, mailing list software would include a message's
            archive URL, or at least the message-specific portion of
            the URL, in a header when it distributes the message to
            recipients.  That way people who have a copy of the
            message would be able to know its archive location
            without having to actually visit the archives, which would
            be helpful because any operation that involves one's web
            browser is automatically time-consuming.  Whether any
            mailing list software actually offers this feature, I don't
            know; unfortunately, the ones I have used do not.
            However, it's something to look for (or, if you write
            mailing list software, it's a feature to consider
            implementing, please).</para>
-->
      <para>
        理想を言えば、メールをメンバーに配信する際に、
        そのメッセージがアーカイブされている URL
        をヘッダに含められるようになっていればなおよいでしょう。
        そうすれば、そのメールを受け取った人は
        わざわざアーカイブサイトを訪れなくても
        そのメッセージがアーカイブされている場所を知ることができます。
        ブラウザを開いて何らかの操作をするというのは時間のかかる作業なので、
        それが省けるだけでも非常に便利です。
        このような機能を持つメーリングリスト管理ソフトウェアがあるかどうかは、
        私は知りません。残念ながら、
        私が今使っているソフトウェアにはそのような機能はないようです。
        しかし、どこかにそんなソフトウェアがあるのではと期待しています
        (もしあなたが新たにメーリングリスト管理ソフトウェアを開発するのなら、
        ぜひこの機能を実装してください。お願いします)。
      </para>
    </listitem>
  </varlistentry>

<!--
  <varlistentry><term>Backups</term>
-->
  <varlistentry><term>バックアップ</term>
    <listitem>
<!--
      <para>It should be reasonably obvious how to back up the
            archives, and the restoration recipe should not be too
            difficult.  In other words, don't treat your archiver as a
            black box.  You (or someone in your project) should know
            where it's storing the messages, and how to regenerate the
            actual archive pages from the message store if it should
            ever become necessary.  Those archives are precious
            data&mdash;a project that loses them loses a good part of
            its collective memory.</para>
-->
      <para>
        当然、アーカイブのバックアップとバックアップからの復旧の方法は
        簡単なほうがよいでしょう。いいかえれば、
        アーカイブソフトがブラックボックス化してしまってはいけないということです。
        あなた (もしくはプロジェクト内の誰か)
        はメッセージが実際にどのように保存されているかを知っている必要があり、また、
        必要になったときにはそこからアーカイブを復元できるようにしておかなければなりません。
        プロジェクトにとって、アーカイブの内容は宝物です。
        万一アーカイブを失ってしまうことがあれば、
        貴重な記録を失ってしまうことになります。
      </para>
    </listitem>
  </varlistentry>

<!--
  <varlistentry><term>Thread support</term>
-->
  <varlistentry><term>スレッドのサポート</term>
    <listitem>
<!--
      <para>It should be possible to go from any individual message to
            the <firstterm>thread</firstterm> (group of related
            messages) that that original message is part of.  Each
            thread should have its own URL too, separate from the URLs
            of the individual messages in the thread.</para>
-->
      <para>
        個々のメッセージから、そのメッセージが属する
        <firstterm>スレッド</firstterm> (関連するメッセージのまとまり)
        へ移動できるようにしておく必要があります。
        また、各メッセージ個別の URL とは別に、
        スレッドを表す URL もあるとよいでしょう。
      </para>
    </listitem>
  </varlistentry>

<!--
  <varlistentry><term>Searchability</term>
-->
  <varlistentry><term>検索機能</term>
    <listitem>
<!--
      <para>An archiver that doesn't support searching&mdash;on the
            bodies of messages, as well as on authors and
            subjects&mdash;is close to useless.  Note that some archivers 
            support searching by simply farming the work out to an
            external search engine such as <ulink
            url="http://www.google.com/">Google</ulink>.  This is
            acceptable, but direct search support is usually more
            fine-tuned, because it allows the searcher to specify that
            the match must appear in a subject line versus the body,
            for example.</para>
-->
      <para>
        メッセージの本文や送信者、件名などによる検索機能を
        サポートしていないアーカイブソフトなんて、使い物にならないといっていいでしょう。
        アーカイブソフトの中には、単に
        <ulink url="http://www.google.com/">Google</ulink>
        などの外部のサーチエンジンに処理をまかせているだけのものもあります。
        機能がないよりはましですが、検索機能を自前で実装しているほうが
        よりきめ細やかな処理ができます。
        たとえば、タイトルだけを対象に検索したり、
        本文も含めて検索したりといったこともできるでしょう。
      </para>
    </listitem>
  </varlistentry>

</variablelist>

<!--
<para>The above is just a technical checklist to help you evaluate and
set up an archiver.  Getting people to
actually <emphasis>use</emphasis> the archiver to the project's
advantage is discussed in later chapters, in particular
<xref linkend="using-archives"/>.</para>
-->
<para>
  上にあげたのは、アーカイブソフトを選択する際に注意する点として
  技術的な面にしぼった一覧です。
  実際にみんなにアーカイブソフトを<emphasis>利用</emphasis>
  してもらうことにどのような利点があるのかについては、
  <xref linkend="using-archives"/>でとりあげます。
</para>

</sect2>

<!-- ========================== subsection =========================== -->
<sect2 id="mailing-list-software">
<!--
<title>Software</title>
-->
<title>ソフトウェア</title>

<!--
<para>Here are some open source tools for doing list management and
archiving.  If the site where you're hosting your project already has
a default setup, then you may not ever have to decide on a tool at
all.  But if you must install one yourself, these are some
possibilities.  The ones I have actually used are Mailman, Ezmlm,
MHonArc, and Hypermail, but that doesn't mean the others aren't good
too (and of course, there are probably other tools out there that I
just didn't happen to find, so don't take this as a complete
list).</para>
-->
<para>
  メーリングリストの管理やアーカイブの作成用に、
  さまざまなツールがオープンソースで公開されています。
  あなたのプロジェクトを公開しているサイトで何かのツールが用意されているのなら、
  それを使えばいいでしょう。しかし、もし自分で新たにインストールする必要があるのなら、
  いくつかの選択肢があります。私が実際に使用したことがあるのは
  Mailman、Ezmlm、MHonArc、そして Hypermail です。
  しかし、それ以外のソフトウェアが劣っているというわけではありません
  (また、当然のことですが、私が知っているソフトウェアだけがすべてではありません。
  それ以外にもさまざまなものがあるはずなので、
  これを完全なリストとはとらえないでください)。
</para>

<!--
<para>Mailing list management software:</para>
-->
<para>メーリングリスト管理ソフトウェア</para>

<itemizedlist>
 <listitem>
   <para><emphasis role="bold">Mailman</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://www.list.org/"/></para>
<!--
   <para>(Has built-in archiver, and hooks for plugging in
         external archivers.)</para>
-->
   <para>
     (独自のアーカイバが組み込まれていますが、
     プラグイン形式で外部のアーカイバを使用することもできます)
   </para>
 </listitem>
 <listitem>
   <para><emphasis role="bold">SmartList</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://www.procmail.org/"/></para>
<!--
   <para>(Meant to be used with the Procmail mail processing system.)</para>
-->
   <para>(メール処理システム Procmail と組み合わせて使用するためのものです)</para>
 </listitem>
 <listitem>
   <para><emphasis role="bold">Ecartis</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://www.ecartis.org/"/></para>
 </listitem>
 <listitem>
   <para><emphasis role="bold">ListProc</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://listproc.sourceforge.net/"/></para>
 </listitem>
 <listitem>
   <para><emphasis role="bold">Ezmlm</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://cr.yp.to/ezmlm.html"/></para>
<!--
   <para>(Designed to work with the <ulink
         url="http://cr.yp.to/qmail.html">Qmail</ulink> mail
         delivery system.)</para> 
-->
   <para>
     (メール配送システム <ulink
     url="http://cr.yp.to/qmail.html">Qmail</ulink>
     と組み合わせて使用するように設計されています)
   </para> 
 </listitem>
 <listitem>
   <para><emphasis role="bold">Dada</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://mojo.skazat.com/"/></para>
<!--
   <para>(Despite the web site's bizarre attempts to hide the fact,
         this is free software, released under the GNU General
         Public License.  It also has a built-in archiver.)</para>
-->
   <para>
     (なぜかサイト上では隠そうとしているようですが、
     これはフリーソフトウェアで、GNU General Public License
     のもとで公開されています。また、アーカイバも組み込まれています)
   </para>
 </listitem>
</itemizedlist>

<!--
<para>Mailing list archiving software:</para>
-->
<para>メーリングリストのアーカイブ用ソフトウェア</para>

<itemizedlist>
 <listitem>
   <para><emphasis role="bold">MHonArc</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://www.mhonarc.org/"/></para>
 </listitem>
 <listitem>
   <para><emphasis role="bold">Hypermail</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://www.hypermail.org/"/></para>
 </listitem>
 <listitem>
   <para><emphasis role="bold">Lurker</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://sourceforge.net/projects/lurker/"/></para>
 </listitem>
 <listitem>
   <para><emphasis role="bold">Procmail</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://www.procmail.org/"/></para>
<!--
   <para>(Companion software to SmartList, this is a general mail
         processing system that can, apparently, be configured as an
         archiver.)</para>
-->
   <para>
     (SmartList に同梱されているソフトウェアです。
     通常のメール処理システムなのですが、
     アーカイバとしても使えるようです)
   </para>
 </listitem>
</itemizedlist>

</sect2>

</sect1>


<!-- ========================== SECTION =========================== -->
<sect1 id="vc">
<!--
<title>Version Control</title>
-->
<title>バージョン管理</title>

<!--
<para>A <firstterm>version control system</firstterm> (or
<firstterm>revision control system</firstterm>) is a combination of
technologies and practices for tracking and controlling changes to a
project's files, in particular to source code, documentation, and web
pages.  If you have never used version control before, the first thing
you should do is go find someone who has, and get them to join your
project.  These days, everyone will expect at least your project's
source code to be under version control, and probably will not take
the project seriously if it doesn't use version control with at least
minimal competence.</para>
-->
<para>
  <firstterm>バージョン管理システム</firstterm>（あるいは
  <firstterm>リビジョン管理システム</firstterm>）は、
  プロジェクト内のさまざまなファイルの変更履歴を管理するための
  テクノロジーや習慣を組み合わせたものです。
  たとえば、ソースコードやドキュメント、
  ウェブページなどがバージョン管理の対象となります。
  もしこれまでにバージョン管理システムを使ったことがないのなら、
  まずはバージョン管理システムを使ったことのある人を探して
  プロジェクトに引きずり込みましょう。いまどきのプロジェクトなら、
  少なくともソースコードくらいはバージョン管理されていて当然です。
  また、たかがバージョン管理程度のことすらできていないプロジェクトなど、
  誰もまともに取り合ってくれないかもしれません。
</para>

<!--
<para>The reason version control is so universal is that it helps with
virtually every aspect of running a project: inter-developer
communications, release management, bug management, code stability and
experimental development efforts, and attribution and authorization of
changes by particular developers.  The version control system provides
a central coordinating force among all of these areas.  The core of
version control is <firstterm>change management</firstterm>:
identifying each discrete change made to the project's files,
annotating each change with metadata like the change's date and
author, and then replaying these facts to whoever asks, in whatever
way they ask.  It is a communications mechanism where a change is the
basic unit of information.</para>
-->
<para>
  バージョン管理がこれほどまで一般的になった理由は、
  プロジェクトを運営していく上でいろいろな場面で役立つということです。
  開発者どうしのコミュニケーション、リリース管理、バグ管理、
  コードの安定性の確保、安心して新機能を実験できる環境、
  各開発者の権限の管理など、
  あらゆる場面でバージョン管理が利用できます。
  バージョン管理システムは、これらの内容を一まとめにして管理します。
  その中心となる機能が、<firstterm>変更管理</firstterm>です。
  これは、プロジェクト内のファイルが変更されるたびに
  その変更についてのメタデータ（更新日や更新者など）
  を収集する仕組みです。
  そして、あとからその変更の内容を再現できるようにするのです。
  つまり、変更が発生した単位で情報を管理する仕組みといえます。
</para>

<!--
<para>This section does not discuss all aspects of using a version
control system.  It's so all-encompassing that it must be addressed
topically throughout the book.  Here, we will concentrate on choosing
and setting up a version control system in a way that will foster
cooperative development down the road.</para>
-->
<para>
  このセクションでは、バージョン管理システムのあらゆる機能を説明するわけにはいきません。
  あまりにもさまざまな機能があるので、本書ではすべてを紹介することができないのです。
  ここでは、使用するバージョン管理システムを選択して
  実際に稼動させるところまでに絞って説明していきます。
</para>

<!-- ========================== subsection =========================== -->
<sect2 id="vc-vocabulary">
<!--
<title>Version Control Vocabulary</title>
-->
<title>バージョン管理に関する用語集</title>

<!--
<para>This book cannot teach you how to use version control if you've
never used it before, but it would be impossible to discuss the
subject without a few key terms.  These terms are useful independently
of any particular version control system: they are the basic nouns and
verbs of networked collaboration, and will be used generically
throughout the rest of this book.  Even if there were no version
control systems in the world, the problem of change management would
remain, and these words give us a language for talking about that
problem concisely.
-->
<para>
  本書では、まだバージョン管理システムを使ったことがない人に対して
  その基本的な使い方を解説することはできません。
  しかし、いくつかのキーワードを知っていなければ、
  これ以降の議論についていけなくなるでしょう。
  ここで説明するキーワードは、どのバージョン管理システムでも共通に使われるものです。
  これらの言葉については、これ以降でもとくに説明せずに使用していきます。
  たとえこの世にバージョン管理システムがなかったとしても、
  変更の管理をどうするかという問題が消えてなくなることはありません。
  この問題について語る際には、ここで取り上げたキーワードを知っていると便利です。

<variablelist>

 <varlistentry id="vc-vocabulary-commit">
<!--
  <term><firstterm>commit</firstterm></term>
-->
  <term><firstterm>コミット</firstterm></term>
<!--
  <listitem><para>To make a change to the project; more formally, to
  store a change in the version control database in such a way that it
  can be incorporated into future releases of the project.  "Commit"
  can be used as a verb or a noun.  As a noun, it is essentially
  synonymous with "change".  For example: "I just committed a fix for
  the server crash bug people have been reporting on Mac OS X.  Jay,
  could you please review the commit and check that I'm not misusing
  the allocator there?"</para></listitem>
-->
  <listitem>
    <para>
      プロジェクトに変更を加えること。もう少しかしこまって言うと、
      変更した内容をバージョン管理データベースに格納し、
      そのプロジェクトが次に公開するリリースに反映されるようにすること。
      "コミット" は、動詞としても名詞としても用いられます。
      名詞として使った場合の意味は、"変更" とほぼ同じです。
      たとえば次のように使用します。"Mac OS X
      上でサーバがクラッシュするバグを修正してコミットした。
      ジェイ、悪いけどこのコミットの内容をチェックしてくれないかな？
      もしかしたらメモリを確保する方法を間違っているかもしれないし"
    </para>
  </listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-log-message">
<!--
  <term><firstterm>log&nbsp;message</firstterm></term>
-->
  <term><firstterm>ログメッセージ</firstterm></term>
<!--
  <listitem><para>A bit of commentary attached to each commit,
  describing the nature and purpose of the commit.  Log messages are
  among the most important documents in any project: they are the
  bridge between the highly technical language of individual code
  changes and the more user-oriented language of features, bugfixes,
  and project progress.  Later in this section, we'll look at ways to
  distribute log messages to the appropriate audiences; also, <xref
  linkend="codifying-tradition"/><phrase output="printed"> in
  <xref linkend="communications"/></phrase> discusses ways to
  encourage contributors to write concise and useful log
  messages.</para></listitem>
-->
  <listitem>
    <para>
      各コミットに添付されたコメントで、
      そのコミットの内容や目的を説明するもの。
      ログメッセージは、そのプロジェクトのドキュメントの中で
      最も重要なものです。これは、実際に変更したコードの内容を
      人間が読んでわかりやすい言葉 ("機能追加"、"バグ対応"、
      あるいはプロジェクトの進捗状況など)
      に変換する意味合いがあります。
      このセクションの後半では、
      ログメッセージを適切なメンバーに配信する方法を説明します。また、
      <phrase output="printed"><xref linkend="communications"/></phrase>
      の <xref linkend="codifying-tradition"/> では
      各メンバーにいかにして有用なログメッセージを書いてもらうかを説明します。
    </para>
  </listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-update">
<!--
  <term><firstterm>update</firstterm></term>
-->
  <term><firstterm>アップデート</firstterm></term>
<!--
  <listitem><para>To ask that others' changes (commits) be
  incorporated into your local copy of the project; that is, to bring
  your copy "up-to-date".  This is a very common operation; most
  developers update their code several times a day, so that they know
  they're running roughly the same thing the other developers are
  running, and so that if they see a bug, they can be pretty sure it
  hasn't been fixed already.  For example: "Hey, I noticed the
  indexing code is always dropping the last byte.  Is this a new bug?"
  "Yes, but it was fixed last week&mdash;try updating, it should go
  away."</para></listitem>
-->
  <listitem>
    <para>
      他のメンバーの変更 (コミット) をローカル環境に取り込むこと。
      つまり、ローカル環境を "最新版" にすること。
      これは非常に頻繁に行われる操作です。
      ほとんどの開発者は、自分のコードを一日に何度もアップデートします。
      それにより、自分の開発環境を他のメンバーとほぼ同じ状態に保つようにするのです。
      また、もし何かバグを見つけたときに、
      おそらくまだそれは修正されていないものであろうことを予想できるようにします。
      たとえば次のように使用します。"ねぇ、このコードって、
      いちばん最後のバイトを読んでいないように見えるんだけど……。
      バグじゃない？"
      "うん。でもそれは先週修正したよ。
      最新版にアップデートしたらバグはなくなるはずだ。"
    </para>
  </listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-repository">
<!--
  <term><firstterm>repository</firstterm></term> <listitem><para>A
  database in which changes are stored.  Some version control systems
  are centralized: there is a single, master repository, which stores
  all changes to the project.  Others are decentralized: each
  developer has his own repository, and changes can be swapped back
  and forth between repositories arbitrarily.  The version control
  system keeps track of dependencies between changes, and when it's
  time to make a release, a particular set of changes is approved for
  that release.  The question of whether centralized or decentralized
  is better is one of the enduring holy wars of software development;
  try not to fall into the trap of arguing about it on your project
  lists.</para></listitem>
-->
  <term><firstterm>リポジトリ</firstterm></term>
  <listitem>
    <para>
      変更内容を格納するデータベース。
      たとえば中央管理方式のバージョン管理システムでは、
      マスタリポジトリがひとつだけ存在します。
      すべての変更内容がここに格納されることになります。
      分散管理方式の場合は、各開発者が個別にリポジトリを所有します。
      他のリポジトリとの間のデータ交換が、任意のタイミングで発生します。
      バージョン管理システムは、各変更の内容を記録しています。
      リリース時期には、特定の時点の内容をリリース用として指定します。
      中央管理方式と分散管理方式のどちらがよいかについて語りだすと、
      終わりのない宗教戦争に巻き込まれてしまいます。
      プロジェクトのメーリングリストでは、
      できるだけこの問題には触れないようにしましょう。
    </para>
  </listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-checkout">
<!--
  <term><firstterm>checkout</firstterm></term>
  <listitem><para>The process of obtaining a copy of the project from
  a repository.  A checkout usually produces a directory tree called a
  "working copy" (see below), from which changes may be committed back
  to the original repository.  In some decentralized version control
  systems, each working copy is itself a repository, and changes can
  be pushed out to (or pulled into) any repository that's willing
  to accept them.</para></listitem>
-->
  <term><firstterm>チェックアウト</firstterm></term>
  <listitem>
    <para>
      リポジトリからプロジェクトの内容を取得する処理。
      チェックアウトを行うと、いわゆる「作業コピー」
      （次の項を参照ください）と呼ばれるディレクトリツリーが作成されます。
      このツリーに変更を加えた結果をコミットし、元のリポジトリに反映させます。
      分散型のバージョン管理システムの中には、
      作業コピーそのものがリポジトリでもあるというものもあります。
      その変更内容を、他のリポジトリとの間でやりとりしたりする構造になっています。
    </para>
  </listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-working-copy">
<!--
  <term><firstterm>working copy</firstterm></term>
  <listitem><para>A developer's private directory tree containing the
  project's source code files, and possibly its web pages or other
  documents.  A working copy also contains a little bit of metadata
  managed by the version control system, telling the working copy what
  repository it comes from, what "revisions" (see below) of the files
  are present, etc.  Generally, each developer has his own working
  copy, in which he makes and tests changes, and from which he
  commits.</para></listitem>
-->
  <term><firstterm>作業コピー</firstterm></term>
  <listitem>
    <para>
      開発者がローカル環境に保持するディレクトリツリーで、
      この中にはプロジェクトのソースコードやウェブページ、
      その他のドキュメントが格納されることになります。
      作業コピーには、バージョン管理システムが使用するメタデータも含まれています。
      このメタデータの中には、取得元のリポジトリの場所や現在の
      "リビジョン"（次の項を参照ください）などについての情報が格納されています。
      一般に、個々の開発者は自分の作業コピーを取得してそこで開発を行います。
      そして、変更した内容のテストを済ませたうえで
      それをコミットします。
    </para>
  </listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-revision">
<!--
  <term><firstterm>revision</firstterm>,
        <firstterm>change</firstterm>,
        <firstterm>changeset</firstterm></term>
-->
  <term><firstterm>リビジョン</firstterm>、
        <firstterm>チェンジ</firstterm>、
        <firstterm>チェンジセット</firstterm></term>
<!--
  <listitem><para>A "revision" is usually one specific incarnation of
  a particular file or directory.  For example, if the project starts
  out with revision 6 of file F, and then someone commits a change to
  F, this produces revision 7 of F.  Some systems also use
  "revision", "change", or "changeset" to refer to a set of changes
  committed together as one conceptual unit.</para> 
-->
  <listitem>
    <para>
      "リビジョン" とは、指定したファイルやディレクトリの
      特定の時点の状態のことです。
      たとえば、あるプロジェクトのファイル F のリビジョンが 6
      であった場合に、誰かがファイル F を変更してコミットすると、
      F のリビジョンは 7 となります。
      システムによっては、一度に行われたある特定の変更群を称して
      "リビジョン"、"チェンジ" あるいは "チェンジセット"
      とするものもあります。
    </para> 

<!--
  <para>These terms occasionally have distinct technical meanings in
  different version control systems, but the general idea is always
  the same: they give a way to speak precisely about exact points in
  time in the history of a file or a set of files (say, immediately
  before and after a bug is fixed).  For example: "Oh yes, she fixed
  that in revision 10" or "She fixed that in revision 10 of
  foo.c."</para>
-->
    <para>
      バージョン管理システムによっては、
      これらの用語を明確に定義しているものもあります。
      しかし、一般的な考え方はどれも同じです。
      一連の流れの中の特定の時点
      (バグ修正が行われた箇所など)
      を指定する方法を用意しているわけです。
      たとえば、次のように使用します。
      "ああ、それなら彼女がリビジョン 10 で修正したよ。"
      あるいは
      "彼女は foo.c のリビジョン10でそれを修正したよ。"
    </para>

<!--
  <para>When one talks about a file or collection of files without
  specifying a particular revision, it is generally assumed that one
  means the most recent revision(s) available.</para></listitem>
 </varlistentry>
-->
    <para>
      特定のリビジョンを指定せずに話を進めている場合は、
      一般に最新のリビジョンについて語っているものと考えていいでしょう。
    </para>
  </listitem>
 </varlistentry>

  <sidebar id="version-vs-revision">
<!--
  <title>"Version" Versus "Revision"</title>
-->
  <title>"バージョン"？それとも"リビジョン"？</title>
<!--
  <para>The word <firstterm>version</firstterm> is sometimes used as a
  synonym for "revision", but I will not use it that way in this
  book, because it is too easily confused with "version" in the sense
  of a version of a piece of software&mdash;that is, the release or
  edition number, as in "Version 1.0".  However, since the phrase
  "version control" is already standard, I will continue to use it as
  a synonym for "revision control" and "change control".</para>
-->
  <para>
    "リビジョン" と同じような意味で <firstterm>バージョン</firstterm>
    という言葉を使う人もいますが、本書の中ではこの使い方はしません。
    "バージョン" といってしまうと、ソフトウェアのリリース時の版番号
    (たとえば "バージョン 1.0 をリリースしました" などと使用)
    と混同されてしまうからです。
    しかし、"バージョン管理" という言葉は既に市民権を得てしまっているので、
    この言葉は使うようにします (本来なら "リビジョン管理"
    や "変更管理" と言いたいところです)。
  </para>
  </sidebar>

 <varlistentry id="vc-vocabulary-diff">
<!--
  <term><firstterm>diff</firstterm></term>
  <listitem><para>A textual representation of a change.  A diff shows
  which lines were changed and how, plus a few lines of surrounding
  context on either side.  A developer who is already familiar with
  some code can usually read a diff against that code and understand
  what the change did, and even spot bugs.</para></listitem>
-->
  <term><firstterm>差分</firstterm></term>
  <listitem>
    <para>
      変更内容を表すテキスト。
      変更があった箇所とその前後数行について、
      変更前と変更後の状態を表示します。
      元のコードになじみがある人なら、
      差分を見ればどこをどう変更したのかがわかります。
      時にはバグを見つけたりすることもできるでしょう。
    </para>
  </listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-tag">
<!--
  <term><firstterm>tag</firstterm></term>
-->
  <term><firstterm>タグ</firstterm></term>
<!--
  <listitem><para>A label for a particular collection of files at
  specified revisions.  Tags are usually used to preserve
  interesting snapshots of the project.  For example, a tag is usually
  made for each public release, so that one can obtain, directly from
  the version control system, the exact set of files/revisions
  comprising that release.  Common tag names are things like
  <literal>Release_1_0</literal>, <literal>Delivery_00456</literal>,
  etc.</para></listitem>
-->
  <listitem>
    <para>
      指定したリビジョンを構成するファイルにつけるラベル。タグは、
      プロジェクトの特筆すべき時点の状態を保護するために使用することが多くなります。
      特筆すべき点とは、たとえば一般向けのリリースなどがあげられます。
      リリースごとにタグをつけておけば、
      そのリリースとまったく同じ内容のファイル群を
      バージョン管理システムから簡単に取得できるようになります。
      タグの名前としてよく用いられるのは、
      <literal>Release_1_0</literal> や
      <literal>Delivery_00456</literal> といったものです。
    </para>
  </listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-branch">
<!--
  <term><firstterm>branch</firstterm></term>
-->
  <term><firstterm>ブランチ</firstterm></term>
<!--
  <listitem><para>A copy of the project, under version control but
  isolated, so that changes made to the branch don't affect the rest
  of the project, and vice versa, except when changes are
  deliberately "merged" from one side to the other (see below).
  Branches are also known as "lines of development".  Even when a
  project has no explicit branches, development is still considered
  to be happening on the "main branch", also known as the "main line"
  or "<firstterm>trunk</firstterm>".</para>
-->
  <listitem>
    <para>
      プロジェクトの一部でありバージョン管理下に存在するが、
      他とは隔離されている部分。ブランチに対して適用した変更は
      その他の部分に対しては影響をおよぼしません。また逆も同様です。
      ただし、明示的に "マージ" した場合は別です (以下を参照ください)。
      ブランチは、"開発ライン" と呼ばれることもあります。
      明示的にブランチを作成していない場合でも、
      "メインブランチ" で開発を進めているものと考えます。このブランチのことは
      "メインライン" あるいは "<firstterm>トランク (trunk)</firstterm>"
      と呼ばれることもあります
    </para>

<!--
  <para>Branches offer a way to isolate different lines of development
  from each other.  For example, a branch can be used for experimental
  development that would be too destabilizing for the main trunk.  Or
  conversely, a branch can be used as a place to stabilize a new
  release.  During the release process, regular development would
  continue uninterrupted in the main branch of the repository;
  meanwhile, on the release branch, no changes are allowed except
  those approved by the release managers.  This way, making a release
  needn't interfere with ongoing development work.  See <xref
  linkend="branches"/><phrase output="printed"> later in this
  chapter</phrase> for a more detailed discussion of
  branching.</para></listitem>
-->
  <para>
    ブランチを使用すると、複数の開発ラインを別々に管理できるようになります。
    たとえば、本流の開発ラインとは別に実験的な開発用のブランチを作成し、
    本流を不安定にさせる可能性があるような開発はそちらで行うということができます。
    あるいは逆に、新しいリリース用の安定版ブランチを作成するといった使用法もあります。
    この方式の場合、リリースが間近に迫っても、
    通常の開発は本流ブランチ上で途切れなく続けられます。
    一方、リリース用ブランチではリリース作業に入った段階でコミットを停止し、
    リリース管理者が許可しない限りはコミットをしないようにします。
    この方式を採用すると、リリース前にいったん開発を中断する必要がなくなります。
    ブランチについての詳細は、<phrase output="printed">本章の後半</phrase>
    にある <xref linkend="branches"/> をご覧ください。
  </para>
  </listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-merge">
<!--
  <term><firstterm>merge (a.k.a. port)</firstterm></term>
-->
  <term><firstterm>マージ (あるいはポート)</firstterm></term>
<!--
  <listitem><para>To move a change from one branch to another.  This
  includes merging from the main trunk to some other branch, or vice
  versa.  In fact, those are the most common kinds of merges; it is
  rare to port a change between two non-main branches.  See <xref
  linkend="vc-singularity"/> for more about this kind of
  merging.</para>
-->
  <listitem>
    <para>
      変更内容を、あるブランチから別のブランチに移動すること。
      本流の変更内容を他のブランチに適用したり、その逆を行ったりすることも含みます。
      実際のところ、ほとんどのマージ作業はこのパターンです。
      本流以外の２つのブランチ間でのマージはほとんどありません。
      この手のマージについては
      <xref linkend="vc-singularity"/> をご覧ください。
    </para>

<!--
  <para>"Merge" has a second, related meaning: it is what the version
  control system does when it sees that two people have changed the
  same file but in non-overlapping ways.  Since the two changes do not
  interfere with each other, when one of the people updates their copy
  of the file (already containing their own changes), the other
  person's changes will be automatically merged in.  This is very
  common, especially on projects where multiple people are hacking on
  the same code.  When two different changes <emphasis>do</emphasis>
  overlap, the result is a "conflict"; see below.</para>
  </listitem>
-->
    <para>
      "マージ" にはもうひとつの意味もあります。
      ひとつのファイルに対して複数人が別々の箇所を変更したときに、
      バージョン管理システムが行う処理のことです。
      お互いの変更が相手の変更を邪魔することはないので、
      手元で修正済みのファイルをアップデートすると、
      相手の変更内容が自動的にマージされ（取り込まれ）ます。
      これは、複数の人が同じファイルをハックしている場合によくあることです。
      万一お互いが変更した箇所が重なっていた場合は、次に説明する
      "コンフリクト" 状態になります。
    </para>
  </listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-conflict">
<!--
  <term><firstterm>conflict</firstterm></term>
  <listitem><para>What happens when two people try to make different
  changes to the same place in the code.  All version control systems
  automatically detect conflicts, and notify at least one of the
  humans involved that their changes conflict with someone else's.  It
  is then up to that human to <firstterm>resolve</firstterm> the
  conflict, and to communicate that resolution to the version control
  system.</para></listitem>
-->
  <term><firstterm>コンフリクト</firstterm></term>
  <listitem>
    <para>
      ひとつのコードの同じ箇所を異なる人が変更しようとした際に起こる現象。
      バージョン管理システムは、コンフリクトの発生を自動的に検出します。
      そして、変更しようとしたユーザーに対してそれを通知します。
      発生したコンフリクトを <firstterm>解決</firstterm>
      するのは、変更しようとした人たち自身の責任です。
      解決したあとで、それをバージョン管理システムに通知します。
    </para>
  </listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-lock">
<!--
  <term><firstterm>lock</firstterm></term>
-->
  <term><firstterm>ロック</firstterm></term>
<!--
  <listitem><para>A way to declare an exclusive intent to change a
  particular file or directory.  For example, "I can't commit any
  changes to the web pages right now.  It seems Alfred has them all
  locked while he fixes their background images."  Not all version
  control systems even offer the ability to lock, and of those that
  do, not all require the locking feature to be used.  This is because
  parallel, simultaneous development is the norm, and locking people
  out of files is (usually) contrary to this ideal.</para>
-->
  <listitem>
    <para>
      特定のファイルやディレクトリを、他人に変更されないように宣言する方法。
      たとえば "ウェブページの変更内容をコミットしようとしたけどできない。
      たぶん、Alfred が背景画像を修正する間、すべてのファイルをロックしているんだろう"
      というように使います。
      中にはロック機能を持っていないバージョン管理システムもあります。
      また、その機能を持っていたとしても、実際にそれが必要となることはあまりないでしょう。
      いろんな人が同時に平行して開発を進めるというのが普通の状況なのであり、
      ロックして他人を締め出すというのはこの理想に相反するものです。
    </para>

<!--
  <para>Version control systems that require locking to make commits
  are said to use the <firstterm>lock-modify-unlock</firstterm> model.
  Those that do not are said to use the
  <firstterm>copy-modify-merge</firstterm> model.  An excellent
  in-depth explanation and comparison of the two models may be found
  at <ulink
  url="http://svnbook.red-bean.com/svnbook-1.0/ch02s02.html"/>.  In
  general, the copy-modify-merge model is better for open source
  development, and all the version control systems discussed in this
  book support that model.</para></listitem>
-->
    <para>
      コミットするにはロックが必要となるバージョン管理システムのことを、
      「<firstterm>ロック - 修正 - ロック解除 (lock-modify-unlock)</firstterm> モデル」
      といいます。一方、ロックが必要でない方式のことは
      「<firstterm>コピー - 修正 - マージ (copy-modify-merge)</firstterm> モデル」
      といいます。２つの方式について深く掘り下げて比較したすばらしい文書が
      <ulink url="http://svnbook.red-bean.com/svnbook-1.0/ch02s02.html"/>
      （<ulink url="http://subversion.bluegate.org/doc/ch02s02.html">日本語訳</ulink>）
      にあります。一般に、オープンソース開発においては
      コピー - 修正 - マージ モデルの方が適しています。
      本書で扱うバージョン管理システムは、すべてこの方式を採用しています。
    </para>
  </listitem>
 </varlistentry>

</variablelist>

</para>

</sect2>


<!-- ========================== subsection =========================== -->
<sect2 id="vc-choosing">
<!--
<title>Choosing a Version Control System</title>
-->
<title>バージョン管理システムの選択</title>

<!--
<para>As of this writing, the two most popular version control systems
in the free software world are <firstterm>Concurrent Versions
System</firstterm> (<firstterm>CVS</firstterm>,
<ulink url="http://www.cvshome.org/"/>)
and <firstterm>Subversion</firstterm> (<firstterm>SVN</firstterm>,
<ulink url="http://subversion.tigris.org/"/>).</para>
-->
<para>
  本書の執筆時点では、
  フリーソフトウェアの世界で最もよく使われているバージョン管理システムは
  <firstterm>Concurrent Versions System</firstterm>
  (<firstterm>CVS</firstterm>, <ulink url="http://www.cvshome.org/"/>)
  と <firstterm>Subversion</firstterm> (<firstterm>SVN</firstterm>,
  <ulink url="http://subversion.tigris.org/"/>) の２つです。
</para>

<!--
<para>CVS has been around for a long time.  Most experienced
developers are already familiar with it, it does more or less what you
need, and since it's been popular for a long time, you probably won't
end up in any long debates about whether or not it was the right
choice.  CVS has some disadvantages, however.  It doesn't provide an
easy way to refer to multi-file changes; it doesn't allow you to
rename or copy files under version control (so if you need to
reorganize your code tree after starting the project, it can be a real
pain); it has poor merging support; it doesn't handle large files or
binary files very well; and some operations are slow when large
numbers of files are involved.</para>
-->
<para>
  CVS には長い歴史があります。
  ベテランの開発者はすでに CVS についてはよくご存知でしょう。
  これまでにも CVS がいろいろな場面で役に立ってきたはずです。
  CVS の時代があまりにも長く続いてきたので、
  本当にそれが最適な選択肢だったのかどうかなんて聞くだけ野暮というものでしょう。
  しかし、CVS には欠点もあります。
  まず、複数のファイルを一括して変更したときに、それを追いかける簡単な手段がありません。
  また、バージョン管理下にあるファイルの名前を変えたりコピーしたりすることができません
  （プロジェクトをいったん開始した後でコードツリーの構成を変更したい場合は、
  泣きながら大変な作業をこなすことになるでしょう)。
  そして、マージ機能はかなりお粗末なものです。
  巨大なファイルやバイナリファイルの扱いも不得意です。
  そして、大量のファイルを一括して操作しようとすると非常に時間がかかることがあります。
</para>

<!--
<para>None of CVS's flaws is fatal, and it is still quite popular.
However, in the last few years the more recent Subversion has been
gaining ground, especially in newer
projects.<footnote><para>See <ulink url="http://cia.vc/stats/vcs"/> and
<ulink url="http://subversion.tigris.org/svn-dav-securityspace-survey.html"/>
for evidence of this growth.</para></footnote>.  If you're starting a
new project, I recommend Subversion.</para>
-->
<para>
  CVS のこれらの欠点は決して致命的なものではありませんが、
  無視できるものでもありません。
  ここ数年、新たに立ち上げられたプロジェクトでは
  Subversion を採用することが多くなってきました
  <footnote>
    <para>
      その証拠としては
      <ulink url="http://cia.vc/stats/vcs"/> や
      <ulink url="http://subversion.tigris.org/svn-dav-securityspace-survey.html"/>
      があります。
    </para>
  </footnote>。
  これから新たにプロジェクトを立ち上げるのなら、Subversion をお勧めします。
</para>

<!--
<para>On the other hand, since I'm involved in the Subversion project,
my objectivity might reasonably be questioned.  And in the last few
years a number of new open-source version control systems have
appeared.  <xref linkend="vc-systems"/> lists all the ones I know of,
in rough order of popularity.  As the list makes clear, deciding on a
version control system could easily become a lifelong research
project.  Possibly you will be spared the decision because it will be
made for you by your hosting site.  But if you must choose, consult
with your other developers, ask around to see what people have
experience with, then pick one and run with it.  Any stable,
production-ready version control system will do; you don't have to
worry too much about making a drastically wrong decision.  If you
simply can't make up your mind, then go with Subversion.  It's fairly
easy to learn, and is likely to remain a standard for at least a few
years.</para>
-->
<para>
  一方、私が Subversion プロジェクトにかかわっていることもあり、
  私の意見の客観性に疑問を持たれる方もいるかもしれません。
  ここ数年、新たなオープンソースのバージョン管理システムがいくつか登場しています。
  <xref linkend="vc-systems"/> に、
  私が知っているものを挙げておきます。
  このリストを見てもわかるように、バージョン管理システムにどれを採用するかを決めるには、
  下手したら一生かかってしまうかも知れません。
  もしかしたら、あなたには選択の余地がないかも知れません。
  というのは、ホスティングサイトを使用する場合は
  ホスティングサイト側でバージョン管理システムが設定されているかもしれないからです。
  もしあなたが自分で選択しなければならない立場になったのなら、
  まず周りの意見をよく聞いてからどれかひとつを選択し、
  そして動かしてみましょう。
  最近のバージョン管理システムは、どれもそれなりに機能します。
  どれを選んだとしても、致命的な被害を受けることはないでしょう。
  もしまだ迷っているのなら、Subversion を使ってみましょう。
  これは簡単に習得でき、少なくとも今後数年は標準的に使われることでしょう。
</para>

</sect2>


<!-- ========================== subsection =========================== -->
<sect2 id="vc-using">
<!--
<title>Using the Version Control System</title>
-->
<title>バージョン管理システムの使用法</title>

<!--
<para>The recommendations in this section are not targeted toward a
particular version control system, and should be simple to implement
in any of them.  Consult your specific system's documentation for
details.</para>
-->
<para>
  この章で説明する内容は、特定のバージョン管理システムに固有のものではありません。
  どのシステムを選択した場合にも適用できるはずです。
  詳細は、各システムのドキュメントを調べるようにしましょう。
</para>

<sect3 id="version-everything">
<!--
<title>Version everything</title>
-->
<title>すべてをバージョン管理する</title>

<!--
<para>Keep not only your project's source code under version control,
but also its web pages, documentation, FAQ, design notes, and anything
else that people might want to edit.  Keep them right next to the
source code, in the same repository tree.  Any piece of information
worth writing down is worth versioning&mdash;that is, any piece of
information that could change.  Things that don't change should be
archived, not versioned.  For example, an email, once posted, does not
change; therefore, versioning it wouldn't make sense (unless it becomes
part of some larger, evolving document).</para>
-->
<para>
  ソースコードだけでなく、ウェブページやドキュメント、FAQ、設計メモなどなど、
  編集する可能性のあるものはすべてバージョン管理下におくようにしましょう。
  これらは、同一リポジトリツリー内でソースコードの隣に置いておきます。
  書き残した情報は、すべてバージョン管理する価値があります。
  つまり、あらゆる情報は変化する可能性があるということです。
  今後変わりようのない内容については、
  バージョン管理ではなくアーカイブしなければなりません。
  たとえば、メーリングリストに投稿されたメールの内容は、変わることがありません。
  このようなものをバージョン管理しても無意味です
  (もちろん、それが巨大な文書の一部となる場合などは別ですが)。
</para>

<!--
<para>The reason versioning everything together in one place is
important is so people only have to learn one mechanism for submitting
changes.  Often a contributor will start out making edits to the web
pages or documentation, and move to small code contributions later,
for example.  When the project uses the same system for all kinds of
submissions, people only have to learn the ropes once.  Versioning
everything together also means that new features can be committed
together with their documentation updates, that branching the code
will branch the documentation too, etc.</para>
-->
<para>
  すべてを同じ場所でバージョン管理する理由は、
  そうしておけば作業に参加する人がひとつのことを覚えるだけですむようになるからです。
  たとえば、最初はウェブページやドキュメントの修正から参加しはじめたメンバーが、
  後にコードそのものの修正にも参加するようになるといったことがあります。
  すべてを同じ仕組みでバージョン管理しておけば、
  このような場合に新たにその使用法を学ぶ必要がなくなるのです。
  また、新機能を追加すると同時にドキュメントも更新したり、
  コードのブランチを作成すると同時にドキュメントのブランチも作成したり
  といった際にも便利です。
</para>

<!--
<para>Don't keep <firstterm>generated files</firstterm> under version
control.  They are not truly editable data, since they are produced
programmatically from other files.  For example, some build systems
create <filename>configure</filename> based on the template
<filename>configure.in</filename>.  To make a change to the
<filename>configure</filename>, one would edit
<filename>configure.in</filename> and then regenerate; thus, only the
template <filename>configure.in</filename> is an "editable file."
Just version the templates&mdash;if you version the result files as
well, people will inevitably forget to regenerate when they commit a
change to a template, and the resulting inconsistencies will cause no
end of confusion.<footnote><para>For a different opinion on the
question of versioning <filename>configure</filename> files, see
Alexey Makhotkin's post "<citetitle>configure.in and version
control</citetitle>" at
<ulink url="http://versioncontrolblog.com/2007/01/08/configurein-and-version-control/"/>.</para></footnote></para>
-->
<para>
  <firstterm>自動生成されるファイル</firstterm> はバージョン管理する必要がありません。
  これらのファイルは純粋に編集可能なデータではなく、
  別のファイルの内容をもとにして自動生成されるものだからです。
  たとえば、ビルドシステムでよく用いられるファイル <filename>configure</filename>
  は、テンプレート <filename>configure.in</filename>
  の内容をもとにして自動生成されるものです。もし <filename>configure</filename>
  を変更したいのなら、<filename>configure.in</filename>
  を編集してから再生成するということになります。つまり、この場合で言う
  「真に編集可能なファイル」は、テンプレートである <filename>configure.in</filename>
  だけということになります。バージョン管理するのはテンプレートだけにします。
  生成した結果までバージョン管理してしまうと、
  テンプレートを修正した際にファイルを再生成することを忘れてしまうかも知れません。
  そうすると、ファイルの整合性が取れなくなってしまって混乱の元となります。
  <footnote>
    <para>
      <filename>configure</filename> ファイルをバージョン管理するか否かについては、
      別の見方もあります。Alexey Makhotkin の記事 "<citetitle>configure.in and version
      control</citetitle>" が、次の URL で見られます。
      <ulink url="http://versioncontrolblog.com/2007/01/08/configurein-and-version-control/"/>
    </para>
  </footnote>
</para>

<!--
<para>The rule that all editable data should be kept under version
control has one unfortunate exception: the bug tracker.  Bug databases
hold plenty of editable data, but for technical reasons generally
cannot store that data in the main version control system.  (Some
trackers have primitive versioning features of their own, however,
independent of the project's main repository.)</para>
-->
<para>
  「編集可能なデータはすべてバージョン管理下におかなければならない」
  という規則には、残念ながらひとつだけ例外があります。
  それが バグ追跡システム です。
  バグデータベースは編集可能なデータを大量に保持していますが、
  技術的な理由により、このデータをバージョン管理することはできません
  (バグ追跡システムの中には、ちょっとしたバージョン管理機能を独自に実装しているものもあります。
  しかし、これはプロジェクトのメインリポジトリとは独立したものとなります)。
</para>

</sect3>

<sect3 id="vc-browsing">
<!--
<title>Browsability</title>
-->
<title>ウェブで閲覧できるようにする</title>

<!--
<para>The project's repository should be browsable on the Web.  This
means not only the ability to see the latest revisions of the
project's files, but to go back in time and look at earlier revisions,
view the differences between revisions, read log messages for selected
changes, etc.</para>
-->
<para>
  プロジェクトのリポジトリは、ウェブ上からも閲覧できるようにしなければなりません。
  これは、ただ単に最新のリビジョンが見られればいいというレベルのものではありません。
  前のリビジョンにさかのぼったりリビジョン間の差分を見たり、
  変更時のログメッセージを見たりといった機能も含みます。
</para>

<!--
<para>Browsability is important because it is a lightweight portal to
project data.  If the repository cannot be viewed through a web
browser, then someone wanting to inspect a particular file (say, to
see if a certain bugfix had made it into the code) would first have to
install version control client software locally, which could turn
their simple query from a two-minute task into a half-hour or longer
task.</para>
-->
<para>
  これは、そのプロジェクトのデータに関する便利な入り口となるので、
  ブラウザビリティ（閲覧のしやすさ）が重要となります。
  もしウェブブラウザ経由での閲覧ができなければ、
  そのプロジェクトの特定のファイルを調べたい人
  （あのバグ修正はどんな風に行われたのかな？など）はまず
  バージョン管理システムのクライアントソフトウェアを
  インストールするところから始めなければならなくなってしまいます。
  ウェブで見られれば２分ですむことなのに、
  それがないために30分がかりの作業になってしまうということになります。
</para>

<!--
<para>Browsability also implies canonical URLs for viewing specific
revisions of files, and for viewing the latest revision at any given
time.  This can be very useful in technical discussions or when
pointing people to documentation.  For example, instead of saying "For
tips on debugging the server, see the www/hacking.html file in your
working copy," one can say "For tips on debugging the server, see
<emphasis>http://svn.collab.net/repos/svn/trunk/www/hacking.html</emphasis>,"
giving a URL that always points to the latest revision of
the <filename>hacking.html</filename> file.  The URL is better because
it is completely unambiguous, and avoids the question of whether the
addressee has an up-to-date working copy.</para>
-->
<para>
  ブラウザビリティの中には、特定のファイルの特定のリビジョンが特定の
  URL で見られること、そして特定のファイルの（その時点での）
  最新リビジョンも特定の URL で見られることといった内容も含まれます。
  こうしておくと、技術的な議論の際にその場所を示しやすくなるので便利です。
  たとえば「サーバをデバッグするためのヒントは、作業コピーにある
  www/hacking.html をご覧ください」という代わりに
  「サーバをデバッグするためのヒントは
  <emphasis>http://svn.collab.net/repos/svn/trunk/www/hacking.html</emphasis>
  をご覧ください」と言えるのです。
  これは、常に <filename>hacking.html</filename>
  の最新リビジョンを指す URL です。URL を指定するほうが、
  あいまい性を排除するという点でよいでしょう。
</para>

<!--
<para>Some version control systems come with built-in
repository-browsing mechanisms, while others rely on third-party tools
to do it.  Three such tools are <firstterm>ViewCVS</firstterm> (<ulink
url="http://viewcvs.sourceforge.net/"/>),
<firstterm>CVSWeb</firstterm> (<ulink
url="http://www.freebsd.org/projects/cvsweb.html"/>), and
<firstterm>WebSVN</firstterm> (<ulink
url="http://websvn.tigris.org/"/>).  The first works with both CVS and
Subversion, the second with CVS only, and the third with Subversion
only.</para>
-->
<para>
  バージョン管理システムの中には、
  リポジトリをウェブで閲覧するための仕組みが組み込まれているものもあります。
  また、サードパーティのツールを使ってこの機能を実現しているものもあります。
  サードパーティのツールとして有名なのは
  <firstterm>ViewCVS</firstterm> (<ulink url="http://viewcvs.sourceforge.net/"/>)、
  <firstterm>CVSWeb</firstterm> (<ulink url="http://www.freebsd.org/projects/cvsweb.html"/>)、
  そして
  <firstterm>WebSVN</firstterm> (<ulink url="http://websvn.tigris.org/"/>)
  です。ViewCVS は CVS と Subversion の両方に対応しています。
  一方、CVSWeb は CVS 専用、WebSVN は Subversion 専用です。
</para>

</sect3>

<sect3 id="commit-emails">
<!--
<title>Commit emails</title>
-->
<title>コミットメール</title>

<!--
<para>Every commit to the repository should generate an email showing
who made the change, when they made it, what files and directories
changed, and how they changed.  The email should go to a special
mailing list devoted to commit emails, separate from the mailing lists
to which humans post.  Developers and other interested parties should
be encouraged to subscribe to the commits list, as it is the most
effective way to keep up with what's happening in the project at the
code level.  Aside from the obvious technical benefits of peer review
(see <xref linkend="code-review"/>), commit emails help create a
sense of community, because they establish a shared environment in
which people can react to events (commits) that they know are visible
to others as well.</para>
-->
<para>
  コミットが行われるたびに、その内容をメールで送信するようにします。
  メールには「だれが」「いつ」「どのファイルやディレクトリを」「どのように」
  変更したのかを記述します。
  このメールの送信先は独立したメーリングリストとし、
  人間が投稿する普通のメーリングリストとは独立させましょう。
  コミットメールを受け取りたいひとだけがそのメーリングリストに参加することになります。
  開発者やプロジェクトに興味があるその他の人たちには、
  このメーリングリストへの加入を勧めましょう。
  今そのプロジェクトに何が起こっているのかをコードレベルで知るために、
  このメーリングリストは最適な手段となります。
  ピアレビューの技術的な有用性については改めて語るまでもありません
  (<xref linkend="code-review"/> をご覧ください)
  が、コミットメールもコミュニティーにおいては有用なものとなります。
  すべてのイベント（コミット）の内容が共有されることで、
  他のメンバーがそれに反応したりといったことがしやすくなるのです。
</para>

<!--
<para>The specifics of setting up commit emails will vary depending on
your version control system, but usually there's a script or other
packaged facility for doing it.  If you're having trouble finding it,
try looking for documentation on <firstterm>hooks</firstterm>,
specifically a <firstterm>post-commit hook</firstterm>, also called
the <firstterm>loginfo hook</firstterm> in CVS.  Post-commit hooks are
a general means of launching automated tasks in response to commits.
The hook is triggered by an individual commit, is fed all the
information about that commit, and is then free to use that
information to do anything&mdash;for example, to send out an
email.</para>
-->
<para>
  コミットメールの設定方法は、使用するバージョン管理システムによって異なります。
  しかし、通常はそれ用のスクリプトやパッケージが用意されているはずです。
  もし見つからなければ、使用しているシステムのドキュメントで
  <firstterm>フック（hooks）</firstterm>、あるいは
  <firstterm>コミット後フック（post-commit hook）</firstterm>
  といったキーワードで探してみましょう。ちなみに CVS では
  <firstterm>loginfo フック（loginfo hook）</firstterm>
  と言うようです。
  コミットがあるたびに自動で特定の作業をさせる際に使用するのが
  コミット後フックです。これは各コミットの直後に呼び出され、
  そのコミットに関する情報を受け取って任意の作業を行うことができます。
  そう。たとえばメールを送信したりなど。
</para>

<!--
<para>With pre-packaged commit email systems, you may want to
modify some of the default behaviors:</para>
-->
<para>
  用意されているメール送信の仕組みを使用していると、
  そのデフォルトの動作をちょっと変更したくなってくるかもしれません。
</para>

<orderedlist>

  <listitem>
<!--
  <para>Some commit mailers don't include the actual diffs in the
  email, but instead provide a URL to view the change on the web using
  the repository browsing system.  While it's good to provide the URL,
  so the change can be referred to later, it is also
  <emphasis>very</emphasis> important that the commit email include
  the diffs themselves.  Reading email is already part of people's
  routine, so if the content of the change is visible right there in
  the commit email, developers will review the commit on the spot,
  without leaving their mail reader.  If they have to click on a URL to
  review the change, most won't do it, because that requires a new
  action instead of a continuation of what they were already doing.
  Furthermore, if the reviewer wants to ask something about the
  change, it's vastly easier to hit reply-with-text and simply
  annotate the quoted diff than it is to visit a web page and
  laboriously cut-and-paste parts of the diff from web browser to
  email client.</para>
-->
  <para>
    コミットメールシステムの中には、実際の差分そのものは本文に含めず、
    それをウェブで見るための URL だけを記載するというものがあります。
    もちろん URL は大事です。後から変更内容を確認するのにも便利ですしね。
    でも、差分の内容そのものをメールの本文に含めておくことも
    <emphasis>非常に</emphasis> 重要です。多くの人にとって、
    メールを読むという作業は日常のルーチンワークとして組み込まれているでしょう。
    変更の内容が直接メールに書かれていれば、
    一連の流れの中で自然にコミットをレビューすることができます。
    いちいちメールソフトを終了してブラウザに切り替える必要がなくなるのです。
    変更を確認するには URL をクリックする必要があるとなれば、
    ほとんどの人はクリックなどしてくれないでしょう。
    だって、これまでずっとメールを読んでいたのに、
    いきなり別の操作が必要となるのですから。
    さらに、変更点をレビューした人がその内容について質問をしたいときに、
    そのメールに「返信」すれば自動的に変更内容が得られるので便利です。
    さもないと、ウェブページを開いて変更点を
    カット＆ペーストするという大変な手間がかかってしまいます。
  </para>

<!--
  <para>(Of course, if the diff is huge, such as when a large body of
  new code has been added to the repository, then it makes sense to
  omit the diff and offer only the URL.  Most commit mailers can do
  this kind of limiting automatically.  If yours can't, then it's
  still better to include diffs, and live with the occasional huge
  email, than to leave the diffs off entirely.  Convenient reviewing
  and commenting is a cornerstone of cooperative development, much
  too important to do without.)</para>
-->
  <para>
    (もちろん、新たにリポジトリにコードを追加したなどで変更点が大量にある場合は、
    差分を省略して URL だけにするというのもわかります。
    コミットメールのシステムの多くは、
    何らかの制限値を設定してこの処理を自動化してくれるようになっています。
    もしそんな機能がついていなかったとしましょう。そんな場合でも、
    差分をまったく記載しないよりは常に差分を含めるようにするほうがずっとマシです。
    たまに巨大なメールが送信されることになりますが、許容範囲です。
    共同開発においては、みんなが他人の変更をレビューしたりコメントしたりすることが重要です。
    そのための努力は、いくらしてもしすぎることはありません)
  </para>
  </listitem>

<!--
  <listitem><para>The commit emails should set their Reply-to header
  to the regular development list, not the commit email list.  That
  is, when someone reviews a commit and writes a response, their
  response should be automatically directed toward the human
  development list, where technical issues are normally discussed.
  There are a few reasons for this.  First, you want to keep all
  technical discussion on one list, because that's where people expect
  it to happen, and because that way there's only one archive to
  search.  Second, there might be interested parties not subscribed to
  the commit email list.  Third, the commit email list advertises
  itself as a service for watching commits, not for watching commits
  <emphasis>and</emphasis> occasional technical discussions.  Those who
  subscribed to the commit email list did not sign up for anything but
  commit emails; sending them other material via that list would
  violate an implicit contract.  Fourth, people often write programs
  that read the commit email list and process the results (for
  display on a web page, for example).  Those programs are prepared to
  handle consistently-formatted commit emails, but not inconsistent
  human-written mails.</para>
-->
  <listitem>
  <para>
    コミットメールの Reply-to ヘッダは、コミットメール用のメーリングリストではなく
    開発者向けのメーリングリストにしておきましょう。
    そうすると、コミットメールの内容をレビューして何らかのコメントをしたくなった人が
    「返信」すると、それが自動的に開発者向けメーリングリストに流れることになります。
    こうしておくべき理由はいくつかあります。
    まず、技術的な議論はひとつの場所に集約するということ。
    技術的な議論を行う場として最適なのは、開発者向けメーリングリストです。
    次に、コミットメール用のメーリングリストに参加していないメンバーにも
    議論の内容を伝えるということ。
    ３つ目に、コミットメール用のメーリングリストはあくまでも
    コミットの内容をチェックするだけのものであり、
    決して「コミットの内容のチェックがメインだけど、
    たまに技術的な議論もある」というものであってはいけないからです。
    コミットメール用のメーリングリストに登録する人たちは、
    コミット内容のメールだけが送られてくることを期待しています。
    それ以外の内容が送られると、暗黙の了解を裏切ってしまうことになります。
    最後に、コミットメールの内容を処理して（ウェブページなどに）
    結果を出力するプログラムを作成するような人のことを考えるということ。
    この種のプログラムは、
    コミットメールのようなお決まりのパターンのメールに関してはうまく動作します。
    しかし、人間が書いたメールを処理させると変な結果になってしまうでしょう。
  </para>

<!--
  <para>Note that this advice to set Reply-to does not contradict the
  recommendations in
  <xref linkend="reply-to"/><phrase output="printed"> earlier in
  this chapter</phrase>.  It's
  always okay for the <emphasis>sender</emphasis> of a message to set
  Reply-to.  In this case, the sender is the version control system
  itself, and it sets Reply-to in order to indicate that the
  appropriate place for replies is the development mailing list, not
  the commit list.</para>
-->
  <para>
    ここでお勧めした Reply-to の設定は、決して
    <phrase output="printed">本章の前半で述べた</phrase>
    <xref linkend="reply-to"/> の内容と矛盾するものではないことに注意しましょう。
    先ほども、メッセージの <emphasis>送信者</emphasis> 自身が
    Reply-to を設定するぶんには特に問題はないとしています。今回の場合、
    メッセージの送信者はバージョン管理システムです。
    バージョン管理システム自身で Reply-to
    を指定して開発者向けメーリングリスト向けに返信させようとしているのですから、
    さきほどの説明とは矛盾しません。
  </para>

  </listitem>

</orderedlist>

<sidebar id="cia">
<!--
<title>CIA: Another Change Publication Mechanism</title>
-->
<title>CIA: 変更点を公開するためのもうひとつの方法</title>

<!--
<para>Commit emails are not the only way to propagate change news.
Recently, another mechanism called CIA (<ulink
url="http://cia.navi.cx/"/>) has been developed.  CIA is a real-time
commit statistics aggregator and distributor.  The most popular use of
CIA is to send commit notifications to IRC channels, so that people
logged into those channels see the commits happening in real time.
Though of somewhat less technical utility than commit emails, since
observers might or might not be around when a commit notice pops up in
IRC, this technique is of immense <emphasis>social</emphasis> utility.
People get the sense of being part of something alive and active, and
feel that they can see progress being made right before their
eyes.</para>
-->
<para>
  変更点を公開する方法は、コミットメールだけではありません。
  最近、CIA (<ulink url="http://cia.navi.cx/"/>)
  と呼ばれる別の仕組みが開発されました。
  CIA は、コミットの状況をリアルタイムで収集し、配信するものです。
  CIA の最も一般的な使用法は、コミットの通知を
  IRC チャネルに送信するというものです。
  そのチャネルに参加していれば、
  コミットがあるたびに即時にそれを知ることができます。
  メールに比べたら、技術的に劣っているかもしれません。
  だって、IRC にコミット通知を送ったとしても
  それを見ている人がいるかどうかがわからないわけですから。
  それでも、この仕組みは <emphasis>社会的な面で</emphasis>
  面白いものです。参加している人たちは
  そこで何かが起こっていることが感じられ、
  開発の進行状況をまさに目の前で見られるというわけです。
</para>

<!--
<para>The way it works is that you invoke the CIA notifier program
from your post-commit hook.  The notifier formats the commit
information into an XML message, and sends to a central server
(typically <literal>cia.navi.cx</literal>).  That server then
distributes the commit information to other forums.</para>
-->
<para>
  この仕組みを使用するには、コミット後のフックで
  CIA の通知用プログラム (CIA notifier) を実行します。
  このプログラムは、コミットに関する情報を XML
  形式に変換して中央サーバ (通常は <literal>cia.navi.cx</literal>)
  に送ります。するとサーバがその情報を別のフォーラムに配信するのです。
</para>

<!--
<para>CIA can also be configured to send out <ulink
url="http://www.xml.com/pub/a/2002/12/18/dive-into-xml.html">RSS</ulink>
feeds.  See the documentation at <ulink url="http://cia.navi.cx/"/>
for details.</para>
-->
<para>
  CIA を設定することで、
  <ulink url="http://www.xml.com/pub/a/2002/12/18/dive-into-xml.html">RSS</ulink>
  フィードを送信させることもできます。詳細は
  <ulink url="http://cia.navi.cx/"/> のドキュメントをご確認ください。
</para>

<!--
<para>To see an example of CIA in action, point your IRC
client at <literal>irc.freenode.net</literal>, channel
<literal>#commits</literal>.</para>
-->
<para>
  CIA が実際に動作している例を見るには、IRC クライアントで
  <literal>irc.freenode.net</literal> のチャネル <literal>#commits</literal>
  に行ってみましょう。
</para>

</sidebar>

</sect3>

<sect3 id="branches">
<!--
<title>Use branches to avoid bottlenecks</title>
-->
<title>ブランチの活用</title>

<!--
<para>Non-expert version control users are sometimes a bit afraid of
branching and merging.  This is probably a side effect of CVS's
popularity: CVS's interface for branching and merging is somewhat
counterintuitive, so many people have learned to avoid those
operations entirely.</para>
-->
<para>
  バージョン管理システムにあまり慣れていないユーザーは、
  ブランチの作成やマージ作業を怖がる傾向があるようです。
  おそらく、これは CVS の悪評の副作用でしょう。
  CVS のブランチ作成処理やマージ処理は直感的とは言えず、
  多くの人がそれを避けるようにしています。
</para>

<!--
<para>If you are among those people, resolve right now to conquer any
fears you may have and take the time to learn how to do branching and
merging.  They are not difficult operations, once you get used to
them, and they become increasingly important as a project acquires
more developers.</para>
-->
<para>
  もしあなたもその中のひとりだというのなら、
  怖がる気持ちを乗り越えてブランチ作成やマージについて勉強してみましょう。
  いったん作業に慣れてしまえば、そんなに難しいものではありません。
  また、プロジェクトに参加するメンバーが増えれば増えるほどこの作業の重要性も増します。
</para>

<!--
<para>Branches are valuable because they turn a scarce
resource&mdash;working room in the project's code&mdash;into an
abundant one.  Normally, all developers work together in the same
sandbox, constructing the same castle.  When someone wants to add a
new drawbridge, but can't convince everyone else that it would be an
improvement, branching makes it possible for her to go to an isolated
corner and try it out.  If the effort succeeds, she can invite the
other developers to examine the result.  If everyone agrees that the
result is good, they can tell the version control system to move
("merge") the drawbridge from the branch castle over to the main
castle.</para>
-->
<para>
  ブランチを使用すると、限られた資源（プロジェクトのソースコード中の作業場所）
  を有効活用できるので便利です。
  通常は、すべての開発者がひとつの砂場の上で作業をします。
  みんなでひとつのお城を作っていこうとしているわけです。
  あるとき、ひとりのメンバーが「ここに跳ね橋をつけましょうよ」と言い出しました。
  でも、他のメンバーは、それがそのお城にとって本当に有用なのかどうかがわかりません。
  そのメンバー用に砂場の一角を隔離し、彼女にはそこで作業をしてもらう。
  ブランチを作成するとは、そういうことになります。
  もしうまい具合に跳ね橋が出来上がったら、
  彼女は他のメンバーを呼び寄せてそれを見てもらいます。
  みんなが納得するようなできばえであることがわかれば、
  バージョン管理システムを使ってその跳ね橋をみんなのお城に移植
  （"マージ"）するのです。
</para>

<!--
<para>It's easy to see how this ability helps collaborative
development.  People need the freedom to try new things without
feeling like they're interfering with others' work.  Equally
importantly, there are times when code needs to be isolated from the
usual development churn, in order to get a bug fixed or a release
stabilized (see <xref linkend="stabilizing-a-release"/> and
<xref linkend="release-lines"/><phrase output="printed"> in
<xref linkend="development-cycle"/></phrase>) without worrying
about tracking a moving target.</para>
-->
<para>
  共同作業を進めるうえでこの機能がいかに有用かは、
  言うまでもないことでしょう。この機能を使えば、
  「他の人に迷惑がかからないかな？」
  なんて気にせずに思う存分新しいことを試せるのです。
  同じくらい重要なこととして、
  バグ修正や安定版リリースのためのブランチを本流から隔離する
  (<phrase output="printed"><xref linkend="development-cycle"/> の</phrase>
  <xref linkend="stabilizing-a-release"/> と
  <xref linkend="release-lines"/> を参照ください) ということがあります。
  そうすれば、それぞれの流れを追いやすくなります。
</para>

<!--
<para>Use branches liberally, and encourage others to use them.  But
also make sure that a given branch is only active for exactly as long
as needed.  Every active branch is a slight drain on the community's
attention.  Even those who are not working in a branch still maintain
a peripheral awareness of what's going on in it.  Such awareness is
desirable, of course, and commit emails should be sent out for branch
commits just as for any other commit.  But branches should not become
a mechanism for dividing the development community.  With rare
exceptions, the eventual goal of most branches should be to merge
their changes back into the main line and disappear.</para>
-->
<para>
  偏見を捨て、ブランチを積極的に使うようにしましょう。
  そして、他のメンバーにもブランチの使用を推奨しましょう。
  しかし、不要になったブランチはいつまでも残しておかないようにしましょう。
  ブランチが増えれば増えるほど、コミュニティー内での注目が散らばってしまいます。
  そのブランチとは直接関係のない開発者であっても、
  周りで起こっていることを気にせずにはいられないでしょう。
  無理もありません。もちろん、
  ブランチに対するコミットであってもコミットメールは同じように送ります。
  しかし、ブランチは開発者のコミュニティーを分断する仕組みとなるべきではありません。
  わずかな例外を除いては、
  初期の目的を達成して本流にマージした時点でブランチを削除するようにしましょう。
</para>

</sect3>

<sect3 id="vc-singularity">
<!--
<title>Singularity of information</title>
-->
<title>情報の一元管理</title>

<!--
<para>Merging has an important corollary: never commit the same change
twice.  That is, a given change should enter the version control
system exactly once.  The revision (or set of revisions) in which the
change entered is its unique identifier from then on.  If it needs to
be applied to branches other than the one on which it entered, then it
should be merged from its original entry point to those other
destinations&mdash;as opposed to committing a textually identical
change, which would have the same effect in the code, but would make
accurate bookkeeping and release management impossible.</para>
-->
<para>
  ブランチが重要だということは、当然マージ処理も重要になってくるということです。
  同じコミットを２回繰り返すなんていうことがないようにしましょう。
  つまり、ある変更がバージョン管理システムに投入されるのは１回だけにしておくということです。
  そうしておくことで、ある変更に対応するリビジョン（あるいはリビジョン群）
  が一意に決まるようになります。その変更と同じ内容を別のブランチにも適用したい場合は、
  そのブランチ上でもまったく同じように手を加えてそれをコミットするというのではなく、
  最初の変更をマージするようにしましょう。
  手作業で同じように修正したものをコミットしても結果は同じですが、
  そうすると正確なリリース管理ができなくなります。
</para>

<!--
<para>The practical effects of this advice differ from one version
control system to another.  In some systems, merges are special
events, fundamentally distinct from commits, and carry their own
metadata with them.  In others, the results of merges are committed
the same way other changes are committed, so the primary means of
distinguishing a "merge commit" from a "new change commit" is in the
log message.  In a merge's log message, don't repeat the log message
of the original change.  Instead, just indicate that this is a merge,
and give the identifying revision of the original change, with at most
a one-sentence summary of its effect.  If someone wants to see the
full log message, she should consult the original revision.</para>
-->
<para>
  この件に関する実際のアドバイスは、
  使用するバージョン管理システムによって異なります。
  あるシステムでは、「マージ」は特別な処理として扱われ、
  通常のコミットとは別のものとなります。
  そして独自のメタデータを保持します。
  また、システムによっては、
  マージした結果を通常のコミットと同様に適用するものもあります。
  このようなシステムでは、「マージした結果のコミット」と
  「新しい変更のコミット」の区別はログメッセージで行います。
  マージした際のログメッセージには、
  元の変更の際のログをそのまま繰り返してはいけません。
  そうではなく、「この変更はマージである」ことと、
  どのリビジョンをマージしたのかを簡単に記述するようにします。
  実際の変更内容を知りたければ、
  マージ元のログメッセージを見るようにするわけです。
</para>

<!--
<para>The reason it's important to avoid repeating the log message is
that log messages are sometimes edited after they've been committed.
If a change's log message were repeated at each merge destination,
then even if someone edited the original message, she'd still leave
all the repeats uncorrected&mdash;which would only cause confusion
down the road.</para>
-->
<para>
  ログメッセージの重複を避けるのがなぜそんなに大事なのかというと、
  ログメッセージは後から修正される可能性があるからです。
  同じ内容のログを繰り返し記述していると、
  だれかが元のログメッセージを修正したときに
  コピー先のメッセージがそのままになってしまう可能性があります。
  後から見たら、これは非常にややこしい状況になります。
</para>

<!--
<para>The same principle applies to reverting a change.  If a change
is withdrawn from the code, then the log message for the reversion
should merely state that some specific revision(s) is being reverted,
<emphasis>not</emphasis> describe the actual code change that results
from the reversion, since the semantics of the change can be derived
by reading the original log message and change.  Of course, the
reversion's log message should also state the reason why the change is
being reverted, but it should not duplicate anything from the original
change's log message.  If possible, go back and edit the original
change's log message to point out that it was reverted.</para>
-->
<para>
  同じ原則は、変更を取り消す (revert) 際にもあてはまります。
  ある修正が廃案になったときのログメッセージは、
  単にそれが revert されたということだけを記述します。
  実際に何をどのように戻したのかまでを書いては
  <emphasis>いけません</emphasis>。だってそれは、
  もともとその変更を行った際のログを見ればわかることなんですから。
  もちろん「なぜ」取り消したのかという理由の説明は必要でしょう。
  しかし、元の変更の際のログメッセージを一言一句書き写す必要はありません。
  できれば、元の変更の際のログメッセージも修正し、
  それが結局取り消されたことを記述しておくとよいでしょう。
</para>

<!--
<para>All of the above implies that you should use a consistent syntax
for referring to revisions.  This is helpful not only in log messages,
but in emails, the bug tracker, and elsewhere.  If you're using
CVS, I suggest "<literal>path/to/file/in/project/tree:REV</literal>",
where REV is a CVS revision number such as "1.76".  If you're using
Subversion, the standard syntax for revision 1729 is "r1729" (file
paths are not needed because Subversion uses global revision numbers).
In other systems, there is usually a standard syntax for expressing
the changeset name.  Whatever the appropriate syntax is for your
system, encourage people to use it when referring to changes.
Consistent expression of change names makes project bookkeeping much
easier (as we will see in <xref linkend="communications"/> and
<xref linkend="development-cycle"/>), and since a lot of the
bookkeeping will be done by volunteers, it needs to be as easy as
possible.</para>
-->
<para>
  これまで説明してきたことからも何となくお分かりでしょうが、
  特定のリビジョンを参照する際の表記方法は統一しておいたほうがいいでしょう。
  これは、ログメッセージだけでなくメールやバグ追跡システムなどでも同じです。
  CVS を使っているのなら、
  "<literal>path/to/file/in/project/tree:REV</literal>"
  という形式をお勧めします。ここで、REV は CVS のリビジョン番号
  (たとえば "1.76" など) を指します。
  Subversion を使っているのなら、(たとえばリビジョン 1729 の場合の)
  標準の表記法は "r1729" となります (ファイルのパスは不要です。
  Subversion はリポジトリ全体でリビジョン番号を管理するからです)。
  それ以外のシステムでもきっと、
  チェンジセットを表すための標準形式があることでしょう。
  ともかく、メンバーには標準の形式を使ってもらうようにしましょう。
  この表記法を統一しておくと、後からプロジェクトの流れを追うのが簡単になり
  (<xref linkend="communications"/> や
  <xref linkend="development-cycle"/> で説明します) ます。
  これらの管理を行うのはたいていはボランティアなので、
  できるだけ簡単に進められるようにしておくことが重要です。
</para>

<!--
<para>See also
<xref
linkend="releases-and-daily-development"/><phrase
output="printed"> in
<xref linkend="development-cycle"/></phrase>.</para>
-->
<para>
  <phrase output="printed"><xref linkend="development-cycle"/></phrase>
  の <xref linkend="releases-and-daily-development"/>
  もご覧ください。
</para>

</sect3>

<sect3 id="vc-authz">
<!--
<title>Authorization</title>
-->
<title>承認</title>

<!--
<para>Most version control systems offer a feature whereby certain
people can be allowed or disallowed from committing in specific
sub-areas of the repository.  Following the principle that when handed
a hammer, people start looking around for nails, many projects use
this feature with abandon, carefully granting people access to just
those areas where they have been approved to commit, and making sure
they can't commit anywhere else.  (See
<xref linkend="committers"/><phrase output="printed"> in
<xref linkend="managing-volunteers"/></phrase> for how projects
decide who can commit where.)</para>
-->
<para>
  たいていのバージョン管理システムには、
  特定のユーザーに対してリポジトリ内の特定の場所だけのコミットを許可したり
  逆に拒否したりといったことをする機能があります。
  「ハンマーを与えられたら、人はみんな周囲の釘を探すようになる」
  という原則どおり、多くのプロジェクトでこの機能が使われてきました。
  アクセス権を注意深く管理し、特定の場所にだけコミット権を与えて
  他の場所は触らせないようにするといった具合です
  (<phrase output="printed"><xref linkend="managing-volunteers"/></phrase>
  の <xref linkend="committers"/> で、
  コミット権の管理方法について説明しています)。
</para>

<!--
<para>There is probably little harm done by exercising such tight
control, but a more relaxed policy is fine too.  Some projects simply
use an honor system: when a person is granted commit access, even for
a sub-area of the repository, what they actually receive is a password
that allows them to commit anywhere in the project.  They're just
asked to keep their commits in their area.  Remember that there is no
real risk here: in an active project, all commits are reviewed anyway.
If someone commits where they're not supposed to, others will
notice it and say something.  If a change needs to be undone, that's
simple enough&mdash;everything's under version control anyway, so
just revert.</para>
-->
<para>
  このように厳格に管理してしまえば、悪影響が出る可能性を減らせることでしょう。
  しかし、もうすこし緩やかな方針でもかまいません。
  プロジェクトによっては、緩やかな方針を採用しているものもあります。
  たとえリポジトリの一部分のみへのコミット権を与えられたユーザーであっても、
  設定上はリポジトリ全体を変更できる権限を与えるというものです。
  ただ「コミットするのはこの範囲だけにしておいてね」とお願いするだけです。
  こうしたところで、実害はないことを覚えておきましょう。
  ふつうのプロジェクトなら、すべてのコミットは何らかの形でレビューされます。
  誰かが予期せぬコミットをしたら、
  それを見つけた人が何かコメントすることでしょう。
  その変更を取り消すべきだと判断したのなら、やることは簡単です。
  すべてバージョン管理されているのだから、
  単にその変更を取り消せばいいだけのことです。
</para>

<!--
<para>There are several advantages to the relaxed approach.  First, as
developers expand into other areas (which they usually will if they
stay with the project), there is no administrative overhead to
granting them wider privileges.  Once the decision is made, the person
can just start committing in the new area right away.</para>
-->
<para>
  緩やかな方針にしておく利点はいくつかあります。
  まず、ある開発者の権限を拡張する
  （プロジェクトに長年かかわっていると、よくあることです）
  場合に一切手間がかからないということです。
  単に「今日からは、ここもコミットしていいよ」というだけで、
  後はすぐにコミットできるようになります。
</para>

<!--
<para>Second, expansion can be done in a more fine-grained manner.
Generally, a committer in area X who wants to expand to area Y will
start posting patches against Y and asking for review.  If someone who
already has commit access to area Y sees such a patch and approves of
it, they can just tell the submitter to commit the change directly
(mentioning the reviewer/approver's name in the log message, of
course).  That way, the commit will come from the person who actually
wrote the change, which is preferable from both an information
management standpoint and from a crediting standpoint.</para>
-->
<para>
  次に、より緻密な方法で権限の拡張ができるようになります。
  一般に、エリア X のコミッターがエリア Y にもコミットしたいと考えた場合は、
  まず Y に対するパッチを投稿してレビューしてもらうことになります。
  すでに Y へのコミット権を持つメンバーがそのパッチをレビューして承認したら、
  パッチを投稿した人に対して「直接コミットしてもいいよ」と伝えます
  (もちろん、誰がレビューして承認したのかという情報は
  ログメッセージに残しておきます)。
  この方法だと、実際にパッチを書いた人がコミットをすることになります。
  これは、情報管理の面でも功績をたたえる意味でも重要です。
</para>

<!--
<para>Last, and perhaps most important, using the honor system
encourages an atmosphere of trust and mutual respect.  Giving someone
commit access to a subdomain is a statement about their technical
preparedness&mdash;it says: "We see you have expertise to make commits
in a certain domain, so go for it."  But imposing strict authorization
controls says: "Not only are we asserting a limit on your expertise,
we're also a bit suspicious about
your <emphasis>intentions</emphasis>."  That's not the sort of
statement you want to make if you can avoid it.  Bringing someone into
the project as a committer is an opportunity to initiate them into a
circle of mutual trust.  A good way to do that is to give them more
power than they're supposed to use, then inform them that it's up to
them to stay within the stated limits.</para>
-->
<para>
  最後に、最も重要なのが、この緩やかな方式を採用すると
  お互いに信頼し、尊重しあう空気が生まれるということです。
  この方式の場合、「君はこの部分にコミットする能力があることがわかった。
  ぜひコミットしてくれ」というようにとられます。
  厳格に管理してしまうと「君のできることには制限があるんだ」
  ということを強調するだけでなく
  「間違って変なことをしてしまわないかどうかが心配なんだ」
  と疑っているように感じられてしまいます。
  できればこのようなことは避けたいでしょう。
  だれかを新たにコミッターとして迎え入れるということは、
  みんなの信頼の輪の中に新しいメンバーを加えるということです。
  その際には、本来必要なもの以上の力を与え、
  「それをどう使うかはあなたしだい。でもこれ以上のことはしないでね」
  としたほうがいいでしょう。
</para>

<!--
<para>The Subversion project has operated on the honor system way for
more than four years, with 33 full and 43 partial committers as of
this writing.  The only distinction the system actually enforces is
between committers and non-committers; further subdivisions are
maintained solely by humans.  Yet we've never had a problem with
someone deliberately committing outside their domain.  Once or twice
there's been an innocent misunderstanding about the extent of
someone's commit privileges, but it's always been resolved quickly and
amiably.</para>
-->
<para>
  Subversion プロジェクトでは、かれこれ 4 年以上この「緩やかな管理」
  方式を採用しています。本書の執筆時点で、フルコミッターは 33 人、
  一部にだけコミット権限のあるメンバーが 43 人います。
  この管理方式では、システムが管理するのは「コミッターかそうでないか」
  だけです。その詳細 (どの部分にコミット権があるかなど) は人間が管理します。
  今のところ、コミット権のない部分について故意にコミットするなどといった
  問題は発生していません。コミット権に関する誤解が生じたことも何度かありましたが、
  いつも速やかに円満解決していました。
</para>

<!--
<para>Obviously, in situations where self-policing is impractical, you
must rely on hard authorization controls.  But such situations are
rare.  Even when there are millions of lines of code and hundreds or
thousands of developers, a commit to any given code module should
still be reviewed by those who work on that module, and they can
recognize if someone committed there who wasn't supposed to.  If
regular commit review <emphasis>isn't</emphasis> happening, then the
project has bigger problems to deal with than the authorization system
anyway.</para>
-->
<para>
  このような自己管理方式が明らかに現実的でない場面もあるでしょう。
  当然、そんな場合は厳格な管理が必要となります。
  とはいえ、そんな状況はまれです。
  たとえ何千人の開発者が何百万行のコードを扱っていたとしても、
  そのコードに対するすべてのコミットはだれか他の人によるレビューを受けます。
  おかしなコミットがあればすぐに指摘されるでしょう。
  もしコミットをレビューしあう習慣が<emphasis>できていない</emphasis>のなら、
  それは認証システムがどうのこうのいう以前の問題です。
</para>

<!--
<para>In summary, don't spend too much time fiddling with the version
control authorization system, unless you have a specific reason to.  It
usually won't bring much tangible benefit, and there are advantages to
relying on human controls instead.</para>
-->
<para>
  まとめると、よっぽどの理由がない限りは
  バージョン管理システム上のアクセス権限にあまり気を使う必要はないということです。
  厳密に管理したところで得られる具体的なメリットはあまりありません。
  それより人間による管理に頼ったほうが得られるものは多いでしょう。
</para>

<!--
<para>None of this should be taken to mean that the restrictions
themselves are unimportant, of course.  It would be bad for a project
to encourage people to commit in areas where they're not qualified.
Furthermore, in many projects, full (unrestricted) commit access has a
special status: it implies voting rights on project-wide questions.
This political aspect of commit access is discussed more in <xref
linkend="electorate"/><phrase output="printed"> in
<xref linkend="social-infrastructure"/></phrase>.</para>
-->
<para>
  もちろん、制限をすること自体が無意味だといっているわけではありません。
  権限のないところへコミットさせるようなことは、あまりしたくないでしょう。
  さらに、多くのプロジェクトでは「フルコミッター (制限のないコミッター)」
  には何らかの特権 (たとえばプロジェクトの運営に関する投票に参加できるなど)
  が与えられています。コミット権の扱いに関する政治的な意味合いについては
  <phrase output="printed"><xref linkend="social-infrastructure"/></phrase>
  の <xref linkend="electorate"/> で詳しく説明します。
</para>

</sect3>

</sect2>

</sect1>


<!-- ========================== SECTION =========================== -->
<sect1 id="bug-tracker">
<title>バグ追跡システム</title>

<!--
<para>Bug tracking is a broad topic; various aspects of it are
discussed throughout this book.  Here I'll try to concentrate mainly
on setup and technical considerations, but to get to those, we have to
start with a policy question: exactly what kind of information should
be kept in a bug tracker?</para>
-->

<para>
    バグ追跡 が扱う範囲は多岐にわたります。
    この本ではバグ追跡についての様々な側面を議論しています。
    ここでは バグ追跡システムをセットアップすることと、
    その作業に関する技術的な考察に集中しようと思います。
    その話題に入る前に、バグ追跡の方針に関する質問から始めましょう。
    具体的にどの情報をバグ追跡システムに保存すべきなのでしょうか?
</para>

<!--
<para>The term <firstterm>bug tracker</firstterm> is misleading.  Bug
tracking systems are also frequently used to track new feature
requests, one-time tasks, unsolicited patches&mdash;really anything
that has distinct beginning and end states, with optional transition
states in between, and that accrues information over its lifetime.
For this reason, bug trackers are also called <firstterm>issue
trackers</firstterm>, <firstterm>defect trackers</firstterm>,
<firstterm>artifact trackers</firstterm>, <firstterm>request
trackers</firstterm>, <firstterm>trouble ticket systems</firstterm>,
etc.  See <xref linkend="bug-trackers"/> for a list of software.
</para>
-->

<para>
    <firstterm>バグ追跡システム</firstterm> は、誤解を招きやすい用語です。
    バグ追跡システムは、新しい機能要望や、一度限りのタスク、
    送られてきたパッチ &mdash; はじまりと終わりの状態があるすべてのもの、
    存在している間に情報が発生するすべてのものを追跡するためによく使われます。
    このため、バグ追跡システムは、
    <firstterm>問題追跡システム</firstterm>、
    <firstterm>不具合追跡システム</firstterm>、
    <firstterm>影響追跡システム</firstterm>、
    <firstterm>要望追跡システム</firstterm>、
    <firstterm>チケットシステム</firstterm> などとも呼ばれています。
    バグ追跡システムのソフトウェアの一覧は、<xref linkend="bug-trackers"/> を参照してください。
</para>

<!--
<para>In this book, I'll continue to use "bug tracker" for the
software that does the tracking, because that's what most people call
it, but will use <firstterm>issue</firstterm> to refer to a single
item in the bug tracker's database.  This allows us to distinguish
between the behavior or misbehavior that the user encountered (that is,
the bug itself), and the tracker's <emphasis>record</emphasis> of the
bug's discovery, diagnosis, and eventual resolution.  Keep in mind
that although most issues are about actual bugs, issues can be used to
track other kinds of tasks too.</para>
-->

<para>
    この本では "バグ追跡システム" という用語を、
    バグを追跡するソフトウェアを指すものとします。
    なぜなら、殆どの人がバグ追跡システムと呼んでいるからです。
    しかし、バグ追跡システムのデータベースに登録される個々のアイテムを指すものとして、
    <firstterm>問題</firstterm> という用語を使います。
    これによってユーザーが遭遇するソフトウェアの変な振る舞い（つまり、バグです）と、
    バグの発見、診断、解決の <emphasis>記録</emphasis> を区別できるからです。
    殆どの問題は実際に起こったバグに関するものですが、
    他のタスクに関することでも問題という用語が使えるということを覚えておいてください。
</para>

<!--
<para>The classic issue life cycle looks like this:
-->

<para>問題の典型的なライフサイクルは次のようなものです。

<orderedlist>
  <listitem>
            <!--
            <para>Someone files the issue.  They provide a summary, an
            initial description (including a reproduction recipe, if
            applicable; see
            <xref
            linkend="users-to-volunteers"/><phrase
            output="printed"> in
            <xref linkend="managing-volunteers"/></phrase> for
            how to encourage good bug reports), and whatever other
            information the tracker asks for.  The person who files
            the issue may be totally unknown to the project&mdash;bug
            reports and feature requests are as likely to come from
            the user community as from the developers.</para>
            -->

            <para>誰かが問題をバグデータベースに記録します。
            この記録には、問題の要点、問題の説明(もしあれば、
            問題を再現させるための手順も。
            ユーザーに優れたバグ報告をさせる方法については、
            <phrase output="printed"><xref linkend="managing-volunteers"/></phrase> の <xref linkend="users-to-volunteers"/> を参照してください)
            、バグ追跡システムが求めているその他の情報が全て含まれています。
            問題を報告した人は、プロジェクトについて全く知らないかもしれません。&mdash;
            ユーザーのコミュニティーと開発者達から、同じくらいの割合でバグ報告や機能要望があがってきます。</para>

            <!--
            <para>Once filed, the issue is in what's called an
            <firstterm>open</firstterm> state.  Because no action has
            been taken yet, some trackers also label it as
            <firstterm>unverified</firstterm> and/or
            <firstterm>unstarted</firstterm>.  It is not assigned to
            anyone; or, in some systems, it is assigned to a fake
            user to represent the lack of real assignation.  At this
            point, it is in a holding area: the issue has been
            recorded, but not yet integrated into the project's
            consciousness.</para>
            -->

            <para>いったん問題が報告されると、その問題は <firstterm>保留中</firstterm> の状態にあるといいます。
            なぜなら、それに対して何らアクションがとられていないからです。
            システムによっては、
            <firstterm>未確認</firstterm> とか <firstterm>未着手</firstterm> といったラベルを付与するものもあります。
            まだ誰もこの問題を担当していません。システムによっては、
            担当が決まっていないことを表すためにダミーの担当者を割り当てるものもあります。
            この時点では、問題は一時的な領域に置かれています。つまり、
            システムに記録されてはいるが、プロジェクトがまだ関心を持っていないということです。</para>
  </listitem>
  <listitem>
            <!--
            <para>Others read the issue, add comments to it, and
            perhaps ask the original filer for clarification on some
            points.</para>
            -->

            <para>
            誰か他の人が問題を読み、コメントを付けます。
            おそらく問題を報告した人に、不明な点について説明を求めるでしょう。
            </para>
  </listitem>
  <listitem>
            <!--
            <para>The bug gets <firstterm>reproduced</firstterm>.
            This may be the most important moment in its
            life cycle.  Although the bug is not actually fixed yet,
            the fact that someone besides the original filer was able
            to make it happen proves that it is genuine, and, no less
            importantly, confirms to the original filer that they've
            contributed to the project by reporting a real bug.</para>
            -->

            <para>
            問題はやがて <firstterm>再現済み</firstterm> という状態になります。
            これは問題のライフサイクルの中で最も重要かもしれません。これは、
            まだ解決されたわけではないが、
            報告した人以外の誰かが問題を再現でき、
            この問題が本物だと証明したことをいいます。
            そして同じくらい重要なことですが、
            報告した人が本物のバグを報告することで、
            プロジェクトに貢献したと確認することでもあります。
            </para>
  </listitem>
  <listitem>
            <!--
            <para>The bug gets <firstterm>diagnosed</firstterm>: its
            cause is identified, and if possible, the effort required
            to fix it is estimated.  Make sure these things get
            recorded in the issue; if the person who diagnosed the
            bug suddenly has to step away from the project for a
            while (as can often happen with volunteer developers),
            someone else should be able to pick up where she left
            off.</para>
            -->

            <para>
            そして <firstterm>診断済み</firstterm> という状態になります。
            問題の原因が特定され、可能なら解決に必要な労力が見積もられます。
            これらのことは必ず追跡システムに記録するようにしましょう。    
            原因を調べた人が突然しばらくプロジェクトを離れなければならない（これはボランティアの開発者にはよくあることです）場合に、
            誰かが穴を埋められるようにしておくべきだからです。
            </para>

            <!--
            <para>In this stage, or sometimes the previous one, a
            developer may "take ownership" of the issue and
            <firstterm>assign</firstterm> it to herself (<xref
            linkend="delegation-assignment"/><phrase
            output="printed"> in
            <xref linkend="managing-volunteers"/></phrase>
            examines the assignment process in more detail).  The issue's
            <firstterm>priority</firstterm> may also be set at this
            stage.  For example, if it is so severe that it should
            delay the next release, that fact needs to be identified
            early, and the tracker should have some way of noting
            it.</para>
            -->

            <para>
            この段階か、もうひとつ前の段階で、
            開発者が問題を "自分が解決することにして"、 自分自身を <firstterm>担当者にする</firstterm> するかもしれません。
            (担当者を決める手続きをさらに詳細に調べるには
            <phrase output="printed"><xref linkend="managing-volunteers"/> の </phrase>、
            <xref linkend="delegation-assignment"/> を参照してください)
            この段階で、問題に<firstterm>優先度</firstterm> も割り当てられるかもしれません。
            たとえば、問題がとても深刻なので解決は次のリリースにまわすべき場合、
            その事実は早い段階で確認する必要があります。
            よって、追跡システムはそれを記録する何らかの方法を備えるべきということになります。
            </para>
  </listitem>
  <listitem>
            <!--
            <para>The issue gets scheduled for resolution.
            Scheduling doesn't necessarily mean naming a date by which
            it will be fixed.  Sometimes it just means deciding which
            future release (not necessarily the next one) the bug
            should be fixed by, or deciding that it need not block any
            particular release.  Scheduling may also be dispensed
            with, if the bug is quick to fix.</para>
            -->

            <para>
            問題をいつ解決するかという予定が立てられます。
            予定を決めるということは、
            いつまでに直すという日程を決めることとは限りません。
            将来のどのリリース（次のバージョンとは限りません）で直すかを決めるだけのこともありますし、
            特定のリリースで直すと決めない場合もあります。
            バグが素早く直せる場合には、予定を立てないこともあります。
            </para>
  </listitem>
  <listitem>
            <!--
            <para>The bug gets fixed (or the task completed, or
            the patch applied, or whatever).  The change or set of
            changes that fixed it should be recorded in a comment in
            the issue, after which the issue is
            <firstterm>closed</firstterm> and/or marked as
            <firstterm>resolved</firstterm>.</para>
            -->

            <para>
            問題が解決されます。（タスクが終了したり、
            パッチが適用されたりとか、そういったものです）
            行った変更は、問題の <firstterm>処理が済んだ</firstterm> り、
            <firstterm>解決済み</firstterm> とマークされたあとに、
            コメントとして記録するようにしましょう。
            </para>
  </listitem>
</orderedlist>

</para>

<!--
<para>There are some common variations on this life cycle.  Sometimes
an issue is closed very soon after being filed, because it turns out
not to be a bug at all, but rather a misunderstanding on the part of
the user.  As a project acquires more users, more and more such
invalid issues will come in, and developers will close them with
increasingly short-tempered responses.  Try to guard against the
latter tendency.  It does no one any good, as the individual user in
each case is not responsible for all the previous invalid issues; the
statistical trend is visible only from the developers' point of view,
not the user's.  (In
<xref linkend="bug-filtering"/><phrase output="printed"> later
in this chapter,</phrase> we'll look at
techniques for reducing the number of invalid issues.)  Also, if
different users are experiencing the same misunderstanding over and
over, it might mean that that aspect of the software needs to be
redesigned.  This sort of pattern is easiest to notice when there is
an issue manager monitoring the bug database; see
<xref linkend="issue-manager"/><phrase output="printed"> in
<xref linkend="managing-volunteers"/></phrase>.</para>
-->

<para>
    問題のライフサイクルには共通のバリエーションがいくつかあります。
    問題によっては、バグではなくユーザー側が誤解していたという理由ですぐに処理済みとされることがあります。
    プロジェクトが多くのユーザーを獲得するにつれ、
    バグではない問題が報告される回数も増えていき、
    開発者は次第にぶっきらぼうな返事をして問題を処理済みとするようになります。
    こういう風潮にならないよう努力しましょう。
    ぶっきらぼうに問題を処理済みにしてもいいことは何もありません。
    バグではない問題を報告したユーザ－は、以前報告された問題には何の責任もないのですから。
    それに報告される問題が統計的にどういった傾向にあるかは、
    開発者のみわかることで、ユーザーにはわからないことです。
    (<phrase output="printed">この章の後半の</phrase> <xref linkend="bug-filtering"/> で、
    バグではない問題の数を減らすテクニックについて見ていきます)
    また、異なったユーザーが繰り返し同じような誤解をする場合は、
    誤解を生む部分を再設計する必要があるということかもしれません。
    この手のパターンはバグデータベースを監視する問題管理システムがあれば簡単に見つかります。
    <phrase output="printed"><xref linkend="managing-volunteers"/> の</phrase>、
    <xref linkend="issue-manager"/> を参照してください。
</para>

<!--
<para>Another common life cycle variation is for the issue to be closed
as a <firstterm>duplicate</firstterm> soon after Step 1.  A duplicate
is when someone files an issue that's already known to the project.
Duplicates are not confined to open issues: it's possible for a bug to
come back after having been fixed (this is known as a
<firstterm>regression</firstterm>), in which case the preferred course
is usually to reopen the original issue and close any new reports as
duplicates of the original one.  The bug tracking system should keep
track of this relationship bidirectionally, so that reproduction
information in the duplicates is available to the original issue, and
vice versa.</para>
-->

<para>
    別のバリエーションとして、
    1. のすぐ後で問題が <firstterm>重複している</firstterm> として処理済みにされる場合があります。
    重複した問題は、プロジェクトが既に認識している問題を誰かがまた報告すると発生します。
    重複した状態は 保留中 の問題で発生するとは限りません。
    解決したあとで再び報告される(この状態を <firstterm>リグレッション（回帰）</firstterm> と呼びます)こともあります。
    こういう場合は、重複の元となった問題を 再度保留中の状態にして、
    重複した問題は処理済みにしてしまうのが普通は望ましいでしょう。
    バグ追跡システムは、
    問題を再現する情報ははじめに報告された問題で見られるように（逆も同様）、
    問題同士の関連を追跡しているはずです。
</para>

<!--
<para>A third variation is for the developers to close the issue,
thinking they have fixed it, only to have the original reporter reject
the fix and reopen it.  This is usually because the developers simply
don't have access to the environment necessary to reproduce the bug,
or because they didn't test the fix using the exact same reproduction
recipe as the reporter.</para>
-->

<para>
    開発者が問題を処理済みにする3つ目のバリエーションは、
    問題を解決したと思い込んで処理済みにするパターンです。
    これは結局、問題を報告した人がそれを拒んで再度保留中にする結果になります。
    これは開発者が単にバグを再現するのに必要な環境にアクセスできないか、
    問題を再現する手順に正確に従ってテストをしなかったために発生します。
</para>

<!--
<para>Aside from these variations, there may be other small details of
the life cycle that vary depending on the tracking software.  But the
basic shape is the same, and while the life cycle itself is not
specific to open source software, it has implications for how open
source projects use their bug trackers.</para>
-->

<para>
    これらのバリエーションのほかにも、
    バグ追跡システムによって細かい部分が変わる場合はありますが、
    基本的なパターンは同じです。
    問題のライフサイクルそのものもオープンソースソフトウェアに特有のものではありませんが、
    オープンソースプロジェクトのバグ追跡システムの使い方に影響を与えています。
</para>

<!--
<para>As Step 1 implies, the tracker is as much a public face of the
project as the mailing lists or web pages.  Anyone may file an issue,
anyone may look at an issue, and anyone may browse the list of currently
open issues.  It follows that you never know how many people are
waiting to see progress on a given issue.  While the size and skill of
the development community constrains the rate at which issues can be
resolved, the project should at least try to acknowledge each issue the
moment it appears.  Even if the issue lingers for a while, a response
encourages the reporter to stay involved, because she feels that a
human has registered what she has done (remember that filing an
issue usually involves more effort than, say, posting an email).
Furthermore, once an issue is seen by a developer, it enters the
project's consciousness, in the sense that that developer can be on
the lookout for other instances of the issue, can talk about it with
other developers, etc.</para>
-->

<para>
    1. が暗に示すとおり、
    バグ追跡システムはメーリングリストやウェブページと同様プロジェクトの顔です。
    誰でも問題を報告し、調べることができますし、現在保留中とされている問題の一覧を見ることができます。
    よって、報告されている問題の進捗を何人の人が知りたがっているのかが、
    開発者にはわからないということになります。
    問題が解決される割合は開発者コミュニティーの規模やスキルに左右されますが、
    プロジェクトは少なくとも問題が報告されたらすぐにそれを認識しようとすべきです。
    たとえ問題が解決されずにしばらく残り続けても、
    開発者が返答すると、問題を報告した人は引き続き参加したいと考えます。
    なぜなら、自分がやったことが認められたと感じるからです。(問題を報告することは、
    たとえば電子メールを送ること以上に労力がいることを思い出してください)
    それ以上に、問題をいったん開発者が見れば、
    報告された問題の他の事例に注意を払ったり、他の開発者と話し合える、などの意味で、
    プロジェクトが問題を認識したことになります。
</para>

<!--
<para>The need for timely reactions implies two things:
-->

<para>
    適切なタイミングで問題に応答するには、次の二つが必要です。

<itemizedlist>
  <listitem>
    <!--
    <para>The tracker must be connected to a mailing list, such that
    every change to an issue, including its initial filing, causes a
    mail to go out describing what happened.  This mailing list
    is usually different from the regular development list, since not
    all developers may want to receive automated bug mails, but (just
    as with commit mails) the Reply-to header should be set to the
    development mailing list.</para>
    -->

    <para>
        バグ追跡システムをメーリングリストと接続しなければいけません。
        これは、問題を報告することを含めた、問題の状態を変更するあらゆる行動が、
        メールで投稿されるようにするためです。
        このメーリングリストは通常使う開発用のものとは違うのが普通です。
        なぜなら、開発者全員が自動送信されるバグ報告メールを受け取りたいとは限らないからです。
        しかし、(コミットメールと同様に) Reply-to ヘッダは開発用のメーリングリストのアドレスに設定しておきましょう。
    </para>

  </listitem>
  <listitem>
    <!--
    <para>The form for filing issues should capture the reporter's
    email address, so she can be contacted for more information.
    (However, it should not <emphasis>require</emphasis> the
    reporter's email address, as some people prefer to report issues
    anonymously.  See
    <xref linkend="anonymity"/><phrase output="printed"> later
    in this chapter</phrase> for more on the importance of
    anonymity.)</para>
    -->

    <para>
        問題を報告するときの記入フォームは、
        報告する人の電子メールアドレスの欄にフォーカスを当てておくべきです。
        (しかし、匿名で報告したいと思う人もいるので、
        電子メールアドレスを <emphasis>必須</emphasis> にすべきではありません。
        匿名の重要性については、
        <phrase output="printed">この章の後半にある</phrase> <xref linkend="anonymity"/> を参照してください。
    </para>
  </listitem>
</itemizedlist>

</para>

<sect2 id="bug-tracker-mailing-list-interaction">
<title>議論の場としてメーリングリストを使う</title>

<!--
<para>Make sure the bug tracker doesn't turn into a discussion forum.
Although it is important to maintain a human presence in the bug
tracker, it is not fundamentally suited to real-time discussion.
Think of it rather as an archiver, a way to organize facts and
references to other discussions, primarily those that take place on
mailing lists.</para>
-->

<para>
    バグ追跡システムがディスカッションフォーラムにならないようにしましょう。
    バグ追跡システムに人間が顔を出し続けることは大事ですが、
    それがリアルタイムに議論するのに適しているわけではありません。
    バグ追跡システムは、起こった事実や他の議論に対する参照、
    メーリングリストで起きた議論をまとめるアーカイバと考えるようにしましょう。
</para>

<!--
<para>There are two reasons to make this distinction.  First, the bug
tracker is more cumbersome to use than the mailing lists (or than
real-time chat forums, for that matter).  This is not because bug
trackers have bad user interface design, it's just that their
interfaces were designed for capturing and presenting discrete states,
not free-flowing discussions.  Second, not everyone who should be
involved in discussing a given issue is necessarily watching the bug
tracker.  Part of good issue management (see
<xref linkend="share-management"/><phrase output="printed"> in
<xref linkend="managing-volunteers"/></phrase>) is to make sure
each issue is brought to the right peoples' attention, rather than
requiring every developer to monitor all issues.  In
<xref linkend="bug-tracker-usage"/><phrase output="printed"> in <xref linkend="communications"/>,</phrase> we'll look at ways to make
sure people don't accidentally siphon discussions out of appropriate
forums and into the bug tracker.</para>
-->

<para>
    こうした区別をするのはふたつの理由があります。
    ひとつめは、バグ追跡システムがメーリングリストに比べて（ついでにいうと、リアルタイムに会話ができるチャットシステムと比べても）使いにくいからです。
    これはバグ追跡システムのインターフェイス設計が悪いからではなく、
    単にメーリングリストやチャットシステムが、連続していない状態、つまり自由に流れていく議論を取り込めるように設計されているからです。
    ふたつめは、ある議論に参加している人が、
    バグ追跡システムを見ているとは限らないからです。
    よい問題管理のやり方(<phrase output="printed"><xref linkend="managing-volunteers"/> の、</phrase> <xref linkend="share-management"/> を参照してください)は、
    開発者全員に起こっている問題全部を追いかけさせるのではなく、
    適切な人の注意をひくようにすることです。
    <phrase output="printed"><xref linkend="communications"/> の</phrase> <xref linkend="bug-tracker-usage"/>では、
    適切なフォーラム以外に偶然議論が波及しないようにする方法や、
    バグ追跡システムに議論を持ち込まないようにする方法を見ていきます。
</para>

<!--
<para>Some bug trackers can monitor mailing lists and automatically
log all emails that are about a known issue.  Typically they do this
by recognizing the issue's identifying number in the subject line of
the mail, as part of a special string; developers learn to include
these strings in their mails to attract the tracker's notice.  The bug
tracker may either save the entire email, or (even better) just record
a link to the mail in the regular mailing list archive.  Either way,
this is a very useful feature; if your tracker has it, make sure
both to turn it on and to remind people to take advantage of
it.</para>
-->

<para>
    バグ追跡システムによっては、メーリングリストをモニタし、
    既知の問題に関する電子メールを全て自動的に記録するものがあります。
    通常、こうしたシステムはメールの件名の行にある問題の番号を、
    特別な文字列として認識することでこれを行います。
    開発者達は、バグ追跡システムの注意を引くために、
    電子メールにこうした文字列を含めることができるようになります。
    バグ追跡システムに電子メール全体を記録させてもいいですし、
    (よりよいのは)通常のメーリングリストのアーカイブにあるメールへのリンクを記録させてもよいでしょう。
    どちらの方法でも、これはとても役に立つ機能です。
    あなたが使っているバグ追跡システムにこの機能があるなら、
    それを有効にして人々が利用するように知らせておきましょう。
</para>

</sect2>

<sect2 id="bug-filtering">
<title>バグ追跡システムをあらかじめフィルタする</title>

<!--
<para>Most issue databases eventually suffer from the same problem: a
crushing load of duplicate or invalid issues filed by well-meaning but
inexperienced or ill-informed users.  The first step in combatting
this trend is usually to put a prominent notice on the front page of
the bug tracker, explaining how to tell if a bug is really a bug, how
to search to see if it's already been filed, and finally, how to
effectively report it if one still thinks it's a new bug.</para>
-->

<para>
    ほとんどのバグ追跡システムは結局同じ課題に悩まされます。
    バグを報告した経験が少なかったり、
    肝心な部分を知らない善意のユーザーが、
    既に報告されている問題やバグではない問題を大量に報告してくるのです。
    この傾向に対処するはじめのステップとして、
    バグ追跡システムのトップページに目立つように注意書きを置いておく方法があります。
    そこで本当にバグかどうかを区別する方法や、
    既に報告されている問題かどうかを検索する方法、
    そして最後に、本当に新規のバグであった場合に効果的に報告する方法を説明しておくのです。
</para>

<!--
<para>This will reduce the noise level for a while, but as the number
of users increases, the problem will eventually come back.  No
individual user can be blamed for it.  Each one is just trying to
contribute to the project's well-being, and even if their first bug
report isn't helpful, you still want to encourage them to stay
involved and file better issues in the future.  In the meantime,
though, the project needs to keep the issue database as free of junk
as possible.</para>
-->

<para>
    こうすることでしばらくは報告されてくる問題のノイズは下げられますが、
    ユーザーが増えてくるにつれてこの課題は結局再燃します。
    このことでユーザーを責めることはできません。
    ひとりひとりのユーザーはただプロジェクトをよくするために貢献しようとしているだけですし、
    たとえ彼らのバグ報告がはじめは役に立たなかったとしても、
    あなたは彼らにひき続きプロジェクトに参加してもらって、
    将来はよりよいバグ報告をして欲しいと思うでしょう。
    しばらくの間は、バグ追跡システムに自由にバグを報告させ続ける必要があります。
</para>

<!--
<para>The two things that will do the most to prevent this problem
are: making sure there are people watching the bug tracker who have
enough knowledge to close issues as invalid or duplicates the moment
they come in, and requiring (or strongly encouraging) users to confirm
their bugs with other people before filing them in the tracker.</para>
-->

<para>
    この課題を避けるために何より実行すべきことがふたつあります。
    バグではない問題や、
    重複したバグ報告を報告されたらすぐに 処理済みとマークできる十分な知識がある人にバグ報告システムを見張ってもらうこと。
    そしてバグ報告システムにバグを報告する前に、
    他の人とバグかどうかを確認するようユーザーに求める（または強く勧める）ことです。
</para>

<!--
<para>The first technique seems to be used universally.  Even projects
with huge issue databases (say, the Debian bug tracker at
<ulink url="http://bugs.debian.org/"/>, which contained 315,929 issues
as of this writing) still arrange things so that
<emphasis>someone</emphasis> sees each issue that comes in.  It may be
a different person depending on the category of the issue.  For
example, the Debian project is a collection of software packages, so
Debian automatically routes each issue to the appropriate package
maintainers.  Of course, users can sometimes misidentify an issue's
category, with the result that the issue is sent to the wrong person
initially, who may then have to reroute it.  However, the important
thing is that the burden is still shared&mdash;whether the user
guesses right or wrong when filing, issue watching is still
distributed more or less evenly among the developers, so each issue is
able to receive a timely response.</para>
-->

<para>
    はじめのテクニックはあらゆるところで使われているようです。
    巨大なバグデータベースを持つ（たとえば <ulink url="http://bugs.debian.org/"/> にある Debian のバグ追跡システムは、執筆時点で 315,929個 のバグ情報があります）プロジェクトでも、バグが報告されるたびに <emphasis>誰かが</emphasis> 見張るようにシステムを改造しています。
    問題のカテゴリによって見張る人は違うかもしれません。
    たとえばDebianプロジェクトはソフトウェアパッケージの集合体なので、
    自動的にそれぞれの問題を適切なパッケージメンテナに転送しています。
    もちろん、ユーザーがときどき問題のカテゴリを誤解することもありえます。
    そういう場合は、そのバグははじめは間違った人に転送されるので、
    転送された人が再度転送し直さなければなりません。
    しかし重要なのは、その負担が共有されているということです
    &mdash; ユーザーがバグを報告するときに正しいか間違っているかを推測しようがすまいが、
    報告されたバグを見張る役目は多かれ少なかれ開発者に分散されています。
    よって問題が報告されるたびに、適切なタイミングで応答できるのです。
</para>

<!--
<para>The second technique is less widespread, probably because it's
harder to automate.  The essential idea is that every new issue gets
"buddied" into the database.  When a user thinks he's found a problem,
he is asked to describe it on one of the mailing lists, or in an IRC
channel, and get confirmation from someone that it is indeed a bug.
Bringing in that second pair of eyes early can prevent a lot of
spurious reports.  Sometimes the second party is able to identify that
the behavior is not a bug, or is fixed in recent releases.  Or she may
be familiar with the symptoms from a previous issue, and can prevent a
duplicate filing by pointing the user to the older issue.  Often it's
enough just to ask the user "Did you search the bug tracker to see if
it's already been reported?"  Many people simply don't think of that,
yet are happy to do the search once they know someone's
<emphasis>expecting</emphasis> them to.</para>
-->

<para>
    ふたつめのテクニックは広く使われているわけではありませんが、
    これはおそらく自動化が難しいからでしょう。
    アイディアの要点は、新しく報告されてくる問題をデータベースに登録する前に、
    "仲間を" 巻き込むことです。
    ユーザーが問題を見つけたと思ったときは、
    メーリングリストかIRCで説明するように求めます。
    そうすることで、誰かが本当にバグかどうかを確認するのです。
    別の人の目に早めに晒すことで、たくさんの間違った報告を避けることができます。
    別の人がその振る舞いはバグではないとわかったり、
    最近のリリースで解決済みだとわかる場合があります。
    または、別の人が以前報告された問題から報告されるバグの兆候に精通しているので、
    古い問題であるとユーザーに指摘することで重複した報告を防ぐことができる場合もあります。
    "既に報告された問題かどうかをバグ追跡システムで検索したかい?"
    とユーザーに聞くだけで十分なこともあります。
    多くの人はそんなことを考えてもいませんが、
    誰かがそうすることを <emphasis>期待している</emphasis> とわかれば、
    喜んで検索するものです。
</para>

<!--
<para>The buddy system can really keep the issue database clean, but
it has some disadvantages too.  Many people will file solo anyway,
either through not seeing, or through disregarding, the instructions
to find a buddy for new issues.  Thus it is still necessary for
volunteers to watch the issue database.  Furthermore, because most new
reporters don't understand how difficult the task of maintaining the
issue database is, it's not fair to chide them too harshly for
ignoring the guidelines.  Thus the volunteers must be vigilant, and
yet exercise restraint in how they bounce unbuddied issues back to
their reporters.  The goal is to train each reporter to use the
buddying system in the future, so that there is an ever-growing pool
of people who understand the issue-filtering system.  On seeing an
unbuddied issue, the ideal steps are:</para>
-->

<para>
    仲間を巻き込む仕組みはバグデータベースをきれいにしてくれますが、
    欠点もいくつかあります。
    多くの人が、新しくバグを報告するときに仲間を見つけなさいという指示を見ないか、
    軽視するかして、結局ひとりでバグ報告をしてしまうことです。
    よって、ボランティアにはやはりバグデータベースを見張ってもらう必要があります。
    さらに、ほとんどの新しい報告者はバグデータベースを維持するのがどれだけ難しいかを知らないので、
    ガイドラインを無視しているからといって厳しく注意するのはフェアではありません。
    よってボランティアは、
    誰にも見てもらっていないバグ報告を報告者にどう差し戻すのかについては、
    用心深く、なおかつ慎重でなければなりません。
    これは、問題をフィルタする仕組みを理解する人々を増やせるように、
    ゆくゆくは仲間を巻き込んでバグ報告をしてもらうことが目的です。
    誰にも見てもらっていないバグ報告を見つけたら、
    とるべき理想的な対処のステップは次のようなものです。
</para>

<orderedlist>
  <listitem>
    <!--
    <para>Immediately respond to the issue, politely thanking the user
          for filing, but pointing them to the buddying guidelines
          (which should, of course, be prominently posted on the web
          site).</para>
    -->
    <para>
    すぐにバグ報告に応答し、
    ユーザーがバグ報告をしてくれたことに丁寧にお礼を言います。
    しかし、バグかどうかを誰かに見てもらうガイドラインがあることを指摘します。（これはもちろん、ウェブサイトに目立つように投稿すべきです）
    </para>
  </listitem>
  <listitem>
    <!--
    <para>If the issue is clearly valid and not a duplicate, approve it
          anyway, and start it down the normal life cycle.  After all,
          the reporter's now been informed about buddying, so there's
          no point wasting the work done so far by closing a valid
          issue.</para>
    -->
    <para>
    報告された問題が明らかに正しいもので重複していない場合は、
    とりあえずそれを受け入れて通常のライフサイクルを開始します。
    結局、報告した人はバグかどうかを誰かに見てもらうべきだと言われているので、
    正しいバグ報告を処理済みにするまで労力を無駄にする点はありません。
    </para>
  </listitem>
  <listitem>
    <!--
    <para>Otherwise, if the issue is not clearly valid, close it, but
          ask the reporter to reopen it if they get confirmation from
          a buddy.   When they do, they should put a reference to the
          confirmation thread (e.g., a URL into the mailing list
          archives).</para>
    -->
    <para>
    そうでない場合、つまり報告された明らかに正しくない場合は処理済みとマークしましょう。
    しかし、報告した人には誰かにバグであるかを確認した上で報告したのなら、再度保留中にして欲しいと伝えます。
    この場合、報告した人は確認をとったスレッドへの参照（e.g. メーリングリストアーカイブへのURLなど）を掲載するはずです。
    </para>
  </listitem>
</orderedlist>

<!--
<para>Remember that although this system will improve the signal/noise
ratio in the issue database over time, it will never completely stop
the misfilings.  The only way to prevent misfilings entirely is to
close off the bug tracker to everyone but developers&mdash;a cure that
is almost always worse than the disease.  It's better to accept that
cleaning out invalid issues will always be part of the project's
routine maintenance, and to try to get as many people as possible to
help.</para>
-->

<para>
    この方法はいずれバグ追跡システムの S/N比を改善してくれるでしょう。
    しかし、間違ったバグ報告は決してなくならないことを覚えておいてください。
    間違ったバグ報告を根絶する唯一の方法は、
    開発者以外の人にはバグ追跡システムを使わせないことです &mdash;
    しかし、この方法でよい結果が出ることはほとんどありません。
    間違ったバグ報告を取り除くことがプロジェクトのルーチンワークであることを受け入れ、
    できるだけ多くの人達の助けを得ようとした方がよいでしょう。
</para>

<para><phrase output="printed"><xref linkend="managing-volunteers"/> の </phrase><xref linkend="issue-manager"/> も参照してください。</para>

</sect2>

</sect1>

<!-- ========================== SECTION =========================== -->
<sect1 id="irc">
<title>IRC / リアルタイムに行なわれるチャットシステム</title>

<!--
<para>Many projects offer real-time chat rooms using <firstterm>Internet
Relay Chat</firstterm> (<firstterm>IRC</firstterm>), forums where users
and developers can ask each other questions and get instant responses.
While you <emphasis>can</emphasis> run an IRC server from your own
web site, it is generally not worth the hassle.  Instead, do what
everyone else does: run your IRC channels at Freenode
(<ulink url="http://freenode.net/"/>).  Freenode gives you the control
you need to administer your project's IRC
channels,<footnote><para>There is no requirement or expectation that
you donate to Freenode, but if you or your project can afford it,
please consider a contribution.  They are a tax-exempt charity in the
U.S., and they perform a valuable service.</para></footnote> while
sparing you the not-insignificant trouble of maintaining an IRC server
yourself.</para>
-->

<para>
    多くのプロジェクトでは、<firstterm>Internet Relay Chat</firstterm> (<firstterm>IRC</firstterm>) を使ったリアルタイムのチャットルームを提供しています。
    そこではユーザーと開発者が質問を出し合い、すぐに返事を貰うことができます。
    自前のIRCサーバを動かすことも <emphasis>可能です</emphasis> が、
    普通はそこまで頑張る必要はありません。むしろみんながやっていることを真似てみましょう。
    つまり、Freenode (<ulink url="http://freenode.net/"/>) で自分のIRCチャンネルを開設するのです。
    Freenodeは、IRCサーバを自分で管理する苦労からあなたを解放すると同時に、
    <footnote><para>Freenode への寄付を要求されたり、
    期待されたりすることはありませんが、
    あなた個人やプロジェクトに余裕があるなら寄付することを考えてみてください。
    アメリカ国内からだと税金が控除される寄付金として扱われますし、
    寄付されたお金を使って価値のあるサービスが提供されるのです。</para></footnote>
    プロジェクトのIRCチャンネルを管理するために必要な規制を行っています。
</para>

<!--
<para>The first thing to do is choose a channel name.  The most
obvious choice is the name of your project&mdash;if that's available
at Freenode, then use it.  If not, try to choose something as close to
your project's name, and as easy to remember, as possible.  Advertise
the channel's availabity from your project's web site, so a visitor
with a quick question will see it right away.  For example, this
appears in a prominently placed box at the top of Subversion's home
page:</para>
-->

<para>
    まずやるべきことはチャンネルの名前を決めることです。
    もっともわかりやすいのはプロジェクトの名前です。
    &mdash; Freenode で使える名前なら使ってください。
    もし使えないのなら、
    プロジェクトの名前に近い名前で、
    できるだけ覚えやすい名前を選ぶようにしてみてください。
    質問に素早く答えて欲しいユーザーがすぐにわかるように、
    プロジェクトのウェブサイトでIRCチャンネルが利用できることを知らせましょう。
    たとえばSubversion のホームページでは、
    ページ上部の目立つボックス部分に次のような情報を表示しています。
</para>

<!--
  <blockquote>
    <para><emphasis>If you're using Subversion, we recommend that you
    join the</emphasis> <literal>users@subversion.tigris.org</literal>
    <emphasis>mailing list, and read the <ulink
    url="http://svnbook.red-bean.com/">Subversion Book</ulink> and
    <ulink
    url="http://subversion.tigris.org/faq.html">FAQ</ulink>.
    You can also ask questions on IRC at</emphasis>
    <literal>irc.freenode.net</literal>
    <emphasis>channel</emphasis>&nbsp;<literal>#svn</literal>.</para>
  </blockquote>
-->

  <blockquote>
    <para>
        <emphasis>Subversionをお使いなら、メーリングリスト</emphasis>
        <literal>users@subversion.tigris.org</literal>
        <emphasis>を購読し、
        <ulink url="http://svnbook.red-bean.com/index.ja.html">Subversionによるバージョン管理</ulink> と 
        <ulink url="http://subversion.tigris.org/faq.html">FAQ</ulink>
        を読むことを勧めます。</emphasis> 
        <emphasis>IRCの</emphasis>
        <literal>irc.freenode.net</literal>
        <emphasis>上のチャンネル</emphasis>
        &nbsp;<literal>#svn</literal>&nbsp;
        <emphasis>でも質問することができます。</emphasis>
    </para>
  </blockquote>

<!--
<para>Some projects have multiple channels, one per subtopic.  For
example, one channel for installation problems, another for usage
questions, another for development chat, etc. (<xref
linkend="growth"/><phrase output="printed"> in
<xref linkend="communications"/></phrase> discusses and how to
divide into multiple channels).  When your project is young, there
should only be one channel, with everyone talking together.  Later, as
the user-to-developer ratio increases, separate channels may become
necessary.</para>
-->

<para>
    プロジェクトによっては複数のチャンネルを持つものもあり、
    ひとつひとつが副次的なトピックを扱っています。
    たとえばあるチャンネルはインストール時の問題を扱い、
    別のチャンネルでは使い方の問題、開発に関するチャット、等です。
    (<phrase output="printed"><xref linkend="communications"/> の <xref linkend="growth"/> では</phrase>、チャンネルを複数に分割する方法について議論しています。)
    プロジェクトが始まって間もないなら、皆が一緒にお喋りできるようにチャンネルの数はひとつにすべきでしょう。
    後に開発者ひとりに対するユーザーの数が増えるのに応じて、
    チャンネルの分割が必要になるかもしれません。
</para>

<!--
<para>How will people know all the available channels, let alone which
channel to talk in?  And when they talk, how will they know what the
local conventions are?</para>
-->

<para>
    どのチャンネルで喋ればよいかは言うまでもなく、
    利用できる全てのチャンネルを知らせるにはどうしたらよいでしょうか?
    そしてチャットをするとき、
    プロジェクトに特有の決まりごとを知らせるにはどうすればよいでしょうか?
</para>
    
<!--
<para>The answer is to tell them by setting the <firstterm>channel
topic</firstterm>.<footnote><para>To set a channel topic, use the
<literal>/topic</literal> command.  All commands in IRC start with
"<literal>/</literal>".  See <ulink url="http://www.irchelp.org/"/> if
you're not familiar with IRC usage and administration; in particular,
<ulink url="http://www.irchelp.org/irchelp/irctutorial.html"/> is an
excellent tutorial.</para></footnote>  The channel topic is a brief
message each user sees when they first enter the channel.  It gives
quick guidance to newcomers, and pointers to further information.  For
example:</para>
-->

<para>
    答えは <firstterm>チャンネルトピック</firstterm>
    <footnote><para>
    チャンネルトピックを設定するには <literal>/topic</literal> コマンドを使います。
    IRCコマンドは全て "<literal>/</literal>" で始まります。
    IRCの使い方やチャンネルの管理に慣れていないのであれば、
    <ulink url="http://www.irchelp.org/"/> を参照してください。:
    特に <ulink url="http://www.irchelp.org/irchelp/irctutorial.html"/> は優れたチュートリアルです。
    </para></footnote>
    を設定して知らせることです。
    チャンネルトピックは、初めてチャンネルに入ったときにユーザーが見るメッセージです。
    これは新顔のユーザーに簡単な案内をすると同時に、
    さらに詳しい情報へのポインタを提供します。
    たとえば以下のようなものです。:
</para>

<!--
<screen>
You are now talking on #svn

Topic for #svn is Forum for Subversion user questions, see also
http://subversion.tigris.org/. || Development discussion happens in
#svn-dev. || Please don't paste long transcripts here, instead use
a pastebin site like http://pastebin.ca/. || NEWS: Subversion 1.1.0
is released, see http://svn110.notlong.com/ for details.
</screen>
-->

<screen>
あなたは #svn で喋っています。

#svn のトピックは以下の通りです。Subversionユーザーの質問を受け付ける
フォーラムです。http://subversion.tigris.org も参照してください。 || 
開発に関する議論は、#svn-dev で行われています。 || 長い Subversion の
トランザクションを貼り付けないでください。http://pastebin.ca/ のような
貼り付け用のサイトを使ってください。 || ニュース: Subversion 1.1.0 が
リリースされました。詳しくは http://svn110.notlong.com/ を参照してくだ
さい。
</screen>

<!--
<para>That's terse, but it tells newcomers what they need to know.  It
says exactly what the channel is for, gives the project home page (in
case someone wanders into the channel without having first been to the
project web site), mentions a related channel, and gives some guidance
about pasting.</para>
-->

<para>
    これは簡単ですが、新顔のユーザーが知る必要がある情報を伝えています。
    チャンネルの目的を正確に伝え、
    プロジェクトのホームページを示し(ユーザーによっては、
    プロジェクトのウェブサイトを訪れたことがないとチャンネル内で迷子になってしまいます。)
    関連するチャンネルに言及し、貼り付けに関する案内もあります。
</para>

<sidebar id="paste-sites">
<title>貼り付け用のサイト</title>

<!--
<para>An IRC channel is a shared space: everyone can see what everyone
else is saying.  Normally, this is a good thing, as it allows people
to jump into a conversation when they think they have something to
contribute, and allows spectators to learn by watching.  But it
becomes problematic when someone has to provide a large quantity of
information at once, such as a debugging session transcript, because
pasting too many lines of output into the channel will disrupt other
conversations.</para>
-->

<para>
    IRCチャンネルは共有スペースです。誰でも他人の発言を見ることができます。
    これは貢献したいと思うときに会話に割って入れますし、
    他のメンバはやりとりを見て学ぶことができるので普段はよい状態です。
    しかしデバッグセッションのコピーのように、
    大量の情報を一度に流さなければならない場合は問題になります。
    なぜなら、チャンネルにあまりに多くの行を貼り付けると他の会話をぶち壊してしまうからです。
</para>

<!--
<para>The solution is to use one of the
<firstterm>pastebin</firstterm> or <firstterm>pastebot</firstterm>
sites.  When requesting a large amount of data from someone, ask them
not to paste it into the channel, but instead to go to (for example)
<ulink url="http://pastebin.ca/"/>, paste their data into the form
there, and tell the resulting new URL to the IRC channel.  Anyone can
then visit the URL and view the data.</para>
-->

<para>
    こうした問題の解決策は、
    <firstterm>ペーストビン</firstterm> または <firstterm>ペーストボット</firstterm> サイトを使うことです。
    大量のデータを他人から見てほしいと頼まれる時は、
    チャンネルに貼り付けないで、
    (たとえば) <ulink url="http://pastebin.ca/"/> に行き、
    フォームにデータを入力して生成されたURLをチャンネルに伝えるように頼みましょう。
    そうすれば、そのURLを誰でも訪れてデータを見ることができます。
</para>

<!--
<para>There are a number of free paste sites available now, too many
for a comprehensive list, but here are some of the ones I've seen used:
<ulink url="http://www.nomorepasting.com/"/>,
<ulink url="http://pastebin.ca/"/>,
<ulink url="http://nopaste.php.cd/"/>
<ulink url="http://rafb.net/paste/"/>
<ulink url="http://sourcepost.sytes.net/"/>,
<ulink url="http://extraball.sunsite.dk/notepad.php"/>,
and
<ulink url="http://www.pastebin.com/"/>.</para>
-->

<para>
    今ではたくさんの貼り付けサイトが無料で利用できますし、
    まとめて示すには数が多すぎますが、
    私が使われているのを見たことがあるサイトをいくつか以下に示します:
<ulink url="http://www.nomorepasting.com/"/>,
<ulink url="http://pastebin.ca/"/>,
<ulink url="http://nopaste.php.cd/"/>,
<ulink url="http://rafb.net/paste/"/>,
<ulink url="http://sourcepost.sytes.net/"/>,
<ulink url="http://extraball.sunsite.dk/notepad.php"/>,
<ulink url="http://www.pastebin.com/"/></para>
</sidebar>

<sect2 id="bots">
<title>ボット</title>

<!--
<para>Many technically-oriented IRC channels have a non-human member,
a so-called <firstterm>bot</firstterm>, that is capable of storing and
regurgitating information in response to specific commands.
Typically, the bot is addressed just like any other member of the
channel, that is, the commands are delivered by "speaking to" the bot.
For example:</para>
-->

<para>
    多くの技術指向なIRCチャンネルには、
    いわゆる <firstterm>ボット</firstterm> と呼ばれる人間でないメンバーがいます。
    これは特定のコマンドに反応して情報を保存したり、
    表示したりできます。
    通常は、ボットはチャンネルにいる他のメンバーと同じように扱います。
    つまり、コマンドはボットに "話しかける" ことで伝えます。
    たとえば次のようなものです :
</para>

<screen>
&lt;kfogel&gt; ayita: learn diff-cmd = http://subversion.tigris.org/faq.html#diff-cmd
&lt;ayita&gt;  Thanks!
</screen>

<!--
<para>That told the bot (who is logged into the channel as ayita) to
remember a certain URL as the answer to the query "diff-cmd".  Now we
can address ayita, asking the bot to tell another user about
diff-cmd:</para>
-->

<para>
    これはボット(ayita としてチャンネルにログインしています)に "diff-cmd" という問い合わせの答えとしてあるURLを覚えておくように伝えています。
    では、ayita に話しかけて、他のユーザーに diff-cmd に関する情報を伝えるように頼んでみましょう :
</para>
<screen>
&lt;kfogel&gt; ayita: tell jrandom about diff-cmd
&lt;ayita&gt;  jrandom: http://subversion.tigris.org/faq.html#diff-cmd
</screen>

<!--
<para>The same thing can be accomplished via a convenient shorthand:</para>
-->

<para>
    便利な短縮コマンドを使っても同じことが実現できます。
</para>

<screen>
&lt;kfogel&gt; !a jrandom diff-cmd
&lt;ayita&gt;  jrandom: http://subversion.tigris.org/faq.html#diff-cmd
</screen>

<!--
<para>The exact command set and behaviors differ from bot to bot.  The
above example is with <literal>ayita</literal>
(<ulink url="http://hix.nu/svn-public/alexis/trunk/"/>), of which
there is usually an instance running in <literal>#svn</literal> at
freenode.  Other bots include Dancer
(<ulink url="http://dancer.sourceforge.net/"/>) and Supybot
(<ulink url="http://supybot.com/"/>).  Note that no special server
privileges are required to run a bot.  A bot is a client program;
anyone can set one up and direct it to listen to a particular
server/channel.</para>
-->

<para>
    正確なコマンドとそれに対する振舞いはボットによって異なります。
    上の例は Freenode の <literal>#svn</literal> で通常動いている <literal>ayita</literal>(<ulink url="http://hix.nu/svn-public/alexis/trunk/"/>) のものです。
    他にも Dancer(<ulink url="http://dancer.sourceforge.net/"/>) や Supybot(<ulink url="http://supybot.com/"/>) といったボットがいます。
    ボットを動かすのに特別なIRCサーバ上の権限は必要ないということを覚えておいてください。
    ボットはクライアントプログラムなので、誰でもセットアップして特定の IRCサーバ/チャンネル 上で待機させることができます。
</para>

<!--
<para>If your channel tends to get the same questions over and over,
I highly recommend setting up a bot.  Only a small percentage of
channel users will acquire the expertise needed to manipulate the bot,
but those users will answer a disproportionately high percentage of
questions, because the bot enables them to respond so much more
efficiently.</para>
-->

<para>
    あなたのチャンネルで同じ質問が繰り返される傾向があるなら、
    ボットをセットアップすることを強くお勧めします。
    ボットの操作方法を身に付けるのはほんの一握りのメンバですが、
    ボットが効率的に反応してくれるので、
    少ない人数で繰り返される質問に答えられるのです。
</para>

</sect2>

<sect2 id="irc-archiving">
<title>IRCの会話を保存する</title>

<!--
<para>Although it is possible to archive everything that happens in an
IRC channel, it's not necessarily expected.  IRC conversations may be
nominally public, but many people think of them as informal,
semi-private conversations.  Users may be careless with grammar, and
often express opinions (for example, about other software or other
programmers) that they wouldn't want preserved forever in an online
archive.</para>
-->

<para>
    IRCチャンネルで起こったことは全て保存できますが、
    必ずしもそれが期待されているわけではありません。
    IRCでの会話は建前上は公なものかもしれませんが、
    非公式なもの、もしくは半ばプライベートな会話だと考える人も多くいます。
    IRC上ではユーザーは文法に無頓着ですし、
    オンライン上で絶対に保存されたくない意見(たとえば、
    他のソフトウェアやプログラマーに関するもの)を言ったりするかもしれません。
</para>

<!--
<para>Of course, there will sometimes be <emphasis>excerpts</emphasis>
that should be preserved, and that's fine.  Most IRC clients can log a
conversation to a file at the user's request, or failing that, one can
always just cut and paste the conversation from IRC into a more
permanent forum (most often the bug tracker).  But indiscriminate
logging may make some users uneasy.  If you do archive everything,
make sure you state so clearly in the channel topic, and give a URL to
the archive.</para>
-->

<para>
    もちろん、<emphasis>会話のまとめ</emphasis> を保存すべき時もあるでしょう。
    その場合はよいのです。
    ほとんどのIRCクライアントはユーザーの要求に応じて会話を保存することが出来ますし、
    それができなくても会話をフォーラム(ほとんどの場合はバグ追跡システム)に貼り付けるだけならいつでもできます。
    しかし、節操なく会話を保存すると不安になるユーザーもいるかもしれません。
    全ての会話を保存するのなら、必ずその旨をチャンネルトピックで明示的に宣言し、保存先のURLを示すようにしましょう。
</para>

</sect2>

</sect1>

<!-- ========================== SECTION =========================== -->
<sect1 id="rss">
<title>RSS フィード</title>

<!--
<para><firstterm>RSS</firstterm> (Really Simple Syndication) is a
mechanism for distributing meta-data-rich news summaries to
"subscribers", that is, people who have indicated an interest in
receiving those summaries.  A given RSS source is usually called
a <firstterm>feed</firstterm>, and the user's subscription interface
is called a <firstterm>feed reader</firstterm> or <firstterm>feed
aggregator</firstterm>.  <ulink url="http://www.rssbandit.org/">RSS
Bandit</ulink> and the eponymous
<ulink url="http://www.feedreader.com/">Feedreader</ulink> are two
open source RSS readers, for example.</para>
-->
<para>
  <firstterm>RSS</firstterm> (Really Simple Syndication)
  は、ニュースの概要を表すメタデータを "購読者" に配信するための仕組みです。
  "購読者" とは、その概要を受信したいという意思を示した人たちのことです。
  RSS ソースのことを通常は <firstterm>フィード</firstterm> と呼びます。
  また、ユーザーがフィードを購読するインターフェイスのことを
  <firstterm>フィードリーダー</firstterm> や
  <firstterm>フィードアグリゲータ</firstterm> などといいます。
  オープンソースの RSS リーダーとしては、たとえば
  <ulink url="http://www.rssbandit.org/">RSS Bandit</ulink> や、
  そのまんまの名前である <ulink url="http://www.feedreader.com/">Feedreader</ulink>
  などがあります。
</para>

<!--
<para>There is not space here for a detailed technical explanation of
RSS<footnote><para>See
<ulink url="http://www.xml.com/pub/a/2002/12/18/dive-into-xml.html"/>
for that.</para></footnote>, but you should be aware of two main
things.  First, the feed reading software is chosen by the subscriber
and is <emphasis>the same</emphasis> for all the feeds that subscriber
monitors&nbsp;&mdash;&nbsp;in fact, this is the major selling point of
RSS: that the subscriber chooses one interface to use for all their
feeds, so each feed can concentrate just on delivering content.
Second, RSS is now ubiquitous, so much so that most people who use it
don't even know they're using it.  To the world at large, RSS looks
like a little button on a web page, with a label saying "Subscribe to
this site" or "News feed".  You click on the button, and from then on,
your feed reader (which may well be an applet embedded in your home
page) automatically updates whenever there's news from the
site.</para>
-->
<para>
  ここでは、RSS についての技術的な詳細を説明することは控えます
  <footnote>
    <para>
      詳細は
      <ulink url="http://www.xml.com/pub/a/2002/12/18/dive-into-xml.html"/>
      をご覧ください。
    </para>
  </footnote>が、次のふたつはしっかり覚えておきましょう。
  まず、購読者がフィードリーダーを使用すると、購読しているフィードを
  <emphasis>同じように</emphasis> 扱えるようになります。
  これが RSS のセールスポイントのひとつです。
  何かひとつのインターフェイスを選択すれば、
  すべてのフィードが同じインターフェイスで使用でき、
  配信される内容に集中することができるというわけです。
  次に、RSS は今やあらゆるところで利用されており、
  ほとんどの人は知らず知らずのうちにそれを使用しているということです。
  世間一般の人たちにとっては、RSS というのはウェブページ上の
  "このサイトを購読" とか "ニュースフィード" とか言うちっちゃなボタンのことです。
  そのボタンをクリックすれば、フィードリーダー
  (ホームページに埋め込まれているアプレットかもしれません)
  は自動的にそのサイトのニュースの更新情報を取得してくれます。
</para>

<!--
<para>This means that your open source project should probably offer
an RSS feed (note that many of the canned hosting
sites&nbsp;&mdash;&nbsp;see
<xref linkend="canned-hosting"/>&nbsp;&mdash;&nbsp;offer it right out
of the box).  Be careful not to post so many news items each day that
subscribers can't separate the wheat from the chaff.  If there are too
many news events, people will just ignore the feed, or even
unsubscribe in exasperation.  Ideally, a project would offer separate
feeds, one for big announcements, another following (say) events in
the issue tracker, another for each mailing list, etc.  In practice,
this is hard to do well: it can result in interface confusion both for
visitors to the project's web site and for the administrators.  But at
a minimum, the project should offer one RSS feed on the front page,
for sending out major announcements such as releases and security
alerts.<footnote><para>Credit where credit is due: this section wasn't
in the first published edition of the book, but Brian Aker's blog
entry
<ulink url="http://krow.livejournal.com/564980.html">"Release Criteria,
Open Source, Thoughts On..."</ulink> reminded me of the usefulness of
RSS feeds for open source projects.</para></footnote></para>
-->
<para>
  これらを踏まえると、あなたが運営するオープンソースプロジェクトでもおそらく
  RSS フィードを提供しなければならなくなるでしょう
  (あらかじめ用意されているホスティングサイト
  &nbsp;&mdash;&nbsp;<xref linkend="canned-hosting"/>
  を参照ください&nbsp;&mdash;&nbsp;の多くは、この機能を持っています)。
  一日になんどもニュースを投稿してしまわないように注意しましょう。
  そんなことをしたら、購読者たちは
  どれが本当に大切なニュースなのかを判断できなくなってしまいます。
  あまりにも大量のニュースが投稿されると、
  そのフィードを無視されてしまったり、
  あるいは腹が立ってそのフィードの購読をやめてしまうかもしれません。
  理想を言えば、用途に応じて個別のフィードを提供するのがいいでしょう。
  大事な告知用のフィード、たとえばバグ追跡システム用のフィード、
  メーリングリストの投稿用のフィードなとといった具合です。
  とは言え、実際にこれをするのは大変です。
  プロジェクトのウェブサイトを訪れる人たちにとっても、
  プロジェクトの管理者にとっても、
  何をどうしたらいいのか混乱してしまうことでしょう。
  しかし、少なくともプロジェクトのトップページには RSS フィードを提供するようにしましょう。
  このフィードでは、リリース情報やセキュリティ警告といった重要な告知を配信します。
  <footnote>
    <para>
      このセクションは、書籍として出版された初版には存在しません。
      Brian Aker のブログのエントリ
      <ulink url="http://krow.livejournal.com/564980.html">"Release Criteria, Open Source, Thoughts On..."</ulink>
      を読んで、オープンソースプロジェクトにおける RSS フィードの有用性に気づいたので追記しました。
    </para>
  </footnote>
</para>

</sect1>

<!-- ========================== SECTION =========================== -->
<sect1 id="wikis">
<title>Wiki</title>

<!--
<para>A <firstterm>wiki</firstterm> is a web site that allows any
visitor to edit or extend its content; the term "wiki" (from a
Hawaiian word meaning "quick" or "super-fast") is also used to refer
to the software that enables such editing.  Wikis were invented in
1995, but their popularity has really started to take off since 2000
or 2001, boosted partly by the success of Wikipedia (<ulink
url="http://www.wikipedia.org/"/>), a wiki-based free-content
encyclopedia.  Think of a wiki as falling somewhere between IRC and
web pages: wikis don't happen in realtime, so people get a chance to
ponder and polish their contributions, but they are also very easy to
add to, involving less interface overhead than editing a regular web
page.</para>
-->

<para>
    <firstterm>wiki</firstterm> とは、
    訪れた人が誰でもコンテンツを編集し、
    拡張できるウェブサイトのことです。
    "wiki" (ハワイ語で "素早い" とか "超高速の"という意味です）という用語は、
    ウェブサイトの編集ができるソフトウェアを指すものとしても使われています。
    wiki は1995年に発明されましたが、
    2000年か2001年に人気が出て、
    wiki ベースな無料の百科事典である Wikipedia(<ulink url="http://www.wikipedia.org/"/>) の成功がそれを後押ししました。
    wiki は、IRCとウェブサイトの中間的なものと考えればよいでしょう。
    wiki は即時性がないので、
    自分が更新する内容について推敲することができます。
    それでいて更新も非常に簡単なので、通常のウェブサイトを編集するのに比べて、
    HTMLに悩む負担が小さくなっています。
</para>

<!--
<para>Wikis are not yet standard equipment for open source projects,
but they probably will be soon.  As they are relatively new
technology, and people are still experimenting with different ways of
using them, I will just offer a few words of caution here&mdash;at
this stage, it's easier to analyze misuses of wikis than to analyze
their successes.</para>
-->

<para>
    wiki はまだオープンソースプロジェクトで標準的なツールになっているわけではありませんが、
    多分すぐにそうなるでしょう。
    wikiは比較的新しい技術ですし、
    人々は wiki をいろいろなやり方でまだ試しているところです。
    よって&mdash;今の段階では、
    2,3警告をするだけにしておいて、
    wiki の成功を分析するよりは、
    wiki の間違った使い方を分析する方がわかりやすいでしょう。
</para>

<!--
<para>If you decide to run a wiki, put a lot of effort into having a
clear page organization and pleasing visual layout, so that visitors
(i.e., potential editors) will instinctively know how to fit in their
contributions.  Equally important, post those standards on the wiki
itself, so people have somewhere to go for guidance.  Too often, wiki
administrators fall victim to the fantasy that because hordes of
visitors are individually adding high quality content to the site,
the sum of all these contributions must therefore also be of high
quality.  That's not how web sites work.  Each individual page or
paragraph may be good when considered by itself, but it will not be
good if embedded in a disorganized or confusing whole.  Too often,
wikis suffer from:</para>
-->

<para>
    wiki を使おうと決めたら、
    見通しの良いサイト構成にすることと、
    魅力的な見た目になるように特に力を注ぎましょう。
    これは訪問者（i.e. 編集する可能性がある人でもあります）が無意識にどのように編集したらよいかがわかるようにするためです。
    同じく重要なのは、
    人々を誘導できるように、
    こうした見た目やサイト構成に関する基準を wiki に投稿しておくことです。
    よくあるのは、
    wiki の管理者が、
    「多くの訪問者が高い品質のコンテンツを個別に追加してくれているんだから、
    こうした更新が集まったウェブサイト全体も高い品質であるに違いない」という幻想に堕ちてしまうことです。
    多く更新されているからといって、
    ウェブサイトがうまく機能するわけではありません。
    個々のページや段落は、
    それ自体素晴らしいものかもしれませんが、
    全体が混乱したり、
    まとまっていないウェブサイトに紛れ込んでしまうと、そうではなくなるでしょう。
    wiki を使うと、
    次のような事態によく悩まされます。
</para>

<!--
<itemizedlist>
  <listitem>
     <para><emphasis role="bold">Lack of navigational principles.</emphasis>
     A well-organized web site makes visitors feel like they know
     where they are at any time.  For example, if the pages are
     well-designed, people can intuitively tell the difference
     between a "table of contents" region and a "content" region.
     Contributors to a wiki will respect such differences too, but
     only if the differences are present to begin with.</para>
  </listitem>
  <listitem>
     <para><emphasis role="bold">Duplication of information.</emphasis>
     Wikis frequently end up with different pages saying similar
     things, because the individual contributors did not notice the
     duplications.  This can be partly a consequence of the lack of
     navigational principles noted above, in that people may not find
     the duplicate content if it is not where they expect it to
     be.</para>
  </listitem>
  <listitem>
     <para><emphasis role="bold">Inconsistent target audience.</emphasis>
     To some degree this problem is inevitable when there are so many
     authors, but it can be lessened if there are written guidelines
     about how to create new content.  It also helps to aggressively
     edit new contributions at the beginning, as an example, so that
     the standards start to sink in.</para>
  </listitem>
</itemizedlist>
-->

<itemizedlist>
  <listitem>
     <para>
     <emphasis role="bold">読者を誘導するルールが欠けている</emphasis>
     うまく構成されたウェブサイトは、
     訪問者がいつでもサイト内のどこにいるかをわかるようにしています。
     例えば、ページがうまく設計されていると、
     訪問者は"目次"の部分と、"内容"の部分を直感的に区別できます。
     wikiのページを更新する人も、
     はじめからそういった区別がされていれば、それを尊重することでしょう。
     </para>
  </listitem>
  <listitem>
     <para>
     <emphasis role="bold">情報が重複している</emphasis>
     wikiでは、更新を行なう個々の人達が、
     情報が重複しているかを気にしないので、
     似たようなことを述べている異なったページが複数存在することがよくあります。
     これは、上で述べた読者を誘導するルールが欠けていることとも重なる部分がありますが、
     情報が重複していると、
     訪問者は自分が期待するコンテンツのありかを見つけられないかもしれません。</para>
  </listitem>
  <listitem>
     <para>
     <emphasis role="bold">対象読者が決まっていない</emphasis>
     これは、更新を行なう人が多くいる場合にはある程度避けられない問題です。
     しかし、コンテンツを追加する方法の指針があれば、
     この問題で苦しむ可能性は少なくなるかもしれません。
     また、更新に関する指針が根付くように、
     はじめから例としてコンテンツをたくさん追加しておくのもよいでしょう。
     </para>
  </listitem>
</itemizedlist>

<!--
<para>The common solution to all these problems is the same: have
editorial standards, and demonstrate them not only by posting them,
but by editing pages to adhere to them.  In general, wikis will
amplify any failings in their original material, since contributors
imitate whatever patterns they see in front of them.  Don't just
set up the wiki and hope everything falls into place.  You must also
prime it with well-written content, so people have a template to
follow.</para>
-->

<para>
    こうした問題に対する共通の解は同じです。: 編集に関する指針を作り、
    その指針を wiki に投稿するだけではなく、
    それに従ってページを編集することです。
    一般に wiki は、更新する人が自分が見るページのあらゆる傾向を真似てしまうため、
    もともと存在するページのあらゆる不備が全体に伝染してしまいがちです。
    wiki をただセットアップするだけで、全てうまくいくと期待しないでください。
    まずは、人々を誘導するテンプレートとなるように、
    よく練られたコンテンツを置いておかなければならないのです。
</para>

<!--
<para>The shining example of a well-run wiki is Wikipedia, though this
may be partly 
because the content (encyclopedia entries) is naturally well-suited to
the wiki format.  But if you examine Wikipedia closely, you'll see
that its administrators laid a <emphasis>very</emphasis> thorough
foundation for cooperation.  There is extensive documentation on how
to write new entries, how to maintain an appropriate point of view,
what sorts of edits to make, what edits to avoid, a dispute resolution
process for contested edits (involving several stages, including
eventual arbitration), and so forth.  They also have authorization
controls, so that if a page is the target of repeated inappropriate
edits, they can lock it down until the problem is resolved.  In other
words, they didn't just throw some templates onto a web site and hope
for the best.  Wikipedia works because its founders thought carefully
about how to get thousands of strangers to tailor their writing to a
common vision.  While you may not need the same level of preparedness
to run a wiki for a free software project, the spirit is worth
emulating.</para>
-->

<para>
    うまくいっている wiki の良い例は Wikipedia ですが、これは、
    （百科事典の項目という）内容が本来 wiki のフォーマットとよく合っているからというのが理由のひとつです。
    しかし、Wikipedia をよく調べてみると、
    管理者達が  お互いが協力するために<emphasis>とても</emphasis>周到に準備をしていることがわかるでしょう。
    新しい項目を追加する方法、適切な観点で編集する方法、どのような編集を行なうべきか、避けるべきか、
    編集合戦にまつわる論争を解決するプロセス（ある段階では、最終的な調停も含みます）、
    などにまつわる外部文書が存在します。
    管理者達は、繰り返し不適切に編集されたページがあった場合に、
    問題が解決されるまでそれをロックできるようアクセス制御も行なっています。
    言い換えれば、彼らはウェブサイトにページの雛形を書き込むだけで、
    うまくいくと思っていたわけではないということです。
    Wikipedia は、創始者達が、どうしたら何千ものどこの馬の骨ともわからない人たちに、
    中立的な観点で記事を書かせることができるかを注意深く考えたからこそうまくいっているのです。
    フリーソフトウェアのプロジェクトで wiki を使うのに、これと同じくらい周到になる必要はないかもしれませんが、
    その精神は真似る価値があります。
</para>

<!--
<para>For more information about wikis, see
<ulink url="http://en.wikipedia.org/wiki/Wiki"/>.  Also, the first
wiki remains alive and well, and contains a lot of discussion about
running wikis: see <ulink
url="http://www.c2.com/cgi/wiki?WelcomeVisitors"/>, 
<ulink url="http://www.c2.com/cgi/wiki?WhyWikiWorks"/>, and
<ulink url="http://www.c2.com/cgi/wiki?WhyWikiWorksNot"/> for
various points of view.</para>
-->

<para>
    wikiに関するさらに詳しい情報は、<ulink url="http://en.wikipedia.org/wiki/Wiki"/> を参照してください。
    また、世界で最初のwikiはまだ健在で、wikiの運用に関する多くの議論が含まれています。
    : 様々な観点から、<ulink url="http://www.c2.com/cgi/wiki?WelcomeVisitors"/>,
    <ulink url="http://www.c2.com/cgi/wiki?WhyWikiWorks"/>, そして
    <ulink url="http://www.c2.com/cgi/wiki?WhyWikiWorksNot"/> を参照してみてください。
</para>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="web-site">
<title>ウェブサイト</title>

<!--
<para>There is not much to say about setting up the project web site
from a technical point of view: setting up a web server and writing
web pages are fairly simple tasks, and most of the important things to
say about layout and arrangement were covered in the previous chapter.
The web site's main function is to present a clear and welcoming
overview of the project, and to bind together the other tools (the
version control system, bug tracker, etc.).  If you don't have the
expertise to set up a web server yourself, it's usually not hard to
find someone who does and is willing to help out.  Nonetheless, to
save time and effort, people often prefer to use one of the canned
hosting sites.</para>
-->

<para>
    技術的な観点からプロジェクトのウェブサイトを立ち上げることについては、
    それほど語ることはありません。ウェブサーバを起動し、
    ウェブページを書くことはかなり単純な仕事ですし、
    ページの配置や設計に関して重要なことはほとんど以前の章で述べました。
    ウェブサイトの主な機能は、明快にプロジェクトの概要を提供し、
    (バージョン管理システム, バグ追跡システムなどの)他のツールをウェブサイトと結びつけることです。
    たとえあなたにウェブサーバを設定して起動する技量がなくても、
    その作業を喜んでやってくれる人を探すことは普通難しくありません。
    とはいえ、時間と労力を節約するために、
    プロジェクトを運営するためのツールが一通り揃っているホスティングサイトがよく好んで使われます。
</para>

<sect2 id="canned-hosting">

<!--
<title>Canned Hosting</title>

<para>There are two main advantages to using a canned site.  The first
is server capacity and bandwidth: their servers are beefy boxes sitting
on really fat pipes.  No matter how successful your project gets,
you're not going to run out of disk space or swamp the network
connection.  The second advantage is simplicity.  They have already
chosen a bug tracker, a version control system, a mailing list manager,
an archiver, and everything else you need to run a site.  They've
configured the tools, and are taking care of backups for all the data
stored in the tools.  You don't need to make many decisions.  All you
have to do is fill in a form, press a button, and suddenly you've got
a project web site.</para>
-->

<title>ツールが一通り揃ったホスティングサイト</title>

<!--
<para>There are two main advantages to using a canned site.  The first
is server capacity and bandwidth: their servers are beefy boxes sitting
on really fat pipes.  No matter how successful your project gets,
you're not going to run out of disk space or swamp the network
connection.  The second advantage is simplicity.  They have already
chosen a bug tracker, a version control system, a mailing list manager,
an archiver, and everything else you need to run a site.  They've
configured the tools, and are taking care of backups for all the data
stored in the tools.  You don't need to make many decisions.  All you
have to do is fill in a form, press a button, and suddenly you've got
a project web site.</para>
-->

<para>
    一通りのものが揃ったホスティングサイトには、主に二つの利点があります。
    ひとつめは、サーバのディスク容量とネットワーク帯域の太さです。つまり、
    超高速なネットワーク上に、複数のサーバマシンが巨大なラックに収納されているのです。
    プロジェクトがどれだけ成功しても、ディスク容量を使い切ったり、
    ネットワーク接続が使い物にならなくなることはないでしょう。
    ふたつめは、サイトの維持が簡単なことです。
    ホスティングサイトは、バグ追跡システム、バージョン管理システム、
    メーリングリスト管理システム、アーカイバや、
    プロジェクトのウェブサイトを運営するのに必要ものを全て選んでくれています。
    また、それらは既に設定済みであり、蓄積される全てのデータのバックアップにも注意を払ってくれます。
    多くの決断をする必要はありません。フォームに入力し、ボタンを押しさえすればよいのです。
    そうすれば巨大なプロジェクト用ウェブサイトが突然手に入ることでしょう。
</para>

<!--
<para>These are pretty significant benefits.  The disadvantage, of
course, is that you must accept <emphasis>their</emphasis> choices and
configurations, even if something different would be better for your
project.  Usually canned sites are adjustable within certain narrow
parameters, but you will never get the fine-grained control you would
have if you set up the site yourself and had full administrative
access to the server.</para>
-->

<para>
    これらはとても重要な利点です。勿論、他のツールでよいものがあったとしても、
    <emphasis>ホスティングサイトが</emphasis> 選択したツールや設定を受け入れなければならないという欠点があります。
    ホスティングサイトは、設定できるパラメータの範囲を普通狭くしているので柔軟性がありません。
    自前でウェブサイトを立ち上げてサーバへの完全な管理権限を持っていた場合にできる、
    きめの細かい制御は決してできないでしょう。
</para>

<!--
<para>A perfect example of this is the handling of generated files.
Certain project web pages may be generated files&mdash;for example,
there are systems for keeping FAQ data in an easy-to-edit master
format, from which HTML, PDF, and other presentation formats can be
generated.  As explained in
<xref linkend="version-everything"/><phrase output="printed">
earlier in this chapter</phrase>,
you wouldn't want to version the generated formats, only the master
file.  But when your web site is hosted on someone else's server, it
may be impossible to set up a custom hook to regenerate the online
HTML version of the FAQ whenever the master file is changed.  The only
workaround is to version the generated formats too, so that they show
up on the web site.</para>
-->

<para>
    このことのよい例が、自動生成されるファイルの扱いです。
    あるプロジェクトのウェブページは、自動生成されたファイルかもしれません &mdash;
    たとえば、FAQのデータを編集しやすいマスターフォーマットに保存し、それからHTMLやPDF、
    その他表示用のフォーマットを生成するシステムがあるとします。
    <phrase output="printed">この章の</phrase> <xref linkend="version-everything"/> で説明したとおり、
    あなたは自動生成されたフォーマットではなく、
    マスターファイルだけをバージョン管理したいと考えるでしょう。
    しかしウェブサイトが他人のサーバに置いてある場合は、
    マスターファイルが変更された場合にFAQのHTML版を再生成するカスタムフックを設定できないかもしれません。
    唯一の回避策は、ウェブサイトで表示できるように自動生成されたフォーマットもバージョン管理することです。
</para>

<!--
<para>There can be larger consequences as well.  You may not have as
much control over presentation as you would wish.  Some of the canned
hosting sites allow you to customize your web pages, but the site's
default layout usually ends up showing through in various awkward
ways.  For example, some projects that host themselves at SourceForge
have completely customized home pages, but still point developers to
their "SourceForge page" for more information.  The SourceForge page
is what would be the project's home page, had the project not used a
custom home page.  The SourceForge page has links to the bug tracker,
the CVS repository, downloads, etc.  Unfortunately, a SourceForge page
also contains a great deal of extraneous noise.  The top is a banner
ad, often an animated image.  The left side is a vertical arrangement
of links of little relevance to someone interested in the project.
The right side is often another advertisement.  Only the center of the
page is devoted to truly project-specific material, and even that is
arranged in a confusing way that often makes visitors unsure of what
to click on next.</para>
-->

<para>
    もっと大きな影響があるかもしれません。
    あなたが望むほどウェブサイトの見た目を変える権限がないかもしれません。
    ホスティングサイトの中には、ウェブページをカスタマイズすることを許可してはいますが、
    結局はデフォルトの配置がうんざりするようなやり方で表示されてしまうものもあります。
    たとえば、SourceForge がホスティングしているプロジェクトの中には、
    完全にカスタマイズしたホームページがあるけれども、
    詳しい情報を参照させるために "Sourceforge上のページ" に開発者を誘導しているものがあります。
    SourceForge のページは、プロジェクトのホームページになるはずのものでしたが、
    ユーザーに自前のホームページを使わせないようにしています。
    SourceForge のページには、バグ追跡システムやCVSリポジトリ、ダウンロードサイトへのリンクなどがあります。
    不幸なことに、SourceForge のページにはたくさんのプロジェクトとは無関係なリンクも含まれているのです。
    ページの一番上部にはバナー広告がありますが、アニメーション画像であることもよくあります。
    左側にはプロジェクトに興味がある人には殆ど関係がないリンクが垂直に配置されています。
    右側には別の広告がよく配置されています。
    ページの中央部分だけが本当にプロジェクトに特有の事項に専用の場所になっていますが、
    これらもわかりにくい方法で配置されているので、
    訪問者が次にどこをクリックしたらいいのかわからなくなってしまうことがよくあります。
</para>

<!--
<para>Behind every individual aspect of SourceForge's design, there is
no doubt a good reason&mdash;good from SourceForge's point of view,
such as the advertisements.  But from an individual project's point of
view, the result can be a less-than-ideal web page.  I don't mean to
pick on SourceForge; similar concerns apply to many of the canned
hosting sites.  The point is that there's a tradeoff.  You get relief
from the technical burdens of running a project site, but only at the
price of accepting someone else's way of running it.</para>
-->

<para>
    SourceForge のページ設計の裏には、きっと &mdash; 広告のように、
    SourceForge の立場からすれば尤もな理由があるのでしょう。しかし、
    プロジェクトの立場から見れば、その結果が理想のウェブページとはかけ離れたものになるかもしれません。
    私は SourceForge を非難するつもりで言っているのではありません。
    似たような懸念は多くのホスティングサイトにも当てはまります。
    重要なのは、トレードオフが存在するということです。
    プロジェクトのウェブサイトを維持するための技術的な重荷から解放されますが、
    他人のやり方を受け入れることとひきかえにはじめて恩恵を受けられるのです。
</para>

<!--
<para>Only you can decide whether canned hosting is best for your
project.  If you choose a canned site, leave open the option of
switching to your own servers later, by using a custom domain name for
the project's "home address".  You can forward the URL to the canned
site, or have a fully customized home page at the public URL and hand
users off to the canned site for sophisticated functionality.  Just
make sure to arrange things such that if you later decide to use a
different hosting solution, the project's address doesn't need to
change.</para>
-->

<para>
    ホスティングサイトがプロジェクトに最適かどうかを決められるのはあなただけです。
    仮にホスティングサイトを選んだ場合、プロジェクトの"ホームとなるURL"に自前のドメインを使うことで、
    自前のサーバに移行する余地を残しておくようにしましょう。
    自前のURLをホスティングサイトに転送することもできますし、
    公開されているURLに完全に手を加えたホームページを置くことで、
    ユーザーを洗練された機能を持ったホスティングサイトに誘導することもできます。
    ウェブサイトのホスティングについて後に別の解を選んだとしても、
    プロジェクトのURLは変えないように確実に準備をしておくようにしましょう。
</para>

<sect3 id="canned-hosting-choosing">

<!--
<title>Choosing a canned hosting site</title>

<para>The largest and most well-known hosting site is <ulink
url="http://www.sourceforge.net/">SourceForge</ulink>.  Two other
sites providing the same or similar services are <ulink
url="http://savannah.gnu.org/">savannah.gnu.org</ulink> and <ulink
url="http://www.berlios.de/">BerliOS.de</ulink>.  A few organizations,
such as the <ulink url="http://www.apache.org/">Apache Software
Foundation</ulink> and <ulink
url="http://www.tigris.org/">Tigris.org</ulink><footnote><para>Disclaimer:
I am employed by <ulink
url="http://www.collab.net/">CollabNet</ulink>, which sponsors
Tigris.org, and I use Tigris regularly.</para></footnote>, give free
hosting to open source projects that fit well with their missions and
their community of existing projects.</para>
-->

<title>ホスティングサイトを選ぶ</title> 

<para>
    最も規模が大きく、有名なホスティングサイトは <ulink url="http://www.sourceforge.net/">SourceForge</ulink> です。
    他には、<ulink url="http://savannah.gnu.org/">savannah.gnu.org</ulink> と <ulink url="http://www.berlios.de/">BerliOS.de</ulink> の二つが SourceForge と同様または類似のサービスを提供しています。
    <ulink url="http://www.apache.org/">Apache Software Foundation</ulink> や <ulink url="http://www.tigris.org/">Tigris.org</ulink><footnote><para>注意:
筆者は Tigris.org に出資している <ulink url="http://www.collab.net/">CollabNet</ulink> で働いており、普段 Tigrisを使っています。</para></footnote> のような組織は、自分達の任務と既にあるプロジェクトのコミュニティーにうまく合っているオープンソースプロジェクトを無料でホスティングしています。
</para>

</sect3>

<sect3 id="anonymity">

<!--
<title>Anonymity and involvement</title>

<para>A problem that is not strictly limited to the canned sites, but
is most often found there, is the abuse of user login functionality.
The functionality itself is simple enough: the site allows each
visitor to register herself with a username and password.  From
then on it keeps a profile for that user, and project administrators
can assign the user certain permissions, for example, the right to
commit to the repository.</para>
-->

<title>匿名性とプロジェクト参加</title>

<para>
    厳密にはホスティングサイトに限った問題ではないのですが、
    ホスティングサイトで最もよく見られるのが、ユーザーログインの機能に関する苦情です。
    ログイン機能自体は十分単純です。
    ウェブサイトでは、訪問者が自分のユーザー名とパスワードを登録することができるのです。
    登録するとユーザーのプロフィールが保存され、
    プロジェクトの管理者は、ユーザーにリポジトリへのコミット権限のような特定の権限を与えることができます。
</para>

<!--
<para>This can be extremely useful, and in fact it's one of the prime
advantages of canned hosting.  The problem is that sometimes user
login ends up being required for tasks that ought to be permitted to
unregistered visitors, specifically the ability to file issues in the
bug tracker, and to comment on existing issues.  By requiring a
logged-in username for such actions, the project raises the
involvement bar for what should be quick, convenient tasks.  Of
course, one wants to be able to contact someone who's entered data
into the issue tracker, but having a field where she can enter her
email address (if she wants to) is sufficient.  If a new user spots a
bug and wants to report it, she'll only be annoyed at having to fill
out an account creation form before she can enter the bug into the
tracker.  She may simply decide not to file the bug at all.</para>
-->

<para>
    この機能は非常に有用で、ホスティングサイトの主な利点のひとつです。
    問題は、未登録のユーザーにも許可されるべきタスク、
    特にバグ追跡システム内のファイルアップロードや、既存の問題にコメントをつけるときに、
    往々にしてログインが必要になってしまっている点にあります。
    こうしたタスクにログインを必要としてしまうと、
    本来迅速で便利であるべきタスクに参加する敷居が高くなってしまいます。
    勿論、バグ追跡システムにデータを登録した人に連絡を取りたい人もいますが、
    その場合は(本人が望んだ場合に)電子メールアドレスを入力できるフィールドを設けておけば十分です。
    新しいユーザーがバグを発見して報告したいと思ったとして、
    バグ追跡システムに入力する前にアカウント作成フォームを入力しないといけないとわかればうんざりするでしょう。
    そのユーザーは結局バグを登録しないかもしれません。
</para>

<!--
<para>The advantages of user management generally outweigh the
disadvantages.  But if you can choose which actions can be done
anonymously, make sure not only that <emphasis>all</emphasis>
read-only actions are permitted to non-logged-in visitors, but also
some data entry actions, especially in the bug tracker and, if you
have them, wiki pages.</para>
-->

<para>
    ユーザーを管理する利点は、通常は欠点に勝るものです。
    しかしユーザーを匿名で行動させる選択肢があるなら、
    <emphasis>全ての</emphasis> 読み取り専用のアクションだけでなく、
    特にバグ追跡システムや、持っているならwikiページのデータ入力についても、
    ログインしていないユーザーに許可するようにしましょう。
</para>

</sect3>

</sect2>

</sect1>


<!-- ======================== SECTION ============================== -->


</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->

