<chapter id="pfs-ch-4">

<title>Social and Political Infrastructure <!-- [ 15-25 pp ] --></title>

<simplesect>

<para>The first question people usually ask about free software is
"How does it work?  What keeps the project running &mdash; who makes
the decisions?"  I'm always dissatisfied with bland responses about
meritocracy, the spirit of cooperation, code speaking for itself, etc.
The fact is, the question is not easy to answer.  Meritocracy,
cooperation, and running code are all part of it, but these words do
little to explain how projects actually run on a day-to-day basis, and
they say nothing about how conflicts are resolved.</para>

<para>This chapter tries to show some common ingredients in the
structure of succesful projects.  Here, "success" means not just
technical quality, but operational health and survivability.
Operational health is the project's ongoing ability to incorporate new
code contributions and new developers, and to handle incoming bug
reports without falling apart.  Survivability can be described as the
likelihood that the project would continue even if all of its founding
members were to move on to other things.  Many projects have initial
technical success, but without a robust developer base and social
foundation, may be unable to handle the growth that initial success
brings, or the departure of charismatic individuals.</para>

<para>There are various different ways to achieve this kind of
success.  Some ways involve a formal governance structure, by which
new developers are invited in, bug reports routed, release made,
debates resolved, and so on.  Other ways involve less formal
structure, but more conscious self-restraint, to produce an atmosphere
of fairness that people can rely on as a <foreignphrase>de
facto</foreignphrase> form of governance.  Both ways lead to the same
result: a sense of institutional permanence, supported by habits and
procedures that are well-understood by everyone who participates.
These features are even more important in self-organized systems than
in centrally-controlled ones, because in self-organized systems,
everyone is aware that a few bad apples can bring the whole thing
crashing down, at least for a while.</para>

<para>Even free software projects which run on the Benevolent
Dictatorship model are not truly centrally-controlled. <remark>(Talk
about the magic of forkability here &mdash; how forakability is,
paradoxically, what keeps things together.  Some people say it all
boils down to who has root on the server.  Show why this is not really
true.  Also, difference between formal governance and their daily
practice.  Note that the less governance structure there is, the more
careful senior developers have to be about stomping on newcomers
&mdash; not so much because the target will feel squished, as that
<emphasis>other</emphasis> people will not be willing to come to their
aid, because <emphasis>they</emphasis> will not feel protected by the
"rule of law".  Oh, and if there ends up being a section dedicated to
the Benevolent Dictator phenomenon, then link to it from
above.)</remark></para>

</simplesect>


<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-money">
<title>Money and How to Handle It</title>

<screen>
Conflicts of Interest: In a funded project, the corporation or
consortium supplying the money may have different goals than many of
the volunteers have.  How to balance the funder's interests with the
volunteers' interests without either side becoming disgruntled.  [Case
studies: Subversion, possibly others ]
</screen>

<para><remark>Deleted material from Chapter 1, in the spot which now
just refers to this chapter: "This means that if the project has
corporate sponsorship, it should lay out clear guidelines for how the
sponsor may and may not influence project direction.  For if the
unpaid volunteers get the feeling that design decisions or feature
additions are simply available to the highest bidder, they'll most
likely head off to someplace that seems more like a meritocracy and
less like unpaid labor for someone else's benefit.  Volunteer
developers generally do not mind corporate support for the projects
they work on; in fact, they often welcome it, because it can give the
project a higher chance of surviving.  But they insist, reasonably
enough, on being treated as equal partners."</remark></para>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-written-rules">
<title> Written vs Unwritten Rules </title>

<para> When does a project need a written constitution, and what kind? </para>

<!-- Make sure to talk about the procedures by which a
     contributor gets <firstterm>commit access</firstterm>, that is,
     the ability to put changes directly into the software without
     going through some other developer.)  Refer back to the Mike
     Pilato example. --> 

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-decision-making">
<title> Consensus vs Voting vs Tyranny </title>

<para> Consensus vs voting: the importance of having a voting system,
but also, the importance of rarely using it.  Contrast official
tyranny with de facto tyranny. </para>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-money-vs-love">
<title>Money Can't Buy You Love</title>

<para><remark>(Still deciding if this section belongs here, or
somewhere in Chapter 5.  For now, here, as I think it's one of the
better examples, so might as well put it sooner rather than
later.)</remark></para>

<para>Free software projects today are funded by a wide variety of
methods.  There are</para>

<itemizedlist>
  <listitem>
  <para>Totally unfunded projects, done simply for pleasure or
        personal utility and then released for free.</para>
  </listitem>

  <listitem>
  <para>Projects which are essentially done for the love of it but
        which solicit small-scale donations.</para>
  </listitem>

  <listitem>
  <para>Projects that receive all, or a significant portion of, their
        funding from non-profit organizations (such as the Free
        Software Foundation, the Apache Software Foundation,
        Xiph.org, et al).</para>
  </listitem>

  <listitem>
  <para>Projects that are funded from royalties driven by a
        dual-licencing model (see <xref linkend="pfs-dual-licensing"/>),  
        where those using the software in proprietary products
        subsidize its development for the free world.</para>
  </listitem>

  <listitem>
  <para>Projects which are started and managed by for-profit
        corporations for strategic reasons, for example to drive
        support or hardware sales.</para>
  </listitem>
</itemizedlist>

<para>...and all sorts of outliers and edge cases.</para>

<para>Money can affect a project both positively and negatively.  By
reducing the project's vulnerability the Forces of Chaos, which sweep
away so many projects before they really get off the ground, it can
make people more willing to give the software a chance &mdash; they
feel they're investing their time into something that will be around a
year from now.  On the other hand, if not handled carefully, money can
also divide the project into in-group and out-group developers.</para>

<para>If your project is funded, even partially, then it is very
important for you to set guidelines about what the money can and
cannot buy right, from the start.  This does not mean you need to post
twice a day to the mailing lists reiterating your nobility and
incorruptibility.  It merely means that you should be on the lookout
for opportunities to defuse the tensions that
<emphasis>could</emphasis> be created by money.  You don't need to
start out assuming that the tensions are there; you just need to show
an awareness that there is a potential for them to arise.</para>

<para>A perfect example of this came up in the Subversion project.
Subversion was started in 2000 by <ulink
url="http://www.collab.net/">CollabNet</ulink>, which has been the
project's primary funder since its inception, paying the salaries of
several developers (disclaimer: I'm one of them).  Fairly early in the
project, we hired another developer, Mike Pilato, to join the effort.
By then, coding had already started, although we were still very much
in the early stages.</para>

<para>The question was, how to receive Mike into the public project?
Subversion already had a policy about how new developers get commit
access: first, they submit some patches to the development mailing
list.  After enough patches have gone by for the other committers to
see that the new contributor knows what he's doing, someone proposes
that he just commit directly (this proposal takes place on a closed
mailing list of just committers, so no feelings will be hurt if the
proposal fails).  When the committers agree, someone mails the new
developer and offers him direct commit access to the project's master
sources.</para>

<para>But what about Mike?  CollabNet had hired him specifically to
work on Subversion.  There was no doubt about his coding skills or his
readiness to work on the project.  Furthermore, the non-salaried
developers had a very good relationship with the CollabNet employees,
and most likely would not have objected if we'd just given Mike commit
access the day he was hired.  But we realized we were setting a
precedent.  If we just granted Mike commit access by fiat, we'd be
saying that CollabNet had the right to ignore project guidelines,
simply by virtue of being the primary funder.  While the damage from
this might not have been immediately apparent, it would eventually
result in the non-salaried developers feeling gradually
disenfranchised.  Other people have to earn their commit access
&mdash; CollabNet just buys it.</para>

<para>So Mike agreed to start out his employment at CollabNet like any
other volunteer developer, without commit access.  He sent patches to
the mailing list, where they could be, and were, reviewed by everyone.
Equally importantly, we said on the list that we were doing things
this way deliberately, so there could be no missing the point.  After
a while, someone (I can't remember if it was a CollabNet developer or
not) proposed Mike for commit access, and he was accepted, as everyone
knew he would be.</para>

<para>That kind of consistency gets you a credibility that money could
never buy.  And credibility is a valuable currency to have in
technical discussions: it's immunization against having ones motives
questioned later.  In the heat of argument, people will sometimes look
for non-technical ways to win the battle.  The project's primary
funder, because of its deep involvement and obvious concern over the
directions the project takes, presents a wider target than most.  By
being scrupulous to observe all project guidelines right from the
start, the funder makes themselves the same size as everyone
else.</para>

<para><remark>(Check with Mike that it's okay to use his name.  I
don't think he'll mind, but it's nice to ask.)</remark></para>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-contracting">
<title> Contracting </title>

<para> Contracting.  You may have funding, but that doesn't mean it's
easy to disburse.  Subcontracting needs to be done carefully in free
software projects, because part of the deal is that the
subcontractor's work must be accepted by the community -- and just
because someone funded the work doesn't necessarily mean the community
will accept it!  [Tell the story of CVS pserver here?]  </para>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-holy-wars">
<title>Avoid Holy Wars</title>

<para>A <firstterm>Holy War</firstterm> is a dispute, usually over a
relatively minor issue, which has no hope of being resolved on the
merits of the arguments, but where people feel passionate enough to
continue arguing anyway in the hope that their side will
prevail.</para>

<para>Once a holy war has started, it generally cannot be resolved to
everyone's satisfaction.  It does no good to point out, in the midst
of a holy war, that a holy war is going on.  Everyone knows that
already.  Unfortunately, a common feature of holy wars is disagreement
on the very question of <emphasis>whether</emphasis> the dispute is
resolveable by continued discussion.  Viewed from outside, it is clear
that neither side is changing the other's mind.  Viewed from inside,
the other side is being obtuse and not thinking clearly, but they
might come around if browbeaten enough.  Now, I am
<emphasis>not</emphasis> saying there's never a right side in a holy
war.  Sometimes there is &mdash; in the holy wars I've participated
in, it's always been my side, of course.  But it doesn't matter,
because there's no algorithm for convincingly demonstrating that one
side or the other is right.</para>

<para>A common, but unsatisfactory, way people try to resolve holy
wars is to say "We've already spent far more time and energy
discussing this than it's worth!  Can we please just drop it?"  There
are two problems with this.  First, that time and energy has already
been spent and can never be retrieved &mdash; the only question now
is, how much <emphasis>more</emphasis> effort remains?  If some people
feel that just a little more discussion will bring the issue to a
close, then it still makes sense (from their point of view) to
continue.</para>

<para>The other problem with asking for the matter to be dropped is
that this is often equivalent to allowing one side, the status quo, to
declare victory by inaction.  And in some cases, the status quo is
known to be unacceptable anyway: everyone agrees that some decision
must be made, some action taken.  Dropping the subject would be worse
for everyone than simply giving up the argument would be for anyone.
But since that dilemma applies to all equally, it's still possible to
end up arguing forever about what to do.</para>

<para>So how should you handle a holy war?</para>

<para>The first answer is, try to set things up so they don't happen.
This is not as hopeless as it sounds:</para>

<para><remark>(finish) This is done by anticipating standard holy
wars: languages, licences (<xref linkend="pfs-avoiding-license-wars"/>),
reply-to munging.  Regarding language holy wars: most important thing
is, choose a language that you and the the other initial developers
are comfortable with, and defend the language on *those* grounds,
*not* on the grounds that it's better than some other possible
language.  Never ever let the conversation degenerate into an academic
comparison of programming languages (this seems to happen especially
often when someone brings up Perl); that's one of many examples of a
death topic that should be stopped before it gets
started.</remark></para>

<para><remark>When a holy war can't be avoided, decide early how much
you care, and then be willing to publicly give up.  When you do so,
say that you're backing out because the holy war isn't worth it, but
don't be bitter and <emphasis>don't</emphasis> take the opportunity
for a last parting shot at the opposing side's arguments.  Giving up
is only effective when done gracefully.</remark></para>

<para>For more historical background on holy wars, see <ulink
url="http://catb.org/~esr/jargon/html/H/holy-wars.html"/>, and the
paper by Danny Cohen that popularized the term, <ulink
url="http://www.ietf.org/rfc/ien/ien137.txt"/>.</para>

</sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->

