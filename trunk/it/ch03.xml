<chapter id="technical-infrastructure">

<title>L'Infrastruttura Tecnica
</title>

<simplesect>

    <para>
      I progetti di software libero poggiano su tecnologie che supportano la cattura e l'integrazione dell'informazione. Più esperti sarete nell'usare queste tecnologie, e nel persuadere gli altri a usarle, più il vostro progetto avrà successo. Ciò diventa vero quando il progetto cresce. La buona gestione dell'informazione è ciò che previene dal collasso del progetto sotto il peso della legge di Brooks
      ,<footnote>
        <para>
          Dal suo libro
          <citetitle>
            Il mitico mese dell'uomo
          </citetitle>, 1975.  vedere
          <ulink
         url="http://en.wikipedia.org/wiki/The_Mythical_Man-Month"/> and <ulink
url="http://en.wikipedia.org/wiki/Brooks_Law"/>.
        </para>
      </footnote>
      che stabilisce che aggiungere forza lavoro a un progetto avanzato lo rende più avanzato.
      Fred Brooks osservò che la complessità di un progetto cresce con
      <emphasis>il quadrato</emphasis>del numero dei partecipanti.  Quando sono coinvolte solo poche
      persone, ognuno può parlare facilmente all'altro, ma quando sono coinvolte centinaia di persone, non è ulteriormente possibile per una persona essere messa al corrente di ciò che ciascun altro sta facendo. Se una buona gestione di software libero sta facendo in modo che ognuno si senta al lavoro con gli altri nella medesima stanza, la domanda ovvia è: cosa avviene quando ognuno in una stanza affollata cerca di parlare simultaneamente?
    </para>

    <para>
      Questo problema non è nuovo. In stanze non-metaforicamente affollate la soluzione è una
      <firstterm>
<<<<<<< .mine
        la procedura parlamentare
      </firstterm>: linee guida formali su come avere discussioni in tempo reale in grandi gruppi, come assicurarsi che importanti dissensi non si perdano nelle inondazioni di commenti “anch'io”
=======
        procedura parlamentare
      </firstterm>: linee guida formali su come avere discussioni in tempo reale in grandi gruppi, come assicurarsi che importanti dissensi non si perdano nelle inondazioni dei commenti anch'io
>>>>>>> .r1830
      , come dar forma a sottocommissioni, come riconoscere quando le decisioni vengono prese, ecc..
<<<<<<< .mine
      Una parte importante della procedura parlamentare è specificare come il gruppo interagisce con il suo sistema di gestione delle informazioni. Alcuni rilievi vengono fatti “per registrazione”
      , altri no. La registrazione stessa è soggetta a una manipolazione diretta ed è scambiata per una trascrizione letterale di ciò che è avvenuto, non per ciò su cui il gruppo
      <emphasis>concorda</emphasis> che sia avvenuto. La registrazione non è monolitica, ma assume forme differenti a seconda del fine. Essa comprende i minuti degli incontri individuali, l'insieme di tutti i minuti di tutti gli incontri, i sommari, le agende e le loro annotazioni, i rapporti della commissione, i rapporti dei corrispondenti non presenti, gli elenchi delle azioni, ecc..
=======
      Una parte importante della procedura parlamentare è specificare come il gruppo interagisce con il suo sistema di gestione delle informazioni. Alcuni rilievi vengono fatti per registrazione
      , altri no. La registrazione stessa è soggetta a una manipolazione diretta ed è scambiata per una trascrizione letterale di ciò che è avvenuto, non per ciò su cui il gruppo
      <emphasis>concorda</emphasis> che sia avvenuto. La registrazione non è monolitica, ma assume forme differenti a seconda del fine. Essa comprende i minuti degli incontri individuali, l'insieme di tutti i minuti di tutti gli incontri, i sommari, le agende e le loro annotazioni, i rapporti della commissione, i rapporti dei corrispondenti non presenti, gli elenchi delle azioni, ecc..
>>>>>>> .r1830
    </para>

    <para>Poichè Internet non è una stanza reale, noi non dobbiamo preoccuparci di riprodurre quelle parti della procedura parlamentare che mantengono le persone ferme mentre altre stanno parlando. Invece quando fanno propria la tecnica dell'organizzazione delle informazioni, i progetti open source che vanno bene sono una forma molto amplificata di procedura parlamentare. Poiché quasi tutte le comunicazioni nei progetti open source avvengono scrivendo, i sistemi elaborati si sono evoluti per l'instradamento e l'etichettatura dei dati; per evitare ripetizioni, come per evitare divergenze spurie; per immagazzinare e recuperare dati; per correggere informazioni cattive ed obsolete; e per associare pezzi di informazione con ogni altra nella misura un cui vengono rilevate nuove connessioni. I partecipanti attivi nei progetti open source fanno proprie molte di queste tecniche e  metteranno a punto complesse operazioni manuali per assicurare all'informazione di essere instradata correttamente. Ma l'intero sforzo spesso dipende da un sofisticato supporto di software. Quanto più possibile, i mezzi di comunicazione non realizzano l'instradamento, la classificazione e la registrazione, e dovrebbero rendere disponibile l'informazione agli uomini nella maniera più pratica. In pratica, gli uomini avranno ancora bisogno di intervenire in molti punti del processo, ed è importante che il software renda tali interventi anche pratici. Ma, in generale, se gli uomini hanno cura di classificare e di instradare l'informazione al suo primo ingresso nel sistema il software sarà configurato in modo da fare uso di gruppi di dati il più possibile.</para>

    <para>
      Il consiglio in questo capitolo è intensamente pratico, basato su sull'esperienza con software specifici e su esempi d'uso. Ma il punto non è solo insegnare un particolare insieme di tecniche. E' anche quello di dimostrare, con l'aiuto di molti piccoli esempi, l'attitudine complessiva che che meglio incoraggerà la buona gestione dell'informazione nei vostri progetti. Questa attitudine coinvolgerà una combinazione di capacità tecniche e capacità umane. Le capacità tecniche sono perchè la gestione delle informazioni spesso richiede la configurazione, più una certa quantità di manutenzione in corso e di nuove regolate nelle misura in cui nuovi bisogni sorgono (come esempio vedere la discussione su come trattare un progetto cresciuto in
      <xref linkend="bug-filtering"/><phrase output="printed"> più in là in questo capitolo</phrase>).  Le abilità delle persone sono necessarie perché la comunità umana anche richiede manutenzione: non è sempre immediatamente ovvio come usare questi strumenti con profitto, e in alcuni casi i progetti hanno delle convenzioni in conflitto (per esempio vedere la discussione sul predisporre le intestazione <systemitem>Rispondere-a</systemitem> nei posts in uscita in <xref linkend="mailing-lists"/>).
      Chiunque sarà coinvolto nel progetto avrà bisogno di essere incoraggiato, al momento giusto e nella giusta maniera, per fare la sua parte nel mantenere l'informazione del progetto ben organizzata. Più sarà coinvolto il collaboratore, più saranno complesse e specializzate le tecniche che ci si aspetterà che possa imparare.
    </para>

    <para>
      La gestione delle informazioni non ha una soluzione dal taglio secco. Ci sono molte variabili. Potete aver configurato definitivamente ogni cosa giusto nel modo che voi volevate, ed avere la maggior parte della comunità che partecipa, ma la crescita del progetto renderà alcune di quelle pratiche non accessibili. O la crescita del progetto si può stabilizzare, e le comunità degli sviluppatori e degli utilizzatori si possono comporre in una comoda relazione con l'infrastruttura, ma allora qualcuno si muoverà e inventerà un servizio di gestione delle informazioni completamente nuovo, e ben presto i nuovo arrivati si chiederanno perché voi non lo usiate &mdash;per esempio ciò sta avvenendo per un sacco di progetti di software libero che anticipano l'invenzione del wiki (vedere
      <ulink url="http://en.wikipedia.org/wiki/Wiki"/>).  Molte questioni sono materia di giudizio, riguardando un compromesso tra la convenienza di quelli che producono informazione e la convenienza di quelli che la utilizzano, o fra il tempo richiesto per configurare il software per la gestione l'informazione e i vantaggi che porta al progetto.
    </para>

    <para>Guardarsi dalla tentazione di una super automazione, cioè, automatizzare cose che richiedono attenzione umana. L'infrastruttura tecnica è importante, ma ciò che fa si che il progetto di software libero funzioni è la cura e l'intelligente manifestazione di quella cura, immessavi dagli uomini. L'infrastruttura tecnica consiste nel dare agli uomini modi convenienti di realizzare ciò.</para>

  </simplesect>

<!-- ======================== SECTION ============================== -->
<sect1 id="tools-needed">
<title>Di cosa ha bisogno un progetto</title>

<para>La maggior parte dei progetti open source offrono almeno un minimo insieme
standard di strumenti per la gestione dell'informazione:</para>

<variablelist>

   <varlistentry><term>Sito Web</term>
     <listitem>
     <para>Principalmente un canale di informazione centralizzato e a senso unico,
     dal progetto verso il pubblico. Il sito web può anche servire come interfaccia
     di amministrazione di altri strumenti del progetto. 
     </para>
     </listitem>
   </varlistentry>

   <varlistentry><term>Mailing list</term>
     <listitem>
       <para>Solitamente il forum di comunicazione più attivo,
        e il mezzo di memorizzazione ("medium of record").
     </para> 
     </listitem>
   </varlistentry>

   <varlistentry><term>Controllo di versione</term>
     <listitem>
       <para>Permette agli sviluppatori di gestire adeguatamente
       le modifiche nel codice, compresi i passi indietro e il cambio
       di portabilità. Permette a tutti di vedere cosa sta succedendo
       al codice.</para>
     </listitem>
   </varlistentry>

   <varlistentry><term>Tracciamento dei bug</term>
     <listitem>
       <para>Permette agli sviluppatori di tenere traccia di quello
       su cui stanno lavorando, coordinarsi l'uno con l'altro e pianificare
       i rilasci. Permette a tutti di fare interrogazioni sullo stato dei bug e di
       memorizzare informazioni (per esempio istruzioni per la soluzione di certi
       tipi di problemi) riguardanti particolari bug. Può essere usato
       non solo per i bug ma anche per attività, rilasci, nuove funzionalità eccetera.</para>
     </listitem>
   </varlistentry>
   
<!--(e.g., reproduction recipes)  qualcosa di meglio??  -->


<!--
   <varlistentry><term>Forum di discussione</term>
     <listitem>
       <para><remark>Basically, bulletin board systems.  These are not
             as widespread as one would expect, and where they are
             found, they're not used as much as one would expect.  Why?
             Are they worth mentioning at all?</remark></para>
     </listitem>
   </varlistentry>
-->

   <varlistentry><term>Chat in tempo reale</term>
     <listitem>
       <para>Un posto per scambi di botta&mdash;e&mdash;risposta e discussioni
       veloci e leggere. Non sempre completamente archiviata.</para>
     </listitem>
   </varlistentry>

</variablelist>

<para>Ognuno di questi strumenti affronta un bisogno specifico, ma le
loro funzioni sono anche correlate, e gli strumenti devono essere fatti per
lavorare insieme. Più avanti esamineremo come possono farlo, e ancora più 
importante, come fare in modo che la gente li usi. Il sito web non sarà discusso
fino alla fine dato che funziona più come colla per le altre componenti che uno 
strumento in sè.</para>

<para>Dovreste essere in grado di evitare molti mal di testa scegliendo
e configurando questi strumenti usando un sito di cossiddetto <firstterm>canned
hosting</firstterm>: un server che offre aree web preconfezionate, con stile coerente
e con tutti gli strumenti necessari a portare avanti un progetto di software libero. Vedi
<xref linkend="canned-hosting"/><phrase output="printed"> più avanti in questo capitolo</phrase>
per una discussione su vantaggi e svantaggi del canned hosting.</para>

</sect1>


<!-- ========================== SECTION =========================== -->
<sect1 id="mailing-lists">
<title>Mailing Lists</title>

<para>Le mailing list sono il sale delle comunicazioni all'interno di 
un progetto. Se un utente fa parte di un forum che non siano le pagine web,
è molto probabile che sia la mailing list. Ma prima che gli utenti provino
la mailing list, devono provare l'interfaccia della mailing list&mdash;cioè
il meccanismo con cui si aggiungono ("subscribe to") alla mailing list. Questo ci porta alla
Regola numero 1 della mailing list:</para>

<blockquote>
   <para><emphasis>Non provate a gestire le mailing list a mano&mdash; usa un 
   software di gestione.</emphasis></para>
</blockquote>

<para>Si può essere tenatati di farna a meno. Configuare un software di gestione
di mailing list può sembrare un massacro, di primo acchito. Gestire liste, piccole 
e con poco traffico, a mano sembrerà seduttivamente facile: si crea un indirizzo di
sottoscrizione che fa il forward delle mail su di voi, e quando qualcuno ci scrive,
aggiungete (o togliete) gli indirizzi email in qualche file di testo che contiene
tutti gli indirizzi della lista. Cosa c'è di più facile?</para>

<para>Il trucco sta nel fatto che una buona gestione di mailing list&mdash;che è cosa
le persone sono arrivate ad aspettarsi&mdash;non è per niente facile.
Non è solo questione di aggiungere o rimuovere utenti quando lo richiedono.
E' anche moderare per prevenire lo spam, offrire la mailing list come compendio piuttosto
che messaggio per messaggio, fornire una lista standard e informazioni sul progetto come
risposte automatiche, e varie altre cose. Un essere umano che controlla gli indirizzi
di sottoscrizione può fornire appena un minimo di funzionalità, e neppure in modo affidabiele
e pronto come lo farebbe un software.</para>

<para>I moderni software di gestione di mailing list solitamente offrono almeno le seguenti funzionalità:</para>

<variablelist>

  <varlistentry><term>Sottoscrizione sia via email che da sito web</term>
    <listitem>
      <para>Quando un utente sottoscrive la mailing list, dovrebbe
            <emphasis>velocemente</emphasis> ricevere un messaggio automatico
            di benvenuto in risposta, che spieghi cosa ha sottoscritto, come
            interagire ulteriormente con il software di mailing list e (soprattutto)
            come disiscriversi. Questa risposta automatica può essere personalizzata
            in modo da contentere informazioni specifiche del progetto, di sicuro, come
            il sito web del progetto, dove si trovano le FAQ, eccetera.</para>
    </listitem>
  </varlistentry>

  <varlistentry><term>Sottoscrizione sia in modalità aggregata che in modalità messaggio 
  			per messaggio</term>
    <listitem>
      <para>Nella modalità aggregata, il sottoscrittore riceve una mail al giorno,
            contenente tutta l'attività di quel giorno. Per le persone che stanno seguendo
            la mailing list senza parteciparvi attivamente, la modalità aggregata è spesso
            preferibile, perchè permette loro di vedere tutti gli argomenti in una volta sola e
            di evitare la distrazione causata da email in arrivo ad ogni momento.</para>
    </listitem>
  </varlistentry>

  <varlistentry><term>Funzionalità di moderazione</term>
    <listitem>
      <para>"Moderare" è l'attività di controllare i messaggi per assicurarsi
      		che siano a)&nbsp;non&nbsp;spam, e b)&nbsp;sull'&nbsp;argomento,
      		prima che vengano mandati a tutta la mailing list. L'attività di
      		moderazione necessariamente impiega gli umani, ma il software può
      		fare molto per semplificarla. Più avanti verrà detto altro riguardo
      		alla moderazione.</para>
    </listitem>
  </varlistentry>

  <varlistentry><term>Interfaccia di amministrazione</term>
    <listitem>
      <para>Tra le altre cose, permette ad un amministratore di entrare
      	    e rimuovere facilmente indirizzi obsoleti. Questo può diventare
      	    urgente quando un indirizzo destinatario inizia a mandare indietro risposte
      	    automatiche "Non sono più a questo indirizzo" alla mailing list in risposta
      	    ad ogni messaggio. (Alcuni software per mailing list possono perfino capirlo
      	    da soli e rimuovere la persona in maniera automatica)</para>
    </listitem>
  </varlistentry>

  <varlistentry><term>Manipolazione degli header</term>
    <listitem>
      <para>Molta gente definisce nei propri programmi di posta sofisticate
      regole di filtro e risposta. I software di gestione di mailing list possono
      aggiungere e manipolare certi header standard per queste persone così da
      guadagnare vantaggio da (maggiori dettagli sotto).</para>
    </listitem>
  </varlistentry>

  <varlistentry><term>Archiviazione</term>
    <listitem>
      <para>Tutti i messaggi della mailing list sono memorizzati e resi disponibili
      sul web; come alternativa, alcuni software di gestione offrono speciali
      interfacce per l'integrazione di strumenti di archiviazione esterni come MHonArc
            (<ulink url="http://www.mhonarc.org/"/>).  Come
            <xref
            linkend="using-archives"/><phrase output="printed">
            in <xref linkend="communications"/></phrase>
            sostiene, l'archiviazione è cruciale.</para>
    </listitem>
  </varlistentry>

</variablelist>

<para>Lo scopo di tutto questo è semplicente enfatizzare il fatto che la
gestione di mailing list è un problema complesso che ha dato molti problemi, la
maggior parte dei quali è stata risolta. Sicuramente non avrete bisogno di diventarne
degli esperti. Ma dovete essere consci del fatto che c'è sempre modo di imparare cose nuove,
e che la gestione della mailing list occuperà la vostra attenzione di tanto in tanto
durante la vita di un progetto open source. Più avanti esamineremo alcuni dei problemi di configurazione
di mailing list più comuni.</para>

<!-- ========================== subsection =========================== -->
<sect2 id="spam-prevention">
<title>Prevenire lo spam</title>

<para>Tra quando questa frase è stata scritta e quando è stata pubblicata,
il problema dello spam, grande quanto la Reta, sarà probabilmente raddoppiato nella
sua gravità&mdash; o almeno sembrerà così. C'era una volta, non così tanto tempo fa,
quando uno poteva gestire una mailing list senza adottare assolutamente nessuna prevenzione 
per lo spam. Gli occasionali messaggi non pertinenti sarebbero comunque comparsi, ma abbastanza 
infrequentemente per essere solo una piccola noia. Quell'era è andata per sempre. Oggi, una mailing
list che non adotta misure di prevenzione dello spam sarà velocemente sommersa di email spazzatura,
fino al punto di diventare inusabile.La prevenzione dello spam è obbligatoria.</para>

<para>Dividiamo la prevenzione dello spam in due categorie: prevenire il comparire
di messaggi di spam sulla mailing list e prevenire che la vostra mailing list diventi una
fonte di nuovi indirizzi email per gli spammer. Il primo è più importante, quindi lo esaminiamo
per primo.</para>

<sect3 id="spam-filtering">
<title>Filtrare i messaggi</title>

<para>Ci sono tre tecniche di base per prevenire i messaggi di spam, e la
maggior parte dei software di gestione di mailing list li offre tutti.
E' meglio usarli tutti insieme:</para>

<orderedlist>

  <listitem><para><emphasis role="bold">Permettere la pubblicazione automatica
  di messagggi solo dai sottoscrittori della mailing list.</emphasis></para>

            <para>Questo è efficace finchè funziona, e comporta un piccolissimo
            sforzo amministrativo, dato che solitamente si tratta di cambiare una 
            configurazione nel software di gestione di mailing list. Ma bisogna notare
            che i messaggi che non sono approvati automaticamente non devono essere
            semplicemente scartati. Invece, dovrebbero essere passati alla moderazione, per
            due ragioni. Primo, potete voler permettere ai non inscritti di pubblicare messaggi.
            Una persona con una domanda o un consiglio non dovrebbe avere bisogno di iscriversi
            alla mailing list solo per pubblicare un solo messaggio. Secondo, anche gli iscritti
            possono a volte pbblicare da un indirizzo diverso da quello con cui si sono iscritti.
            Gli indirizzi email non sono un metodo affidabile per identificare le persone, e non
            dovrebbero essere trattati come tali.</para>
            </listitem>

  <listitem><para><emphasis role="bold">Filtrare i messaggi attraverso software
  che filtrano spam.</emphasis></para>

            <para>Se il software di gestione lo rende possibile (molti lo fanno),
            potete avere i messaggi filtrati da apposito software. Il filtro automatico
            per lo spam non è perfetto, e non lo sarà mai, dato che ci sarà una corsa alle
            armi senza fine tra spammer e creatori di filtri. Comunque, può considerevolmente
            ridurre la quantità di spam che passa attraverso la coda di moderazione, e dato che 
            più lunga è la coda e più tempo gli umani ci mettono a controllarla, ogni quantità
            di filtro automatico è vantaggiosa.</para>

            <para>Non c'è spazio qui per le istruzioni dettagliate su come
            configurare i filtri per lo spam. Dovrete consultare la documentazione
            del vostro software di gestione mailing list per questo (vedi
            <xref
            linkend="mailing-list-software"/><phrase
            output="printed"> più avanti in questo capitolo</phrase>).  Tali software
            a volte arrivano con alcune funzionalità precostruite di prevenzione spam,
            ma potreste voler aggiungere alcuni filtri di terze parti. Ho avuto
            buone esperienze con questi due:
            SpamAssassin
            (<ulink url="http://spamassassin.apache.org/"/>)
            e SpamProbe
            (<ulink url="http://spamprobe.sourceforge.net/"/>).  Questo non
            è un commento sui molti altri filtri open source per lo spam là fuori,
            alcuni dei quali sono a prima vista abbastanza buoni. Semplicemente mi
            è capitato di usare questi due e ne sono rimasto soddisfatto.</para>
  </listitem>

  <listitem><para><emphasis role="bold">Moderazione.</emphasis></para>
            <para>Per le mail che non sono automaticamente autorizzate in virtù
            del provenire da un iscritto alla mailing list, e che passano attraverso
            il software di filtraggio spam, se presente, l'ultimo passo è la 
            <firstterm>moderation</firstterm>: la mail è mandata ad uno speciale
            indirizzo, dove un umano la esamina e la conferma o la respinge.</para>

            <para>Confermare un messaggio assume una tra due forme:
            potete accettare il messaggio solo per questa volta, o potete dire
            al software di ammettere questo e i prossimi messaggi dallo stesso mittente.
            Dovreste quasi sempre fare così, per ridurre la futura mole di moderazione.
            I dettagli su come fare ad accettare cambiano da sistema a sistema, ma è
            solitamente cosa di rispondere ad uno speciale indirizzo con il comando "accept"
            (che significa accettazione solo per questo messaggio) o "allow" (permetti questo
            e i messaggi futuri).</para>

            <para>Si respinge solitamente ignorando la mail di moderazione. Se il software di
            gestione non riceve mai conferme che qualcosa è un messaggio valido, alloea non lo
            passerà alla mailing list, quindi semplicemente ignorando la mail di moderazione 
            ottiene l'effetto desiderato. A volte avete anche l'opzione di rispondere con un 
            comando "rejet" o "deny", per disapprovare automaticamente le future mail dallo
            stesso mittente senza neppure farle passare attraverso la moderazione. Raramente 
            c'è motivo di fare così, dato che la moderazione si occupa soprattutto di spam, e 
            gli spammer tendono a non usare lo stesso indirizzo due volte.</para>
            </listitem>
</orderedlist>

<para>Cercate di usare la moderazione <emphasis>solo</emphasis> per scartare spam
e messaggi palesemente non attinenti, come quando qualcuno manda un messaggio alla
mailing list sbagliata. Il sistema di moderazione solitamente vi fornirà un modo per
rispondere direttamente al mittente, ma non usate questo metodo per rispondere a domande
che in realtà appartengono alla stessa mailing list, anche se sapete al volo la risposta.
Fare così priverà la comunità del progetto dell'immagine accurata dei tipi di domande che la
gente pone, e negherà un'opportunità di rispondere alle domande e/o di vedere le risposte di
altri. La moderazione di mailing list riguarda soltanto l'evitare i messaggi spazzatura e email
non pertinenti, nient'altro.</para>

</sect3>

<sect3 id="address-hiding">
<title>Nascondere gli indirizzi presenti negli archivi</title>

<para>Per prevenire che la vostra mailing list diventi una fonte di indirizzi
per gli spammer, una tecnica comune è nascondere gli indirizzi di email delle persone presenti negli archivi,
ad esempio sostituendo</para>

    <blockquote>
      <para><literal>jrandom@somedomain.com</literal></para>
    </blockquote>

<para>con</para>

    <blockquote>
      <para><literal>jrandom_AT_somedomain.com</literal></para>
    </blockquote>

<para>oppure</para>

    <blockquote>
      <para><literal>jrandomNOSPAM@somedomain.com</literal></para>
    </blockquote>

<para>o qualche altra simile evidente (per gli umani) codifica. Dato che 
i raccoglitori di indirizzi di spam spesso funzionano elaborando le pagine
web&mdash;compresi gli archivi onlime della vostra mailing list&mdash;e cercando
sequenze di caratteri contententi "@", codificare gli indirizzi è un modo di 
rendere gli indirizzi email della gente invisibili o inutili per gli spammer.
Questo non evita che dello spam sia inviato alla mailing list stessa, certo, ma
evita che la quantità di spam inviata direttamente agli indirizzi personali degli
utenti aumenti.</para>

<para>Nascondere gli indirizzi può essere controverso. Alcune persone lo apprezzano
molto e saranno sorpresi se i vostri archivi non lo fanno automaticamente.
Altri pensano che sia un disturbo (perchè gli umani devono anche ritradurre
gli indirizzi prima di usarli).
A volte la gente afferma che sia inutile, perchè un raccoglitore di indirizzi potrebbe
in teoria compensare ogni modo coerente di codifica.
Comunque, va notato che c'è una prova empirica del fatto che nascondere gli
indirizzi <emphasis>è</emphasis> efficace, vedi <ulink
url="http://www.cdt.org/speech/spam/030319spamreport.shtml"/>.</para>

<para>Idealmente il software di gestione dovrebbe lasciare la scelta ad 
ogni sottoscrittore individualmente, o attraverso uno speciale header si/no
oppure una configurazione nelle preferenze del proprio account. Comunque,
non sono a conoscenza di alcun software che offre una scelta per sottoscrittore
o per messaggio, quindi per ora il gestore della mailing list deve prendere una 
decisione per tutti (assumendo che l'archiviazione abbia tale funzionalità, che non accade
sempre). Tendo moderatamente verso l'attivazione dell'occultamento degli indirizzi.
Alcune persone sono molto attente ad evitare di pubblicare i loro indirizzi email su
pagine web o in qualunque altro posto in cui un raccoglitore di indirizzi potrebbe vederlo,
e sarebbero dispiaciute di vedere tutta la loro cura buttata via da un archivio di mailing list;
allo stesso tempo, il disturbo che l'occultamento di indirizzi crea agli utenti è molto leggero, 
dato che è banale ritrasformare un indirizzo oscurato in uno valido se avete bisogno di contattare
quella persona. Ma tenete a mente che, alla fine, è sempre una corsa alle armi: nel tempo in cui 
avete letto questo, i raccoglitori di indirizzi potrebbero essere evoluti al punto in cui possono
riconoscere i metodi più comuni di occultamento, e dovremo pensare a qualcos'altro.</para>

</sect3>

</sect2>

<!-- ========================== subsection =========================== -->
<sect2 id="header-management">
<title>Identificazione e gestione degli header</title>

<para>Gli iscritti spesso vogliono mettere le mail della mailing list in
una cartella specifica per il progetto, separata dalle altre mail.
Il loro software per la lettura di email può fare ciò automaticamente 
esaminando gli <firstterm>header</firstterm> delle email. Gli header
sono i campi alla cima della mail che indicano mittente, destinatario, oggetto,
data, e varie altre cose riguardo al messaggio. Alcuni header sono noti e anche
obbligatori:</para>

<screen>
From: ...
To: ...
Subject: ...
Date: ...
</screen>

<para>Altri sono opzionali, anche se abbastanza standard. Per esempio,
alle email non è strettamente richiesto di avere il seguente header</para>

<screen>
Reply-to: sender@email.address.here
</screen>

<para>ma molti ce l'hanno, perchè da ai destinatari un modo per raggiungere l'autore
a prova di stupido (è specialmente utile quando l'autore ha dovuto inviare da un 
indirizzo diverso da quello a cui le risposte andrebbero inviate).</para>

<para>Alcuni software per la lettura delle email offrono semplici interfacce
per riempire le email basandosi sul modello dell'header dell'oggetto della mail.
Questo porta la gente a richiedere che la mailing list aggiunga automaticamente
un prefisso a tutti gli oggetti delle email, così che loro possano configurare i
loro software per cercare tale prefisso e mettere le email nelle giusta cartella
in modo automatico. L'idea è che l'autore scriva:</para>

<screen>
Oggetto: fare la release 2.5.
</screen>

<para>ma l'email inviata nella mailing list sarà del tipo:</para>

<screen>
Oggetto: [discuss@lists.example.org] fare la release 2.5.
</screen>

<para>Anche se la maggior parte dei software di gestione offre l'opzione di farlo,
raccomando fortemente di non abilitare questa opzione. Il problema che risolve
può essere facilmente affrontato in altri modi meno intrusivi, e il costo dello spazio
sprecato nell'header dell'oggetto è davvero troppo alto.
Gli utenti esperti di mailing list scorrono gli oggetti delle email in arrivo per 
decidere cosa leggere e/o a cosa rispondere. Aggiungere il nome della mailing list
all'inizio dell'oggetto delle email può spingere la parte destra dell'oggetto fuori
dallo schermo, invisibile. Ciò nasconde l'informazione di cui la gente ha bisogno per 
decidere quali email aprire, riducendo quindi per tutti la funzionalità complessiva
della mailing list.</para>

<para>Invece di usare l'header dell'oggetto, insegnate ai vostri utenti ad usare a loro
vantaggio gli altri header standard, a cominciare dal header del destinatario (To), che
dovrebbe dire il nome della mailing list:</para>

<screen>
To: &lt;discuss@lists.example.org&gt;
</screen>

<para>Ogni software di lettura mail che può applicare filtri sull'oggetto dovrebbe
essere in grado di filtrare altrettanto facilmente l'header del destinatario.</para>

<para>Ci sono alcuni altri header opzionali ma standard che sono attesi nelle
mailing list. Applicare filtri su questi è persino più affidabile che usare gli
header "To" o "Cc" (Carbon copy, Copia carbone); dato che questi header sono aggiunti dal
software di gestione ad ogni nuovo messaggio pubblicato, alcuni utenti potrebbero contare 
sulla loro presenza:</para>

<screen>
list-help: &lt;mailto:discuss-help@lists.example.org&gt;
list-unsubscribe: &lt;mailto:discuss-unsubscribe@lists.example.org&gt;
list-post: &lt;mailto:discuss@lists.example.org&gt;
Delivered-To: mailing list discuss@lists.example.org
Mailing-List: contact discuss-help@lists.example.org; run by ezmlm
</screen>

<para>Per la maggior parte, sono auto-esplicativi.  Vedi <ulink
url="http://www.nisto.com/listspec/list-manager-intro.html"/> per ulteriori
spiegazioni, o se avete bisogno della specifica formale e veramente dettagliata,
<ulink url="http://www.faqs.org/rfcs/rfc2369.html"/>.
</para>

<para>Va notato che questi header implicano che se avete una mailing list che si chiama
"list", allora avete anche gli indirizzi amministrativi "list-help"
e "list-unsubscribe" a disposizione. Oltre a questi, è normale avere "list-subscribe", 
per iscriversi, e "list-owner", per contattare gli amministratori della mailing list.
A seconda del software di gestione che usate, questi e/o vari altri indirizzi amministrativi
possono essere creati; la documentazione conterrà dettagli su questo. Solitamente una spiegazione
completa di tutti questi indirizzi speciali è inviata ad ogni nuovo utente come parte di una 
email automatica di benvenuto quando si iscrive. Voi stessi probabilmente avrete una copia di 
questa mail di benvenuto. Se non l'avete, allora chiedetene una copia a qualcun altro, così saprete
cosa gli utenti vedono quando si iscrivono alla mailing list. 
Tenete questa copia a portata di mano così da poter rispondere alle domande riguardo alle 
funzionalità della mailing list, o ancora meglio mettetela su una pagina web da qualche parte.
In questo modo quando la gente perde la loro copia delle istruzioni e scrive per chiedere "Come mi
disiscrivo dalla mailing list?", possiate semplicemente passar loro l'URL.</para>

<para>Alcuni software di gestione offrono come opzione l'appendere le istruzioni
per la disiscrizione al fondo di ogni messaggio. Se tale opzione è disponibile, 
usatela. Provoca solo qualche riga in più ad ogni messaggio, in un posto che non dannoso, 
e può risparmiarvi molto tempo, riducendo il numero di persone che scrivono&mdash;o peggio,
scrivono alla mailing list!&mdash;chiedendo come disiscriversi.</para>

</sect2>

<!-- ========================== subsection =========================== -->
<sect2 id="reply-to">
<title>Il grande dibattito sul 'Rispondi A'</title>

<para>Prima, in <xref linkend="avoid-private-discussions"/>, ho sottolineato 
l'importanza di fare in modo che le discussioni avvengano sui forum pubblici, e
ho parlato di come misure sono a volte necessarie per prevenire che le conversazioni
finiscano in flussi di email private; inoltre, questo capitolo tratta di come configurare
il software di comunicazione del progetto per fargli fare al vostro posto la maggior
parte di lavoro possibile.
Quindi, se il software di gestione offre un modo di far rimanere in modo automatico le discussioni
nella mailing list, potreste pensare che abilitare questa funzionalità sia la scelta più ovvia.</para>

<para>Be', non proprio. Questa funzionalità esiste, ma ha alcuni importanti svantaggi. La domanda riguardante
il suo uso o meno è uno dei dibattiti più accesi nella gestione di mailing list&mdash;magari non la
notizia che compare sui giornali della sera, ma può comparire di tanto in tanto nei progetti di free software.
Più avanti, descriverò questa funzionalità, darò le argomentazioni a sostegno di entrambe le fazioni, e darò
il miglior consiglio che posso.</para>

<para>La funzionalità in sè è molto semplice: il software di gestione può, se volete, configurare 
automaticamente l'header Reply-to (Rispondi A) di ogni messaggio in modo da ridirigere le risposte sulla
mailing list. Cioè, nonostante cosa il mittente originale ha messo nell'header Reply-to (o anche se non è
stato incluso del tutto), al momento in cui gli iscritti vedono il messaggio, l'header conterrà l'indirizzo della
mailing list:</para>

<screen>
Reply-to: discuss@lists.example.org
</screen>

<para>A prima vista, sembra essere una buona cosa. Dato che virtualmente
ogni software di lettura mail presta attenzione all'header Reply-to, quando
chiunque risponde ad un messaggio, la risposta sarà automaticamente mandata
all'intera mailing list, non solo al mittente del messaggio a cui si è risposto.
Sicuramente, chi risponde può ancora cambiare a mano il destinatario, ma la cosa
importante è che <emphasis>per default</emphasis> le risposte sono mandate alla
mailing list. E' un esempio perfetto dell'uso della tecnologia per incoraggiare la collaborazione.</para>

<para>Sfortunatamente, ci sono alcuni svantaggi. Il primo è noto come
il problema del <firstterm>Non Riesco a Trovare la Strada di Casa</firstterm>:
a volte il mittente originale potrà mettere il proprio "vero" indirizzo email nel
campo Reply-to, perchè per una qualche ragione manda la mail da un indirizzo diverso
da quello dove lo riceve. La gente che legge e manda sempre dallo stesso indirizzo non ha
questo problema, e potrebbe essere sorpresa della sua esistenza.
Ma per chi ha configurazioni email particolari, o chi non può controllare come il suo indirizzo
mittente sarà composto (magari perchè scrivono dal lavoro e non hanno influenze sul dipartimento IT),
usare il Reply-to potrebbe essere l'unico modo che hanno per assicure che la risposta li raggiunga.
Quando una persona di questo genere scrive ad una mailing list a cui non è iscritto, la sua configurazione
del Reply-to diventa un'informazione essenziale. Se il software di gestione lo sovrascrive, potrebbe non
vedere mai la risposta al suo messaggio.</para>

<para>Il secondo svantaggio ha a che fare con le aspettative, e secondo la mia
opinione è l'argomento più potente contro l'occultamento del Reply-to.
La maggior parte degli utenti esperti di email sono abituati a due modi basilari
di risposta:<firstterm>rispondi a tutti (reply-to-all)</firstterm> e
<firstterm>rispondi all'autore (reply-to-author)</firstterm>.  
Tutti i moderni software di lettura mail hanno comandi separati per queste due azioni.
Gli utenti  sanno che per rispondere a tutti (quindi, includendo la mailing list), devono
scegliere reply-to-all, e che per rispondere privatamente all'autore, devono scegliere
reply-to-author.  
Anche se volete incoraggiare le persone a rispondere alla mailing list ogni volta sia possibile,
ci sono certe circostanze in cui una risposta privata è prerogativa di chi risponde&mdash;
per esempio, potrebbero volere dire qualcosa di confidenziale all'autore del messaggio originale,
qualcosa che potrebbe essere non appropriato per la mailing list pubblica.</para>

<para>Considerate ora cosa succede quando la mailing list sovrascrive il Reply-to
del mittente originale. Chi risponde schiaccia il tasto reply-to-author, aspettandosi
di mandare indietro un messaggio privato all'autore originale.
Dato che questo è il comportamento atteso, potrebbe non preoccuparsi di guardare
con attenzione all'indirizzo di destinazione nel nuovo messaggio. Scrive il suo messaggio privato
e confidenziale, uno in cui magari dice cose imbarazzanti riguardo a qualcuno della mailing list,
e schiaccia il tasto di invio.
Inaspettatamente, pochi minuti dopo il suo messaggio appare <emphasis>sulla
mailing list!</emphasis>. D'accordo, in teoria dovrebbe avere controllato al campo destinatario, e 
non dovrebbe aver presunto nulal riguardo all'header Reply-to.
Ma gli autori praticamente sempre mettono nel Reply-to il loro indirizzo personale ( o meglio il software
di posta lo fa per loro), e molti utilizzatori di email di lunga data se lo aspettano. Infatti, quando una
persona mette deliberatamente nel Reply-to qualche altro indirizzo, come la mailing list, solitamente
lo scrive nel corpo del messaggio, così che la gente non sarà sorpresa per cosa succede quando rispondono.</para>

<para>A causa delle conseguenze anche serie di questo comportamento inaspettato,
la mia personale preferenza è la configurazione del software di gestione della mailing
list in modo che non tocchi mai l'header Reply-to. Questo è un caso in cui usare la
tecnologia per incoraggiare la collaborazione ha, mi sembra, side-effect potenzialmente
pericolosi. In ogni caso, ci sono anche alcuni buoni argomenti nell'altra fazione del dibattito.
Qualunque modo sceglierete, ogni tanto troverete persone che scrivono sulla mailing list chiedendo
perchè non abbiate scelto l'altro modo. Dato che questo non è qualcosa che desideriate avere come 
argomento principale di discussione, potrebbe essere conveniente avere una risposta pronta preconfezionata,
del tipo che sia incline a fermare la discussione piuttosto che incoraggiarla.
Cercate di <emphasis>non</emphasis> insistere sul fatto che la vostra decisione, qualunque sia, è
ovviamente l'unica giusta e sensata (anche se pensate che sia così). Cercate invece di precisare che è un 
vecchio dibattito, che ci sono buone argomentazioni a favore di entrambe le fazioni, che nessuna scelta soddisferà
tutti gli utenti e quindi avete solo fatto la miglior decisione che potevate.
Educatamente chiedete che l'argomento non sia ripreso a meno che qualcuno abbia qualcosa di davvero nuovo da dire,
quindi stare fuori dalla discussione e sperare che muoia di morte naturale.</para>

<para>Qualcuno potrebbe suggerire una votazione per scegliere un modo piuttosto che un altro. Potete farlo se volete,
ma personalmente non penso che votare sia una soluzione soddisfacente in questo caso. La penalità per qualcuno che 
è sorpreso dal comportamento è così grande (mandare accidentalmente una email privata ad una mailing list pubblica) e
l'inconveniente per gli altri è talmente leggero (doversi ricordare qualche volta di rispondere a tutta la mailing list 
invece che solo a voi), che non è chiaro perchè la maggioranza, anche se rimane la maggioranza, dovrebbe essere in grado
di esporre la minoranza a tale rischio.</para>

<para>Non ho trattato tutti gli aspetti del problema qui, solo quelli che sembravano di primaria importanza.
Per una discussione completa, vedete questi due documenti 'canonici', che sono quelli che la gente cita sempre quando
affrontano questo dibattito:

<itemizedlist>
  <listitem>
     <para><emphasis role="bold">Leave Reply-to alone</emphasis>,
     <emphasis>by Chip Rosenthal</emphasis></para>
     <para><ulink
        url="http://www.unicom.com/pw/reply-to-harmful.html"/></para>
  </listitem>
  <listitem>
     <para><emphasis role="bold">Set Reply-to to list</emphasis>,
     <emphasis>by Simon Hill</emphasis></para>
     <para><ulink
        url="http://www.metasystema.net/essays/reply-to.mhtml"/></para>
  </listitem>
</itemizedlist>

</para>

<para>Nonostante la debole preferenza indicata sopra, non penso che ci sia una risposta
"giusta" a questo problema, e participo felicemente a molte mailing list che <emphasis>configurano</emphasis>
il Reply-to.  
La cosa più importante che possiate fare è di implementare un modo o l'altro da subito, cercando di non 
essere coinvolti in questo dibattito in seguito.</para>

<sect3 id="reply-fantasies">
<title>Due fantasie</title>

<para>Un giorno, qualcuno avrà la brillante idea di implementare un tasto
<firstterm>reply-to-list</firstterm> nel software di lettura posta.  
Userebbe qualcuno degli header menzionati prima per capire l'indirizzo della
mailing list, e quindi inviare la risposta direttamente alla mailing list soltanto,
lasciando fuori ogni altro indirizzo di destinatazione, dato che la maggior parte 
dei quali è comunque iscritto nella lista. Infine, altri software di email adotteranno
tale funzionalità e tutta questa discussione scomparirà. (Veramente, il sofware
di posta <ulink url="http://www.mutt.org/">Mutt</ulink>
offre questa funzionalità.<footnote><para>Poco dopo la pubblicazione di questo libro, 
<ulink url="http://www.michaelbernstein.com/"
>Michael Bernstein</ulink> mi scrisse per dirmi : "Ci sono altri software di mail
che implementano la funzionalità reply-to-list oltre a Mutt. Per esempio, Evolution 
ha questa funzionalità come scorciatoia da tastiera, ma non come bottone (Ctrl+L)."</para></footnote>)</para>

<para>Una soluzione persino migliore per l'occultamento del Reply-to sarebbe 
una preferenza del sottoscrittore. Coloro che vogliono la mailing list con il Reply-to nascosto potrebbero
chiederlo, e coloro che non lo vogliono potrebbero chiedere di lasciare il Reply-to com'è.
Comunque, non sono a conoscenza di nessun software di gestione di mailing list che offra
questa opzione per sottoscrittore. Per ora, pare di essere fermi ad un'impostazione di tipo globale.
<footnote><para>Da quando ho scritto ciò, ho saputo che c'è almeno un sistema di gestione che
offre tale funzionalità: <ulink url="http://siesta.unixbeard.net/">Siesta</ulink>.
Vedete anche questo articolo a riguardo:
<ulink url="http://www.perl.com/pub/a/2004/02/05/siesta.html"
/></para></footnote></para>

</sect3>

</sect2>

<!-- ========================== subsection =========================== -->
<sect2 id="archiving">
<title>Archiviazione</title>

<para>I dettagli tecnici della configurazione della mailing list sono specifici
rispetto al software che in uso, e sono fuori dall'ambito di questo libro.
Al momento della scelta o della configurazione dell'archiviatore, considerate 
queste caratteristiche:</para>

<variablelist>

  <varlistentry><term>Aggiornamento veloce</term>
    <listitem>
      <para>La gente a volte vuole far riferimento ad un messaggio in archivio
      inviato nell'ultima ora o due. Se possibile, l'archiviatore dovrebbe archiviare
      ogni messaggio istantaneamente, così che per il momento in cui il messaggio compare
      nella mailing list, è già presente negli archivi. Se questa opzione non è disponibile,
      cercate almeno di provare a fare in modo che l'archiviatore si aggiorni all'incirca ogni ora.
      (per default, alcuni archiviatori compiono i loro processi di aggiornamento una volta ogni notte,
      ma in pratica è tempo troppo ampio per una mailing list attiva)</para>
    </listitem>
  </varlistentry>

  <varlistentry><term>Stabilità referenziale</term>
    <listitem>
      <para>Una volta che un messaggio è memorizzato ad una particolare URL, dovrebbe rimanere accessibile
      a quella stessa URL per sempre, o per il maggior tempo possibile. Anche se gli archivi saranno ricostituiti,
      ristabiliti da backup o messi a posto in qualche altro modo, tutte le URL che sono già state rese pubblicamente
      disponibili dovrebbero rimanere invariate. Referenze stabili rendono possibile per i motori di ricerca Internet
      di indicizzare gli archivi, che è una manna per gli utenti in cerca di risposte. Referenze stabili sono
      anche importanti perchè il bug tracker spesso fa riferimento ai messaggi della mailing list (vedi
            <xref
            linkend="bug-tracker"/>)<phrase output="printed">
            più avanti in questo capitolo</phrase> o in documenti da altri progetti.</para>

      <para>Idealmente, il software di gestione della mailing list dovrebbe includere in un header quando
      distribuisce il messaggio ai destinatari, una URL di archiviazione del messaggio, o almeno una porzione della URL
       specifica per il messaggio. In questo modo la gente che ha una copia del messaggio possa essere in grado di sapere
       la sua collocazione nell'archivio senza dovere veramente visitare l'archivio, il che sarebbe d'aiuto
       dato che ogni operazione che coinvolge il proprio web browser automaticamente occupa del tempo.
       Non so se ogni software di gestione include tale funzionalità; sfortunatamente, quelli che ho usato no.
       Comunque, è qualcosa da cercare (o, se scrivete software per mailing list, è una funzionalità la cui implementazione
       è, per favore, da considerare).</para>
    </listitem>
  </varlistentry>

  <varlistentry><term>Backup</term>
    <listitem>
      <para>Dovrebbe essere ragionevolmente ovvio come fare il backup degli archivi, 
      e il modo di ristabilirli non dovrebbe essere troppo difficile. In altre parole, non
      trattate il vostro archiviatore come una scatola nera (black box). Voi (o qualcuno nel
      vostro progetto) deve sapere dove i messaggi sono memorizzati, e come rigenerare l'archivio corrente
      dal backup se dovesse essere necessario. Questi archivi sono dati preziosi&mdash;un progetto
      che li perde, perde una buona parte della sua memoria collettiva.</para>
    </listitem>
  </varlistentry>

  <varlistentry><term>Supporto ai thread</term>
    <listitem>
      <para>Dovrebbe essere possibile andare da ogni singolo messaggio al <firstterm>thread</firstterm> 
      (gruppo di messaggi correlati) di cui il messaggio originale fa parte. Ogni thread dovrebbe avere
      anche la propria URL, diversa dalle URL dei messaggi singoli che lo compongono.</para>
    </listitem>
  </varlistentry>

  <varlistentry><term>Ricercabilità</term>
    <listitem>
      <para>Un archiviatore che non supporta la ricerca&mdash;sui contenuti dei messaggi, così
      come sugli autori e oggetti&mdash;è praticamente inutile. Va notato che alcuni archiviatori
      supportano la ricerca semplicemente appoggiandosi per l'elaborazione su di un motore di ricerca
      esterno come<ulink
            url="http://www.google.com/">Google</ulink>. 
        Questo è accettabile, ma il supporto alla ricerca diretta è solitamente meglio rifinito, perchè permette
        a chi cerca, per esempio, di specificare che la chiave di ricerca appaio nell'oggetto piuttosto 
        che nel corpo del messaggio.</para>
    </listitem>
  </varlistentry>

</variablelist>

<para>Cosa scritto sopra è solo una lista di punti tecnici per aiutarvi a valutare e configurare un archiviatore.
Fare in modo che la gente davvero <emphasis>usi</emphasis> l'archiviatore per il bene del progetto, è discusso nei prossimi
capitoli, in particolare <xref linkend="using-archives"/>.</para>

</sect2>

<!-- ========================== subsection =========================== -->
<sect2 id="mailing-list-software">
<title>Software</title>

<para>Qui di seguito ci sono alcuni strumenti open source per gestire mailing list e archiviazione.
Se il sito dove è ospitato il vostro progetto ha già una configurazione di default, allora
potreste non avere mai bisogno di decidere sull'uso di nessun strumento.
Ma se dovete installarne uno da voi, ci sono alcune possibilità. Quelli che ho effettivamente
usato sono Mailman, Ezmlm,MHonArc, e Hypermail, ma questo non vuol dire che altri non siano pure 
buoni (e di sicuro ci saranno altri strumenti là fuori che non ho trovato, quindi non prendete questa
come una lista completa).</para>

<para>Software di gestione di mailing list:</para>

<itemizedlist>
 <listitem>
   <para><emphasis role="bold">Mailman</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://www.list.org/"/></para>
   <para>(contiene un archiviatore, e ha la possibilità di aggiungerne di esterni.)</para>
 </listitem>
 <listitem>
   <para><emphasis role="bold">SmartList</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://www.procmail.org/"/></para>
   <para>(Fatto per essere usato con il sistema di elaborazione email Procmail.)</para>
 </listitem>
 <listitem>
   <para><emphasis role="bold">Ecartis</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://www.ecartis.org/"/></para>
 </listitem>
 <listitem>
   <para><emphasis role="bold">ListProc</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://listproc.sourceforge.net/"/></para>
 </listitem>
 <listitem>
   <para><emphasis role="bold">Ezmlm</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://cr.yp.to/ezmlm.html"/></para>
   <para>(Progettato per lavorare con il sistema di consegna mail<ulink
         url="http://cr.yp.to/qmail.html">Qmail</ulink> )</para> 
 </listitem>
 <listitem>
   <para><emphasis role="bold">Dada</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://mojo.skazat.com/"/></para>
   <para>(Nonostante i bizzarri tentativi di nasconderlo,
         questo è free software, rilasciato sotto la licenza GNU General
         Public License.  Contiene anche un archiviatore.)</para>
 </listitem>
</itemizedlist>

<para>Software di archiviazione mailing list:</para>

<itemizedlist>
 <listitem>
   <para><emphasis role="bold">MHonArc</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://www.mhonarc.org/"/></para>
 </listitem>
 <listitem>
   <para><emphasis role="bold">Hypermail</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://www.hypermail.org/"/></para>
 </listitem>
 <listitem>
   <para><emphasis role="bold">Lurker</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://sourceforge.net/projects/lurker/"/></para>
 </listitem>
 <listitem>
   <para><emphasis role="bold">Procmail</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://www.procmail.org/"/></para>
   <para>(Software complementare a SmartList, questo è un sistema generale di processamento
   email che può, apparentemente, essere configurato con archiviatore.)</para>
 </listitem>
</itemizedlist>

</sect2>

</sect1>


<!-- ========================== SECTION =========================== -->
<sect1 id="vc">
<title>Controllo di versione</title>

<para>Un <firstterm>sistema di controllo di versione</firstterm>(version control system) (o
<firstterm>sistema di controllo di revisione</firstterm>) è una combinazione di tecnologie e procedure
per tenere traccia e controllare i cambiamenti dei file di un progetto, in particolare del codice sorgente,
della documentazione e delle pagine web. Se non avete mai usato il controllo di versione prima, la prima cosa
che dovreste fare è cercare qualcuno che l'abbia usato e coinvolgerlo nel vostro progetto. In questi tempi,
chiunque si aspetterà che almeno il codice sorgente del vostro progetto sia sotto controllo di versione, e 
probabilmente non prenderà il progetto seriamente se questo non usa il controllo di versione con
almeno le minime competenze.</para>

<para>La ragione per cui il controllo di versione è così universale è che aiuta potenzialmente ogni
aspetto della gestione di un progetto: comunicazioni tra sviluppatori, gestione dei rilasci, gestione
dei bug, stabilità del codice e tentativi di sviluppo sperimentali, e attribuzione e autorizzazione di
cambiamenti da parte di alcuni sviluppatori. Il controllo di versione mette a disposizione un centro di
coordinamento per tutte queste aree. Il cuore del controllo di versione è la 
a central coordinating force among all of these areas.  The core of <firstterm>gestione dei cambiamenti</firstterm>
(change management) che identifica ogni cambiamento apportato ai file del progetto, annotando ogni cambiamento con
metadati quali la data di modifica e l'autore e quindi replicando questi fatti a chiunque chieda, in qualunque
modo sia chiesto. E' un meccanismo di comunicazione dove un cambiamento è l'unità base di informazione.</para>

<para>Questa sezione non discute tutti gli aspetti dell'uso del controllo di versione. E' una cosa così
pervasiva che deve essere trattata per argomento lungo tutto il libro. Qui ci concentreremo sulla 
scelta e sulla configurazione di un sistema di controllo di versione in modo da incoraggiare lo sviluppo 
cooperativo.</para>

<!-- ========================== subsection =========================== -->
<sect2 id="vc-vocabulary">
<title>Vocabolario del controllo di versione</title>

<para>Questo libro non può insegnarvi come usare il controllo di versione se non l'avete
mai usato prima, ma sarebbe impossibile discuterne senza alcune parole chiave.
Queste parole sono utili indipendentemente da ogni sistema di controllo di versione: sono
i nomi e i verbi di base della collaborazione in rete, e saranno usati in modo generico
lungo il resto di questo libro. Anche se non ci fossero sistemi di controllo di versione,
il problema della gestione delle modifiche rimarrebbe, e queste parole ci forniscono un linguaggio
per parlare concisamente di questo problema.

<variablelist>

 <varlistentry id="vc-vocabulary-commit">
  <term><firstterm>commit</firstterm></term>
  <listitem><para>Fare una modifica al progetto; più formalmente, archiviare
  una modifica al progetto nel database del controllo di versione in modo che possa
  essere incluso nei futuri rilasci del progetto. "Commit" può essere usato come nome
  e come verbo. Come nome, è essenzialmente un sinonimo di "cambiamento". Per esempio:
  "Ho appena commitato una fiz per il crollo del server che gli addetti ai bug hanno segnalato
  su Mac OS X. Jay, potresti per favore rivedere il commit e controllare che lì non stia usando
  male l'allocatore?"</para></listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-log-message">
  <term><firstterm>messaggio di log</firstterm></term>
  <listitem><para>Un po' di commento allegato ad ogni commit, descrivendo la natura e lo scopo del 
  commit. I messaggi di log sono tra i documenti più importanti di ogni progetto: sono il ponte tra
  il linguaggio altamente tecnico dei cambiamenti individuali di codice e il linguaggio,più orientato all'utente,
  delle funzionalità, del fissaggio di bug e del progresso del progetto. Più avanti in questa sezione, vedremo
  modi di distribuire messaggi di log alla audience adeguataa; inoltre, <xref
  linkend="codifying-tradition"/><phrase output="printed"> in
  <xref linkend="communications"/></phrase> discute i modi per incoraggiare i contributori a
  scrivere messaggi di log concisi e utili.</para></listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-update">
  <term><firstterm>update</firstterm></term>
  <listitem><para>Richiedere che le modifiche (commit) degli altri siano inclusi 
  nella vostra copia locale del progetto; cioè rendere la vostra copia aggiornata.
  Questa operazione è molto comune; la maggior parte degli sviluppatori aggiornano
  il loro codice diverse volte al giorno, così da sapere che stanno usando all'incirca
  la stessa cosa degli altri sviluppatori, e così che se vedono un bug, possano essere 
  abbastanza sicuri che non sia stato già fissato. Per esempio:"Hey, ho notato che il
  codice di indicizzazione scarta sempre l'ultimo byte. Questo è un bug?" "Si, ma è 
  stato fissato la scorsa settimana&mdash;prova ad aggiornarti, dovrebbe sparire."</para></listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-repository">
  <term><firstterm>repository</firstterm></term> <listitem><para>
  Un database in cui sono memorizzate le modifiche. Alcuni sistemi di controllo
  di versione sono centralizzati: c'è un solo repository principale, che memorizza
  tutte le modifiche del progetto. Altri sono decentralizzati: ogni sviluppatore ha il proprio
  repository, e le modifiche sono scambiate arbitrariamente avanti e indietro tra i repository
  Il sistema di controllo di versione mantiene traccia delle dipendenze tra le modifiche, e quando
  è il momento del rilascio, un particolare insieme di modifiche viene approvato per il rilascio.
  La domanda su quale sia migliore tra i sistemi centralizzati e decentralizzati è
  una delle lunghe guerre sante dello sviluppo software; cercate di non cadere nella trappola
  di discuterne sulle mailing list del vostro progetto.</para></listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-checkout">
  <term><firstterm>checkout</firstterm></term>
  <listitem><para>Il processo di ottenere una copia del progetto da un repository.
  Un checkout solitamente produce un albero di directory chiamato "copia di lavoro"
  (vedi sotto), da cui le modifiche possono essere committate indietro al repository
  originale. In alcune versioni di sistemi di controllo decentralizzati, ogni copia
  di lavoro è essa stessa un repository, e i cambiamenti possono essere presi o richiesti
  da ogni repository che vuole accettarli.</para></listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-working-copy">
  <term><firstterm>copia di lavoro</firstterm></term>
  <listitem><para>L'albero di directory privato di uno sviluppatore
  contenente i file di codice sorgente del progetto, e possibilmente le sue pagine
  web e altri documenti. Una copia di lavoro contiene anche un po' di metadati gestiti
  dal sistema di controllo di versione, che dice alla copia di lavoro da quale repository
  viene, quali "revisioni" (vedi sotto) dei file sono presenti eccetera. Generalmente ogni 
  sviluppatore ha la sua copia di lavoro, in cui fa e prova modifiche, e da cui fa commit.</para></listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-revision">
  <term><firstterm>revisione</firstterm>,
        <firstterm>modifica</firstterm>,
        <firstterm>insieme di modifiche</firstterm></term>
  <listitem><para>Una "revisione" è solitamente un'incarnazione specifica
  di un particolare file o directory. Per esempio, se il progetto presenta
  la revisione 6 del file F, e poi qualcuno fa il commit di una modifica a F,
  ciò crea la revisione 7 di F. Alcuni sistemi usano anche "revisione","modifica",
  "insieme di modifiche" per riferirsi ad un insieme di modifiche comittate insieme
  come una unità concettuale.</para> 

  <para>Questi termini hanno occasionalmente significati tecnici distinti in diversi
  sistemi di controllo di versione, ma l'idea generale è sempre la stessa: danno modo
  di parlare in modo preciso di punti esatti nella storia di un file o di un insieme di file
  (per dire, immediatamente prima e dopo la riparazione di un bug). Per esempio : "Si, ha 
  fissato il bug nella versione 10" oppure "ha fissato il bug nella versione 10 del file foo.c"</para>

  <para>Quando si parla di un file o di una collezione di file senza specificare la revisione, generalmente
  si assume che si intenda la revisione più recente disponibile.</para></listitem>
 </varlistentry>

  <sidebar id="version-vs-revision">
  <title>"Versione" contro "Revisione"</title>
  <para>La parola <firstterm>versione</firstterm> è a volte usata come un sinonimo
  di "revisione", ma non la userò in questo libro, perchè è troppo facilmente confusa con 
  "versione" nel senso di una versione di un software&mdash;cioè, il rilascio o numero di edizione,
  come in "Versione 1.0". Tuttavia, dal momento che la frase "controllo di versione" è già standard, continuerò
  ad usarla come sinonimo di "controllo di revisione" e "controllo delle modifiche".</para>
  </sidebar>

 <varlistentry id="vc-vocabulary-diff">
  <term><firstterm>diff</firstterm></term>
  <listitem><para>Una rappresentazione testuale di una modifica. Una diff mostra
  quali righe sono state cambiate e come, più alcune righe del contesto attorno on entrambi i lati.
  Uno sviluppatore che è già familiare con un po' di codice può solitamente leggere una diff rispetto
  a quel codice e capire cosa ha fatto la modifica, e persino scoprire bug.</para></listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-tag">
  <term><firstterm>tag</firstterm></term>
  <listitem><para>Un'etichetta per un particolare insieme di file ad una specifica revisione.
  I tag sono solitamente usati per preservare "istantanee" interessanti del progetto. Per esempio,
  un tag è solitamente fatto per ogni pubblico rilascio, così che one possa ottenere, direttamente
  dal sistema di controllo di versione, l'insieme esatto dei file/revisioni compresi in quel rilascio.
  Nomi di tag comuni sono cose del tipo <literal>Release_1_0</literal>, <literal>Delivery_00456</literal>,
  eccetera.</para></listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-branch">
  <term><firstterm>Ramo (branch)</firstterm></term>
  <listitem><para>Una copia del progetto, sotto controllo di versione ma isolata,
  così che i cambiamenti fatti nel ramo non interferiscono con il resto
  del progetto e viceversa, tranne quando i cambiamenti sono deliberatamente uniti da
  un lato all'altro (vedi sotto). I rami sono anche noti come "linee di sviluppo".
  Anche se un progetto non ha rami specifici, lo sviluppo è comunque considerato
  accadere nel "ramo principale", detto anche "linea principale" o  
  "<firstterm>tronco</firstterm>"(trunk).</para>

  <para>i rami offrono un modo per isolare le diverse linee di sviluppo l'una
  dall'altra. Per esempio, un ramo può essere usato per sviluppo sperimentale che sarebbe
  troppo destabilizzante sul tronco principale. O al contrario, un ramo può essere usato come
  luogo per stabilizzare un nuovo rilascio. Durante il processo di rilascio, lo sviluppo
  regolare dovrebbe continuare ininterrotto nel tronco principale del repository; nel frattempo,
  nel ramo del rilascio, nessuna modifica è permessa tranne quelle approvate dal manager del rilascio.
  In questo modo, fare un rilascio non ha bisogno di interferire con lo sviluppo in corso. Vedi See <xref
  linkend="branches"/><phrase output="printed"> più avanti in quesot capitolo</phrase>
  per una discussione più dettagliata della ramificazione.</para></listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-merge">
  <term><firstterm>Unire(merge)</firstterm></term>
  <listitem><para>Spostare una modifica da un ramo ad un altro.
  Ciò include l'unione(merging) tra il tronco principale e qualche altro ramo o viceversa.
  Infatti, questi sono i tipi più comuni di union; è raro portare una modifica
  tra due rami non principali. Vedi <xref
  linkend="vc-singularity"/> per più dettagli su questo tipo di unione.</para>

  <para>"Unire" ha altro significato correlato: è ciò che il sistema di controllo
  di versione fa quando vede che due persone hanno cambiato lo stesso file ma in modo
  non contrastante. Dato che le due modifiche non interferiscono l'una con l'altra,
  quando una delle persone aggiorna la propria copia del file (che già contiene le proprie
  modifiche), le modifiche dell'altra persona saranno unite automaticamente. Questo è molto 
  comune, specialmente in progetti dove molte persone lavorano sullo stesso codice. Quando
  due modifiche diverse contrastano, il risultato è un "conflitto"; vedere sotto.</para>
  </listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-conflict">
  <term><firstterm>conflitto</firstterm></term>
  <listitem><para>Cosa succede quando due persone provano a fare modifiche diverse
  nello stesso punto del codice. Tutti i sistemi di controllo di versione trovano
  automaticamente i conflitti, e notificano ad almeno uno degli umani coinvolti che
  i suoi cambiamenti sono in conflitto con quelli di qualcun altro. E' quindi lasciato
  all'umano <firstterm>risolvere</firstterm> il conflitto, e comunicare la soluzione al
  sistema di controllo di versione.</para></listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-lock">
  <term><firstterm>Blocco</firstterm></term>
  <listitem><para>Un modo di dichiarare un'intenzione esclusiva di cambiare
  un certo file o directory. Per esempio, "Non posso fare il commit di tutti
  i cambiamenti alle pagine web ora. Sembra che Alfredo le abbia bloccate tutte
  mentre mette a posto le immagini di sfondo."
  Non tutte le versioni di sistemi di controllo offrono anche questa possibilità
  di blocco, e quelli che lo fanno, non tutti richiedono di usare questa funzionalità.
  Questo perchè lo sviluppo parallelo, simultaneo è la norma, e negare alla gente l'accesso
  ai file è (solitamente) contrario a questo ideale.</para>

  <para>I sistemi di controllo di versione che richiedono il blocco per fare i commit
  sono detti usare il modello <firstterm>blocca-modifica-sblocca</firstterm>(lock-modify-unlock).
  Un'ottima e profonda spiegazione e confronto dei due modelli può essere trovata qui <ulink
  url="http://svnbook.red-bean.com/svnbook-1.0/ch02s02.html"/>.
  In generale, il modello copia-modifica è migliore per lo sviluppo open source, e tutti i sistemi
  di controllo di versione discussi in questo libro supportano tale modello.</para></listitem>
 </varlistentry>

</variablelist>

</para>

</sect2>


<!-- ========================== subsection =========================== -->
<sect2 id="vc-choosing">
<title>Scegliere un sistema di controllo di versione</title>

<para>I due sistemi di controllo di versione più popolari nel mondo del free
software sono <firstterm>Concurrent Versions
System</firstterm> (<firstterm>CVS</firstterm>,
<ulink url="http://www.cvshome.org/"/>)
e <firstterm>Subversion</firstterm> (<firstterm>SVN</firstterm>,
<ulink url="http://subversion.tigris.org/"/>).</para>

<para>CVS c'è da molto tempo. La maggior parte degli sviluppatori esperti ne hanno
già familiarità, fa più o meno cosa di cui avete bisogno, e dal momento che è stato
popolare per molto tempo, probabilmente non finirete in nessun lungo dibattito sul fatto
che sia la scelta giusta o meno. Comunque, CVS ha alcuni svantaggi. Non fornisce un modo
semplice per riferirsi a modifiche che coinvolgono diversi file; non vi permette di rinominare
o copiare file sotto il controllo di versione (quindi se avete bisogno di riorganizzare il vostro 
albero del codice dopo l'inizio del progetto, può essere una vera sofferenza); ha un mediocre 
supporto al merging (unione); non maneggia molto bene grossi file o file binari; e alcune operazioni
sono lente quando un gran numero di file è coinvolto.</para>

<para>Nessuna delle crepe di CVS è fatale ed è tuttora abbastanza popolare.
Ad ogni modo, negli ultimi anni il più recente Subversion ha guadagnato terreno, soprattutto
nei progetti più nuovi.<footnote><para>Vedi <ulink url="http://cia.vc/stats/vcs"/> e
<ulink url="http://subversion.tigris.org/svn-dav-securityspace-survey.html"/>
per prove di questa crescita.</para></footnote>. Se state iniziando un nuovo progetto,
raccomando Subversion.</para>

<para>Dall'altro lato, dato che sono coinvolto nel progetto Subversion, la mia
oggettività può essere giustamente messa in discussione. E negli ultimi anni alcuni nuovi
sistemi di controllo open source hanno fatto la loro comparsa.  
<xref linkend="vc-systems"/> elenca tutti quelli di cui sono a conoscenza,
in un ordine approssimativo di popolarità. Come la lista mostra, decidere su
un sistema di controllo di versione può facilmente diventare un progetto di ricerca lungo una vita.
Magari vi risparmierete la decisione perchè sarà presa per voi dal sito che vi ospita. Ma se dovete scegliere,
consultatevi con gli altri sviluppatori, chiedete in giro per vedere con quale la gente ha esperienza, infine
prendetene uno e andate avanti con quello. Ogni sistema di controllo di versione stabile e pronto alla produzione
andrà bene; non dovete preoccuparvi troppo di fare una scelta totalmente sbagliata. Se proprio non riuscite a 
farvi un'idea, allora usate Subversion. E' abbastanza facile da imparare e probabilmente rimmarrà standard per almeno
un po' di anni.</para>

</sect2>


<!-- ========================== subsection =========================== -->
<sect2 id="vc-using">
<title>Usare un sistema di controllo di versione</title>

<para>I consigli di questa sezione non sono indirizzati a particolari versioni 
di sistemi di controllo di versione, e dovrebbero essere facili da implementare
in ognuno di loro. Consultate la documentazione specifica del vostro sistema di 
versione per i dettagli.</para>

<sect3 id="version-everything">
<title>Tenere tutto sotto controllo di versione</title>

<para>Tenere non solo il codice sorgente del vostro progetto sotto controllo di versione,
ma anche le sue pagine web, la documentazione, FAQ, note di progetto, e qualsiasi altra cosa che
la gente potrebbe voler modificare. Teneteli vicino al codice sorgente, nello stesso albero di
repository. Ogni brandello di informazione che valga la pena scrivere vale la pena mettere sotto
controllo&mdash;cioè ogni brandello di informazione che potrebbe cambiare. Cose che non
cambiano dovrebbero essere archiviate e non messe sotto controllo di versione. Per esempio, le email,
quando pubblicate, non cambiano (a meno che diventino parte di un documento più grande e in evoluzione).</para>

<para>La ragione per cui è importante mettere tutto insieme cio che è sotto controllo di versione è che in questo modo 
la gente deve imparare solo un meccanismo per inviare le modifiche. Qualche volta un contributore 
inizierà con l'apportare modifiche a pagine web o alla documentazione, spostandosi su piccoli contributi di
codice in un secondo momento, per esempio. Quando il progetto usa lo stesso sistema per ogni tipo di contribuzione,
la gente deve imparare solo una volta. Inoltre le nuove funzionalità possono essere contribuite insieme con le modifiche
alla documentazione, fare il branching del codice farà fare il branch anche alla documentazione eccetera.</para>

<para>Non tenete i <firstterm>file generati</firstterm>(generated files) sotto controllo di
versione. Non sono dati veramente editabili, dato che sono generati programmaticamente
da altri file. Per esempio, alcuni sistemi di build creano dei <filename>configure</filename> 
basati sul template<filename>configure.in</filename>.  Per fare un cambiamento al <filename>configure</filename>,
bisognerebbe cambiare il <filename>configure.in</filename> e poi rigenerare; quindi solo il
template <filename>configure.in</filename> è un "file editabile".
Mettete sotto controllo di versione solo i template&mdash;se lo fate anche con i file generati, la gente
si dimenticherà inevitabilmente di rigenerare quando fanno il commit di una modifica al template, e le 
inconsistenze risultanti causeranno confusione a non finire.<footnote><para>Per una differente opinione
sulla questione dei file<filename>configure</filename>, vedete il post di Alexey Makhotkin "<citetitle>configure.in and version
control</citetitle>" qui
<ulink url="http://versioncontrolblog.com/2007/01/08/configurein-and-version-control/"/>.</para></footnote></para>

<para>La regola che tutti i dati editabili vadano tenuti sotto controllo di versione
ha una sfortunata eccezione: il tracciatore dei bug. I database di bug contengono una
gran quantità di dati editabili, ma per ragioni tecniche generalmente non possono
memorizzare questi dati nel sistema di controllo principale. ( Comunque, alcuni tracciatori
hanno funzionalità di versionamento primitive, indipendenti dal repository principale del progetto.)</para>

</sect3>

<sect3 id="vc-browsing">
<title>Navigabilità</title>

<para>Il repository del progetto dovrebbe essere navigabile sul web. Questo non 
significa solo la possibilità di vedere le ultime revisioni dei file del progetto,
ma di andare indietro nel tempo e vedere le versioni precedenti, vedere le differenze
tra le revisioni, leggere i messaggi di log per le modifiche selezionate eccetera.</para>

<para>La navigabilità è importante perchè è un portale leggero verso i dati del progetto.
Se il repository non può essere visto attraverso un browser web, allora qualcuno che vuole
esaminare un file particolare (per esempio, per vedere se una certa fix è stata fatta in quel codice)
dovrebbe prima installare localmente il software del client del controllo di versione, il che 
muterebbe la semplice richiesta da un'attività di due minuti in una da mezz'ora o più.</para>

<para>La navigabilità implica anche URL canoniche per vedere le specifiche revisioni dei file,
 e per vedere le ultime revisioni in ogni momento. Questo può essere molto utile nelle discussioni
 tecniche o quando si rimanda la gente alla documentazione. Per esempio, invece di dire "Per 
 suggerimenti sul debugging del server. vedi il file www/hacking.html nella tua copia di lavoro,"
 uno può dire "Per suggerimenti sul debugging del server, vedi
<emphasis>http://svn.collab.net/repos/svn/trunk/www/hacking.html</emphasis>,"
dando una URL che punti sempre all'ultima revisione del file<filename>hacking.html</filename>.  
L'URL è meglio perchè è totalmente non ambigua, ed evita la questione sul fatto che
il destinatario abbia o meno una copia di lavoro aggiornata.</para>

<para>Alcuni sistemi di controllo di versione includono meccanismi precostitutiti di navigazione
 del repository, mentre altri si affidano a strumeti di terze parti. Tre di tali strumenti sono
 <firstterm>ViewCVS</firstterm> (<ulink url="http://viewcvs.sourceforge.net/"/>),
<firstterm>CVSWeb</firstterm> (<ulink
url="http://www.freebsd.org/projects/cvsweb.html"/>), e
<firstterm>WebSVN</firstterm> (<ulink
url="http://websvn.tigris.org/"/>).  Il primo funziona sia con CVS che con Subversion, il 
secondo con CVS soltanto, e il terzo solo con Subversion.</para>

</sect3>

<sect3 id="commit-emails">
<title>Email di commit</title>

<para>Ogni commit sul repository dovrebbe generare un email che mostra 
chi ha fatto le modifiche, quando, quali file e directory sono cambiati,
e come sono cambiate.  L'email dovrebbere essere mandata su una speciale mailing list
dedicata alle email di commit, separata dalle altre mailing list a cui la gente scrive.
Gli sviluppatori e le altre parti interessate dovrebbero essere incoraggiati a sottoscrivere
la mailing list dei commit, dato che è il modo più efficace per stare dietro a cosa sta
succedendo nel progetto al livello del codice. Oltre dagli ovvi benefici tecnici della revisione
di pari (peer review) (see <xref linkend="code-review"/>), le email di commit aiutano a creare
un senso di comunità perchè stabiliscono un ambiente condiviso in cui la gente può reagire agli
eventi (i commit) che sanno essere visibili anche ad altri.</para>

<para>Le specifiche su come creare le email di commit cambieranno a seconda della vostra
versione di sistema di controllo di versione, ma solitamente c'è uno script o qualcosa di
già preparato per farlo.
Se state avendo problemi a trovarlo, provate a guardare la documentazione sugli 
<firstterm>hooks</firstterm>(uncini),
in particolare il <firstterm>post-commit hook</firstterm>, detto anche il
<firstterm>hook loginfo</firstterm>in CVS.  Gli hook post-commit sono strumenti generali
per il lancio di attività automatiche in risposta ai commit. L'hook è lanciato da un commit individuale,
viene fornito di tutta l'informazione sul commit, ed è poi libero di usare questa informazione per fare
qualcosa&mdash;per esempio, mandare un'email.</para>

<para>Con sistemi di email di commit pre-confezionata, potreste volere
modificare qualcuno dei loro comportamenti di defult:</para>

<orderedlist>

  <listitem>
  <para>Alcuni sistemi non includono i diff nella mail, ma invece
  forniscono una URL per vedere le modifiche sul web usando il sistema
  di navigazione del repository. Mentre è bene fornire la URL, così che si
  possa fare riferimento alle modifiche anche in seguito, è anche 
  <emphasis>molto</emphasis> importante che le email di commit includano 
  i diff stessi. Leggere le email è già parte delle abitudini della
  gente, quindi se il contenuto della modifica è visibile proprio lì nella
  email di commit, gli sviluppatori esamineranno il commit al volo, senza
  lasciare il loro programma di lettura di posta. Se devono cliccare su di
  una URL per esaminare le modifiche, la maggior parte non lo farà, perchè
  richiede una nuova azione invece di continuare quella che stanno già facendo.
  Inoltre, se il revisore vuole chiedere qualcosa riguardo alla modifica, è 
  molto più semplice premere il tasto di risposta con testo e annotare il
  diff in questione rispetto alla visita di una pagina web e laboriosamente
  fare copia e incolla di parti del diff dal browser web al programma di email.</para>

  <para>(Ovviamente, se il diff è grande, come quando una gran quantità di nuovo
  codice è stato aggiunto al repository, allora ha senso omettere il diff e offrire
  solo la URL. La maggior parte dei sistemi possono fare automaticamente questo tipo
  di limitazione. Se il vostro non può, allora è in ogni caso meglio includere i diff,
  e vivere con l'occasionale mail smisurata, piuttosto che lasciare del tutto fuori
  i diff. La revisione e il commento sono la pietra angolare dello sviluppo cooperativo,
  troppo importante per farne a meno.)</para>
  </listitem>

  <listitem><para>Le email di commit devono avere l'header Reply-to impostato sulla
  normale mailing list di sviluppo, non sulla mailing list dei commit.
  Cioè quando qualcuno esamina un commit e scrive una risposta, tale risposta
  deve essere automaticamente diretta alla mailing list di sviluppo, dove
  le questioni tecninche sono solitamente discusse. Ci sono alcune ragioni per 
  questo. Primo, vorrete tenere tutte le discussioni tecniche su una mailing list,
  perchè è ciò che la gente si aspetta, e per mantenere un solo archivio di ricerca.
  Secondo, ci potrebbero essere parti interessate non iscritte alla mailing list di 
  commit. Terzo, la mailing list di commit si presenta come un servizio per vedere i 
  commit, non per vedere commit <emphasis>e</emphasis> occasionali discussioni
  tecniche. Chi ha sottoscritto la mailing list di commit l'ha fatto per nient'altro
  che le email di commit; mandare loro altro materiale attraverso la mailing list
  violerebbe un contratto implicito. Quarto, la gente spesso scrive programmi che leggono 
  le email di commit e processano i risultati (per esempio per mostrarli su una pagina
  web). Questi programmi sono fatti per gestire email di commit formattate in maniera
  consistente, non email scritte senza formattazione da umani.</para>

  <para>Notate che questo consiglio di impostare il Reply-to non contraddice le
  raccomandazioni fatte in <xref linkend="reply-to"/><phrase output="printed"> precedentemente
  in questo capitolo</phrase>. Va sempre bene per il <emphasis>mittente</emphasis> di un messaggio
  impostare il Reply-to. In questo caso, il mittente è il sistema stesso
  di controllo di versione, e imposta il Reply-to per indicare che il posto adeguato per rispondere
  è la mailing list di sviluppo e non quella di commit.</para>

  </listitem>

</orderedlist>

<sidebar id="cia">
<title>CIA: un altro meccanismo di pubblicazione delle modifiche</title>

<para>Le email di commit non sono il solo modo di propagare le notizie di modifica.
Recentemente, è stato sviluppato un altro meccanismo chiamato CIA (<ulink
url="http://cia.navi.cx/"/>).  CIA è un aggregatore e distributore di statistiche 
di commit in tempo reale. L'uso più diffuso di CIA è l'invio di notifiche di commit 
ai canali IRC, così che la gente loggata in questi canali vede succedere i commit
in tempo reale. Anche se una utility in qualche modo meno tecnica delle email di commit, 
dato che gli osservatori possono o meno essere lì quando una notifica compare in IRC,
questa tecnica è una grandissima <emphasis>social</emphasis> utility.
La gente ha la sensazione di essere parte di qualcosa di
vivo e attivo e sente che possono vedere fare il progresso proprio di fronte ai loro occhi.</para>

<para>Il modo in cui funziona è l'invocazione di CIA dal vostro hook di post-commit.
Il notificatore formatta le informazioni di commit in un messaggio XML, e invia ad un
server centrale (tipicamente <literal>cia.navi.cx</literal>). Questo server quindi distribuisce
le informazioni di commit agli altri forum.</para>

<para>CIA può anche essere configurato per mandare feed <ulink
url="http://www.xml.com/pub/a/2002/12/18/dive-into-xml.html">RSS</ulink>. 
Vedete la documentazione qui<ulink url="http://cia.navi.cx/"/>
per dettagli.</para>

<para>Per vedere un esempio di CIA in azione, impostate il vostro client IRC a <literal>irc.freenode.net</literal>, canale
<literal>#commits</literal>.</para>

</sidebar>

</sect3>

<sect3 id="branches">
<title>Use branch per evitare colli di bottiglia</title>

<para>Gli utenti non esperti del controllo di versione sono a volte 
un po' spaventati da branch e merge. Questo è probabilmente uno degli
effetti secondari della popolarità di CVS: la sua interfaccia per branch
e merge è in qualche modo controintuitiva, così molta gente ha imparato
ad evitare totalmente queste operazioni.</para>

<para>Se siete tra queste persone, decidetevi ora a sconfiggere ogni paura
che possiate avere e prendetevi tempo per imparare come fare branch e merge.
Non sono operazioni difficili, una volta che vi siete abituati, e diventano
sempre più importanti man mano che il progetto acquista più sviluppatori.</para>

<para>I branch sono preziosi perchè fanno diventare una risorsa scarsa
&mdash;una stanza di lavoro nel codice del progetto&mdash;in una abbondante.
Normalmente, tutti gli sviluppatori lavorano assieme nello stesso ambiente,
costruendo lo stesso castello. Quando qualcuno vuole aggiungere un nuovo
ponte levatoio, ma non può convincere tutti gli altri che sia un miglioramento,
fare un branch render possibile spostarsi in un angolo e provare. Se lo sforzo
ha successo, può invitare altri sviluppatori ad esaminare il risultato.
Se tutti sono d'accordo che il risultato è buono, possono dire al sistema
di controll di versione di spostare (merge) il ponte levatoio dal castello branch
a quello principale.</para>

<para>E' facile vedere come questa possibilitò aiuti lo sviluppo collaborativo.
La gente ha bisogno della libertà di provare nuove cose senza sentirsi come
se stessero interferendo con il lavoro degli altri. Altrettanto importante,
ci sono volte in cui il codice ha bisogno di essere isolato dalla solita
pentola, per fissare un bug o stabilizzare una release (vedi
 <xref linkend="stabilizing-a-release"/> e 
<xref linkend="release-lines"/><phrase output="printed"> in
<xref linkend="development-cycle"/></phrase>) senza preoccuparvi del 
tracciamento di un bersaglio mobile.</para>

<para>Usate liberamente i branch, e incoraggiate gli altri ad usarli.
Ma accertatevi anche che un dato branch sia solo attivo soltanto per il tempo
necessario. Ogni branch è una piccola falla nell'attenzione della comunità.
Anche coloro che non stanno lavorando in un branch mantengono comunque una
visione periferica di cosa stia succedendo. Tale visione è sicuramente desiderabile,
e le email di commit dovrebbero essere mandate per i commit del branch come per ogni
altro commit. Ma i branch non devono diventare un meccanismo per dividere la 
comunità di sviluppo. Con rare eccezioni, il fine di molti branch dovrebbe
essere qiello di fare il merge delle modifiche con il tronco principale e scomparire.</para>

</sect3>

<sect3 id="vc-singularity">
<title>Singolarità dell'informazione</title>

<para>Fare merge ha un importante corollario: non bisogna mai fare commit
della stessa modifica due vole. Cioè, una certa modifica deve entrare nel
sistema di controllo di versione  esattamente una volta sola. La revisione (o 
insieme di revisioni) in cui la modifica è entrata a fare parte è il suo unico
identificatore da ora in poi. Se ha bisogno di essere applicata a branch diversi
da quello in cui è entrata, allora dovrebbe essere unita (merge) dal suo punto
originale di ingresso a queste altre destinazioni&mdash;in maniera opposta al commit di
una modifica testualmente identica, che avrebbe lo stesso effetto sul codice, ma 
renderebbe l'archiviazione e la gestione dei rilasci impossibili.</para>

<para>Gli effetti pratici di questo consiglio cambiano da un sistema di controllo
di versione all'altro. In alcuni sistemi, i merge sono eventi speciali, fondamentalmente
diversi dai commit, e portano con loro particolari metadati. In altri, i risultati del 
merge sono committati allo stesso modo delle altre modifiche, tanto che lo strumento
principale per distinguere un merge da un modifica è il messaggio di log. Nel messaggio
di log di un merge, non ripetete il messaggio log della modifica originale. Invece, indicate
solo che questo è un merge, e fornite la revisione che identifica la modifica originale,
con al massimo un sommario di una frase sul suo effetto. Se qualcuno vuole vedere il messaggio
di log intero, dovrà consultare la revisione originale.</para>

<para>La ragione per cui è importante evitare la ripetizione dei
messaggi di log è che questi messaggi sono spesso modificati dopo
che il commit è stato fatto. Se il messaggio di log di una modifica
è ripetuto ad ogni destinazione di un merge, allora anche se qualcuno
modificato il messaggio originale, lascierà tutte le ripetizioni non 
corrette&mdash;il che causerebbe solo confusione strada facendo.</para>

<para>Lo stesso principio vale per il disfacimento di una modifica. Se una modifica
viene tolta dal codice, allora il messaggio di log per la revisiona deve solo 
dire che qualche specifica revisione è stata disfatta,
<emphasis>non</emphasis> descrivere i cambi nel codice che risultano
dalla revisione, dato che la semantica della modifica può essere ottenuta
leggendo il messaggio di log e la modifica originali. Di certo il messaggio
di log della revisione deve anche spiegare la ragione per cui la modifica è stata
annullta, ma non deve riprendere nulla del messaggio di log originale della modifica.
Se possibile, tornate indietro e modificate il messaggio di log originale della modifica
per puntualizzare che è stata annullata.</para>

<para>Tutto ciò di cui sopra implicca che dovreste usare una sintassi
consistente per fare riferimento alle revisioni. Ciò è utile non solo nei messaggi di log,
ma anche nelle email, nel tracciatore di bug, e da ogni altra parte. Se state usando CVS,
suggerisco "<literal>path/to/file/in/project/tree:REV</literal>",
dove REV è il numero di revisione CVS tipo "1.76".  Se state usando
Subversion, la sintassi standard per la revisione 1729 è "r1729" (i path dei file
non sono necessari perchè Subversion usa numeri di revisione globali).
In altri sistemi, cìè solitamente una sintassi standard per esprimere il nome degli 
insiemi di modifiche. Qualunque sia la sintassi appropriata per il vostro sistema,
incoraggiate la gente ad usarla quando fa riferimento alle modifiche.
Espressioni consistenti di nomi delle modifiche rende la gestione del progetto molto più facile (come
vedremo in <xref linkend="communications"/> e
<xref linkend="development-cycle"/>), e dato che buona parte della gestione
sarà svolta da volontari, deve essere il più semplice possibile.</para>

<para>Vedi anche
<xref
linkend="releases-and-daily-development"/><phrase
output="printed"> in
<xref linkend="development-cycle"/></phrase>.</para>

</sect3>

<sect3 id="vc-authz">
<title>Autorizzazione</title>

<para>La maggior parte dei sistemi di controllo di versione offre una funzionalità dove
a certe persone può essere permesso o vietato fare il commit in specifiche sotto-aree
del repository. Seguendo il principio che quando la gente quando ha un martello in mano,
si guarda attorno per cercare i chiodi, molti progetti usano questa opzione senza remore,
prudentemente lasciando accesso alla gente solo alle aree in cui un loro commit è approvato,
e cercando di essere sicuri che non facciano commit da nessun'altra parte. (Vedi
<xref linkend="committers"/><phrase output="printed"> in
<xref linkend="managing-volunteers"/></phrase> per come i progetti decidono chi può
fare commit dove.)</para>

<para>E' probabilmente un po' doloroso esercitare un così stretto controllo,
ma una potica più rilassata va anche bene. Alcuni progetti semplicemente
usano un sistema d'onore: quando ad una persona viene riconosciuto l'accesso per il commit,
anche per sotto-aree del repository, cosa questa veramente riceve è una password che
permette di fare commit ovunque nel progetto.
Gli è solamente rischiesto di limitare i commit a quell'area. Ricordate che non c'è nessun rischio qui:
in un progetto attivo, tutti i commit sono esaminati in ogni caso. Se qualcuno fa un commit che non
deve, gli altri lo vedranno e diranno qualcosa. Se una modifica deve essere disfatta,è abbastanza semplice&mdash;
tutto è comunque sotto controllo di versione quindi basta invertire.</para>

<para>Ci sono diversi vantaggi nell'approccio rilassato. Primo, dato che gli sviluppatori
si allargono in altre aree (cosa che solitamente succede se rimangono nel progetto), non c'è
nessuno sforzo amministrativo per garantire loro privilegi più ampi. Una volta che la decisione
è fatta, la persona deve solo iniziare a fare commit nella nuova area.</para>

<para>Secondo, questo allargamento può essere fatto in modo più fine. Generalmente,
uno che fa commit in area X che vuole allargarsi nell'area Y inizierò pubblicando
patch su Y e chiedendone revisione. Se qualcuno che già ha l'accesso per fare commit 
in Y vede la patch e la approva, si può semplicemente dire a chi l'ha sottomessa di 
fare il commit della modifica direttamente (menzionando il nome di chi l'ha ricevuta/approvata 
nel messaggio, ovviamente). In questo modo, il commit verrà dalla persona che ha fisicamente
scritto la modifica, il che è preferibile sia dal punto di vista di gestione dell'informazione
che dal punto di vista del riconoscimento.</para>

<para>Infine, e forse più importante, usare il sistema d'onore incoraggia un'atmosfera di
fiducia e mutuo rispetto. Dare a qualcuno l'accesso per il commit in un sottodominio è 
un'affermazione sulla sua preparazione tecnica&mdash;come dire: "Vediamo che hai le conoscenze
per fare commit in un certo dominio, quindi fallo". Ma imporre uno stretto controllo di autorizzazione
dice: "Non solo stabiliamo un limite alle tue capacità, ma siamo anche un po' sospettosi sulle tue 
<emphasis>intenzioni</emphasis>." Questo non è il tipo di affermazione che volete fare se potete
evitarlo. Portare qualcuno che fa commit nel progetto è un'opportunità per introdurli al circolo
della fiducia reciproca. Un buon modo per fare ciò e dare loro più potere di quello che dovrebbero
usare, e poi informarli che sta a loro rimanere nei limiti accordati.</para>

<para>Il progetto Subversion ha lavorato con il sistema d'onore per più
di quattro anni, con 33 persone che potevano fare commit ovunque e 43 limitatamente.
L'unica distinzione che il sistema applicava è tra chi fa commit e chi no; ulteriori
sottodivisioni sono mantenute solo dagli umani. Comunque non abbiamo mai avuto un
problema con qualcuno che deliberatamente faceva commit fuori dal proprio dominio. Una
o due volte ci sono stati degli innocenti equivoci riguardo ai limiti dei privilegi di commit,
ma sono sempre stati risolti velocemente e amichevolmente.</para>

<para>Ovviamente in situazioni in cui l'autoregolamentazione non è possibile,
dovete affidarvi a severi controlli di autorizzazione. Ma tali situazioni 
sono rare. Anche quando ci sono milioni di righe di codice e centinaia o migliaia
di sviluppatori, un commit su qualunque modulo del codice dovrebbe comunque
verificato da chi lavora su quel modulo, e possono riconoscere se qualcuno
ha fatto il commit senza esserne autorizzato. Se la regolare revisione dei 
commit <emphasis>non</emphasis> funziona, allora il progetto ha problemi più
grandi da affrontare piuttosto che il sistema di autorizzazione.</para>

<para>Riassumendo, non spendete troppo tempo armeggiando con il sistema
di autorizzazione del controllo di versione, a meno che non abbiate delle
specifiche ragioni per farlo. Solitamente non poterà molti vantaggi tangibili,
mentre invece ci sono vantaggi nell'affidarsi al controllo umano.</para>

<para>Di sicuro niente di ciò vuole dire che le limitazioni in sè non sono importanti.
Sarebbe male per un progetto incoraggiare le persone a fare commit in aree in cui
non sono qualificate. Inoltre, in molti progetti un accesso pieno (non limitato) ai
commit ha uno stato speciale: implica diritti di voto su questioni riguardanti il
progetto intero. Questo aspetto politico del commit è discusso in <xref
linkend="electorate"/><phrase output="printed"> in
<xref linkend="social-infrastructure"/></phrase>.</para>

</sect3>

</sect2>

</sect1>


<!-- ========================== SECTION =========================== -->
<sect1 id="bug-tracker">
<title>Il Tracciatore di Errori</title>

<para>Bug tracking is a broad topic; various aspects of it are
discussed throughout this book.  Here I'll try to concentrate mainly
on setup and technical considerations, but to get to those, we have to
start with a policy question: exactly what kind of information should
be kept in a bug tracker?</para>

<para>The term <firstterm>bug tracker</firstterm> is misleading.  Bug
tracking systems are also frequently used to track new feature
requests, one-time tasks, unsolicited patches&mdash;really anything
that has distinct beginning and end states, with optional transition
states in between, and that accrues information over its lifetime.
For this reason, bug trackers are also called <firstterm>issue
trackers</firstterm>, <firstterm>defect trackers</firstterm>,
<firstterm>artifact trackers</firstterm>, <firstterm>request
trackers</firstterm>, <firstterm>trouble ticket systems</firstterm>,
etc.  See <xref linkend="bug-trackers"/> for a list of software.
</para>

<para>In this book, I'll continue to use "bug tracker" for the
software that does the tracking, because that's what most people call
it, but will use <firstterm>issue</firstterm> to refer to a single
item in the bug tracker's database.  This allows us to distinguish
between the behavior or misbehavior that the user encountered (that is,
the bug itself), and the tracker's <emphasis>record</emphasis> of the
bug's discovery, diagnosis, and eventual resolution.  Keep in mind
that although most issues are about actual bugs, issues can be used to
track other kinds of tasks too.</para>

<para>The classic issue life cycle looks like this:

<orderedlist>
  <listitem><para>Someone files the issue.  They provide a summary, an
            initial description (including a reproduction recipe, if
            applicable; see
            <xref
            linkend="users-to-volunteers"/><phrase
            output="printed"> in
            <xref linkend="managing-volunteers"/></phrase> for
            how to encourage good bug reports), and whatever other
            information the tracker asks for.  The person who files
            the issue may be totally unknown to the project&mdash;bug
            reports and feature requests are as likely to come from
            the user community as from the developers.</para>

            <para>Once filed, the issue is in what's called an
            <firstterm>open</firstterm> state.  Because no action has
            been taken yet, some trackers also label it as
            <firstterm>unverified</firstterm> and/or
            <firstterm>unstarted</firstterm>.  It is not assigned to
            anyone; or, in some systems, it is assigned to a fake
            user to represent the lack of real assignation.  At this
            point, it is in a holding area: the issue has been
            recorded, but not yet integrated into the project's
            consciousness.</para>
  </listitem>
  <listitem><para>Others read the issue, add comments to it, and
            perhaps ask the original filer for clarification on some
            points.</para>
  </listitem>
  <listitem><para>The bug gets <firstterm>reproduced</firstterm>.
            This may be the most important moment in its
            life cycle.  Although the bug is not actually fixed yet,
            the fact that someone besides the original filer was able
            to make it happen proves that it is genuine, and, no less
            importantly, confirms to the original filer that they've
            contributed to the project by reporting a real bug.</para>
  </listitem>
  <listitem><para>The bug gets <firstterm>diagnosed</firstterm>: its
            cause is identified, and if possible, the effort required
            to fix it is estimated.  Make sure these things get
            recorded in the issue; if the person who diagnosed the
            bug suddenly has to step away from the project for a
            while (as can often happen with volunteer developers),
            someone else should be able to pick up where she left
            off.</para>

            <para>In this stage, or sometimes the previous one, a
            developer may "take ownership" of the issue and
            <firstterm>assign</firstterm> it to herself (<xref
            linkend="delegation-assignment"/><phrase
            output="printed"> in
            <xref linkend="managing-volunteers"/></phrase>
            examines the assignment process in more detail).  The issue's
            <firstterm>priority</firstterm> may also be set at this
            stage.  For example, if it is so severe that it should
            delay the next release, that fact needs to be identified
            early, and the tracker should have some way of noting
            it.</para>
  </listitem>
  <listitem><para>The issue gets scheduled for resolution.
            Scheduling doesn't necessarily mean naming a date by which
            it will be fixed.  Sometimes it just means deciding which
            future release (not necessarily the next one) the bug
            should be fixed by, or deciding that it need not block any
            particular release.  Scheduling may also be dispensed
            with, if the bug is quick to fix.</para>
  </listitem>
  <listitem><para>The bug gets fixed (or the task completed, or
            the patch applied, or whatever).  The change or set of
            changes that fixed it should be recorded in a comment in
            the issue, after which the issue is
            <firstterm>closed</firstterm> and/or marked as
            <firstterm>resolved</firstterm>.</para>
  </listitem>
</orderedlist>

</para>

<para>There are some common variations on this life cycle.  Sometimes
an issue is closed very soon after being filed, because it turns out
not to be a bug at all, but rather a misunderstanding on the part of
the user.  As a project acquires more users, more and more such
invalid issues will come in, and developers will close them with
increasingly short-tempered responses.  Try to guard against the
latter tendency.  It does no one any good, as the individual user in
each case is not responsible for all the previous invalid issues; the
statistical trend is visible only from the developers' point of view,
not the user's.  (In
<xref linkend="bug-filtering"/><phrase output="printed"> later
in this chapter,</phrase> we'll look at
techniques for reducing the number of invalid issues.)  Also, if
different users are experiencing the same misunderstanding over and
over, it might mean that that aspect of the software needs to be
redesigned.  This sort of pattern is easiest to notice when there is
an issue manager monitoring the bug database; see
<xref linkend="issue-manager"/><phrase output="printed"> in
<xref linkend="managing-volunteers"/></phrase>.</para>

<para>Another common life cycle variation is for the issue to be closed
as a <firstterm>duplicate</firstterm> soon after Step 1.  A duplicate
is when someone files an issue that's already known to the project.
Duplicates are not confined to open issues: it's possible for a bug to
come back after having been fixed (this is known as a
<firstterm>regression</firstterm>), in which case the preferred course
is usually to reopen the original issue and close any new reports as
duplicates of the original one.  The bug tracking system should keep
track of this relationship bidirectionally, so that reproduction
information in the duplicates is available to the original issue, and
vice versa.</para>

<para>A third variation is for the developers to close the issue,
thinking they have fixed it, only to have the original reporter reject
the fix and reopen it.  This is usually because the developers simply
don't have access to the environment necessary to reproduce the bug,
or because they didn't test the fix using the exact same reproduction
recipe as the reporter.</para>

<para>Aside from these variations, there may be other small details of
the life cycle that vary depending on the tracking software.  But the
basic shape is the same, and while the life cycle itself is not
specific to open source software, it has implications for how open
source projects use their bug trackers.</para>

<para>As Step 1 implies, the tracker is as much a public face of the
project as the mailing lists or web pages.  Anyone may file an issue,
anyone may look at an issue, and anyone may browse the list of currently
open issues.  It follows that you never know how many people are
waiting to see progress on a given issue.  While the size and skill of
the development community constrains the rate at which issues can be
resolved, the project should at least try to acknowledge each issue the
moment it appears.  Even if the issue lingers for a while, a response
encourages the reporter to stay involved, because she feels that a
human has registered what she has done (remember that filing an
issue usually involves more effort than, say, posting an email).
Furthermore, once an issue is seen by a developer, it enters the
project's consciousness, in the sense that that developer can be on
the lookout for other instances of the issue, can talk about it with
other developers, etc.</para>

<para>The need for timely reactions implies two things:

<itemizedlist>
  <listitem>
    <para>The tracker must be connected to a mailing list, such that
    every change to an issue, including its initial filing, causes a
    mail to go out describing what happened.  This mailing list
    is usually different from the regular development list, since not
    all developers may want to receive automated bug mails, but (just
    as with commit mails) the Reply-to header should be set to the
    development mailing list.</para>
  </listitem>
  <listitem>
    <para>The form for filing issues should capture the reporter's
    email address, so she can be contacted for more information.
    (However, it should not <emphasis>require</emphasis> the
    reporter's email address, as some people prefer to report issues
    anonymously.  See
    <xref linkend="anonymity"/><phrase output="printed"> later
    in this chapter</phrase> for more on the importance of
    anonymity.)</para>
  </listitem>
</itemizedlist>

</para>

<sect2 id="bug-tracker-mailing-list-interaction">
<title>Interaction with Mailing Lists</title>

<para>Make sure the bug tracker doesn't turn into a discussion forum.
Although it is important to maintain a human presence in the bug
tracker, it is not fundamentally suited to real-time discussion.
Think of it rather as an archiver, a way to organize facts and
references to other discussions, primarily those that take place on
mailing lists.</para>

<para>There are two reasons to make this distinction.  First, the bug
tracker is more cumbersome to use than the mailing lists (or than
real-time chat forums, for that matter).  This is not because bug
trackers have bad user interface design, it's just that their
interfaces were designed for capturing and presenting discrete states,
not free-flowing discussions.  Second, not everyone who should be
involved in discussing a given issue is necessarily watching the bug
tracker.  Part of good issue management (see
<xref linkend="share-management"/><phrase output="printed"> in
<xref linkend="managing-volunteers"/></phrase>) is to make sure
each issue is brought to the right peoples' attention, rather than
requiring every developer to monitor all issues.  In
<xref linkend="bug-tracker-usage"/><phrase output="printed"> in <xref linkend="communications"/>,</phrase> we'll look at ways to make
sure people don't accidentally siphon discussions out of appropriate
forums and into the bug tracker.</para>

<para>Some bug trackers can monitor mailing lists and automatically
log all emails that are about a known issue.  Typically they do this
by recognizing the issue's identifying number in the subject line of
the mail, as part of a special string; developers learn to include
these strings in their mails to attract the tracker's notice.  The bug
tracker may either save the entire email, or (even better) just record
a link to the mail in the regular mailing list archive.  Either way,
this is a very useful feature; if your tracker has it, make sure
both to turn it on and to remind people to take advantage of
it.</para>

</sect2>

<sect2 id="bug-filtering">
<title>Pre-Filtering the Bug Tracker</title>

<para>Most issue databases eventually suffer from the same problem: a
crushing load of duplicate or invalid issues filed by well-meaning but
inexperienced or ill-informed users.  The first step in combatting
this trend is usually to put a prominent notice on the front page of
the bug tracker, explaining how to tell if a bug is really a bug, how
to search to see if it's already been filed, and finally, how to
effectively report it if one still thinks it's a new bug.</para>

<para>This will reduce the noise level for a while, but as the number
of users increases, the problem will eventually come back.  No
individual user can be blamed for it.  Each one is just trying to
contribute to the project's well-being, and even if their first bug
report isn't helpful, you still want to encourage them to stay
involved and file better issues in the future.  In the meantime,
though, the project needs to keep the issue database as free of junk
as possible.</para>

<para>The two things that will do the most to prevent this problem
are: making sure there are people watching the bug tracker who have
enough knowledge to close issues as invalid or duplicates the moment
they come in, and requiring (or strongly encouraging) users to confirm
their bugs with other people before filing them in the tracker.</para>

<para>The first technique seems to be used universally.  Even projects
with huge issue databases (say, the Debian bug tracker at
<ulink url="http://bugs.debian.org/"/>, which contained 315,929 issues
as of this writing) still arrange things so that
<emphasis>someone</emphasis> sees each issue that comes in.  It may be
a different person depending on the category of the issue.  For
example, the Debian project is a collection of software packages, so
Debian automatically routes each issue to the appropriate package
maintainers.  Of course, users can sometimes misidentify an issue's
category, with the result that the issue is sent to the wrong person
initially, who may then have to reroute it.  However, the important
thing is that the burden is still shared&mdash;whether the user
guesses right or wrong when filing, issue watching is still
distributed more or less evenly among the developers, so each issue is
able to receive a timely response.</para>

<para>The second technique is less widespread, probably because it's
harder to automate.  The essential idea is that every new issue gets
"buddied" into the database.  When a user thinks he's found a problem,
he is asked to describe it on one of the mailing lists, or in an IRC
channel, and get confirmation from someone that it is indeed a bug.
Bringing in that second pair of eyes early can prevent a lot of
spurious reports.  Sometimes the second party is able to identify that
the behavior is not a bug, or is fixed in recent releases.  Or she may
be familiar with the symptoms from a previous issue, and can prevent a
duplicate filing by pointing the user to the older issue.  Often it's
enough just to ask the user "Did you search the bug tracker to see if
it's already been reported?"  Many people simply don't think of that,
yet are happy to do the search once they know someone's
<emphasis>expecting</emphasis> them to.</para>

<para>The buddy system can really keep the issue database clean, but
it has some disadvantages too.  Many people will file solo anyway,
either through not seeing, or through disregarding, the instructions
to find a buddy for new issues.  Thus it is still necessary for
volunteers to watch the issue database.  Furthermore, because most new
reporters don't understand how difficult the task of maintaining the
issue database is, it's not fair to chide them too harshly for
ignoring the guidelines.  Thus the volunteers must be vigilant, and
yet exercise restraint in how they bounce unbuddied issues back to
their reporters.  The goal is to train each reporter to use the
buddying system in the future, so that there is an ever-growing pool
of people who understand the issue-filtering system.  On seeing an
unbuddied issue, the ideal steps are:</para>

<orderedlist>
  <listitem>
    <para>Immediately respond to the issue, politely thanking the user
          for filing, but pointing them to the buddying guidelines
          (which should, of course, be prominently posted on the web
          site).</para>
  </listitem>
  <listitem>
    <para>If the issue is clearly valid and not a duplicate, approve it
          anyway, and start it down the normal life cycle.  After all,
          the reporter's now been informed about buddying, so there's
          no point wasting the work done so far by closing a valid
          issue.</para>
  </listitem>
  <listitem>
    <para>Otherwise, if the issue is not clearly valid, close it, but
          ask the reporter to reopen it if they get confirmation from
          a buddy.   When they do, they should put a reference to the
          confirmation thread (e.g., a URL into the mailing list
          archives).</para>
  </listitem>
</orderedlist>

<para>Remember that although this system will improve the signal/noise
ratio in the issue database over time, it will never completely stop
the misfilings.  The only way to prevent misfilings entirely is to
close off the bug tracker to everyone but developers&mdash;a cure that
is almost always worse than the disease.  It's better to accept that
cleaning out invalid issues will always be part of the project's
routine maintenance, and to try to get as many people as possible to
help.</para>

<para>See also
<xref linkend="issue-manager"/><phrase output="printed"> in
<xref linkend="managing-volunteers"/></phrase>.</para>

</sect2>

</sect1>

<!-- ========================== SECTION =========================== -->
<sect1 id="irc">
<title>IRC / Real-Time Chat Systems</title>

<para>Many projects offer real-time chat rooms using <firstterm>Internet
Relay Chat</firstterm> (<firstterm>IRC</firstterm>), forums where users
and developers can ask each other questions and get instant responses.
While you <emphasis>can</emphasis> run an IRC server from your own
web site, it is generally not worth the hassle.  Instead, do what
everyone else does: run your IRC channels at Freenode
(<ulink url="http://freenode.net/"/>).  Freenode gives you the control
you need to administer your project's IRC
channels,<footnote><para>There is no requirement or expectation that
you donate to Freenode, but if you or your project can afford it,
please consider a contribution.  They are a tax-exempt charity in the
U.S., and they perform a valuable service.</para></footnote> while
sparing you the not-insignificant trouble of maintaining an IRC server
yourself.</para>

<para>The first thing to do is choose a channel name.  The most
obvious choice is the name of your project&mdash;if that's available
at Freenode, then use it.  If not, try to choose something as close to
your project's name, and as easy to remember, as possible.  Advertise
the channel's availabity from your project's web site, so a visitor
with a quick question will see it right away.  For example, this
appears in a prominently placed box at the top of Subversion's home
page:</para>

  <blockquote>
    <para><emphasis>If you're using Subversion, we recommend that you
    join the</emphasis> <literal>users@subversion.tigris.org</literal>
    <emphasis>mailing list, and read the <ulink
    url="http://svnbook.red-bean.com/">Subversion Book</ulink> and
    <ulink
    url="http://subversion.tigris.org/faq.html">FAQ</ulink>.
    You can also ask questions on IRC at</emphasis>
    <literal>irc.freenode.net</literal>
    <emphasis>channel</emphasis>&nbsp;<literal>#svn</literal>.</para>
  </blockquote>

<para>Some projects have multiple channels, one per subtopic.  For
example, one channel for installation problems, another for usage
questions, another for development chat, etc. (<xref
linkend="growth"/><phrase output="printed"> in
<xref linkend="communications"/></phrase> discusses and how to
divide into multiple channels).  When your project is young, there
should only be one channel, with everyone talking together.  Later, as
the user-to-developer ratio increases, separate channels may become
necessary.</para>

<para>How will people know all the available channels, let alone which
channel to talk in?  And when they talk, how will they know what the
local conventions are?</para>

<para>The answer is to tell them by setting the <firstterm>channel
topic</firstterm>.<footnote><para>To set a channel topic, use the
<literal>/topic</literal> command.  All commands in IRC start with
"<literal>/</literal>".  See <ulink url="http://www.irchelp.org/"/> if
you're not familiar with IRC usage and administration; in particular,
<ulink url="http://www.irchelp.org/irchelp/irctutorial.html"/> is an
excellent tutorial.</para></footnote>  The channel topic is a brief
message each user sees when they first enter the channel.  It gives
quick guidance to newcomers, and pointers to further information.  For
example:</para>

<screen>
You are now talking on #svn

Topic for #svn is Forum for Subversion user questions, see also
http://subversion.tigris.org/. || Development discussion happens in
#svn-dev. || Please don't paste long transcripts here, instead use
a pastebin site like http://pastebin.ca/. || NEWS: Subversion 1.1.0
is released, see http://svn110.notlong.com/ for details.
</screen>

<para>That's terse, but it tells newcomers what they need to know.  It
says exactly what the channel is for, gives the project home page (in
case someone wanders into the channel without having first been to the
project web site), mentions a related channel, and gives some guidance
about pasting.</para>

<sidebar id="paste-sites">
<title>Paste Sites</title>

<para>An IRC channel is a shared space: everyone can see what everyone
else is saying.  Normally, this is a good thing, as it allows people
to jump into a conversation when they think they have something to
contribute, and allows spectators to learn by watching.  But it
becomes problematic when someone has to provide a large quantity of
information at once, such as a debugging session transcript, because
pasting too many lines of output into the channel will disrupt other
conversations.</para>

<para>The solution is to use one of the
<firstterm>pastebin</firstterm> or <firstterm>pastebot</firstterm>
sites.  When requesting a large amount of data from someone, ask them
not to paste it into the channel, but instead to go to (for example)
<ulink url="http://pastebin.ca/"/>, paste their data into the form
there, and tell the resulting new URL to the IRC channel.  Anyone can
then visit the URL and view the data.</para>

<para>There are a number of free paste sites available now, too many
for a comprehensive list, but here are some of the ones I've seen used:
<ulink url="http://www.nomorepasting.com/"/>,
<ulink url="http://pastebin.ca/"/>,
<ulink url="http://nopaste.php.cd/"/>
<ulink url="http://rafb.net/paste/"/>
<ulink url="http://sourcepost.sytes.net/"/>,
<ulink url="http://extraball.sunsite.dk/notepad.php"/>,
and
<ulink url="http://www.pastebin.com/"/>.</para>

</sidebar>

<sect2 id="bots">
<title>Bots</title>

<para>Many technically-oriented IRC channels have a non-human member,
a so-called <firstterm>bot</firstterm>, that is capable of storing and
regurgitating information in response to specific commands.
Typically, the bot is addressed just like any other member of the
channel, that is, the commands are delivered by "speaking to" the bot.
For example:</para>

<screen>
&lt;kfogel&gt; ayita: learn diff-cmd = http://subversion.tigris.org/faq.html#diff-cmd
&lt;ayita&gt;  Thanks!
</screen>

<para>That told the bot (who is logged into the channel as ayita) to
remember a certain URL as the answer to the query "diff-cmd".  Now we
can address ayita, asking the bot to tell another user about
diff-cmd:</para>

<screen>
&lt;kfogel&gt; ayita: tell jrandom about diff-cmd
&lt;ayita&gt;  jrandom: http://subversion.tigris.org/faq.html#diff-cmd
</screen>

<para>The same thing can be accomplished via a convenient shorthand:</para>

<screen>
&lt;kfogel&gt; !a jrandom diff-cmd
&lt;ayita&gt;  jrandom: http://subversion.tigris.org/faq.html#diff-cmd
</screen>

<para>The exact command set and behaviors differ from bot to bot.  The
above example is with <literal>ayita</literal>
(<ulink url="http://hix.nu/svn-public/alexis/trunk/"/>), of which
there is usually an instance running in <literal>#svn</literal> at
freenode.  Other bots include Dancer
(<ulink url="http://dancer.sourceforge.net/"/>) and Supybot
(<ulink url="http://supybot.com/"/>).  Note that no special server
privileges are required to run a bot.  A bot is a client program;
anyone can set one up and direct it to listen to a particular
server/channel.</para>

<para>If your channel tends to get the same questions over and over,
I highly recommend setting up a bot.  Only a small percentage of
channel users will acquire the expertise needed to manipulate the bot,
but those users will answer a disproportionately high percentage of
questions, because the bot enables them to respond so much more
efficiently.</para>

</sect2>

<sect2 id="irc-archiving">
<title>Archiving IRC</title>

<para>Although it is possible to archive everything that happens in an
IRC channel, it's not necessarily expected.  IRC conversations may be
nominally public, but many people think of them as informal,
semi-private conversations.  Users may be careless with grammar, and
often express opinions (for example, about other software or other
programmers) that they wouldn't want preserved forever in an online
archive.</para>

<para>Of course, there will sometimes be <emphasis>excerpts</emphasis>
that should be preserved, and that's fine.  Most IRC clients can log a
conversation to a file at the user's request, or failing that, one can
always just cut and paste the conversation from IRC into a more
permanent forum (most often the bug tracker).  But indiscriminate
logging may make some users uneasy.  If you do archive everything,
make sure you state so clearly in the channel topic, and give a URL to
the archive.</para>

</sect2>

</sect1>

<!-- ========================== SECTION =========================== -->
<sect1 id="wikis">
<title>Wikis</title>

<para>A <firstterm>wiki</firstterm> is a web site that allows any
visitor to edit or extend its content; the term "wiki" (from a
Hawaiian word meaning "quick" or "super-fast") is also used to refer
to the software that enables such editing.  Wikis were invented in
1995, but their popularity has really started to take off since 2000
or 2001, boosted partly by the success of Wikipedia (<ulink
url="http://www.wikipedia.org/"/>), a wiki-based free-content
encyclopedia.  Think of a wiki as falling somewhere between IRC and
web pages: wikis don't happen in realtime, so people get a chance to
ponder and polish their contributions, but they are also very easy to
add to, involving less interface overhead than editing a regular web
page.</para>

<para>Wikis are not yet standard equipment for open source projects,
but they probably will be soon.  As they are relatively new
technology, and people are still experimenting with different ways of
using them, I will just offer a few words of caution here&mdash;at
this stage, it's easier to analyze misuses of wikis than to analyze
their successes.</para>

<para>If you decide to run a wiki, put a lot of effort into having a
clear page organization and pleasing visual layout, so that visitors
(i.e., potential editors) will instinctively know how to fit in their
contributions.  Equally important, post those standards on the wiki
itself, so people have somewhere to go for guidance.  Too often, wiki
administrators fall victim to the fantasy that because hordes of
visitors are individually adding high quality content to the site,
the sum of all these contributions must therefore also be of high
quality.  That's not how web sites work.  Each individual page or
paragraph may be good when considered by itself, but it will not be
good if embedded in a disorganized or confusing whole.  Too often,
wikis suffer from:</para>

<itemizedlist>
  <listitem>
     <para><emphasis role="bold">Lack of navigational principles.</emphasis>
     A well-organized web site makes visitors feel like they know
     where they are at any time.  For example, if the pages are
     well-designed, people can intuitively tell the difference
     between a "table of contents" region and a "content" region.
     Contributors to a wiki will respect such differences too, but
     only if the differences are present to begin with.</para>
  </listitem>
  <listitem>
     <para><emphasis role="bold">Duplication of information.</emphasis>
     Wikis frequently end up with different pages saying similar
     things, because the individual contributors did not notice the
     duplications.  This can be partly a consequence of the lack of
     navigational principles noted above, in that people may not find
     the duplicate content if it is not where they expect it to
     be.</para>
  </listitem>
  <listitem>
     <para><emphasis role="bold">Inconsistent target audience.</emphasis>
     To some degree this problem is inevitable when there are so many
     authors, but it can be lessened if there are written guidelines
     about how to create new content.  It also helps to aggressively
     edit new contributions at the beginning, as an example, so that
     the standards start to sink in.</para>
  </listitem>
</itemizedlist>

<para>The common solution to all these problems is the same: have
editorial standards, and demonstrate them not only by posting them,
but by editing pages to adhere to them.  In general, wikis will
amplify any failings in their original material, since contributors
imitate whatever patterns they see in front of them.  Don't just
set up the wiki and hope everything falls into place.  You must also
prime it with well-written content, so people have a template to
follow.</para>

<para>The shining example of a well-run wiki is Wikipedia, though this
may be partly 
because the content (encyclopedia entries) is naturally well-suited to
the wiki format.  But if you examine Wikipedia closely, you'll see
that its administrators laid a <emphasis>very</emphasis> thorough
foundation for cooperation.  There is extensive documentation on how
to write new entries, how to maintain an appropriate point of view,
what sorts of edits to make, what edits to avoid, a dispute resolution
process for contested edits (involving several stages, including
eventual arbitration), and so forth.  They also have authorization
controls, so that if a page is the target of repeated inappropriate
edits, they can lock it down until the problem is resolved.  In other
words, they didn't just throw some templates onto a web site and hope
for the best.  Wikipedia works because its founders thought carefully
about how to get thousands of strangers to tailor their writing to a
common vision.  While you may not need the same level of preparedness
to run a wiki for a free software project, the spirit is worth
emulating.</para>

<para>For more information about wikis, see
<ulink url="http://en.wikipedia.org/wiki/Wiki"/>.  Also, the first
wiki remains alive and well, and contains a lot of discussion about
running wikis: see <ulink
url="http://www.c2.com/cgi/wiki?WelcomeVisitors"/>, 
<ulink url="http://www.c2.com/cgi/wiki?WhyWikiWorks"/>, and
<ulink url="http://www.c2.com/cgi/wiki?WhyWikiWorksNot"/> for
various points of view.</para>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="web-site">
<title>Web Site</title>

<para>There is not much to say about setting up the project web site
from a technical point of view: setting up a web server and writing
web pages are fairly simple tasks, and most of the important things to
say about layout and arrangement were covered in the previous chapter.
The web site's main function is to present a clear and welcoming
overview of the project, and to bind together the other tools (the
version control system, bug tracker, etc.).  If you don't have the
expertise to set up a web server yourself, it's usually not hard to
find someone who does and is willing to help out.  Nonetheless, to
save time and effort, people often prefer to use one of the canned
hosting sites.</para>

<sect2 id="canned-hosting">
<title>Canned Hosting</title>

<para>There are two main advantages to using a canned site.  The first
is server capacity and bandwidth: their servers are beefy boxes sitting
on really fat pipes.  No matter how successful your project gets,
you're not going to run out of disk space or swamp the network
connection.  The second advantage is simplicity.  They have already
chosen a bug tracker, a version control system, a mailing list manager,
an archiver, and everything else you need to run a site.  They've
configured the tools, and are taking care of backups for all the data
stored in the tools.  You don't need to make many decisions.  All you
have to do is fill in a form, press a button, and suddenly you've got
a project web site.</para>

<para>These are pretty significant benefits.  The disadvantage, of
course, is that you must accept <emphasis>their</emphasis> choices and
configurations, even if something different would be better for your
project.  Usually canned sites are adjustable within certain narrow
parameters, but you will never get the fine-grained control you would
have if you set up the site yourself and had full administrative
access to the server.</para>

<para>A perfect example of this is the handling of generated files.
Certain project web pages may be generated files&mdash;for example,
there are systems for keeping FAQ data in an easy-to-edit master
format, from which HTML, PDF, and other presentation formats can be
generated.  As explained in
<xref linkend="version-everything"/><phrase output="printed">
earlier in this chapter</phrase>,
you wouldn't want to version the generated formats, only the master
file.  But when your web site is hosted on someone else's server, it
may be impossible to set up a custom hook to regenerate the online
HTML version of the FAQ whenever the master file is changed.  The only
workaround is to version the generated formats too, so that they show
up on the web site.</para>

<para>There can be larger consequences as well.  You may not have as
much control over presentation as you would wish.  Some of the canned
hosting sites allow you to customize your web pages, but the site's
default layout usually ends up showing through in various awkward
ways.  For example, some projects that host themselves at SourceForge
have completely customized home pages, but still point developers to
their "SourceForge page" for more information.  The SourceForge page
is what would be the project's home page, had the project not used a
custom home page.  The SourceForge page has links to the bug tracker,
the CVS repository, downloads, etc.  Unfortunately, a SourceForge page
also contains a great deal of extraneous noise.  The top is a banner
ad, often an animated image.  The left side is a vertical arrangement
of links of little relevance to someone interested in the project.
The right side is often another advertisement.  Only the center of the
page is devoted to truly project-specific material, and even that is
arranged in a confusing way that often makes visitors unsure of what
to click on next.</para>

<para>Behind every individual aspect of SourceForge's design, there is
no doubt a good reason&mdash;good from SourceForge's point of view,
such as the advertisements.  But from an individual project's point of
view, the result can be a less-than-ideal web page.  I don't mean to
pick on SourceForge; similar concerns apply to many of the canned
hosting sites.  The point is that there's a tradeoff.  You get relief
from the technical burdens of running a project site, but only at the
price of accepting someone else's way of running it.</para>

<para>Only you can decide whether canned hosting is best for your
project.  If you choose a canned site, leave open the option of
switching to your own servers later, by using a custom domain name for
the project's "home address".  You can forward the URL to the canned
site, or have a fully customized home page at the public URL and hand
users off to the canned site for sophisticated functionality.  Just
make sure to arrange things such that if you later decide to use a
different hosting solution, the project's address doesn't need to
change.</para>

<sect3 id="canned-hosting-choosing">
<title>Choosing a canned hosting site</title>

<para>The largest and most well-known hosting site is <ulink
url="http://www.sourceforge.net/">SourceForge</ulink>.  Two other
sites providing the same or similar services are <ulink
url="http://savannah.gnu.org/">savannah.gnu.org</ulink> and <ulink
url="http://www.berlios.de/">BerliOS.de</ulink>.  A few organizations,
such as the <ulink url="http://www.apache.org/">Apache Software
Foundation</ulink> and <ulink
url="http://www.tigris.org/">Tigris.org</ulink><footnote><para>Disclaimer:
I am employed by <ulink
url="http://www.collab.net/">CollabNet</ulink>, which sponsors
Tigris.org, and I use Tigris regularly.</para></footnote>, give free
hosting to open source projects that fit well with their missions and
their community of existing projects.</para>

<para>Haggen So did a thorough evaluation of various canned hosting
sites, as part of the research for his Ph.D. thesis,
<citetitle>Construction of an Evaluation Model for Free/Open Source
Project Hosting (FOSPHost) sites</citetitle>.  The results are at
<ulink url="http://www.ibiblio.org/fosphost/"/>, and see especially
the very readable comparison chart at <ulink
url="http://www.ibiblio.org/fosphost/exhost.htm"/>.</para>

</sect3>

<sect3 id="anonymity">
<title>Anonymity and involvement</title>

<para>A problem that is not strictly limited to the canned sites, but
is most often found there, is the abuse of user login functionality.
The functionality itself is simple enough: the site allows each
visitor to register herself with a username and password.  From
then on it keeps a profile for that user, and project administrators
can assign the user certain permissions, for example, the right to
commit to the repository.</para>

<para>This can be extremely useful, and in fact it's one of the prime
advantages of canned hosting.  The problem is that sometimes user
login ends up being required for tasks that ought to be permitted to
unregistered visitors, specifically the ability to file issues in the
bug tracker, and to comment on existing issues.  By requiring a
logged-in username for such actions, the project raises the
involvement bar for what should be quick, convenient tasks.  Of
course, one wants to be able to contact someone who's entered data
into the issue tracker, but having a field where she can enter her
email address (if she wants to) is sufficient.  If a new user spots a
bug and wants to report it, she'll only be annoyed at having to fill
out an account creation form before she can enter the bug into the
tracker.  She may simply decide not to file the bug at all.</para>

<para>The advantages of user management generally outweigh the
disadvantages.  But if you can choose which actions can be done
anonymously, make sure not only that <emphasis>all</emphasis>
read-only actions are permitted to non-logged-in visitors, but also
some data entry actions, especially in the bug tracker and, if you
have them, wiki pages.</para>

</sect3>

</sect2>

</sect1>


<!-- ======================== SECTION ============================== -->


</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->

