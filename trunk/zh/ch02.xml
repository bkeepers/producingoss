<chapter id="getting-started">

<title>起步</title>

<simplesect>

<para>有关自由软件是如何发起的经典模式是由Eric Raymond提出的，在一篇今天广为人
知的名为《大教堂和集市》有关开源开发的论文中，他写道 ：</para>

    <blockquote>
      <para><emphasis>每一个好的软件都始于挠到一个开发者的痒痒处。</emphasis></para>

      <para>(参见  <emphasis role="bold"><ulink
      url="http://www.catb.org/~esr/writings/cathedral-bazaar/"/>
      </emphasis>)</para>
    </blockquote>

<para>注意雷蒙德并没有说只有当某些开发人员心里痒痒之后才会导致一个开源项目的诞生。相反，他是
说优秀的软件只有当程序员对解决某个问题产生了个人兴趣之后才能产生。这一点同自由软件的联
系在于，大部分自由软件项目的最初动机都是始于一个人的痒痒处。</para>

<para>这仍然是大部分项目的动因，但自从1997年雷蒙德写下这些话之后这种现象正在慢慢减少。
今天我们有了一些组织──包括盈利性的大企业──从零开始大型的，集中管理的开源项目。单个
的程序员为了解决一个个人问题敲出一些代码而最后意识到可以有更广泛地应用的例子仍然是许多新自由
软件的源头，但不再是唯一的故事。</para>

<para>然而雷蒙德的观点仍然是真知灼见。关键在于软件的生产者对它的成功有直接的兴趣，因为
是自己用。如果软件没能达到期望的目标，那些编写它的个人或是组织会在日常工作中感到不满。
例如，OpenAdapter项目 (<ulink
url="http://www.openadapter.org/"/>)，这是一个由德累斯顿-克莱沃特投资银行发起
的一个用于集成不等的财经信息的开源框架，就很难说是始于哪个程序员的个人痒痒处。它始于一
个组织的痒痒处。这些痒痒处直接来自这个组织和他们的合伙人的经验，因此如果这个项目没能
减轻这些痒痒症，他们立刻能够感觉到。这种情形产出了优秀的软件，因为形成了一个良性的循环。
程序不是为了卖给其他人而编写的，不是为解决<emphasis>他人的</emphasis>问题。它是为解决某个<emphasis>自己的</emphasis>问题而编写的，
之后再同其他的人分享，足可以把问题想像成疾病而程序是分发的药物，用来彻底地消灭传染病。 </para>

<para>这章是关于如何将一个自由软件项目介绍给全世界，但是其中的很多建议听起来会很
像一个卫生组织在分发药物。两者的目标的确非常相似：你要弄清楚药品的作用，把它发放到需
要的人手中，并确保那些人知道如何使用它。但对一个软件，你还需要诱使那些接受者加入
研究计划来改进"药物"。</para>

<para>自由软件的发布是一项双重任务。软件既要满足使用者，也要满足开发者。这两种需求不
一定是冲突的，但是会为项目的初期简报增加复杂度。其中有些信息对两者都有用，有些只是对其
中一类有用。对两种信息都应该依照简报的比例原则：每个阶段描述的详细程度都应该直接同读者
花费的时间和努力程度挂钩。当这种关系发生偏差，人们有可能很快失去信任并且停止投入精力。</para>

<para>这一点的必然结果就是<emphasis>形象</emphasis>非常重要。程序员们对这一点总是嗤之以鼻。对本质超越形式的热爱成
了他们职业自豪感的一部分。所以毫不意外， 许多程序员表现出对营销和公关工作的厌恶，同样， 职业
图形设计师往往也对程序员们的产品感到惊恐万状。</para>


<para>这是一个遗憾，因为有时候形式<emphasis>就是</emphasis>本质，并且项目简报就是这种情形之一。例如，浏览网页的人
对一个项目的第一观感就是来自网站的外观。这种观感的形成要早于任何一种实际的内容之前──包括文
字和链接。不管这看起来多么不公平，人们无法不形成一个即时的第一印象。网站的形象向读者传递了
一个信号，即网站的简报是否经过了精心安排。人类对觉察心思的投入有着极端敏锐的感觉。我们中的
大多数人都能在一瞥间看出一个网站是随便拉起来的还是经过认真思考的。这是你的项目展现出信息的第
一步，它所建立起来的印象将对整个项目的后续部分施加影响。</para>

<para>因此，尽管本章的大部分篇幅谈论的是你应该用什么样的内容开始你的项目，但别忘了外观和感觉同
样重要。因为项目的网站是同时为使用者和开发者两类人服务的，相应的投入也要透明和有针对性。虽
然这不是一本讨论网页设计的专著，但是当网站是为多种类型的读者服务时，有一条重要原则是值得一提
的，在点击一个链接之前用户应该对它的去处有一个大概的了解。例如，当看到"用户文档"的链接时
明显应该是链接到用户文档，而不是开发者文档。运作一个项目一部分是为了提供信息，但是同时也是
提供舒适。当用户和开发者们正在犹豫要不要加入时，你应该用一套肯定性的标准来使他们安心。
它表明项目有统一的管理，已经预估到了人们可能提出的问题，并且致力于在只花费提问者最少的精力的前提
下来解答这些问题。通过显现这种充分准备的氛围，该项目发出了一个信息："如果加入，你的时间不会被
白白浪费。"而这正是人们想听到的。 </para>


<!-- ======================== subsection ============================== -->
<sect2 id="look-around">
<title>但首先，环顾四周</title>

<para>开始一个开源项目之前，给你一个重要的告诫：</para>

<para>一定要找找看是否有一个现存的项目已经做了你想做的。有很大的几率有人早于你已经解决
了你想解决的问题。如果他们已经解决了它，并且在一个自由协议下发布了他们的代码，那今天你就
没有必要重新发明轮子了。当然有例外，如果是为了练习才开始一个项目，那现有的代码对你没用。
或者你脑中的计划非常特别，你肯定不会有其他人有同样的想法，那你也不妨试试看。但总的来说没有理由不先看一看，而收获总是很
大。如果常见的互联网搜索引擎发现不了什么，试试在 
<ulink url="http://freshmeat.net/"/>（一个开源项目的新闻站点，有关它的更多介绍将在后
面提到）和
<ulink url="http://www.sourceforge.net/"/>上找找看，同时自由软件基金会有一个自由
软件的目录在 
<ulink url="http://directory.fsf.org/"/>。</para>

<para>即使你找不到跟你的想法一模一样的项目，你也许能找到十分接近的，然后加入这个项目为它增加功能
比你自己从零开始一个项目要更有意义。</para>

</sect2>


</simplesect>


<!-- ========================== SECTION =========================== -->
<sect1 id="starting-from-what-you-have">
<title>从现有的开始</title>

<para>你环顾了四周，没找到真正适合你的软件，因而决定开始一个新的项目。</para>

<para>现在应该做什么呢？</para>

<para>开始一个自由软件最难的部分是将个体的设想转化传达给公众。 你或是你的团体也许对要做的事情已经十分明了， 但是将这一目标清楚地传达给世界还需要付出一番努力。 然而，那是必须花时间做的事情。 你和其他的创建人必须决定你们项目的作用-也就是说，划定项目的范围， 做什么，不做什么-然后撰写一份项目使命陈述。这部分通常不太难，但有时候能暴露出一些有关项目本质的臆想， 甚至于分歧。 那也没关系，现在解决这些问题总比拖到以后好。下一步就是将项目打包展示给公众， 而那纯粹是单调乏味的工作。</para>

<para>之所以这样说是因为打包的工作就是把大家都已经知道的东西组织和编辑成文件-这里所说的"大家"指的是到目前为止参与项目工作的人。因此，对于那些做这项工作的人来说，没有什么立竿见影的好处。他们并不需要一个说明文件来了解整个项目的概况， 也不需要一个设计文件或是用户手册。 他们不需要仔细排列好的，与非正式而又普遍采用的软件源码发布方式相一致的代码树形图。 对他们来说，只要源码能够运行，他们就知道怎么用。甚而至于，要是项目最根本的设计假想没有做成文件对他们来说也是无关紧要的；因为他们对那一方面也很熟悉了。</para>

<para>然而，新参与的人需要这些东西。好在他们并不是在一开始就需要全部的资料。在一个项目公之于众之前，你不必提供每一个有关的细节。在一个理想的世界里，每一个新的开源软件项目在开始的时候就具备了一个详细的设计文件，一套完整的用户手册（对已经计划好但还未实施的性能有特别的标识），漂亮地而又可移植地打好了包的代码，并且还可以在任何电脑系统平台上运行等等。 然而在现实当中，做好上述各项工作是非常耗费时间的，可是一旦项目启动之后，这些工作可以指望一些自愿人员协助完成。</para>

<para>重要的是必须做好展示这一步， 以便新的参与者能够顺利通过开始时因对项目不熟悉而造成的障碍。 设想自举过程中的第一步，就是将项目启动所需的能耗降到最低点。我听说过人们用"切入能耗"（hacktivation energy）这个词来形容这一开端：即一个新的参与者在收获之前所必须付出的能量。一个项目的切入能耗控制得越低越好。你的首要任务就是将切入能耗降低到能够鼓励人们参与项目工作的水平。</para>

<para>以下各小节分别描述了开始一个新项目的一个重要的方面。排列顺序大致是按照一个新的访问者将遇到的情形安排的，当然你在实际操作时可以不按照这个顺序进行。你可以将它们看作是一个清单。当你开始一个项目时，只要一一检查，确保每一步骤都做到了，或者在你省略某一部分时，至少你对将来可能出现的后果有把握就行了。</para>

<!-- ======================== subsection ============================== -->
<sect2 id="choosing-a-name">
<title>选择一个好名字</title>

<para>假设你是另外一个人， 可能在搜索一个软件来解决某一个问题是碰巧看到了你的项目。 他首先看到的是项目的名字。</para>

<para>一个好名字不会自然而然地使你的项目成功， 而一个不好的名字也不会终结你的项目-当然了，一个真正糟糕的名字也许会， 但是让我们首先假定谁也不会迫不及待地让自己的项目失败吧。确实，一个不好的名字会延缓他人接受该项目的速度， 要么是因为人们不会认真对待它， 要么是因为人们很难记住它的名字。</para>

<para>一个好名字：

<itemizedlist>
  <listitem><para>告诉人们有关项目性能的一些概念，或至少名字与性能是明显相关联的，以至于人们看到名字的时候就知道项目能做什么，那么人们以后便很容易就想起这个名字。 </para>
  </listitem>
  <listitem><para>便于记忆。在此，我们必须承认英语实际上已成为网络默认语言这一事实。 "便于记忆"就意味着"便于能阅读英语的人记忆"。例如，某一非英语发音的双关语对于该语言之外的许多能阅读英语的人来说是很难理解的。要是这个双关语特别精彩并且令人难忘，那或许值得一试； 但必须记住，这个名字在许多人的脑海里并不会产生在母语人士身上所有的效果。</para>
  </listitem>
  <listitem><para>不与另一个项目重名，也不侵犯任何商标权。 这既表现职业美德，也是具备良好的法律意识。你要避免制造身份混乱。即便没有不同的东西重名的现象，我们现在要搞清楚网络上已有的东西已经很不容易了。</para>

            <para>在前面 <xref linkend="look-around"/> 里提及的资料有助于你发现是否另一个项目已经采用了你正在考虑的名字。 免费的商标搜索见 <ulink url="http://www.nameprotect.org/"/>和 <ulink url="http://www.uspto.gov/"/>。</para>
  </listitem>
  <listitem><para>尽可能成为
            <systemitem>.com</systemitem>,
            <systemitem>.net</systemitem>, 以及
            <systemitem>.org</systemitem> 高层域中的一个域名。你应该选择其中的一个， 或许是 <systemitem>.org</systemitem>吧，作为项目正式的网址；而另外两个网址都转发到前一个，这还可以防止其他人用项目的名字制造身份混乱。即使你打算将项目放在其它的网站空间上， (见<xref linkend="starting-with-canned-hosting"/>)，你仍然可以注册自己项目的域名，而转发至你存放项目的主页上。 对用户来说，使用一个容易记忆的URL是十分有帮助的。</para>
    </listitem>
</itemizedlist>

</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="mission-statement">
<title>有一份清楚的使命陈述</title>

<para>人们找到了项目的网页之后，下一步就要看一份简短的项目描述， 即使命陈述， 以便（在30秒之内）决定他们是否对该项目有兴趣。因此，这份使命陈述必须放在首页显著的位置，最好是紧贴着项目名字的下方</para>

<para>使命陈述必须具体，紧凑；而最重要的是简短。以下是一个很好的例子，选自<ulink
url="http://www.openoffice.org/"/>:</para>

  <blockquote>
  <para><emphasis>创建一个以社区为基础，领先的国际性办公室套件，能够在所有主要的平台上运行，并借基于API和XML文件格式的开放组件，提供对所有功能和数据的接入性。 </emphasis></para>
  </blockquote>

<para>这份使命陈述仅仅用了简短的几句话，通过大量依赖读者已有的知识明白无误地传达了所要传达的信息。"以社区为基础"表明该软件不受任何一家大公司控制其开发；"国际性"指的是该软件允许人们在本地及多种语言环境下工作；"所有主要的平台"说的是该软件可移植到Unix，苹果和视窗操作系统。 其余的文字则说明开源界面以及易读的文件格式都是该软件目标中重要的组成部分。这份使命陈述并没有在字面上告诉读者它旨在成为微软视窗的开源替代品， 但是人们从字里行间便能看出它的含义。乍一看，这份使命陈述似乎有些空泛，但实际上是界定得相当明确的："办公室套件"对那些熟悉这个软件的人来说是非常具体的东西。 在此，读者已有的知识（这里指的是读者有可能对微软办公室软件的了解）又一次用来把使命陈述变得简洁明了了。 </para>

<para>一份使命陈述的性质不单单是由它所描述的软件决定的，而在一定程度上得看是由谁来写的。 例如，OpenOffice.org使用 "<emphasis>以社区为基础</emphasis>"这个词是很有道理的， 因为这个项目最初是由Sun Microsystems发起，而至今仍主要是由这家公司赞助的。在其使命陈述中使用"以社区为基础"这几个字， Sun表明它对一些担心该公司有可能试图垄断开发这一软件的忧虑是有敏感度的。这样的处理方法，即表明对一个有可能出现的潜在的问题有意识，就给将来完全避免这个问题的出现奠定了很好的基础。话又说回来，如果项目并非由一家大公司赞助，那或许根本不需要这样的词语；说到底，社区开发已经成为今天的模式了，因而没有理由要特别将那样的词语写在使命陈述中。 </para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="state-freedom">
<title>声明项目是自由软件</title>

<para>看过使命陈述之后仍对项目有兴趣的人自然想要了解更多的情况， 或许要看一看用户文件和开发人员文件， 最终可能下载一些东西。但在做这些事情以前，他们要确定这是一个开源项目。</para>

<para><emphasis>网站的首页必须清清楚楚地写明这是一个开源项目。</emphasis> 这看起来好像无需加以强调， 但是你会惊讶有多少项目忽略了这一点。我见过不少自由软件网站，其首页不但没有说明该软件是在哪一个自由许可证下发布的，而且根本没在首页表明这是一个自由软件。有时候这一至关重要的信息被次要地放在了下载页， 或是开发人员页，或是其它的一个需要多点击一次鼠标才能看到的一个地方。在一些极端的例子中，网页上哪儿都找不到自由许可证- 唯一能找到的地方是软件下载之后才能看到。 </para>

<para>别犯这个错误。这一忽略有可能让你失去许多潜在的开发人员和用户。务必在首页，也就是使命陈述的正下方，声明该项目是"自由软件"或是"开源软件"，并注明确切的许可证。有关选择许可证的快速指南，见本章后面 <xref linkend="license-quickstart"/><phrase output="printed"></phrase>, 而有关许可证问题的详细讨论见 <xref linkend="legal"/>.</para>

<para>至此，我们假想中的访问者已经决定-或许在随后的一分钟之内-他打算至少再花5分钟的时间研究一下这个项目。下面几个小节要描述他在之后的5分钟里将遇到的情形。</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="features-and-requirements">
<title>特性和要求</title>

<para>你应该列出一个简短的清单，说明软件支持的各种特性(如果某些特性还未完成，也可以列出，但是在旁边注明 "<emphasis>计划中</emphasis>" 或 "<emphasis>in&nbsp;在建中</emphasis>" )，以及运行该软件所要求的系统环境。列这份清单时，你只要设想一个人请你简短地介绍这个软件的特性/要求是什么。 通常，那只是按照逻辑对使命陈述作进一步的扩充。 例如，使命陈述可能写的是：</para>

  <blockquote>
  <para><emphasis>创建一个全文索引器并配备丰富API的搜索引擎，用于编程人员搜索大批量文本文件。</emphasis></para>
  </blockquote>

<para>特性和要求的清单将列出更详细的内容， 对使命陈述的范围加以说明：</para>

  <blockquote>
    <para><emphasis>特性：</emphasis></para>
    <itemizedlist>
      <listitem><para><emphasis>搜索纯文本，HTML和 XML文件</emphasis></para>
      </listitem>
      <listitem><para><emphasis>字或词搜索</emphasis></para>
      </listitem>
      <listitem><para><emphasis>(计划中) 模糊匹配</emphasis></para>
      </listitem>
      <listitem><para><emphasis>(计划中) 及时更新索引</emphasis></para>
      </listitem>
      <listitem><para><emphasis>(计划中) 索引远程站点</emphasis></para>
      </listitem>
    </itemizedlist>
    <para><emphasis>要求</emphasis></para>
    <itemizedlist>
      <listitem><para><emphasis>Python 2.2 或更高版本</emphasis></para>
      </listitem>
      <listitem><para><emphasis>足够的硬盘空间以储存索引 (大约原文件大小的2倍)</emphasis></para>
      </listitem>
    </itemizedlist>
  </blockquote>

<para>有了这样的信息，读者便能很快地决定这个软件是否适用于他们， 也可以考虑是否以开发人员的身份参与其中。</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="development-status">
<title>开发状况</title>

<para>人们总是希望了解一个项目的状况。 对新的项目， 他们想知道项目的承诺和现实之间存在着多大的距离。 对成熟的项目，他们想知道维护得如何，新发布的频率怎样，以及对蠕虫报告反应的及时性等等。</para>

<para>要回答这些问题，你应该建立开发状况页， 列出项目的近期目标和需求(例如，需要具备某方面专长的开发人员)。 开发状况页也可以列出过去发布的记录， 其中包含特性清单， 以便访问者了解项目是如何定义"进展"的，并根据这一定义了解项目进展的速度。</para>

<para>别害怕你的项目看起来没准备好， 也不要向夸大开发状况的诱惑妥协。 谁都清楚软件是分阶段开发的产品； 你不必觉得难以开口说出："这是仍带有蠕虫的alpha软件。 它可以运行，而且至少有时候能正常工作， 但你使用这个软件就得自己承担风险。" 这类语言不会吓跑你在这个阶段需要的开发人员。 然而，对于用户来说，最糟糕的事情莫过于在软件准备好之前就吸引用户。一旦冠上了稳定性差或是蠕虫多多的名声，软件就很难再正名了。 采取保守的策略对长远的目标是非常有益的； 软件的稳定性<emphasis>超出</emphasis>用户的预期总比达不到用户的期望好得多， 而给用户惊喜就会给产品带来最佳口碑。</para>

<sidebar id="alpha-and-beta">
  <title>Alpha 和 Beta</title>
  <para> <firstterm>alpha</firstterm> 这个词通常指的是第一次发布， 但是用户可以使用该软件进行工作，并且软件也具备了最初计划的所有功能， 但已知的蠕虫仍然存在。 Alpha软件的主要目的在于获取回馈， 以便开发人员了解他们应该做什么。下一个阶段， <firstterm>beta</firstterm>是指软件中所有厉害的蠕虫都已经被消灭了，但是软件还未经过足够的测试， 因而还不能正式发布。 Beta软件的目的有二，一是在未发现蠕虫的情况下正式发布软件，二是提供给开发人员详细的回馈， 以便他们能够尽快解决问题之后正式发布软件。Alpha和 Beta的差别通常是由判断而决定的。</para>
</sidebar>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="downloads">
<title>下载</title>

<para>软件应该在标准格式下可以下载源代码。 在一个项目刚起步时，二进制（可执行的）软件包是不必要的， 除非该软件的构造要求相当复杂，且从属性强， 以至于仅仅运行该软件就需要大量的人力投入（如果情形是那样的话，该项目也将很难吸引开发人员的参与！）。</para>

<para>发行机制应该尽量做到方便，标准化以及清楚无误。假如你要根除一种疾病，你分发的药物不会是需要一种非标准化的注射器来操作的吧。 同样的道理， 软件应该与标准化的构造和安装方法相一致； 一个软件距离标准化越远， 用户和开发人员放弃该软件并且一头雾水地离开的可能性就越大。</para>

<para>那听起来是显而易见的道理， 但是许多项目往往等到很晚的时候才动手解决标准化安装程序， 因为他们总是告诉自己这一步什么时候都可以做：<emphasis> “等到代码接近完工的时候再来解决这些所有的问题吧。“</emphasis> 殊不知在拖延完成软件建设和安装程序这类枯燥工作的时候， 他们实际上是在推迟完成代码的时间-因为他们让一些本来可以为软件编程做贡献的开发人员失去了兴趣。 最糟糕的是， 他们根本就<emphasis>不知道</emphasis>他们失去了那些开发人员。 因为那是一连串无果而终的一个过程：某人拜访了一个网页， 下载了软件， 试图参与建设， 失败了，放弃而离开了。 除了拜访者本人以外， 谁会知道发生了这一切？ 项目参与者中谁也不会意识到某位拜访者的兴趣和良好意愿在悄无声息中便被扼杀了。</para>

<para>枯燥但具有高回报的工作应该尽早完成， 而通过良好包装便能够大大降低进入项目障碍的工作显然是具有很高的回报率的。</para>

<para>当你发布一个可以下载的软件包时， 至关重要的一点是给予这一次发布一个独一无二的版本号码， 以便人们对两次发布加以比较， 从而了解哪些东西被替代了。 有关版本编号的详细讨论见“给每一次发布编号小节<xref linkend="release-numbering"/>, 而构造和安装程序标准化的详细内容见第七章“打包，发布和每日进展“<xref linkend="packaging"/><phrase output="printed">, <xref linkend="development-cycle"/></phrase>.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="vc-and-bug-tracker-access">
<title>Version Control and Bug Tracker Access</title>

<para>Downloading source packages is fine for those who just want to
install and use the software, but it's not enough for those who want
to debug or add new features.  Nightly source snapshots can help, but
they're still not fine-grained enough for a thriving development
community.  People need real-time access to the latest sources, and
the way to give them that is to use a version control system.  The
presence of anonymously accessible version controlled sources is a
sign&mdash;to both users and developers&mdash;that this project is
making an effort to give people what they need to participate.  If you
can't offer version control right away, then put up a sign saying you
intend to set it up soon.  Version control infrastructure is discussed
in detail in <xref linkend="vc"/><phrase output="printed"> in
<xref linkend="technical-infrastructure"/></phrase>.</para>

<para>The same goes for the project's bug tracker.  The importance of
a bug tracking system lies not only in its usefulness to developers,
but in what it signifies for project observers.  For many people, an
accessible bug database is one of the strongest signs that a project
should be taken seriously.  Furthermore, the higher the number of bugs
in the database, the better the project looks.  This might seem
counterintuitive, but remember that the number of bugs recorded really
depends on three things: the absolute number of bugs present in the
software, the number of users using the software, and the convenience
with which those users can register new bugs.  Of these three factors,
the latter two are more significant than the first.  Any software of
sufficient size and complexity has an essentially arbitrary number of
bugs waiting to be discovered.  The real question is, how well will
the project do at recording and prioritizing those bugs?  A project
with a large and well-maintained bug database (meaning bugs are
responded to promptly, duplicate bugs are unified, etc.) therefore
makes a better impression than a project with no bug database, or a
nearly empty database.</para>

<para>Of course, if your project is just getting started, then the bug
database will contain very few bugs, and there's not much you can do
about that.  But if the status page emphasizes the project's youth,
and if people looking at the bug database can see that most filings have
taken place recently, they can extrapolate from that that the project
still has a healthy <emphasis>rate</emphasis> of filings, and they
will not be unduly alarmed by the low absolute number of bugs
recorded.</para>

<para>Note that bug trackers are often used to track not only software
bugs, but enhancement requests, documentation changes, pending tasks,
and more.  The details of running a bug tracker are covered in
<xref linkend="bug-tracker"/><phrase output="printed"> in
<xref linkend="technical-infrastructure"/></phrase>, so I won't
go into them here.  The important thing from a presentation point of
view is just to <emphasis>have</emphasis> a bug tracker, and to make
sure that fact is visible from the front page of the project.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="communications-channels">
<title>Communications Channels</title>

<para>Visitors usually want to know how to reach the human beings
involved with the project.  Provide the addresses of mailing lists,
chat rooms, and IRC channels, and any other forums where others
involved with the software can be reached.  Make it clear that you and
the other authors of the project are subscribed to these mailing
lists, so people see there's a way to give feedback that will reach
the developers.  Your presence on the lists does not imply a
committment to answer all questions or implement all feature requests.
In the long run, most users will probably never join the forums
anyway, but they will be comforted to know that they
<emphasis>could</emphasis> if they ever needed to.</para>

<para>In the early stages of a project, there's no need to have
separate user and developer forums.  It's much better to have everyone
involved with the software talking together, in one "room."  Among
early adopters, the distinction between developer and user is often
fuzzy; to the extent that the distinction can be made, the ratio of
developers to users is usually much higher in the early days of the
project than later on.  While you can't assume that every early
adopter is a programmer who wants to hack on the software, you can
assume that they are at least interested in following development
discussions and in getting a sense of the project's direction.</para>
   
<para>As this chapter is only about getting a project started, it's
enough merely to say that these communications forums need to exist.
Later, in <xref linkend="growth"/><phrase output="printed"> in
<xref linkend="communications"/></phrase>, we'll examine where
and how to set up such forums, the ways in which they might need
moderation or other management, and how to separate user forums from
developer forums, when the time comes, without creating an
unbridgeable gulf.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="developer-guidelines">
<title>Developer Guidelines</title>

<para>If someone is considering contributing to the project, she'll
look for developer guidelines.  Developer guidelines are not so much
technical as social: they explain how the developers interact with
each other and with the users, and ultimately how things get
done.</para>

<para>This topic is covered in detail in
<xref linkend="written-rules"/><phrase output="printed"> in
<xref linkend="social-infrastructure"/></phrase>, but the basic
elements of developer guidelines are:

<itemizedlist>
  <listitem><para>pointers to forums for interaction with other
            developers</para> 
  </listitem>
  <listitem><para>instructions on how to report bugs and submit
            patches</para>
  </listitem>
  <listitem><para>some indication of <emphasis>how</emphasis>
            development is usually done&mdash;is the project a
            benevolent dictatorship, a democracy, or something
            else</para>
  </listitem>
</itemizedlist>

No pejorative sense is intended by "dictatorship", by the way.  It's
perfectly okay to run a tyranny where one particular developer has
veto power over all changes.  Many successful projects work this way.
The important thing is that the project come right out and say so.  A
tyranny pretending to be a democracy will turn people off; a tyranny
that says it's a tyranny will do fine as long as the tyrant is
competent and trusted.</para>
  
<para>See <ulink url="http://svn.collab.net/repos/svn/trunk/www/hacking.html"/>
for an example of particularly thorough developer guidelines, or
<ulink url="http://www.openoffice.org/dev_docs/guidelines.html"/> for
broader guidelines that focus more on governance and the spirit of
participation and less on technical matters.</para>

<para>The separate issue of providing a programmer's introduction to
the software is discussed in <xref
linkend="developer-documentation"/><phrase output="printed">
later in this chapter</phrase>.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="documentation">
<title>Documentation</title>

<para>Documentation is essential.  There needs to be
<emphasis>something</emphasis> for people to read, even if it's
rudimentary and incomplete.  This falls squarely into the "drudgery"
category referred to earlier, and is often the first area where a new
open source projects falls down.  Coming up with a mission statement
and feature list, choosing a license, summarizing development
status&mdash;these are all relatively small tasks, which can be
definitively completed and usually need not be returned to once done.
Documentation, on the other hand, is never really finished, which may
be one reason people sometimes delay starting it at all.</para>

<para>The most insidious thing is that documentation's utility to
those writing it is the reverse of its utility to those who will read
it.  The most important documentation for initial users is the basics:
how to quickly set up the software, an overview of how it works,
perhaps some guides to doing common tasks.  Yet these are exactly the
things the <emphasis>writers</emphasis> of the documentation know all
too well&mdash;so well that it can be difficult for them to see
things from the reader's point of view, and to laboriously spell out
the steps that (to the writers) seem so obvious as to be unworthy of
mention.</para>

<para>There's no magic solution to this problem.  Someone just needs
to sit down and write the stuff, and then run it by typical new users
to test its quality.  Use a simple, easy-to-edit format such as HTML,
plain text, Texinfo, or some variant of XML&mdash;something that's
convenient for lightweight, quick improvements on the spur of the
moment.  This is not only to remove any overhead that might impede the
original writers from making incremental improvements, but also for
those who join the project later and want to work on the
documentation.</para>

<para>One way to ensure basic initial documentation gets done is to
limit its scope in advance.  That way, writing it at least won't feel
like an open-ended task.  A good rule of thumb is that it should meet
the following minimal criteria:</para>

<itemizedlist>
  <listitem><para>Tell the reader clearly how much technical
            expertise they're expected to have.</para>
  </listitem>
  <listitem><para>Describe clearly and thoroughly how to set up
            the software, and somewhere near the beginning of the
            documentation, tell the user how to run some sort of
            diagnostic test or simple command to confirm that
            they've set things up correctly.  Startup
            documentation is in some ways more important than
            actual usage documentation.  The more effort someone has
            invested in installing and getting started with the
            software, the more persistent she'll be in figuring out
            advanced functionality that's not well-documented.
            When people abandon, they abandon early; therefore,
            it's the earliest stages, like installation, that need
            the most support.</para>
  </listitem>
  <listitem><para>Give one tutorial-style example of how to do a
            common task.  Obviously, many examples for many tasks
            would be even better, but if time is limited, pick one
            task and walk through it thoroughly.  Once someone
            sees that the software <emphasis>can</emphasis> be
            used for one thing, they'll start to explore what else
            it can do on their own&mdash;and, if you're lucky,
            start filling in the documentation themselves.  Which
            brings us to the next point...</para>
  </listitem>
  <listitem><para>Label the areas where the documentation is known
            to be incomplete.  By showing the readers that you are
            aware of its deficiencies, you align yourself with
            their point of view.  Your empathy reassures them that
            they don't face a struggle to convince the project of
            what's important.  These labels needn't represent
            promises to fill in the gaps by any particular date
           &mdash;it's equally legitimate to treat them as open
            requests for volunteer help.</para>
  </listitem>
</itemizedlist>

<para>The last point is of wider importance, actually, and can be
applied to the entire project, not just the documentation.  An
accurate accounting of known deficiencies is the norm in the open
source world.  You don't have to exaggerate the project's
shortcomings, just identify them scrupulously and dispassionately when
the context calls for it (whether in the documentation, in the bug
tracking database, or on a mailing list discussion).  No one will
treat this as defeatism on the part of the project, nor as a
commitment to solve the problems by a certain date, unless the project
makes such a commitment explicitly.  Since anyone who uses the
software will discover the deficiencies for themselves, it's much
better for them to be psychologically prepared&mdash;then the
project will look like it has a solid knowledge of how it's
doing.</para>

<sidebar id="starting-a-faq">
  <title>Maintaining a FAQ</title>

  <para>A <firstterm>FAQ</firstterm> ("Frequently Asked Questions"
  document) can be one of the best investments a project makes in
  terms of educational payoff.  FAQs are highly tuned to the questions
  users and developers actually ask&mdash;as opposed to the questions
  you might have <emphasis>expected</emphasis> them to ask&mdash;and
  therefore, a well-maintained FAQ tends to give those who consult it
  exactly what they're looking for.  The FAQ is often the first place
  users look when they encounter a problem, often even in preference
  to the official manual, and it's probably the document in your
  project most likely to be linked to from other sites.</para>

  <para>Unfortunately, you cannot make the FAQ at the start of the
  project.  Good FAQs are not written, they are grown.  They are by
  definition reactive documents, evolving over time in response to
  people's day-to-day usage of the software.  Since it's impossible to
  correctly anticipate the questions people will ask, it is impossible
  to sit down and write a useful FAQ from scratch.</para>

  <para>Therefore, don't waste your time trying to.  You may, however,
  find it useful to set up a mostly blank FAQ template, so there will
  be an obvious place for people to contribute questions and answers
  after the project is under way.  At this stage, the most important
  property is not completeness, but convenience: if the FAQ is easy to
  add to, people will add to it.  (Proper FAQ maintenance is a
  non-trivial and intriguing problem, and is discussed more in <xref
  linkend="faq-manager"/><phrase output="printed"> in
  <xref linkend="managing-volunteers"/></phrase>.)</para>
</sidebar>

<sect3 id="documentation-availability">
<title>Availability of documentation</title>

<para>Documentation should be available from two places: online
(directly from the web site), <emphasis>and</emphasis> in the
downloadable distribution of the software (see
<xref linkend="packaging"/><phrase output="printed"> in
<xref linkend="development-cycle"/></phrase>).  It needs to be
online, in browsable form, because people often read documentation
<emphasis>before</emphasis> downloading software for the first time,
as a way of helping them decide whether to download at all.  But it
should also accompany the software, on the principle that downloading
should supply (i.e., make locally accessible) everything one needs to
use the package.</para>

<para>For online documentation, make sure that there is a link that
brings up the <emphasis>entire</emphasis> documentation in one HTML
page (put a note like "monolithic" or "all-in-one" or "single large
page" next to the link, so people know that it might take a while to
load).  This is useful because people often want to search for a
specific word or phrase across the entire documentation.  Generally,
they already know what they're looking for; they just can't remember
what section it's in.  For such people, nothing is more frustrating
than encountering one HTML page for the table of contents, then a
different page for the introduction, then a different page for
installation instructions, etc.  When the pages are broken up like
that, their browser's search function is useless.  The separate-page
style is useful for those who already know what section they need, or
who want to read the entire documentation from front to back in
sequence.  But this is <emphasis>not</emphasis> the most common way
documentation is accessed.  Far more often, someone who is basically
familiar with the software is coming back to search for a specific
word or phrase.  To fail to provide them with a single, searchable
document would only make their lives harder.</para>

</sect3>

<sect3 id="developer-documentation">
<title>Developer documentation</title>

<para>Developer documentation is written to help programmers
understand the code, so they can repair and extend it.  This is
somewhat different from the <emphasis>developer guidelines</emphasis>
discussed earlier, which are more social than technical.  Developer
guidelines tell programmers how to get along with each other;
developer documentation tells them how to get along with the code
itself.  The two are often packaged together in one document for
convenience (as with the <ulink
url="http://svn.collab.net/repos/svn/trunk/www/hacking.html"/> example given
earlier), but they don't have to be.</para>

<para>Although developer documentation can be very helpful, there's no
reason to delay a release to do it.  As long as the original authors
are available (and willing) to answer questions about the code, that's
enough to start with.  In fact, having to answer the same questions
over and over is a common motivation for writing documentation.  But
even before it's written, determined contributors will still manage to
find their way around the code.  The force that drives people to spend
time learning a code base is that the code does something useful for
them.  If people have faith in that, they will take the time to figure
things out; if they don't have that faith, no amount of developer
documentation will get or keep them.</para>

<para>So if you have time to write documentation for only one
audience, write it for users.  All user documentation is, in effect,
developer documentation as well; any programmer who's going to work on
a piece of software will need to be familiar with how to use it.
Later, when you see programmers asking the same questions over and
over, take the time to write up some separate documents just for
them.</para>

<para>Some projects use wikis for their initial documentation, or even
as their primary documentation.  In my experience, this really only
works if the wiki is actively edited by a few people who agree on how
the documentation is to be organized and what sort of "voice" it
should have.  See
<xref linkend="wikis"/><phrase output="printed"> in
<xref linkend="technical-infrastructure"/></phrase> for
more.</para>

</sect3>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="example-output">
<title>Example Output and Screenshots</title>

<para>If the project involves a graphical user interface, or if it
produces graphical or otherwise distinctive output, put some samples
up on the project web site.  In the case of interface, this means
screenshots; for output, it might be screenshots or just files.  Both
cater to people's need for instant gratification: a single screenshot
can be more convincing than paragraphs of descriptive text and mailing
list chatter, because a screenshot is inarguable proof that the
software <emphasis>works</emphasis>.  It may be buggy, it may be hard
to install, it may be incompletely documented, but that screenshot is
still proof that if one puts in enough effort, one can get it to
run.</para>

<sidebar id="screenshots">
  <title>Screenshots</title>
  <para>Since screenshots can be daunting until you've actually made a
  few, here are basic instructions for making them.  Using the Gimp
  (<ulink url="http://www.gimp.org/"/>), open
  <guimenu>File</guimenu>-&gt;<guimenu>Acquire</guimenu>-&gt;<guimenu>Screenshot</guimenu>,
  choose <guimenuitem>Single&nbsp;Window</guimenuitem> or
  <guimenuitem>Whole&nbsp;Screen</guimenuitem>, then click
  <guimenuitem>OK</guimenuitem>.  Now your next mouse click will
  capture the window or screen clicked on as an image in the Gimp.
  Crop and resize the image as necessary, using the instructions at 
  <ulink url="http://www.gimp.org/tutorials/Lite_Quickies/#crop"/>.</para> 
</sidebar>
  
</sect2>

<para>There are many other things you could put on the project web
site, if you have the time, or if for one reason or another they are
especially appropriate: a news page, a project history page, a related
links page, a site-search feature, a donations link, etc.  None of
these are necessities at startup time, but keep them in mind for the
future.</para>

<sect2 id="starting-with-canned-hosting">
<title>Canned Hosting</title>

<para>There are a few sites that provide free hosting and
infrastructure for open source projects: a web area, version control,
a bug tracker, a download area, chat forums, regular backups, etc.
The details vary from site to site, but the same basic services are
offered at all of them.  By using one of these sites, you get a lot
for free; what you give up, obviously, is fine-grained control over
the user experience.  The hosting service decides what software the
site runs, and may control or at least influence the look and feel of
the project's web pages.</para>

<para>See
<xref linkend="canned-hosting"/><phrase output="printed"> in
<xref linkend="technical-infrastructure"/></phrase> for a more
detailed discussion of the advantages and disadvantages of canned
hosting, and a list of sites that offer it.</para>

</sect2>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="license-quickstart">
<title>Choosing a License and Applying It</title>

<para>This section is intended to be a very quick, very rough guide to
choosing a license.  Read <xref linkend="legal"/> to understand
the detailed legal implications of the different licenses, and how the
license you choose can affect people's ability to mix your software
with other free software.</para>

<para>There are a great many free software licenses to choose from.
Most of them we needn't consider here, as they were written to satisfy
the particular legal needs of some corporation or person, and wouldn't
be appropriate for your project.  We will restrict ourselves to just
the most commonly used licenses; in most cases, you will want to
choose one of them.</para>

<!-- ======================== subsection ============================== -->
<sect2 id="license-quickstart-non-gpl">
<title>The "Do Anything" Licenses</title>

<para>If you're comfortable with your project's code potentially being
used in proprietary programs, then use
an <firstterm>MIT/X-style</firstterm> license.  It is the simplest of
several minimal licenses that do little more than assert nominal
copyright (without actually restricting copying) and specify that the
code comes with no warranty.  See
<xref linkend="license-choosing-mit-x"/> for details.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="license-quickstart-gpl">
<title>The GPL</title>

<para>If you don't want your code to be used in proprietary programs,
use the GNU General Public License
(<ulink url="http://www.gnu.org/licenses/gpl.html"/>).  The GPL is
probably the most widely recognized free software license in the world
today.  This is in itself a big advantage, since many potential users
and contributors will already be familiar with it, and therefore won't
have to spend extra time to read and understand your license.  See
<xref linkend="license-choosing-gpl"/><phrase output="printed">
in <xref linkend="legal"/></phrase> for details.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="license-quickstart-applying">
<title>How to Apply a License to Your Software</title>

<para>Once you've chosen a license, you should state it on the
project's front page.  You don't need to include the actual text of
the license there; just give the name of the license, and make it link
to the full license text on another page.</para>

<para>This tells the public what license you
<emphasis>intend</emphasis> the software to be released under, but
it's not sufficient for legal purposes.  For that, the software itself
must contain the license.  The standard way to do this is to put the
full license text in a file called <filename>COPYING</filename> (or
<filename>LICENSE</filename>), and then put a short notice at the top
of each source file, naming the copyright date, holder, and license,
and saying where to find the full text of the license.</para>

<para>There are many variations on this pattern, so we'll look at just
one example here.  The GNU GPL says to put a notice like this at the
top of each source file:</para>

<screen>
Copyright (C) &lt;year&gt;  &lt;name of author&gt;

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
</screen>

<para>It does not say specifically that the copy of the license you
received along with the program is in the file
<filename>COPYING</filename>, but that's where it's usually put.  (You
could change the above notice to state that directly.)  This template
also gives a geographical address from which to request a copy of the
license.  Another common method is to give a link to a web page
containing the license.  Just use your judgement and point to wherever
you feel the most permanent copy of the license is maintained, which
might simply be somewhere on your project's web site.  In general, the
notice you put in each source file does not have to look exactly like
the one above, as long as it starts with the same notice of copyright
holder and date, states the name of the license, and makes it clear
where to view the full license.</para>

</sect2>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="setting-tone">
<title>Setting the Tone</title>

<para>So far we've covered one-time tasks you do during project setup:
picking a license, arranging the initial web site, etc.  But the most
important aspects of starting a new project are dynamic.  Choosing a
mailing list address is easy; ensuring that the list's conversations
remain on-topic and productive is another matter entirely.  If the
project is being opened up after years of closed, in-house
development, its development processes will change, and you will have
to prepare the existing developers for that change.</para>

<para>The first steps are the hardest, because precedents and
expectations for future conduct have not yet been set.  Stability in a
project does not come from formal policies, but from a shared,
hard-to-pin-down collective wisdom that develops over time.  There are
often written rules as well, but they tend to be essentially a
distillation of the intangible, ever-evolving agreements that really
guide the project.  The written policies do not define the project's
culture so much as describe it, and even then only
approximately.</para>

<para>There are a few reasons why things work out this way.  Growth
and high turnover are not as damaging to the accumulation of social
norms as one might think.  As long as change does not happen
<emphasis>too</emphasis> quickly, there is time for new arrivals to
learn how things are done, and after they learn, they will help
reinforce those ways themselves.  Consider how children's songs
survive the centuries.  There are children today singing roughly the
same rhymes as children did hundreds of years ago, even though there
are no children alive now who were alive then.  Younger children hear
the songs sung by older ones, and when they are older, they in turn
will sing them in front of other younger ones.  The children are not
engaging in a conscious program of transmission, of course, but the
reason the songs survive is nonetheless that they are transmitted
regularly and repeatedly.  The time scale of free software projects
may not be measured in centuries (we don't know yet), but the dynamics
of transmission are much the same.  The turnover rate is faster,
however, and must be compensated for by a more active and deliberate
transmission effort.</para>

<para>This effort is aided by the fact that people generally show up
expecting and looking for social norms.  That's just how humans are
built.  In any group unified by a common endeavor, people who join
instinctively search for behaviors that will mark them as part of the
group.  The goal of setting precedents early is to make those
"in-group" behaviors be ones that are useful to the project; for once
established, they will be largely self-perpetuating.</para>

<!-- todo: maybe say this:

     Point out how the sponsor's noble fair-mindedness and balanced
     judgement are not properties that can usefully be written down
     formally, because they wouldn't be believed.  They'd just look
     like propaganda anyway, so there's no point.  This is one of
     those areas where conduct and informal precedent is the *only*
     way to solidify a social norm.  And refer to the relevant parts
     of Chapter 5.
-->

<para>Following are some examples of specific things you can do to set
good precedents.  They're not meant as an exhaustive list, just as
illustrations of the idea that setting a collaborative mood early
helps a project tremendously.  Physically, every developer may be
working alone in a room by themselves, but you can do a lot to make
them <emphasis>feel</emphasis> like they're all working together in
the same room.  The more they feel this way, the more time they'll
want to spend on the project.  I chose these particular examples
because they came up in the Subversion project (<ulink
url="http://subversion.tigris.org/"/>),
which I participated in and observed from its very beginning.  But
they're not unique to Subversion; situations like these will come up
in most open source projects, and should be seen as opportunities to
start things off on the right foot.</para>

<!-- ======================== subsection ============================== -->
<sect2 id="avoid-private-discussions">
<title>Avoid Private Discussions</title>

<para>Even after you've taken the project public, you and the other
founders will often find yourselves wanting to settle difficult
questions by private communications among an inner circle.  This is
especially true in the early days of the project, when there are so
many important decisions to make, and, usually, few volunteers
qualified to make them.  All the obvious disadvantages of public list
discussions will loom palpably in front of you: the delay inherent in
email conversations, the need to leave sufficient time for consensus
to form, the hassle of dealing with naive volunteers who think they
understand all the issues but actually don't (every project has these;
sometimes they're next year's star contributors, sometimes they stay
naive forever), the person who can't understand why you only want to
solve problem X when it's obviously a subset of larger problem Y, and
so on.  The temptation to make decisions behind closed doors and
present them as <foreignphrase>faits accomplis</foreignphrase>, or at
least as the firm recommendations of a united and influential voting
block, will be great indeed.</para>

<para>Don't do it.</para>

<para>As slow and cumbersome as public discussions can be, they're
almost always preferable in the long run.  Making important decisions
in private is like spraying contributor repellant on your project.  No
serious volunteer would stick around for long in an environment where
a secret council makes all the big decisions.  Furthermore, public
discussion has beneficial side effects that will last beyond whatever
ephemeral technical question was at issue:

<itemizedlist>
  <listitem>
  <para>The discussion will help train and educate new developers.
        You never know how many eyes are watching the conversation;
        even if most people don't participate, many may be tracking
        silently, gleaning information about the software.</para>
  </listitem>
  <listitem>
  <para>The discussion will train <emphasis>you</emphasis> in the art
        of explaining technical issues to people who are not as
        familiar with the software as you are.  This is a skill that
        requires practice, and you can't get that practice by talking
        to people who already know what you know.</para>
  </listitem>
  <listitem>
  <para>The discussion and its conclusions will be available in public
        archives forever after, enabling future discussions to avoid
        retracing the same steps.  See
        <xref linkend="using-archives"/><phrase output="printed">
        in <xref linkend="communications"/></phrase>.</para>
  </listitem>
</itemizedlist>

</para>

<para>Finally, there is the possibility that someone on the list may
make a real contribution to the conversation, by coming up with an
idea you never anticipated.  It's hard to say how likely this is; it
just depends on the complexity of the code and degree of
specialization required.  But if anecdotal evidence may be permitted,
I would hazard that this is more likely than one would intuitively
expect.  In the Subversion project, we (the founders) believed we
faced a deep and complex set of problems, which we had been thinking
about hard for several months, and we frankly doubted that anyone on
the newly created mailing list was likely to make a real contribution
to the discussion.  So we took the lazy route and started batting some
technical ideas back and forth in private emails, until an observer of
the project<footnote><para>We haven't gotten to the section on
crediting yet, but just to practice what I'll later preach: the
observer's name was Brian Behlendorf, and it was he who pointed out
the general importance of keeping all discussions public unless there
was a specific need for privacy.</para></footnote> caught wind of what
was happening and asked for the discussion to be moved to the public
list.  Rolling our eyes a bit, we did&mdash;and were stunned by the
number of insightful comments and suggestions that quickly resulted.
In many cases people offered ideas that had never even occurred to us.
It turned out there were some <emphasis>very</emphasis> smart people
on that list; they'd just been waiting for the right bait.  It's true
that the ensuing discussions took longer than they would have if we
had kept the conversation private, but they were so much more
productive that it was well worth the extra time.</para>

<para>Without descending into hand-waving generalizations like "the
group is always smarter than the individual" (we've all met enough
groups to know better), it must be acknowledged that there are certain
activities at which groups excel.  Massive peer review is one of them;
generating large numbers of ideas quickly is another.  The quality of
the ideas depends on the quality of the thinking that went into them,
of course, but you won't know what kinds of thinkers are out there
until you stimulate them with a challenging problem.</para>

<para>Naturally, there are some discussions that must be had
privately; throughout this book we'll see examples of those.  But the
guiding principle should always be: <emphasis>If there's no reason for
it to be private, it should be public.</emphasis></para>

<para>Making this happen requires action.  It's not enough merely to
ensure that all your own posts go to the public list.  You also have
to nudge other people's unnecessarily private conversations to the
list too.  If someone tries to start a private discussion, and there's
no reason for it to be private, then it is incumbent on you to open
the appropriate meta-discussion immediately.  Don't even comment on
the original topic until you've either successfully steered the
conversation to a public place, or ascertained that privacy really was
needed.  If you do this consistently, people will catch on pretty
quickly and start to use the public forums by default.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="prevent-rudeness">
<title>Nip Rudeness in the Bud</title>

<para>From the very start of your project's public existence, you
should maintain a zero-tolerance policy toward rude or insulting
behavior in its forums.  Zero-tolerance does not mean technical
enforcement per se.  You don't have to remove people from the mailing
list when they flame another subscriber, or take away their commit
access because they made derogatory comments.  (In theory, you might
eventually have to resort to such actions, but only after all other
avenues have failed&mdash;which, by definition, isn't the case at the
start of the project.)  Zero-tolerance simply means never letting bad
behavior slide by unnoticed.  For example, when someone posts a
technical comment mixed together with an <foreignphrase>ad
hominem</foreignphrase> attack on some other developer in the project,
it is imperative that your response address the <foreignphrase>ad
hominem</foreignphrase> attack <emphasis>first</emphasis>, as a
separate issue unto itself, and only afterward move on to the
technical content.</para>

<para>It is unfortunately very easy, and all too typical, for
constructive discussions to lapse into destructive flame wars.
People will say things in email that they would never say
face-to-face.  The topics of discussion only amplify this effect: in
technical issues, people often feel there is a single right answer to
most questions, and that disagreement with that answer can only be
explained by ignorance or stupidity.  It's a short distance from
calling someone's technical proposal stupid to calling the person
themselves stupid.  In fact, it's often hard to tell where technical
debate leaves off and character attack begins, which is one reason why
drastic responses or punishments are not a good idea.  Instead, when
you think you see it happening, make a post that stresses the
importance of keeping the discussion friendly, without accusing anyone
of being deliberately poisonous.  Such "Nice Police" posts do have an
unfortunate tendency to sound like a kindergarten teacher lecturing a
class on good behavior:</para>

    <blockquote>
      <para><emphasis>First, let's please cut down on the
      (potentially) ad hominem comments; for example, calling J's
      design for the security layer "naive and ignorant of the basic
      principles of computer security."  That may be true or it may
      not, but in either case it's no way to have the discussion.  J
      made his proposal in good faith.  If it has deficiencies, point
      them out, and we'll fix them or get a new design.  I'm sure M
      meant no personal insult to J, but the phrasing was unfortunate,
      and we try to keep things constructive around here.
      </emphasis></para>

      <para><emphasis>Now, on to the proposal.  I think M was right
      in saying that...</emphasis></para>
    </blockquote>

<para>As stilted as such responses sound, they have a noticeable
effect.  If you consistently call out bad behavior, but don't demand
an apology or acknowledgment from the offending party, then you leave
people free to cool down and show their better side by behaving more
decorously next time&mdash;and they will.  One of the secrets of
doing this successfully is to never make the meta-discussion the main
topic.  It should always be an aside, a brief preface to the main
portion of your response.  Point out in passing that "we don't do
things that way around here," but then move on to the real content, so
that you're giving people something on-topic to respond to.  If
someone protests that they didn't deserve your rebuke, simply refuse
to be drawn into an argument about it.  Either don't respond (if you
think they're just letting off steam and don't require a response), or
say you're sorry if you overreacted and that it's hard to detect
nuance in email, then get back to the main topic.  Never, ever insist
on an acknowledgment, whether public or private, from someone that
they behaved inappropriately.  If they choose of their own volition to
post an apology, that's great, but demanding that they do so will only
cause resentment.</para>

<para>The overall goal is to make good etiquette be seen as one of the
"in-group" behaviors.  This helps the project, because developers can
be driven away (even from projects they like and want to support) by
flame wars.  You may not even know that they were driven away; someone
might lurk on the mailing list, see that it takes a thick skin to
participate in the project, and decide against getting involved at
all.  Keeping forums friendly is a long-term survival strategy, and
it's easier to do when the project is still small.  Once it's part of
the culture, you won't have to be the only person promoting it.  It
will be maintained by everyone.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="code-review">
<title>Practice Conspicuous Code Review</title>

<para>One of the best ways to foster a productive development
community is to get people looking at each others' code.  Some
technical infrastructure is required to do this effectively&mdash;in
particular, commit emails must be turned on; see
<xref linkend="commit-emails"/> for more details.  The effect of
commit emails is that every time someone commits a change to the
source code, an email goes out showing the log message and diffs for
the change (see <xref linkend="vc-vocabulary-diff"/>, in
<xref linkend="vc-vocabulary"/>).  <firstterm>Code review</firstterm>
is the practice of reviewing commit emails as they come in, looking
for bugs and possible improvements.<footnote><para>This is how code
review is usually done in open source projects, at any rate.  In more
centralized projects, "code review" can also mean multiple people
sitting down together and going over printouts of source code, looking
for specific problems and patterns.</para></footnote></para>

<para>Code review serves several purposes simultaneously.  It's the
most obvious example of peer review in the open source world, and
directly helps to maintain software quality.  Every bug that ships in
a piece of software got there by being committed and not detected;
therefore, the more eyes watch commits, the fewer bugs will ship.  But
code review also serves an indirect purpose: it confirms to people
that what they do matters, because one obviously wouldn't take time to
review a commit unless one cared about its effect.  People do their
best work when they know that others will take the time to evaluate
it.</para>

<para>Reviews should be public.  Even on occasions when I have been
sitting in the same physical room with developers, and one of us has
made a commit, we take care not to do the review verbally in the room,
but to send it to the development mailing list instead.  Everyone
benefits from seeing the review happen.  People follow the commentary
and sometimes find flaws in it, and even when they don't, it still
reminds them that review is an expected, regular activity, like
washing the dishes or mowing the lawn.</para>

<para>In the Subversion project, we did not at first make a regular
practice of code review.  There was no guarantee that every commit
would be reviewed, though one might sometimes look over a change if
one was particularly interested in that area of the code.  Bugs
slipped in that really could and should have been caught.  A developer
named Greg Stein, who knew the value of code review from past work,
decided that he was going to set an example by reviewing every line of
<emphasis>every single commit</emphasis> that went into the code
repository.  Each commit anyone made was soon followed by an email to
the developer's list from Greg, dissecting the commit, analyzing
possible problems, and occasionally praising a clever bit of code.  Right
away, he was catching bugs and non-optimal coding practices that would
otherwise have slipped by without ever being noticed.  Pointedly, he
never complained about being the only person reviewing every commit,
even though it took a fair amount of his time, but he did sing the
praises of code review whenever he had the chance.  Pretty soon, other
people, myself included, started reviewing commits regularly too.
What was our motivation?  It wasn't that Greg had consciously shamed
us into it.  But he had proven that reviewing code was a valuable way
to spend time, and that one could contribute as much to the project by
reviewing others' changes as by writing new code.  Once he
demonstrated that, it became expected behavior, to the point where any
commit that didn't get some reaction would cause the committer to
worry, and even ask on the list whether anyone had had a chance to
review it yet.  Later, Greg got a job that didn't leave him as much
time for Subversion, and had to stop doing regular reviews.  But by
then, the habit was so ingrained for the rest of us as to seem that it
had been going on since time immemorial.</para>

<para>Start doing reviews from very first commit.  The sorts of
problems that are easiest to catch by reviewing diffs are security
vulnerabilities, memory leaks, insufficient comments or API
documentation, off-by-one errors, caller/callee discipline mismatches,
and other problems that require a minimum of surrounding context to
spot.  However, even larger-scale issues such as failure to abstract
repeated patterns to a single location become spottable after one has
been doing reviews regularly, because the memory of past diffs informs
the review of present diffs.</para>

<!-- todo: Andrew Stellman suggested putting a checklist of what to
     look for in code review here.  That might be a good idea. -->

<para>Don't worry that you might not find anything to comment on, or
that you don't know enough about every area of the code.  There will
usually be something to say about almost every commit; even where you
don't find anything to question, you may find something to praise.
The important thing is to make it clear to every committer that what
they do is seen and understood.  Of course, code review does not
absolve programmers of the responsibility to review and test their
changes before committing; no one should depend on code review to
catch things he ought to have caught on his own.</para>

</sect2>

<!-- ======================== SECTION ============================== -->
<sect2 id="opening-closed-projects">
<title>When Opening a Formerly Closed Project, be Sensitive to the
Magnitude of the Change</title>

<para>If you're opening up an existing project, one that already has
active developers accustomed to working in a closed-source
environment, make sure everyone understands that a big change is
coming&mdash;and make sure that you understand how it's going to
feel from their point of view.</para>

<para>Try to imagine how the situation looks to them: formerly, all
code and design decisions were made with a group of other programmers
who knew the software more or less equally well, who all received the
same pressures from the same management, and who all know each others'
strengths and weaknesses.  Now you're asking them to expose their code
to the scrutiny of random strangers, who will form judgements based
only on the code, with no awareness of what business pressures may
have forced certain decisions.  These strangers will ask lots of
questions, questions that jolt the existing developers into realizing
that the documentation they slaved so hard over is
<emphasis>still</emphasis> inadequate (this is inevitable).  To top it
all off, the newcomers are unknown, faceless entities.  If one of your
developers already feels insecure about his skills, imagine how that
will be exacerbated when newcomers point out flaws in code he wrote,
and worse, do so in front of his colleagues.  Unless you have a team
of perfect coders, this is unavoidable&mdash;in fact, it will probably
happen to all of them at first.  This is not because they're bad
programmers; it's just that any program above a certain size has bugs,
and peer review will spot some of those bugs (see
<xref linkend="code-review"/><phrase output="printed"> earlier
in this chapter</phrase>).  At the same time, the newcomers
themselves won't be subject to much peer review at first, since they
can't contribute code until they're more familiar with the project.
To your developers, it may feel like all the criticism is incoming,
never outgoing.  Thus, there is the danger of a siege mentality taking
hold among the old hands.</para>

<para>The best way to prevent this is to warn everyone about what's
coming, explain it, tell them that the initial discomfort is perfectly
normal, and reassure them that it's going to get better.  Some of
these warnings should take place privately, before the project is
opened.  But you may also find it helpful to remind people on the
public lists that this is a new way of development for the project,
and that it will take some time to adjust.  The very best thing you
can do is lead by example.  If you don't see your developers answering
enough newbie questions, then just telling them to answer more isn't
going to help.  They may not have a good sense of what warrants a
response and what doesn't yet, or it could be that they don't have a
feel for how to prioritize coding work against the new burden of
external communications.  The way to get them to participate is to
participate yourself.  Be on the public mailing lists, and make sure
to answer some questions there.  When you don't have the
expertise to field a question, then visibly hand it off to a developer
who does&mdash;and watch to make sure he follows up with an answer,
or at least a response.  It will naturally be tempting for the
longtime developers to lapse into private discussions, since that's
what they're used to.  Make sure you're subscribed to the internal
mailing lists on which this might happen, so you can ask that such
discussions be moved to the public lists right away.</para>

<para>There are other, longer-term concerns with opening up formerly
closed projects.  <xref linkend="social-infrastructure"/> explores
techniques for mixing paid and unpaid developers successfully, and
<xref linkend="legal"/> discusses the necessity of legal diligence
when opening up a private code base that may contain software written
or "owned" by other parties.</para>

</sect2>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="announcing">
<title>Announcing</title>

<para>Once the project is presentable&mdash;not perfect, just
presentable&mdash;you're ready to announce it to the world.  This is
actually a very simple process: go to <ulink
url="http://freshmeat.net/"/>, click on
<guimenuitem>Submit</guimenuitem> in the top navigation bar, and fill
out a form announcing your new project.  Freshmeat is the place
everyone watches for new project announcements.  You only have to
catch a few eyes there for news of your project to spread by word of
mouth.</para>

<para>If you know of mailing lists or newsgroups where an announcement
of your project would be on-topic and of interest, then post there,
but be careful to make exactly <emphasis>one</emphasis> post per
forum, and to direct people to your project's own forums for follow-up
discussion (by setting the <systemitem>Reply-to</systemitem> header).
The posts should be short and get right to the point:</para>

<screen>
To: discuss@lists.example.org
Subject: [ANN] Scanley full-text indexer project
Reply-to: dev@scanley.org

This is a one-time post to announce the creation of the Scanley
project, an open source full-text indexer and search engine with a
rich API, for use by programmers in providing search services for
large collections of text files.  Scanley is now running code, is
under active development, and is looking for both developers and
testers.

Home page: http://www.scanley.org/

Features:
   - Searches plain text, HTML, and XML
   - Word or phrase searching
   - (planned) Fuzzy matching
   - (planned) Incremental updating of indexes
   - (planned) Indexing of remote web sites

Requirements:
   - Python 2.2 or higher
   - Enough disk space to hold the indexes (approximately 2x
     original data size)

For more information, please come to scanley.org.

Thank you,
-J. Random
</screen>

<para>(See <xref linkend="publicity"/><phrase output="printed">
in <xref linkend="communications"/></phrase> for advice on announcing
further releases and other project events.)</para>

<para>There is an ongoing debate in the free software world about
whether it is necessary to begin with running code, or whether a
project can benefit from being opened even during the
design/discussion stage.  I used to think starting with running code
was the most important factor, that it was what separated successful
projects from toys, and that serious developers would only be
attracted to software that did something concrete already.</para>

<para>This turned out not to be the case.  In the Subversion project,
we started with a design document, a core of interested and
well-connected developers, a lot of fanfare, and
<emphasis>no</emphasis> running code at all.  To my complete surprise,
the project acquired active participants right from the beginning, and
by the time we did have something running, there were quite a few
volunteer developers already deeply involved.  Subversion is not the
only example; the Mozilla project was also launched without running
code, and is now a successful and popular web browser.</para>

<para>In the face of such evidence, I have to back away from the
assertion that running code is absolutely necessary for launching a
project.  Running code is still the best foundation for success, and a
good rule of thumb would be to wait until you have it before
announcing your project.  However, there may be circumstances where
announcing earlier makes sense.  I do think that at least a
well-developed design document, or else some sort of code framework,
is necessary&mdash;of course it may be revised based on public
feedback, but there has to be something concrete, something more
tangible than just good intentions, for people to sink their teeth
into.</para>

<para>Whenever you announce, don't expect a horde of volunteers to
join the project immediately afterward.  Usually, the result of
announcing is that you get a few casual inquiries, a few more people
join your mailing lists, and aside from that, everything continues
pretty much as before.  But over time, you will notice a gradual
increase in participation from both new code contributors and users.
Announcement is merely the planting of a seed.  It can take a long
time for the news to spread.  If the project consistently rewards
those who get involved, the news <emphasis>will</emphasis> spread,
though, because people want to share when they've found something
good.  If all goes well, the dynamics of exponential communications
networks will slowly transform the project into a complex community,
where you don't necessarily know everyone's name and can no longer
follow every single conversation.  The next chapters are about working
in that environment.</para>

</sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->


