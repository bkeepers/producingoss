<chapter id="managing-volunteers">

<title>管理志愿者</title>

<simplesect>

<para>让人们认可项目所需要的，并一同努力实现，不仅仅需要友好的氛围和避免明显的功能异常。需要某个人或一些人有意识的管理所有参与的人。管理志愿者可能不像计算机编程具有同样的技术技巧，但它是一种可以通过学习和实践改进的技艺。</para>

<para>本章是管理志愿者技术的摸彩袋。可能描绘的分量远重于之前的章节，会以Subversion项目作为案例研究，一方面因为我在这个项目工作，所有主要的资源就在手边，也因为砸自家的玻璃总比砸别人更能让人能接受吧。但是我也看到许多其他的项目因为应用这些建议而获益，以及未能应用的后果；当在政治上适合给出这些项目的案例时，我就会这样做。</para>

<para>说到政治，这是在近距离观察以抛弃那些恶毒语言的好时机。许多工程师认为政治只是其他人参与的东西。 “<emphasis>我只是</emphasis>提出对于这个项目最好的过程，但是<emphasis>她</emphasis>出于政治原因提出反对。”我相信政治（以及那些认为是政治的事情）的灾难在工程师中特别强大，因为工程师带来的思想中总有些解决方案是客观的优于其他方案。因此，当有人被思考之外的方式激发&mdash;例如维护自己的影响，削弱其他人的影响，草率的讨价还价或避免伤害某人的情绪&mdash;项目中的其他参与者就会感到恼怒。当然，当关系到他们自己的关键利益时他们也很难避免这样做。</para>

<para>如果你认为”政治“是一句肮脏的词汇，希望你的项目远离它，请放弃吧。当人们需要合作的管理共享资源时，政治是不可避免的。每个人在作出决策时，都会很自然的考虑到决策的结果对自己在项目中影响力的影响。毕竟，如果你像其他程序员一样相信自己的判断和技能，那么未来影响力的降低也可以看作是技术的结果。同样的远离可以应用于其他的行为，从表面上看就是”纯粹的“政治。事实上，没有纯粹的政治：这是因为如果人们把政治作为首要考虑的因素，则行动在实际上会有多重的后果。最终，政治只是决策所要考虑的<emphasis>所有</emphasis>后果的一种承认。如果某个决策的结果可以让绝大多数参与者在技术上感到满意，但是会导致力量对比发生变化，使关键人物感觉自己被孤立，那么后者与前者同样重要。忽略它并不是高尚，只是短视。</para>

<para>就像你后面将要读到的建议，以及你自己工作的项目，请牢记<emphasis>没有人</emphasis>是高于政治的。对于高于政治的企图仅仅是一种特别的政治策略，有时非常有用，但并不现实。当某人有分歧时政治已经出现，成功的项目能够将政治机制建设性的用于管理分歧。</para>

</simplesect>

<!-- ======================== SECTION ============================== -->
<sect1 id="volunteers">
<title>从志愿者中获取最多</title>

<para>志愿者为什么要为自由软件项目工作？<footnote><para>这个问题已经被详细研究，Karim Lakhani和Robert G. Wolf的一篇论文有非常有趣的结果，题目为<citetitle>Why Hackers Do What They Do: Understanding
Motivation and Effort in Free/Open Source Software
Projects</citetitle>。见<ulink url="http://freesoftware.mit.edu/papers/lakhaniwolf.pdf"
/>。</para></footnote></para>

<para>当被询问时，许多人声称自己只是因为希望制作好软件，或希望自己修复所需要的bug。但是这些原因并不是完整的故事。毕竟，你能想象如果没有人欣赏他的工作或倾听他的讨论，这个志愿者还会呆在这个项目吗？当然不会。很明显，人们在自由软件上花费时间的原因不仅仅是单纯的对生产良好代码的渴望。理解志愿者的真实动机将会帮助你能够合理的安排，以确保吸引和保持他们。对生产优秀软件的渴望、在复杂问题上获取的挑战和学习价值也许都是动机。但是人们有与其他人一起工作的内在期望，并在合作活动中提供和获取尊重。从事合作活动的团队必须进化出行为的标准，能够通过帮助团队的活动获取并保持那种地位。</para>

<para>这些标准并不总能自己出现。例如，在一些项目中&mdash;资深的开源开发者可以从顶级人员中去除几个人&mdash;人们明确的感觉到是通过频繁并详细的发布取得的这种地位。他们并不是偶然得到这个结论；这是因为他们曾经因进行长时间的，复杂的辩论中而得到尊重的回报，即使对项目没有实际的帮助。下面是一些创建氛围的技术，可以让获取地位的活动与建设性活动一致起来。</para>

<!-- ======================== subsection ============================== -->
<sect2 id="delegation">
<title>委派</title>

<para>委派并不仅仅是将工作分散的方法；它也是政治和社会工具。考虑你要求某人做什么事情的所有效应。最明显的效应是如果他接受，就是他完成任务不是你。但是另一个效应则是他意识到你信任他能够处理这个任务。此外，如果你是在公共论坛发起这样的请求，那么他也知道团队中的其他人也表明了对他的信任。他也能感受到需要接受一些压力，这意味着你询问时要使用一种允许他拒绝的方式，如果他确实不想做这个工作的话。如果这个任务需要在项目中协调，你这样做可以有效的提议他更深入的参与进来，形成其他方式无法形成的契约，而且也有可能成为项目某个子领域权威的起源。增加的参与或许令人畏惧，也或者会导致他以其他方式参与进来，例如对于整体承诺的更多感觉。</para>

<para>因为所有这些效应，所以即使你认为你可以完成的更好更快，让其他人来完成也很有意义。当然，也有一个严谨的经济学效率作为论据：或许你自己完成的机会成本太高&mdash;在同一时间里你可以完成许多更重要的事情。但即使机会成本的论据并不适应，你<emphasis>还是</emphasis>会希望其他人完成这个任务，因为从长期来看你希望人们更深入的参与到项目当中，即使一开始需要花费更多的时间关注他们。相反的技术也适应：如果你偶然志愿完成其他人不喜欢或没时间完成的工作，你会得到他的友好关系和尊敬。委派和代理并不仅仅是要完成单个任务；他们也是将人们引入到项目核心的方法。</para>

<sect3 id="delegation-assignment">
<title>明确区分调查和指派</title>

<para>有时可以很明确的期待某人会接受特定的任务。例如，如果某人编写的代码带来了bug，或者提交的代码明显未能符合项目的指导方针，那么直接指出问题，那么之后你可以认为他会小心避免此类问题。但是在一些情况下，没有明确的方法可以确保你获得期望的行动。这个人可以听你的，也可以不听。因为没有人喜欢被熟视无睹，你需要敏感的察觉到这两种情形的区别，并以此为依据调整你的请求。</para>

<para>你让某人做某事，如果你采用的方式让人感觉这是他理所当然的责任，而实际上他并不是这么想的时，几乎一定会立刻让他们感到非常的厌恶。例如，分配的问题可能会带来很多讨厌的事。项目的参与者通常知道谁是某个领域的专家，所以当出现了bug报告，通常会有大家都知道的一两个人可以立刻快速的修正它。然而，如果你没有得到先前的许可就将问题分配给她，她会感觉自己处于一个不舒服的地位。她会感受到这种被期望的压力，而且感觉她是由于其专业技能而被惩罚了。毕竟，获取技能的方法就是通过修正bug，所以某人会接受这个问题！（请注意，在问题跟踪系统中根据bug报告的信息自动分配的问题通常并不太冒犯，因为每个人知道分配是自动的过程，并不代表人们的预期。）</para>

<para>虽然应该尽可能将负担均匀的分配，但有时你需要鼓励能够以最快速度修正bug的 人。考虑到你可能无法承受为每个这种分配进行这种交流的负担（“你愿意看一下这个bug吗？” “可以。” “好的，一会儿吧这个问题分配给你。” “好的。”），你应当以询问的形式进行分配，不要传递出任何压力。事实上所有的问题跟踪系统都允许为任务分配的问题作出评论。在那个评论中，你可以这样说：</para>

<blockquote>
   <para>把这个分配给你，jrandom，因为你可能是最熟悉这些代码的。如果没时间，尽管踢回来。（如果你想在以后接受这中请求，请让我们知道。）</para>
</blockquote>

<para><emphasis>请求</emphasis>完成工作与某人<emphasis>接受</emphasis>工作有明显的区别。在这里观众不仅仅是被分配工作的，而是所有人：整个团队可以看到被安排工作的人的专业技能得到了公开的确认，但是这些信息也明确的表明他可以自由的接受或者拒绝这种责任。</para>

</sect3>

<sect3 id="delegation-followup">
<title>指派后要继续跟踪</title>

<para>当你要求某人做一些事情时，请牢记所做的，并无论如何要继续跟踪他。大多数请求是在公共论坛中做出的，形式大体上类似“你能处理一下X吗？我们只是要获知；如果你不行，那么没问题，我们只需要知道。 ”不一定会得到回应。如果你得到的回应是负面的，则环路可以关闭&mdash;你需要尝试其他的策略来处理X。如果有正面的回应，那就需要继续关注这个问题的进展，并为可见和不可见的进展作出评论（当知道其他人会欣赏他的作品时，每个人都会做的更好）。如果几天内没有回应，可以再次询问，或者发表文章说明你没有得到回应，希望找其他人做这件事。或者直接自己完成，但也要说明最初的询问未能获得回应。</para>

<para>公开提示缺乏回应的目的并<emphasis>不是</emphasis>要羞辱任何人，你的评论一定不要造成这种效果。目的仅仅是说明你还在跟踪自己征求的问题，而且你已经注意到了一些反应。这样做可以增大人们在下一次说同意的机会，因为他们会知道（即使只是无意的）你会注意到他们所做的任何工作，包括许多不太起眼的，人们会忽略的事件。</para>

</sect3>

<sect3 id="delegation-interest">
<title>通知感兴趣的人</title>

<para>另一件可以让人们高兴的事情就是通知他们所感兴趣的事情&mdash;通常情况下，你注意到并记住某人的个性方面越多，他会越觉得舒适，他也就越会希望参与你的团队一起工作。</para>

<para>例如，在Subversion项目有一个非常有明显区别的划分，期望达到决定性的1.0发布的人，和那些主要希望添加新特性，并完成感兴趣的问题，但对1.0并不太关心的人。两者的地位相当；他们只是不同类型的开发者，都在项目中完成了大量工作。但是很快认识到我们绝<emphasis>不能</emphasis>假设所有的人都是由1.0发布的喜悦所驱动的。电子媒介可能很有迷惑性：在你感觉到共同目标的氛围中，实际上只是你与谈过话的人有共同的目标，而其他人则有完全不同的优先级。</para>

<para>你对人们对于项目的期望了解越多，你就越能有效发出请求。即使仅仅是描述一下他们所期望目标的理解，甚至不必发出任何相关的请求，也非常有用，这样可以确保所有人不仅仅是无差别群众中的粒子。</para>

</sect3>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="praise-and-criticism">
<title>赞扬和批评</title>

<para>赞扬和批评并不矛盾；在大多数情况下，是类似的。都是关注的形式，越是明确就越有效。二者必须在牢记实在目标的情况下实施。两者都有可能因为夸大而削弱：赞扬过多或太频繁会使赞扬贬值；对批评也是同样，尽管在实践中，批评通常会有反作用，因而更加不容易贬值。</para>

<para>一个重要的技术文化特性是将详细的，不带偏见的批评当作当作一种赞扬（正如在<phrase output="printed"><xref linkend="communications"/>的</phrase><xref linkend="rudeness"/>中所讨论的），因为这隐含了接收者的工作值得花时间去分析。然而，两种条件&mdash;<emphasis>详细的</emphasis>和<emphasis>不带偏见的</emphasis>&mdash;必须同时满足。例如，如果某人对代码做了些马虎的修改，如果只是说“很马虎”是毫无用处（而且通常是有害的）的。马虎最终是<emphasis>人</emphasis>的一种特性，而不是作品的，应该将反应集中到作品上。更有效的方法是描述变更中所有错误的地方，巧妙而无恶意。如果这是某人连续第3，或者第4次作出疏忽的修改，则可以再说一次这些事&mdash;不必发怒&mdash;批评的最后，要清楚的说明同样的模式早已经被注意到了。</para>

<para>如果某人对于批评不做任何改进，解决办法不应该是更多或更强的批评。对于团队来说，解决方法是将这个人从不能胜任的位置删除，并尽可能使用一种不会造成情绪伤害的方法；见<xref linkend="transitions"/><phrase output="printed">本章后面的</phrase>例子。但实际上，这种情况通常很少发生。大多数人可以很好的回应批评，当然批评必须要特定，详细并有明确的（即使没有说出来）改进预期。</para>

<para>赞扬不会伤害任何人的感情，但并不意味着使用时可以不像批评那样小心。赞扬是一种工具：在使用之前，要问自己<emphasis>为什么</emphasis>你希望使用它。作为一条戒律，不应该因为人们经常做的事情，或正常的和参与到团队中应当要做的行动赞扬他。如果你这样做，估计就停不下来了：你因为普通的事情而赞扬<emphasis>每个人</emphasis>？毕竟，如果你漏掉了某人，他们会问为什么。如果能珍惜你的赞扬和感激会更好，要针对不寻常或意料之外的努力，以鼓励此类努力为目的。当某个参与者永久的进入了更高生产力的状态，要根据此人调整赞扬的阀值。对普通的行为进行反复的赞扬会变得毫无意义。相反，这个人也应该感觉到自己较高的生产力水平已经是正常和自然的，只有超出这个范围的才会被特别关注。</para>

<para>当然，这并不是说不应该感谢某人的贡献。但是请牢记，如果项目设置正确，这个人做的任何事情都会看到，所以这个团队会知道（这个人也会知道团队中的其他人所知道的）所有她所做的。除了直接的赞扬，我们也有其他的方法感谢某人的工作。你也可以采用曲折战术，在讨论相关主题时，她已经给定领域做了许多工作，成为了领域专家；你可以公开的向她咨询代码的问题；或者更有效的，你可以大张旗鼓的进一步利用她的工作，这样她就会为别人依赖于她的工作结果而感到舒服。通常不必在这些问题上精打细算。那些有规律的为项目作出贡献的人知道自己会自然的得到有影响的地位。通常没有必要为此采取明确的步骤，除非你感觉到无论出于什么原因，贡献者都无法得到正确的评价时。</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="territoriality">
<title>防止割据</title>

<para>请留意那些试图在项目中独占某一领域，或希望完成某一领域所有工作的的参与者。此类行为已开始看起来很健康。毕竟，在表面上似乎是某人在肩负更多的责任，并展示在特定领域增长的活动。但从长期来看，则并没有建设性。当人们感觉到“禁止入内”的标志时，他们就会离开。这种结果会减少这个领域的检查，会使之更加脆弱，因为孤单的开发者成为失败的单独一点。更严重的，它会削弱项目的合作，平等精神。理论上应该欢迎任何开发者在任何时间帮助完成任何任务。当然，在实践中会有些不同：人们在不同领域的影响总有差别，非专家通常与项目特定领域的专家不同。但关键是这都是自愿的：非正式的权威是根据竞争性和证明的判断能力赋予的，而不可以主动的<emphasis>获取到</emphasis>。即使某人期望的权威是能够胜任的，仍然需要她非正式的保持权威，通过团队的共识和那种永远不会将其他人排除在该领域之外的权威。</para>

<para>当然，因为技术原因反对或编辑某人的工作则是完全另外一回事。决策因素是工作的内容，而不应该是谁恰好是守门人。也许也是同一个人完成恰好完成了最多的工作，但只要他没有阻止其他人完成这个工作，就没有问题。</para>

<para>为了对抗地方主义的萌芽，许多项目采用禁止在源代码文件中包含作者名或维护者签名的方法。我完全认可这种实践：我们在Subversion项目中也遵循这个方法，这也算是Apache基金会的一种正式政策。ASF成员Sander Striker是这样做的：</para>

<blockquote>
   <para><emphasis>在Apache软件基金会中我们不鼓励在源代码中使用作者标签。除了法律分歧以外，还有多方面的原因。协作开发是以一个团队一起工作，将整个项目看作一个团队。给予信誉非常好，必须有人这么做，但是必须使用不会允许错误归因的方式，即使是通过暗示的方式。何时添加或删除作者标签没有明确的标准。在你修改注释后添加你的名字？或者是添加了一行的修正？在你重构了代码，改变了95%时就可以删除其他作者的标签？当人们去接触每一个文件，修改足够多的内容以达到名字标签的限额，这样他们的名字就会出现在每个地方时，你会怎么做？</emphasis></para>

   <para><emphasis>有更好的办法可以提供信誉，我们推荐这些。从技术观点上讲，作者标签并不是必需的；如果你希望知道哪个人写了某段代码，版本控制工具可以提供。作者标签也经常失去时效性。你希望被私下咨询5年前编写，而且已经希望遗忘的代码？</emphasis></para>
</blockquote>

<para>软件项目的源代码文件时身份的核心。必须要反映整个开发社区为此负责，而不仅仅是简单的各自的封地。</para>

<para>人们有时会为源代码中作者或维护者标签的风格而争论，他们认为这些东西是所做工作的可见信誉。这种论点有两个问题。首先，不可避免的要面对多少工作量才可以进入这个列表的尴尬问题。其次，这样会将信誉的问题与权威合并了：过去曾经完成了工作并不意味着对于曾经工作区域的所有权，但是如果单个人的名字出现在源文件的顶部，想避免这种暗示就变得几乎不可能。在任何情况下，信誉信息都可以从版本控制日志和其他诸如邮件列表归档等外带机制中获取，所以在源代码文件中禁止其出现不会损失任何信息。<footnote><para>但是邮件列表中链接为<ulink url="http://groups.google.com/group/sage-devel/browse_thread/thread/e207ce2206f0beee"/>的<citetitle>“having authors names in .py files”</citetitle>的这篇文章是一个很好的抗辩，作者是William Stein。我认为关键在于许多作者来自一种将信誉直接取自源代码视为标准并高度评价的文化。在那种环境中，可能有必要将作者的名字置于源代码中，并精确的描述每个作者的贡献，因而大多数潜在的贡献者会希望有这种样式的承认。</para></footnote></para>

<para>如果你的项目禁止在源代码文件中包含姓名，请务必不要过分执着。例如，许多项目会有一个保存小工具和辅助脚本的<filename>contrib/</filename>区域，通常由与本项目不相关的人编写。这些文件可以包含作者姓名，因为他们完全不是由项目维护的。另一方面，如果贡献的工具被项目的其他人修改了，最终你希望将其从孤立的位置移出，如果原始作者许可，就可以删除作者名称，这样代码就像其他社区维护的资源一样了。如果作者对此有些敏感，折衷的方案也是可以接受的，例如：</para>

<blockquote>
<programlisting>
# indexclean.py: 从Scanley索引删除旧数据。
#
# 原始作者: K. Maru &lt;kobayashi@yetanotheremailservice.com&gt;
# 现在维护者: Scanley项目组&lt;http://www.scanley.org/&gt;
#                    和K. Maru。
# 
# ...
</programlisting>
</blockquote>

<para>但是最好避免此类折衷，如果可能，大多数作者会被说服，因为他们都会乐于自己的贡献更紧密的成为项目的一部分。</para>

<para>重要的是请牢记项目的核心和外围是一个连续体。项目的主要源代码文件显然是核心部分，会被认为应当是由社区维护的。在另一方面，伙伴工具或一些文档则可能是单独某个人的作品，始终独自维护，即使这些作品是与项目关联，甚至是与项目一起分发的。没有必要应用一个适用于所有文件的规则，只要坚持社区维护的资源不允许成为个人领土的原理就可以了。</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="automation">
<title>自动化率</title>

<para>努力不让人做机器可以做的事情。作为一种经验法则，将一项工作自动化花费的工作量即使十倍于手工执行也是值得的。对于非常频繁或复杂的任务，这个比率可以轻松的达到20倍或更高。</para>

<para>将自己想象为“项目管理员”，而不仅仅是开发者，可能是一个有效的态度。有时，单个开发者会过于沉溺于较底层次的工作，而无法看到全局图并意识到每个人都在手工执行自动化任务上浪费了大量精力。即使那些意识到的人也可能不会花时间解决问题：因为每个个体都不会感觉此类任务是一个巨大的负担，没有人已经厌烦到要为此做些什么。使自动化如此引人注目的是每个很小的负担需要乘上每个开发者执行的次数，然后还要乘上开发者的<emphasis>数量</emphasis>。</para>

<para>这里，我广泛的使用的术语“自动化”，并不仅仅是重复每次只需要修改1到2个变量的动作，而且包括任何辅助人们的技术基础架构。最低标准的自动化需要按照<xref linkend="technical-infrastructure"/>中描述的方式运行一个现在的项目，但是每个项目也都有自己的特殊问题。例如，一组编写文档的人会希望有一个网站能够在任何时间都显示最新版本的文档。因为文档通常由如XML的标记语言编写，会有一个编译步骤，通常非常复杂，包括创建可显示或可下载的文档。组织这种会在每次提交时进行此类编译的网站可能会有点复杂和花费时间&mdash;但是这样很值得，即使这要花费你一天或更多的时间。拥有最新网页的整体收益是巨大的，即使<emphasis>没有</emphasis>的代价仅仅是每个开发者需要每次多一些很小的烦恼。</para>

<para>进行这种步骤不仅仅可以消除时间的浪费，也可以确保消除在执行手工操作时步骤出错（不可避免的会发生）时的痛苦和沮丧。多步的，确定的操作恰好是发明计算机的目的；将人们拯救出来可以做更有意义的事情。</para>

<sect3 id="automated-testing">
<title>自动测试</title>

<para>自动测试对任何软件项目都有用，特别是开源软件项目，因为自动测试（特别是回归测试）可以让开发者舒服的修改自己不熟悉的代码，因而鼓励了探索性的开发。因为手工检测损坏是这样困难&mdash;需要从本质上猜测可能损坏的事情，而且必须尝试多种实验证明其没有损坏&mdash;通过自动化方法检测这种损坏为项目节省了<emphasis>大量</emphasis>时间。它也可以让人们可以更放松的大幅度重构代码，从而对软件的长期可维护性贡献良多。</para>

  <sidebar id="regression-testing">
  <title>回归测试</title>

  <para><firstterm>回归测试</firstterm>指的是判断已修正bug是否重新出现的测试。回归测试的目的是减少代码变更以不可预料的方式破坏软件的机会。随着软件项目的增大和复杂，这种不可预料的副作用会急剧增长。好的设计可以减少随着变更增长带来的这种比率，但是不能完全消除这种问题。</para>

  <para>结果就是许多项目都有了一个<firstterm>测试套</firstterm>，一个单独的可以按照过去模仿bug发生的方式进行调用的程序。如果测试套成功的使某个bug出现，这被称作<firstterm>回归</firstterm>，意味着某人的变更意外的将以前修正的bug又修正回来了。</para>

  <para>请看<ulink url="http://en.wikipedia.org/wiki/Regression_testing"/>。</para>

  </sidebar>

<para>回归测试并不是万能药。首先，它非常适于批量样式界面的程序。对于主要使用图形用户界面操作的软件很难程序化驱动。回归测试的另一个问题是测试套框架本身可能非常复杂，自己有一定的学习曲线和维护负担。减少这种复杂性是你可以做的一件非常有用的事，即使这需要花费相当多的时间。将新测试添加到测试套越简单，就会有越多的开发者这样做，发布中漏网的bug也就会越少。在使测试更简单上的努力将会在项目的生命周期中得到成倍的回报。</para>

<para>许多项目有一个<firstterm>“不要破坏构建！”</firstterm>的规则，意思是：不要提交会使软件不能编译或运行的变更。成为破坏构建的人通常会导致温和的窘迫和取笑。拥有回归测试套的项目通常有一个推论的规则：不要提交会导致测试失败的任何变更。如果整个测试套会自动每夜运行，随着结果发送到开发列表或专门的测试套列表，这类失败可以轻松定位；这是自动化价值所在的另一个实例。</para>

<para>大多数志愿开发者会愿意用额外的时间编写回归测试，只要测试系统是可理解的并易于使用。变更搭配测试可以理解为一种责任，也是协作的一种简单的机会：通常要由两个开发者分担bug修正的工作，其中一个编写修正本身，另外一个编写测试。后一个开发者通常要以更多的工作结束任务，因为编写测试并没有实际的修正那样让人愉悦，测试套不应当使测试体验超出本来应有的痛苦。</para>

<para>一些项目走的更远，<emphasis>每个</emphasis>bug修正或新特性都要伴随新的测试。这是否是个好主意取决于许多因素：软件的特性，开发团队的组成和编写新测试的难度。CVS（<ulink url="http://www.cvshome.org/"/>）团队一直有这样一个规则。在理论上这是一个好政策，因为CVS是版本控制软件，所以非常希望规避处理或误处理用户数据可能性的风险。问题是在实践中CVS的回归测试套是一个单独的巨大shell脚本（好笑的是叫做<filename>sanity.sh</filename>），难于阅读，也难于修改或扩展。增加新测试的难度，以及对于新增补丁必须包含测试的要求，决定了CVS有效的阻碍了补丁。当我在CVS上工作时，我见过有人着手，甚至完成了一个CVS自己代码的补丁，但是当被告知需要在<filename>sanity.sh</filename>增加新测试时则放弃了。</para>

<para>编写新的回归测试比修正原来的bug花费更多的时间非常正常。但是CVS将这种现象发挥到了极致：一个人需要花费数小时才能正确的设计自己的测试，但仍然得到错误的结果，因为修改这样一个35000行的Bourne shell脚本有太多不可预测的复杂情况。即使是长期的CVS开发者也会为增加新测试而感到郁闷。</para>

<para>这种情况源于我们对于自动化比率考虑的失败。转换到一个真正的测试框架&mdash;无论是自定义的还是成品的&mdash;都会成为一种主要的动力。<footnote><para>请注意，没有必要将所有已存在的测试转化到新框架；二者可以和平共处，只需要转化需要改变的测试。</para></footnote>随着时间的推移，这种忽视给项目带来更多的代价。有多少bug修正和新特性<emphasis>未能</emphasis>进入现在的CVS，仅仅因为这尴尬的测试套的阻碍？我们不知道精确的数量，但是一定远大于开发者为了开发新测试系统（或集成一个成品的系统）而会放弃的bug修正或新特性数量。这个任务只会耗费有限的时间，但如果无动于衷，则使用现有测试套的惩罚将会永远持续下去。</para>

<para>重点不在于强制编写测试是错误的，也不是说编写Bourne shell脚本的测试系统必然是不好的。它可能工作的很好，这取决于你的设计和测试的需要。重点仅仅是说当测试系统成为开发的明显障碍时，必须要有行动。同样的道理适用于所有成为障碍或瓶颈的常规过程。</para>

</sect3>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="users-to-volunteers">
<title>将每个用户当作潜在的志愿者</title>

<para>与用户的每次交流都是发展新志愿者的好机会。当一个用户花时间在项目邮件列表上发表文章或报告bug时，他已经认为自己比大多数用户（那些项目永远听不到回音的人）有更大参与的可能。紧跟这种潜力：如果他描述了一个bug，感谢他的报告，并询问他是否有兴趣自己修正它。如果他说FAQ中漏掉了一项重要问题，或者程序的文档有些不足，请坦率的承认问题（假定确实存在），并询问他是否有兴趣自己编写遗失的材料。很自然，大多数时候这个用户不会同意。但是多问一句也不累，而且只要你每次都这么问，也会提醒论坛中的其他听众参与到项目当中是每个人都可以做的。</para>

<para>不要将你的目标限制在新开发者和文档编写者上。例如从长期来看，即使训练人们编写优秀的bug报告也是值得的，如果你没有在每个人身上花费<emphasis>太</emphasis>多时间，而且如果在将来继续提交更多的bug&mdash;如果第一次报告时能获得建设性的互动，以后更有可能这么做。建设性的互动不必是对于bug的修正，尽管那样是理想的；它可以仅仅是一种要求更多信息的恳请，或仅仅是那种行为<emphasis>是</emphasis>bug的确认。人们希望被倾听。其次，他们希望自己的bug被修正。你可能无法一直及时的给予后者，但你（或者说整个团队）可以给他们前者。</para>

<para>一个推论就是开发者不能向出于好意提出含糊bug报告的人们表现出愤怒。这是我个人很气恼的事情。我在许多不同的开源邮件列表中看到许多开发者一直这样做，危害是显而易见的。一些倒霉的新手会发布无用的报告：</para>

<blockquote>
   <para>嗨，我没法运行Scanley。每当我启动它，就会报错。有人遇到过这个问题吗？</para>
</blockquote>

<para>一些开发者&mdash;可能已经遇到此类报告几千次了，但丝毫不考虑这个新手从未遇到过&mdash;会这样回复：</para>

<blockquote>
   <para>这么点信息我们能怎么做？天呐。请给点细节，例如Scanley的版本、你的操作系统和错误信息。</para>
</blockquote>

<para>开发者无法从用户的角度看待事物，也未能考虑到这种反应对于观看这种交互的<emphasis>其他</emphasis>人的效果。很自然，对于没有编程经验的用户，之前没有报告bug的经验，当然不知道如何编写bug报告。对于这种人该怎样正确处理呢？教育他们！要使用会促使他们回来获取更多信息的方式：</para>

<blockquote>
   <para>很遗憾你遇到了困难。我们需要更多信息才能找出发生的问题。请告诉我们Scanley的版本，您的操作系统和错误的精确文本。最好能提供一份你所运行命令的脚本，以及对应的输出。更多信息请看http://www.scanley.org/how_to_report_a_bug.html。</para> 
</blockquote>

<para>这种从用户那里榨取信息的响应方法远谈不上有效率，因为它是从用户的角度编写的。首先，它展示了同情：<emphasis>你遇到了问题；我们也感到痛</emphasis>。（即使在bug报告回应中也不是必须的；这取决于问题的严重程度以及感觉到的用户的伤心程度。）其次，没有对她不知如何报告bug表示轻视，而是告诉她如何，以及怎样的详细程度才会实际有效&mdash;例如，许多用户并不理解“请给些细节”的意思是“展示错误的精确文本”，不要遗漏或删节。当你第一次与这样一个用户工作时，你需要说明这些。最后，应该提供到更加详细和完整的报告bug指导的链接。如果你成功的让用户感觉在为她考虑，她通常会花时间阅读该文档并按照你所说的去做。当然，这通常意味着你需要预先就准备好文档。必须说清楚哪种类型的信息是开发团队在每个bug报告中希望看到的。理想情况下，可能需要通过回应多个这样的用户，逐渐的查漏补缺，使之更好地为项目服务。</para>

<para>Subversion项目的bug报告指导可以说是这类形式的标准案例（见<xref
linkend="bug-reporting"/>）。请注意他们是如何以请求提供一个bug的补丁或修正结束的。这不是因为这种请求将会导致更高的补丁。报告率&mdash;大多数能够修正bug的用户都知道如果能提供补丁会受到欢迎，无需告知他们。请求的真实目的是为了向所有读者，特别是刚来到项目，或者刚来到自由软件的人强调，这个项目是通过志愿者的贡献运营的。这是许多新用户通常不熟悉的一个关键点。一旦他们意识到这一点，他们就更有可能在发生时帮助完成修正，即使不能提供代码，也会提供更完整的重现步骤，甚至是为其他人发布的内容测试修正。目标是让每个用户认识到他们和为项目工作的人没有<emphasis>天生</emphasis>的区别&mdash;问题只是他们能投入多少时间和力量，而不在于是谁。</para>

<para>对于愤怒回应的告诫不能适用于粗暴的用户。偶尔会有一些人会发送毫无信息量的bug报告或投诉，表现对项目某些失误的蔑视。通常此类人会在轻蔑与谄媚之间转换，例如Subversion邮件列表的这个人：</para>

<blockquote>
<para>为什么几乎6天了还没有Windows平台的二进制程序？！？每次都是同样的故事，确实让人灰心。为什么这类工作就不能自动化，可以立刻出现。？？当你发布“RC”构建时，我想你们的意思的是让用户测试构建，但是你们没为此事做任何事。如果你们没提供测试方法，又何必搞一个浸润期？？</para>
</blockquote>

<para>对于这种激动文章的最初回应是令人吃惊的克制：人们指出该项目有自己的发布政策，不会提供官方的二进制文件，并告诉他如果要改变恼人的程度，他应该志愿自己编译代码，如果真的对他很重要的话。相信与否，这段话属于他的下一次发布：</para>

<blockquote>
<para>首先，我要说我认为Subversion很彪悍，很感谢每个参与者的努力。  [...]</para>
</blockquote>

<para>...然后他<emphasis>再次</emphasis>继续为项目没有提供二进制，现在仍然没有志愿者做这件事而斥责项目。之后，大约50人跳了出来，我必须说我确实注意到这一点了。在<phrase output="printed"><xref linkend="getting-started"/>的</phrase><xref linkend="prevent-rudeness"/>提出的，针对粗鲁行为的“零容忍”政策，已经潜移默化的应用到每个人的交互中。但是，当人们认清他一开始就要当一个喷子时，没人能给他好脸色。</para>

<para>很幸运，这些情形非常罕见，很少需要被项目特别关注，并投入力量去保持用户建设性的和有礼貌的交互。</para>

</sect2>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="share-management">
<title>像分担技术任务一样分担管理任务</title>

<para>运行项目时要像分担技术负担那样分担管理负担。随着项目的成长，就会有更多关于管理人员和信息流程的工作。没有道理不分担这些负担，这并不一定需要一种自顶向下的阶级组织&mdash;实践中更多是同级的网络拓扑结构，而不是军队式的命令结构。</para>

<para>有时管理角色是正式的，有时则是自然发生的。在Subversion项目中，我们有一个补丁管理员，一个翻译管理员，文档管理员和，题管理员（尽管是非正式的）以及一个发布管理员。有时这些角色是经过认真考虑才开始的，而有些则完全是自发的；随着项目的成长，我相信会增加更多的角色。下面我们会详细审视这些角色，以及一些其他的角色（除了<phrase output="printed">在本章前面</phrase>的<xref linkend="release-manager"/>和<xref linkend="release-owner"/>中介绍的发布管理员）。</para>

<para>就像你看到的角色描述，请注意没有人独占控制其所在领域。问题管理员并没有防止其他人在问题数据库中做出修改，FAQ管理员也不必是编辑FAQ的唯一人选。他们的角色都是非垄断的责任。每个领域管理员所作工作的重要组成部分是提醒在该领域工作的人，训练他们按照管理员的方式工作，这样多种力量就可以互相加强，而不是发生冲突。领域管理员必须记录他们工作的过程，这样当他们离开时，别人就可以立刻接班。</para>

<para>有时会发生一种冲突：两个或更多的人希望同一个角色。现在没有人处理这件事。你可以建议每个志愿者写一个计划（一个“申请”），让所有的提交者选出最佳。不过这样有些笨拙，而且可能有些尴尬。我发现最好的方法只是告诉多个候选者自己处理。他们通常能够，也会更满意自己得出的结果，而不是别人是施加的结果。</para>

<sect2 id="patch-manager">
<title>补丁管理员</title>

<para>在一个接收许多补丁的自由软件项目，跟踪到达的补丁以及所做的决定会成为一场噩梦，特别当通过非集中方式完成时。大多数补丁是邮件的形式出现项目开发列表（尽管可能有些最早出现在问题跟踪系统，或外部站点）的，在补丁到达时有许多不同的处理补丁的例程可以选择。</para>

<para>有时，某人评审了补丁，发现了问题，然后踢回给原作者整理。这通常会导致一个交互过程&mdash;都在邮件列表中可见&mdash;原始的作者一直发布修正的补丁版本，直到评审者无法找到更多的问题。有时很难说清楚这个过程已经结束：如果评审者提交了补丁，则可以说整个周期已经结束。但是如果她没有，或许仅仅因为她没有时间，或者没有提交权限，而且无法拉其他开发者做这件事。</para>

<para>另一个对补丁的常见回应是轻快的讨论，不必是针对补丁本身，而是关于补丁之后的概念。例如，补丁可能修正了一个bug，但项目希望用另一种方式修正这个bug，作为解决一个更普通类型问题的一部分。通常一开始这都是未知的，只是补丁激发了探索。</para>

<para>偶然情况下，发布的补丁可能会遇到完全的沉默。通常是因为没有开发者有时间<emphasis>那个时刻</emphasis>去评审这个补丁，都希望其他人能去做这件事。因为每个人等待其他人捡起这个球的时间并不一定，而其他优先的事情不断出现，很容易会造成补丁被漏掉的情况，但这是任何人都不会希望发生的事情。项目可能以这种方式错误可用的的补丁，也有其他有害的副作用：会打击作者，他为补丁做了许多工作，让他觉得整个项目难以靠近，特别是对于其他考虑编写补丁的人。</para>

<para>补丁管理员的工作就是确保补丁不会漏掉。这是通过跟踪每个补丁的稳定状态实现的。补丁管理员观察邮件列表中每个由提出补丁引发的线索。如果最终以补丁的提交完成，他不需要做任何事。如果进入了评审/修正迭代，以补丁的最终版本结束，但是没有提交，他发起一个指向最终版本以及相关邮件列表的问题，这样之后跟进的所有开发者都有了一个永久的记录。如果补丁定位了一个现有的问题，他会将相关信息注释到该问题，而不会开一个新事物。</para>

<para>如果某个补丁没有回应，补丁管理员应该等待几天，然后询问是否有人会去评审它。通常会有响应：某个开发者会解释她认为该补丁不必应用，然后给出原因，或者她会去评审它，。如果还是没有回应，补丁管理员可以发起，也可以不发起一个补丁的问题，要根据他自己的判断，但至少最初的提交者得到了<emphasis>一些</emphasis>回应。</para>

<para>拥有一个补丁管理员为Subversion开发团队节省了大量时间和心力。如果没有指定的人负责，每个开发者需要一直担心“如果我没有时间现在回应补丁，我能指望别人做吗？我是否要一直盯着？ 但如果有别人盯着，同样的原因，这样是否是没必要的重复。” 每个开发者在第一次看到这个补丁的时候都要做这样的决定。如果她希望跟进评审，她就可以这样做&mdash;补丁管理员会根据情况调整他的行为方式。如果她希望完全忽略这个补丁，也没问题；补丁管理员会确保它没有被遗忘。</para>

<para>因为这个系统只有在补丁管理员不发生失误的情况下才能运作正常，所以这个角色必须正式任命。在Subversion，我们在开发和用户邮件列表中广而告之，得到了许多志愿者，并选了第一个回复的。当那个人请辞后（<phrase output="printed">本章后面的</phrase><xref linkend="transitions"/>），我们重复了这个步骤。我们一直没有试图让多个人分担这个角色，因为他们之间会需要交流的负担；但是如果补丁提交的规模更大，则一个多头的补丁管理员就会有意义。</para>

</sect2>

<sect2 id="translation-manager">
<title>翻译管理员</title>

<para>在软件项目中，“翻译”可能指的是两件完全不同的事。它可能指的是将软件文档翻译为其他语言，或者指的是翻译软件本身&mdash;也就是让程序使用用户选中的语言显示错误和帮助信息。两者都是复杂的任务，不过一旦建立了正确的基础架构，则可以很大程度上与其他开发分离。因为这些任务非常类似，所以设置一个单独的翻译管理员处理两部分任务就非常有意义（取决于你的项目），亦或者更好的方式是设置两个不同的管理员。</para>

<para>在Subversion项目，我们有一个处理两部分的翻译管理员。他自己并不编写翻译，当然&mdash;他可以帮助一两个，但是在写这些话时，如果他希望与他们所有人一起工作，他需要讲10种语言（12种方言）。因而，他管理志愿翻译者：他帮助他们互相协调，以及他们团队与项目其余部分的协调。</para>

<para>设置翻译管理员的一个原因是翻译者是与开发者不同的人。他们有时只有有限的甚至没有任何在版本控制版本库中工作的经验，也没有与分布式志愿团队一起工作的经验。但在另一方面，他们通常是最好的一类志愿者：拥有特定领域知识，可以看到需求，选择参与进来。他们也通常愿意学习，对工作充满热情。所需要只是有人告诉他们如何做。翻译管理员确保翻译不会没必要的干扰日常的开发。每当开发者必须被告知需要为支持翻译工作提供技术变更时，他也要作为翻译者作为一个统一整体的代表。</para>

<para>因此，这个位置最重要的技能是外交能力，而不是技术能力。例如，在Subversion我们有一个政策，每种语言的翻译都必须至少有两个人正在参与，否则，就没有人可以检查文本。譬如说，有新的志愿者请求提供Subversion马达加斯加语翻译时，翻译管理员必须提示他去与六个月前某个表达过马达加斯加语翻译意向的人建立联系，或者有礼貌的询问志愿者去寻找<emphasis>另一个</emphasis>马达加斯加翻译者与其搭档工作。当有了足够的人手，管理员就可以为他们设置正确的提交访问权限，告知他们项目的惯例（例如如何编写日志文件），然后紧盯他们是否遵循了这些惯例。</para>

<para>翻译管理员和开发者之间，以及翻译管理和翻译团队之间的对话通常使用项目原先的语言&mdash;也就是所以翻译的源语言。对于大多数自由软件项目，就是英语，但是是什么语言并不重要，只要项目认可即可。（对于希望吸引广泛国际开发社区的项目，英语可能是最好的语言。）</para>

<para>在特定翻译小组<emphasis>中的</emphasis>对话通常使用它们共享的语言，然而翻译管理员的另一个任务就是为了每个团队设定一个专门的邮件列表。通过这种方式，翻译者可以自由的讨论他们的工作，而不会打扰项目邮件列表中的人，他们可能根本不理解他们的翻译语言。</para>

  <sidebar id="i7n">
  <title>国际化还是本地化</title>
  
  <para><firstterm>国际化</firstterm>(<firstterm>I18N</firstterm>)和<firstterm>本地化</firstterm>(<firstterm>L10N</firstterm>)都指的是采用非原软件编写的语言和环境使用程序的过程。这两个术语通常是可以互相替换的，但是实际上他们并不是同一回事。就像<ulink url="http://en.wikipedia.org/wiki/G11n"/>所说的：</para>

  <blockquote>
     <para>它们之间的区别是微小的，但是非常重要：国际化指的是为<emphasis>潜在的</emphasis>用于所有地方的产品改造，而本地化是为用于<emphasis>特定</emphasis>地域的特别特性附加。</para>
  </blockquote>

  <para>例如，将您的软件修改为实现对Unicode(<ulink url="http://en.wikipedia.org/wiki/Unicode"/>)文本编码无损处理是一种国际化行动，因为它并不是关于特定的语言，而是关于接受来自任意数量语言的文本。另一方面，当检测到软件是运行于斯洛文尼亚语环境时，便以斯洛文尼亚语打印打印错误信息，则是本地化的行动。</para>

  <para>因此，翻译管理员的任务从原理上是关于本地化的，而不是国际化。</para>
  
  </sidebar>

</sect2>

<sect2 id="documentation-manager">
<title>文档管理员</title>

<para>保持软件文档的实效性是一项无法结束的任务。每个进入代码的新特性或改进都可能会导致文档的变更。另外，一旦项目文档达到了一定级别的完整性，就会发现许多人发来的补丁是针对文档的，而不是代码。这是因为许多人是在文章中修正了bug，而不是在代码中：所有的用户都是读者，但仅有少数是程序员。</para>

<para>文档补丁通常比代码补丁更易于检查和应用。仅需要少许或无需测试，而且可以快速的通过检查评价变更的质量。因为数量很多，但是检查的负担相对较低，文档补丁中有效工作的管理负担比率远比代码补丁高。此外，大多数补丁需要一些调整，才能保持文档中作者语气的一致性。在大多数情况下，补丁通常会覆盖或影响其他补丁，在提交之前需要根据之间的关系进行调整。</para>

<para>出于处理文档补丁的紧迫性，以及需要持续监控代码基以便保持文档的实效性，有必要让某个人或一个小组专门从事这项任务。他们需要精确的保存文档在何处滞后于软件的记录，而且他们可以用一种整体方式的实践步骤来处理大量的补丁。</para>

<para>当然，这样不会阻碍项目中的其他人在工作中应用文档补丁，特别是时间允许时一些小的补丁。同一个补丁管理员（见<phrase output="printed">本章前面提到的</phrase><xref linkend="patch-manager"/>）可以同时跟踪代码和文档补丁，当开发和文档团队希望时完成它们。（如果补丁的总数已经超出了单个人可以跟踪的容量，最好的一个步骤可能就是将补丁管理员分为代码和文档。）文档团队的关键是使人们把保持文档组织性、实效性和一致性当作自己的责任。在实践中，这意味着对于文档的熟悉，关注<emphasis>其他人</emphasis>提交给文档的变更，关注到来的文档补丁，并使用所有这些信息源完成保持文档健康的所有必要工作。</para>

</sect2>

<sect2 id="issue-manager">
<title>问题管理员</title>

<para>项目bug跟踪系统中问题的数量是随着使用产品的人数同比例增加的。因而，即使你在一个快速成长的健壮程序中修正bug并装运，您还是会看到大量开放的问题漫无边际的产生。重复问题，以及不完整或描述糟糕的问题也会频繁发生。</para>

<para>问题管理员通过关注进入数据库的信息，定期的清除特定问题有助于缓和这种问题。他们的大多数常见行为可以修正进入的问题，一方面因为报告者未能正确的处理部分字段，另一方面也因为问题与数据库中的一个问题已经重复。很明显，问题管理员对项目bug数据库越熟悉，他就越能有效率的检测到重复问题&mdash;这也是设置一小部分人专门关注bug数据库，而不是让每个人都<foreignphrase>特别</foreignphrase>参与其中的原因。当团队试图按照非集中式的方式完成这项任务时，就不会有任何一个人具备对于数据库内容的深入专业知识。</para>

<para>问题管理员可以帮助我们映射问题和个别开发者。当有大量bug报告进入时，不是每个开发者会以平等的态度读取问题通知邮件列表。然而，如果某人知道开发团队紧盯着所有进入的问题，她可以将注意力放到特定合适的bug上。当然，这需要对项目所有开发的事情，接受者期望和性情都很敏感。因而，问题管理员最好也是开发者的一分子。</para>

<para>取决于你的项目如何使用问题跟踪系统，问题管理员也可以调整该数据库以反映项目的优先级。例如，在Subversion我们将问题排入未来的特定发布，这样每当有人询问“某个bug X何时可以修复时？”我们可以说“之后的两个发布，”即使我们不能说出确切的日期。这个发布在问题跟踪系统中以目标里程碑的形式展示，也就是IssueZilla中的一个字段。<footnote><para>IssueZilla就是我们使用的问题跟踪系统；它是BugZilla的后继。</para></footnote>作为一个规则，每个Subversion发布都有一个新的特性和一组特定的bug修正。我们为该发布的所有问题赋予一个合适的目标里程碑（包括新特性&mdash;它也会得到一个问题），这样人们就可以通过发布计划查看bug数据库。这些目标很少情况下会保持静止。随着新bug的到来，等级会发生切换，而且有些bug必须移到另一个里程碑，以保证每个发布的可管理性。再次，最好由对项目数据库的内容以及问题之间的关系有着整体意识的人完成。</para>

<para>问题管理员的另一项值得关注的任务是管理废弃的问题。有时，某个bug会因为软件一个不相关变更而意外的修正，或者有时项目对于特定行为是否为bug的意见发生改变。寻找废弃的问题并不简单：唯一的系统方法是清理数据库中的所有问题。随着问题数量的增长，完全的清理会变得越来越不可行。在达到某个点时，保持数据库健康的唯一方法就是分而治之：根据进入数据库的情况将问题分类，并直接分配给合适的开发者或团队。然后接受者负责问题余下的工作，根据需要决定是解决还是废弃。如果数据库足够大，问题管理员的工作就更倾向于协调，将会花费较少的时间用于自己查找问题，而是花更多的时间使之到达正确的人手中。</para>

</sect2>

<sect2 id="faq-manager">
<title>FAQ管理员</title>

<para>FAQ维护是一项出人意料的困难工作。项目中其他文档的内容都是由作者预先计划得到的，而FAQ则完全是被动的文档（见<xref linkend="starting-a-faq"/>）。无论它变得如何巨大，你永远不知道何时会再一次添加。而且因为它总是零零散散的添加，它很容易变得不够一致并缺乏组织，甚至会包含重复的或半重复的条目。即使它没有任何此类的明显问题，项目之间也通常会有不引人注目的互相依赖&mdash;必须有链接，但是没有&mdash;因为与关联的项目添加的时间相差一年。</para>

<para>FAQ管理员的角色是双重的。首先，通过至少对所有问题的标题保持熟悉，她维护了FAQ的整体质量，这样每当有人添加的新条目与原来的条目重复或者相关，可以作出合适的调整。其次，她关注着项目的邮件列表和其他论坛中重复发生的问题或疑问，并根据这些输入编写新的FAQ条目。后一项工作可能非常复杂：必须能紧跟线索，识别出其中的核心问题，发表一个提议FAQ条目，组合来自其他人的评论（因为FAQ管理员不可能是FAQ包含的所有主题的专家），并感知何时结束这个过程并将其添加到FAQ。</para>

<para>FAQ管理员通常也会成为FAQ格式的默认专家。有许多保持FAQ结构的小细节（见<phrase output="printed"><xref linkend="communications"/>的</phrase><xref linkend="all-as-archives"/>）；当某人编辑了FAQ，他们可能会忘记这些细节。但只要FAQ管理员能够在之后查漏补缺，这样便没有任何问题。</para>

<para>许多自由软件可以用于辅助维护FAQ的过程。只要能够保证FAQ的质量，就可以选一个来使用，但是要避免过度自动化。一些项目试图完全自动化FAQ维护的过程，使用类似wiki的模式允许每个人贡献和编辑FAQ条目（见<phrase output="printed"><xref linkend="technical-infrastructure"/>的</phrase><xref linkend="wikis"/>）。我曾经遇到过在Faq-O-Matic上发生的这种情况（<ulink url="http://faqomatic.sourceforge.net/"/>），尽管我看到原因仅仅是对Faq-O-Matic超出本来目的的滥用。在任何情况下，虽然完全的分布式FAQ维护可以减少项目的负担，但也会导致较差的FAQ。没有人具备整个FAQ的广泛视野，没有人注意到了哪个条目需要更新或变得完全不可用，每个人看到的都是孤立的条目。结果是FAQ经常会无法为用户提供他们所需要查找的东西，甚至会误导他们。您可以使用任何必须的工具维护项目FAQ，但是不要因为工具便利性的诱惑而损害FAQ的质量。</para>

<para>见Sean Michael Kerner在<ulink url="http://osdir.com/Article1722.phtml"/>的文章<citetitle>The FAQs on
FAQs</citetitle>，描述和评估了开源FAQ维护工具。</para>

</sect2>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="transitions">
<title>转化</title>

<para>一次又一次，某个位置上承担责任的志愿者（例如补丁管理员，翻译管理员等）无法执行该位置的责任。这可能是因为出现了超出他预期的工作，或者完全因为是许多外部因素：结婚、孩子出世、新的老板等等之类的。</para>

<para>当一个志愿者陷入这种境地，他通常不会立刻注意到。可能以很小的程度发生着变化，而且没有一个时刻可以自觉的认识到他已经无法完成这个角色的任务。相反，项目中的其他部分只是发现有一段时间未能听到他的消息了。然后他们会会立刻匆忙行动，而他则觉得长时间对项目的怠慢是有愧的，并立刻连夜赶工。然后你有更长的一段时间你无法听到他的消息，然后可能是或可能不是另一场慌乱。但是，很少有主动提出的正式辞职。志愿者用自己的业余时间工作，辞职意味着公开承认他的业余时间被永久的减少了。人们通常不愿意这样做。</para>

<para>因而，需要你和项目中的其他人发现发生的事情&mdash;或者说发现没有发生&mdash;，并能够询问哪个志愿者可以继续。这种询问必须是友好和100%无内疚的。你的目的只是找出真相，而不是让人难过。通常情况下，这个询问应当对项目的其他人可见，但是如果你知道一些必须私下进行的原因，也没有问题。公开进行的主要原因是如果志愿者回复说无法完成工作时，就可以为你的<emphasis>下一次</emphasis>公开发布提供一个上下文环境：请求一个新的志愿者完成该角色。</para>

<para>有时，一个志愿者无法完成其接受的工作，但是没有意识到或不希望承认这个事实。当然，任何人在一开始都会遇到困难，特别是当责任很复杂时。然而，如果某人不努力完成他接受的任务，即使所有人都给出全部的帮助和建议，最后唯一的解决方法只能是他放弃并让其他人来尝试。而且如果这个人没能看到这一点，需要有人告诉他。基本上来讲，我认为只有一种处理方法，但是需要一个多步骤的过程，每个步骤都很重要。</para>

<para>首先，确保你自己没有发疯。在私下与项目的其他人讨论，看看他们是不是和你一样认为问题很严重。即使你们已经肯定，这样也实现了让其他人知晓你们正考虑让这个人退出的目的。通常不会有人反对&mdash;他们会很高兴你肩负这个尴尬的任务，这样他们就不必动手了！</para>

<para>下一步，<emphasis>私下</emphasis>联系有问题的志愿者并友好和直接的告知他，你所发现的问题。为了效果，要尽可能提供多的实例。确保能够指出人们是如何不愿继续帮助的，而问题一直存在得不到改善。请确保花较长的时间编写该邮件，对于此类邮件，如果你无法支持你所说的，最好就什么都不要说。要说明你会找一个新的志愿者充当这个角色，但也要指出有许多方法可以支持这个项目。在这个阶段，不要说你已经为此与其他人进行了谈话；没有人希望被告知有人在准备接替他。</para>

<para>之后，可以有许多其他不同的方法。最可能的反应是他们可能会认可你，或者在某种程度上会争论，并愿意退出。如果是这个情况，建议他自己作出声明，然后你可以跟从他的文章寻找一个替代者。</para>

<para>或者，他可能认可自己的问题，但是请求多一点的时间（或者在多一次机会，例如离散任务角色的发布管理员）。如何响应这个情况需要您的判断，但是无论您如何做，不要仅仅因为感到无法拒绝这种请求而表示同意。这样会延续痛苦，但不会有所减轻。这通常是拒绝这种请求的好原因，换句话说就是已经给了足够多的机会，而现在就是得到的结果。这是我告知某人无法肩负发布管理员角色的邮件：</para>

<blockquote>
<screen>
&gt;如果您希望别人替代我，我会有好的将这个角色交给下个人。我有个
&gt;不情之请。我希望再尝试一次发布来证明我。
&gt;
我完全能够体会您的想法，但是在这种情况下 ，我们无法“再试一次”。

这不是第一次或第二次发布，而是第6或第7次... 我知道你也对结果
不够满意（因为我们之前已经讨论过）。所以我们已经有效的完成了
再次尝试的程序。最终，总有一次是最后一次... 我认为[上一次发布]就是
了。

</screen>
</blockquote>

<para>在最坏的情况下，志愿者可能完全不同意。然后你需要接受事情变得尴尬并预先准备。现在是与其他人讨论此事了（但在得到他们的允许前，还是不能说是谁，因为这些对话是机密的）的时候了，也是你认为项目不应该这样继续下去的时候了。坚持，但不要威胁。请注意，大多数角色的转换可能始于某个新人已经开始了它的工作，而<emphasis>不是</emphasis>老人结束了他的工作。例如，如果争论事关角色，譬如说问题管理员，在任何时刻你和其他有影响的人可以请求一个新的问题管理员。可以不必是之前做这些事的人停止了工作，只要他没有妨害（故意或其他原因）新志愿者的努力。</para>

<para>有一个充满诱惑力的想法：为何不去尝试不必告知人们辞职，而仅仅是为他寻找一些帮助？为什么不可以有两个问题管理员、补丁管理员或任何角色？</para>

<para>尽管理论上听起来很不错，但通常不是一个好主意。是什么让管理员角色可以工作&mdash;是什么使之有用，实际上&mdash;应该是非集中化。能够以非集中式完成的工作通常已经这样做了。有两个人肩负管理员角色会带来两个人的交流负担，也可能会带来不可靠的互相依赖（“我以为你带了急救箱！”  “我？我以为<emphasis>你</emphasis>带了急救箱”）。当然，也有例外。有时两个人可以配合的极好，或者任务本身就可以轻松的分散给多个人。但是。如果他一开始就能够重视这些问题，之前就会寻求此类帮助。在任何情况下，让一个人持续做一件不会让人关注的事情都是失礼的。</para>

<para>The most important factor in asking someone to step down is
privacy: giving him the space to make a decision without feeling like
others are watching and waiting.  I once made the mistake&mdash;an
obvious mistake, in retrospect&mdash;of mailing all three parties at
once in order to ask Subversion&apos;s release manager to step aside in
favor of two other volunteers.  I&apos;d already talked to the two new
people privately, and knew that they were willing to take on the
responsibility.  So I thought, na&iuml;vely and somewhat
insensitively, that I&apos;d save some time and hassle by sending one mail
to all of them to initiate the transition.  I assumed that the current
release manager was already fully aware of the problems and would see
the reasonableness of my point immediately.</para>

<para>I was wrong.  The current release manager was very offended, and
rightly so.  It&apos;s one thing to be asked to hand off the job; it&apos;s
another thing to be asked that <emphasis>in front of</emphasis> the
people you&apos;ll hand it off to.  Once I got it through my head why he
was offended, I apologized.  He eventually did step aside gracefully,
and continues to be involved with the project today.  But his
feelings were hurt, and needless to say, this was not the most
auspicious of beginnings for the new volunteers either.</para>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="committers">
<title>Committers</title>

<para>As the only formally distinct class of people found in all open
source projects, committers deserve special attention here.
Committers are an unavoidable concession to discrimination in a system
which is otherwise as non-discriminatory as possible.  But
&quot;discrimination&quot; is not meant as a pejorative here.  The function
committers perform is utterly necessary, and I do not think a project
could succeed without it.  Quality control requires, well, control.
There are always many people who feel competent to make changes to a
program, and some smaller number who actually are.  The project cannot
rely on people&apos;s own judgement; it must impose standards and grant
commit access only to those who meet them<footnote><para>Note that the
commit access means something a bit different in decentralized version
control systems, where anyone can set up a repository that is linked
into the project, and give themselves commit access to that
repository.  Nevertheless, the <emphasis>concept</emphasis> of commit
access still applies: &quot;commit access&quot; is shorthand for &quot;the
right to make changes to the code that will ship in the group&apos;s next
release of the software.&quot;  In centralized version control systems,
this means having direct commit access; in decentralized ones, it
means having one&apos;s changes pulled into the main distribution by
default.  It is the same idea either way; the mechanics by which it is
realized are not terribly important.</para></footnote>.  On the other
hand, having people who can commit changes directly working
side-by-side with people who cannot sets up an obvious power dynamic.
That dynamic must be managed so that it does not harm the
project.</para>

<para>In <xref linkend="electorate"/><phrase output="printed">
in <xref linkend="social-infrastructure"/></phrase>, we already
discussed the mechanics of considering new committers.  Here we will
look at the standards by which potential new committers should be
judged, and how this process should be presented to the larger
community.</para>

<!-- ======================== subsection ============================== -->
<sect2 id="choosing-committers">
<title>Choosing Committers</title>

<para>In the Subversion project, we choose committers primarily on the
Hippocratic Principle: <emphasis>first, do no harm</emphasis>.  Our
main criterion is not technical skill or even knowledge of the code,
but merely that the committer show good judgement.  Judgement can mean
simply knowing what not to take on.  A person might post only small
patches, fixing fairly simple problems in the code; but if the patches
apply cleanly, do not contain bugs, and are mostly in accord with the
project&apos;s log message and coding conventions, and there are enough
patches to show a clear pattern, then an existing committer will
usually propose that person for commit access.  If at least three
people say yes, and no one objects, then the offer is made.  True, we
might have no evidence that the person is able to solve complex
problems in all areas of the code base, but that does not matter: the
person has made it clear that he is capable of at least judging
his own abilities.  Technical skills can be learned (and taught),
but judgement, for the most part, cannot.  Therefore, it is the one
thing you want to make sure a person has before you give him commit
access.</para>

<para>When a new committer proposal does provoke a discussion, it is
usually not about technical ability, but rather about the person&apos;s
behavior on the mailing lists or in IRC.  Sometimes someone shows
technical skill and an ability to work within the project&apos;s formal
guidelines, yet is also consistently belligerent or uncooperative in
public forums.  That&apos;s a serious concern; if the person doesn&apos;t
seem to shape up over time, even in response to hints, then we won&apos;t
add him as a committer no matter how skilled he is.  In a
volunteer group, social skills, or the ability to &quot;play well in the
sandbox&quot;, are as important as raw technical ability.  Because
everything is under version control, the penalty for adding a
committer you shouldn&apos;t have is not so much the problems it could
cause in the code (review would spot those quickly anyway), but that
it might eventually force the project to revoke the person&apos;s commit
access&mdash;an action that is never pleasant and can sometimes be
confrontational.</para>

<para>Many projects insist that the potential committer demonstrate a
certain level of technical expertise and persistence, by submitting
some number of nontrivial patches&mdash;that is, not only do these
projects want to know that the person will do no harm, they want to
know that she is likely to do good across the code base.  This is
fine, but be careful that it doesn&apos;t start to turn committership into
a matter of membership in an exclusive club.  The question to keep in
everyone&apos;s mind should be &quot;What will bring the best results for the
code?&quot; not &quot;Will we devalue the social status associated with
committership by admitting this person?&quot;  The point of commit access
is not to reinforce people&apos;s self-worth, it&apos;s to allow good changes to
enter the code with a minimum of fuss.  If you have 100
committers, 10 of whom make large changes on a regular basis, and the
other 90 of whom just fix typos and small bugs a few times a year,
that&apos;s still better than having only the 10.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="revoking-committers">
<title>Revoking Commit Access</title>

<para>The first thing to be said about revoking commit access is: try
not to be in that situation in the first place.  Depending on whose
access is being revoked, and why, the discussions around such an
action can be very divisive.  Even when not divisive, they will be a
time-consuming distraction from productive work.</para>

<para>However, if you must do it, the discussion should be had
privately among the same people who would be in a position to vote for
<emphasis>granting</emphasis> that person whatever flavor of commit
access they currently have.  The person herself should not be
included.  This contradicts the usual injunction against secrecy, but
in this case it&apos;s necessary.  First, no one would be able to speak
freely otherwise.  Second, if the motion fails, you don&apos;t necessarily
want the person to know it was ever considered, because that could
open up questions (&quot;Who was on my side?  Who was against me?&quot;) that
lead to the worst sort of factionalism.  In certain rare
circumstances, the group may want someone to know that revocation of
commit access is or was being considered, as a warning, but this
openness should be a decision the group makes.  No one should ever, on
her own initiative, reveal information from a discussion and ballot
that others assumed were secret.</para>

<para>Once someone&apos;s access is revoked, that fact is unavoidably
public (see
<xref linkend="commit-access-openness"/><phrase output="printed">
later in this chapter</phrase>), so try to be as tactful as you can in
how it is presented to the outside world.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="partial-committers">
<title>Partial Commit Access</title>

<para>Some projects offer gradations of commit access.  For example,
there might be contributors whose commit access gives them free rein
in the documentation, but who do not commit to the code itself.
Common areas for partial commit access include documentation,
translations, binding code to other programming languages,
specification files for packaging (e.g., RedHat RPM spec files,
etc.), and other places where a mistake will not result in a problem for
the core project.</para>

<para>Since commit access is not only about committing, but about
being part of an electorate (see
<xref linkend="electorate"/><phrase output="printed"> in
<xref linkend="social-infrastructure"/></phrase>),
the question naturally arises: what can the partial committers vote
on?  There is no one right answer; it depends on what sorts of partial
commit domains your project has.  In Subversion we&apos;ve kept things
fairly simple: a partial committer can vote on matters confined
exclusively to that committer&apos;s domain, and not on anything else.
Importantly, we do have a mechanism for casting advisory votes
(essentially, the committer writes &quot;+0&quot; or &quot;+1&nbsp;(non-binding)&quot;
instead of just &quot;+1&quot; on the ballot).  There&apos;s no reason to silence
people entirely just because their vote isn&apos;t formally binding.</para>

<para>Full committers can vote on anything, just as they can commit
anywhere, and only full committers vote on adding new committers of
any kind.  In practice, though, the ability to add new partial
committers is usually delegated: any full committer can &quot;sponsor&quot; a
new partial committer, and partial committers in a domain can often
essentially choose new committers for that same domain (this is
especially helpful in making translation work run smoothly).</para>

<para>Your project may need a slightly different arrangement,
depending on the nature of the work, but the same general principles
apply to all projects.  Each committer should be able to vote on
matters that fall within the scope of her commit access, and not on
matters outside that, and votes on procedural questions should default
to the full committers, unless there&apos;s some reason (as decided by the
full committers) to widen the electorate.</para>

<para>Regarding enforcement of partial commit access: it&apos;s often
best <emphasis>not</emphasis> to have the version control system
enforce partial commit domains, even if it can.  See
<xref linkend="vc-authz"/><phrase output="printed"> in
<xref linkend="technical-infrastructure"/></phrase> for the
reasons why.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="dormant-committers">
<title>Dormant Committers</title>

<para>Some projects automatically remove people&apos;s commit access if
they go a certain amount of time (say, a year) without committing
anything.  I think this is usually unhelpful and even
counterproductive, for two reasons.</para>

<para>First, it may tempt some people into committing acceptable but
unnecessary changes, just to prevent their commit access from
expiring.  Second, it doesn&apos;t really serve any purpose.  If the
main criterion for granting commit access is good judgement, then why
assume someone&apos;s judgement would deteriorate just because he&apos;s away
from the project for a while?  Even if he completely vanishes for
years, not looking at the code or following development discussions,
when he reappears he&apos;ll <emphasis>know</emphasis> how out of touch
he is, and act accordingly.  You trusted his judgement before, so
why not trust it always?  If high school diplomas do not expire, then
commit access certainly shouldn&apos;t.</para>

<para>Sometimes a committer may ask to be removed, or to be explicitly
marked as dormant in the list of committers (see
<xref linkend="commit-access-openness"/><phrase output="printed">
below</phrase> for more about that list).  In these cases, the project
should accede to the person&apos;s wishes, of course.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="commit-access-openness">
<title>Avoid Mystery</title>

<para>Although the discussions around adding any particular new
committer must be confidential, the rules and procedures themselves
need not be secret.  In fact, it&apos;s best to publish them, so people
realize that the committers are not some mysterious Star Chamber,
closed off to mere mortals, but that anyone can join simply by posting
good patches and knowing how to handle herself in the community.
In the Subversion project, we put this information right in the
developer guidelines document, since the people most likely to be
interested in how commit access is granted are those thinking of
contributing code to the project.</para>

<para>In addition to publishing the procedures, publish the
actual <emphasis>list</emphasis> of committers.  The traditional place
for this is a file called <filename>MAINTAINERS</filename>
or <filename>COMMITTERS</filename> in the top level of the project&apos;s
source code tree.  It should list all the full committers first,
followed by the various partial commit domains and the members of each
domain.  Each person should be listed by name and email address,
though the address can be encoded to prevent spam (see
<xref linkend="address-hiding"/><phrase output="printed"> in
<xref linkend="technical-infrastructure"/></phrase>) if the
person prefers that.</para>

<para>Since the distinction between full commit and partial commit
access is obvious and well defined, it is proper for the list to make
that distinction too.  Beyond that, the list should not try to
indicate the informal distinctions that inevitably arise in a project,
such as who is particularly influential and how.  It is a public
record, not an acknowledgments file.  List committers either in
alphabetical order, or in the order in which they arrived.</para>

</sect2>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="credit">
<title>Credit</title>

<para>Credit is the primary currency of the free software world.
Whatever people may say about their motivations for participating in a
project, I don&apos;t know any developers who would be happy doing all
their work anonymously, or under someone else&apos;s name.  There are
tangible reasons for this: one&apos;s reputation in a project roughly
governs how much influence one has, and participation in an open
source project can also indirectly have monetary value, because
some employers now look for it on resum&eacute;s.  There are also
intangible reasons, perhaps even more powerful: people simply want to
be appreciated, and instinctively look for signs that their work was
recognized by others.  The promise of credit is therefore one of best
motivators the project has.  When small contributions are
acknowledged, people come back to do more.</para>

<para>One of the most important features of collaborative development
software (see <xref linkend="technical-infrastructure"/>) is that
it keeps accurate records of who did what, when.  Wherever possible,
use these existing mechanisms to make sure that credit is distributed
accurately, and be specific about the nature of the contribution.
Don&apos;t just write &quot;Thanks to J. Random &lt;jrandom@example.com&gt;&quot; if
instead you can write &quot;Thanks to J. Random &lt;jrandom@example.com&gt;
for the bug report and reproduction recipe&quot; in a log message.</para>

<para>In Subversion, we have an informal but consistent policy of
crediting the reporter of a bug in either the issue filed, if there is
one, or the log message of the commit that fixes the bug, if not.  A
quick survey of Subversion commit logs up to commit number 14525 shows
that about 10% of commits give credit to someone by name and email
address, usually the person who reported or analyzed the bug fixed by
that commit.  Note that this person is different from the developer
who actually made the commit, whose name is already recorded
automatically by the version control system.  Of the 80-odd full and
partial committers Subversion has today, 55 were credited in the
commit logs (usually multiple times) before they became committers
themselves.  This does not, of course, prove that being credited was a
factor in their continued involvement, but it at least sets up an
atmosphere in which people know they can count on their contributions
being acknowledged.</para>

<para>It is important to distinguish between routine acknowledgment
and special thanks.  When discussing a particular piece of code, or
some other contribution someone made, it is fine to acknowledge their
work.  For example, saying &quot;Daniel&apos;s recent changes to the delta code
mean we can now implement feature X&quot; simultaneously helps people
identify which changes you&apos;re talking about and acknowledges Daniel&apos;s
work.  On the other hand, posting solely to thank Daniel for the delta
code changes serves no immediate practical purpose.  It doesn&apos;t add
any information, since the version control system and other mechanisms
have already recorded the fact that he made the changes.  Thanking
everyone for everything would be distracting and ultimately
information-free, since thanks are effective largely by how much they
stand out from the default, background level of favorable comment
going on all the time.  This does not mean, of course, that you should
never thank people.  Just make sure to do it in ways that tend not to
lead to credit inflation.  Following these guidelines will
help:</para>

<itemizedlist>
  <listitem><para>The more ephemeral the forum, the more free you
            should feel to express thanks there.  For example,
            thanking someone for their bugfix in passing during an IRC
            conversation is fine, as is an aside in an email devoted
            mainly to other topics.  But don&apos;t post an email solely to
            thank someone, unless it&apos;s for a truly unusual feat.
            Likewise, don&apos;t clutter the project&apos;s web pages with
            expressions of gratitude.  Once you start that, it&apos;ll
            never be clear when or where to stop. And
            <emphasis>never</emphasis> put thanks into comments in the
            code; that would only be a distraction from the primary
            purpose of comments, which is to help the reader
            understand the code.</para> 
  </listitem>
  <listitem><para>The less involved someone is in the project, the
            more appropriate it is to thank her for something she
            did.  This may sound counterintuitive, but it fits with
            the attitude that expressing thanks is something you do
            when someone contributes even more than you thought she
            would.  Thus, to constantly thank regular contributors for
            doing what they normally do would be to express a lower
            expectation of them than they have of themselves.  If
            anything, you want to aim for the opposite effect!</para>

            <para>There are occasional exceptions to this rule.  It&apos;s
            acceptable to thank someone for fulfilling his expected
            role when that role involves temporary, intense efforts
            from time to time.  The canonical example is the release
            manager, who goes into high gear around the time of each
            release, but otherwise lies dormant (dormant as a release
            manager, in any case&mdash;he may also be an active
            developer, but that&apos;s a different matter).
            </para>
  </listitem>
  <listitem><para>As with criticism and crediting, gratitude should
            be specific.  Don&apos;t thank people just for being great,
            even if they are.  Thank them for something they did that
            was out of the ordinary, and for bonus points, say
            exactly why what they did was so great.</para> 
  </listitem>
</itemizedlist>

<para>In general, there is always a tension between making sure that
people&apos;s individual contributions are recognized, and making sure the
project is a group effort rather than a collection of individual
glories.  Just remain aware of this tension and try to err on the
side of group, and things won&apos;t get out of hand.</para>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="forks">
<title>Forks</title>

<para>In <xref linkend="forkability"/><phrase output="printed">
in <xref linkend="social-infrastructure"/></phrase>, we saw how
the <emphasis>potential</emphasis> to fork has important effects on
how projects are governed.  But what happens when a fork actually
occurs?  How should you handle it, and what effects can you expect it
to have?  Conversely, when should you <emphasis>initiate</emphasis> a
fork?</para>

<para>The answers depend on what kind of fork it is.  Some forks are
due to amicable but irreconcilable disagreements about the direction
of the project; perhaps more are due to both technical disagreements
and interpersonal conflicts.  Of course, it&apos;s not always possible to
tell the difference between the two, as technical arguments may
involve personal elements as well.  What all forks have in common is
that one group of developers (or sometimes even just one developer)
has decided that the costs of working with some or all of the others
now outweigh the benefits.</para>

<para>Once a project forks, there is no definitive answer to the
question of which fork is the &quot;true&quot; or &quot;original&quot; project.  People
will colloquially talk of fork F coming out of project P, as though P
is continuing unchanged down some natural path while F diverges into
new territory, but this is, in effect, a declaration of how that
particular observer feels about it.  It is fundamentally a matter of
perception: when a large enough percentage of observers agree, the
assertion starts to become true.  It is not the case that there is an
objective truth from the outset, one that we are only imperfectly able to
perceive at first.  Rather, the perceptions <emphasis>are</emphasis>
the objective truth, since ultimately a project&mdash;or a
fork&mdash;is an entity that exists only in people&apos;s minds
anyway.</para>

<para>If those initiating the fork feel that they are
sprouting a new branch off the main project, the perception question
is resolved immediately and easily.  Everyone, both developers and
users, will treat the fork as a new project, with a new name (perhaps
based on the old name, but easily distinguishable from it), a separate
web site, and a separate philosophy or goal.  Things get messier,
however, when both sides feel they are the legitimate guardians of the
original project and therefore have the right to continue using the
original name.  If there is some organization with trademark rights to
the name, or legal control over the domain or web pages, that usually
resolves the issue by fiat: that organization will decide who is the
project and who is the fork, because it holds all the cards in a
public relations war.  Naturally, things rarely get that far: since
everyone already knows what the power dynamics are, they will avoid
fighting a battle whose outcome is known in advance, and just jump
straight to the end.</para>

<para>Fortunately, in most cases there is little doubt as to which is
the project and which is the fork, because a fork is, in essence, a vote
of confidence.  If more than half of the developers are in favor of
whatever course the fork proposes to take, usually there is no need to
fork&mdash;the project can simply go that way itself, unless it is run
as a dictatorship with a particularly stubborn dictator.  On the other
hand, if fewer than half of the developers are in favor, the fork is a
clearly minority rebellion, and both courtesy and common sense
indicate that it should think of itself as the divergent branch rather
than the main line.</para>

<sect2 id="forks-handling">
<title>Handling a Fork</title>

<para>If someone threatens a fork in your project, keep calm and
remember your long-term goals.  The mere
<emphasis>existence</emphasis> of a fork isn&apos;t what hurts a project;
rather, it&apos;s the loss of developers and users.  Your real aim,
therefore, is not to squelch the fork, but to minimize these harmful
effects.  You may be mad, you may feel that the fork was unjust and
uncalled for, but expressing that publicly can only alienate undecided
developers.  Instead, don&apos;t force people to make exclusive choices,
and be as cooperative as is practicable with the fork.  To start with,
don&apos;t remove someone&apos;s commit access in your project just because he
decided to work on the fork.  Work on the fork doesn&apos;t mean that
person has suddenly lost his competence to work on the original
project; committers before should remain committers afterward.  Beyond
that, you should express your desire to remain as compatible as
possible with the fork, and say that you hope developers will port
changes between the two whenever appropriate.  If you have
administrative access to the project&apos;s servers, publicly offer the
forkers infrastructure help at startup time.  For example, offer them
a complete, deep-history copy of the version control repository, if
there&apos;s no other way for them to get it, so that they don&apos;t have to
start off without historical data (this may not be necessary depending
on the version control system).  Ask them if there&apos;s anything else
they need, and provide it if you can.  Bend over backward to show
that you are not standing in the way, and that you want the fork to
succeed or fail on its own merits and nothing else.</para>

<para>The reason to do all this&mdash;and do it publicly&mdash;is not
to actually help the fork, but to persuade developers that your side
is a safe bet, by appearing as non-vindictive as possible.  In war it
sometimes makes sense (strategic sense, if not human sense) to force
people to choose sides, but in free software it almost never does.  In
fact, after a fork some developers often openly work on both projects,
and do their best to keep the two compatible.  These developers help
keep the lines of communication open after the fork.  They allow your
project to benefit from interesting new features in the fork (yes, the
fork may have things you want), and also increase the chances of a
merger down the road.</para>

<para>Sometimes a fork becomes so successful that, even though it was
regarded even by its own instigators as a fork at the outset, it
becomes the version everybody prefers, and eventually supplants the
original by popular demand.  A famous instance of this was the
GCC/EGCS fork.  The <firstterm>GNU Compiler Collection</firstterm>
(<firstterm>GCC</firstterm>, formerly the <firstterm>GNU C
Compiler</firstterm>) is the most popular open source native-code
compiler, and also one of the 
most portable compilers in the world.  Due to disagreements between the GCC&apos;s
official maintainers and Cygnus Software,<footnote><para>Now part of
RedHat (<ulink url="http://www.redhat.com/"/>).</para></footnote> one
of GCC&apos;s most active developer groups, Cygnus created a fork of GCC
called <firstterm>EGCS</firstterm>.  The fork was deliberately
non-adversarial: the EGCS developers did not, at any point, try to
portray their version of GCC as a new official version.  Instead, they
concentrated on making EGCS as good as possible, incorporating patches
at a faster rate than the official GCC maintainers.  EGCS gained in
popularity, and eventually some major operating system distributors
decided to package EGCS as their default compiler instead of GCC.  At
this point, it became clear to the GCC maintainers that holding on to
the &quot;GCC&quot; name while everyone switched to the EGCS fork would burden
everyone with a needless name change, yet do nothing to prevent the
switchover.  So GCC adopted the EGCS codebase, and there is once again
a single GCC, but greatly improved because of the fork.</para>

<para>This example shows why you cannot always regard a fork as an
unadulteratedly bad thing.  A fork may be painful and unwelcome at the
time, but you cannot necessarily know whether it will succeed.
Therefore, you and the rest of the project should keep an eye on it,
and be prepared not only to absorb features and code where possible,
but in the most extreme case to even join the fork if it gains the
bulk of the project&apos;s mindshare.  Of course, you will often be able to
predict a fork&apos;s likelihood of success by seeing who joins it.  If the
fork is started by the project&apos;s biggest complainer and joined by a
handful of disgruntled developers who weren&apos;t behaving constructively
anyway, they&apos;ve essentially solved a problem for you by forking, and
you probably don&apos;t need to worry about the fork taking momentum away
from the original project.  But if you see influential and respected
developers supporting the fork, you should ask yourself why.  Perhaps
the project was being overly restrictive, and the best solution is to
adopt into the mainline project some or all of the actions
contemplated by the fork&mdash;in essence, to avoid the fork by
becoming it.</para>

</sect2>

<sect2 id="forks-initiating">
<title>Initiating a Fork</title>

<para>All the advice here assumes that you are forking as a last
resort.  Exhaust all other possibilities before starting a fork.
Forking almost always means losing developers, with only an uncertain
promise of gaining new ones later.  It also means starting out with
competition for users&apos; attention: everyone who&apos;s about to download the
software has to ask themselves: &quot;Hmm, do I want that one or the other
one?&quot;  Whichever one you are, the situation is messy, because a
question has been introduced that wasn&apos;t there before.  Some people
maintain that forks are healthy for the software ecosystem as a whole,
by a standard natural selection argument: the fittest will survive,
which means that, in the end, everyone gets better software.  This may
be true from the ecosystem&apos;s point of view, but it&apos;s not true from the
point of view of any individual project.  Most forks do not succeed,
and most projects are not happy to be forked.</para>

<para>A corollary is that you should not use the threat of a fork as
an extremist debating technique&mdash;&quot;Do things my way or I&apos;ll fork
the project!&quot;&mdash;because everyone is aware that a fork that fails
to attract developers away from the original project is unlikely to
survive long.  All observers&mdash;not just developers, but users and
operating system packagers too&mdash;will make their own judgement about
which side to choose.  You should therefore appear extremely reluctant
to fork, so that if you finally do it, you can credibly claim it was
the only route left.</para>

<para>Do not neglect to take <emphasis>all</emphasis> factors into
account in evaluating the potential success of your fork.  For
example, if many of the developers on a project have the same
employer, then even if they are disgruntled and privately in favor of
a fork, they are unlikely to say so out loud if they know that their
employer is against it.  Many free software programmers like to think
that having a free license on the code means no one company can
dominate development.  It is true that the license is, in an ultimate
sense, a guarantor of freedom&mdash;if others want badly enough to
fork the project, and have the resources to do so, they can.  But in
practice, some projects&apos; development teams are mostly funded by one
entity, and there is no point pretending that that entity&apos;s support
doesn&apos;t matter.  If it is opposed to the fork, its developers are
unlikely to take part, even if they secretly want to.</para>

<para>If you still conclude that you must fork, line up support
privately first, then announce the fork in a non-hostile tone.  Even
if you are angry at, or disappointed with, the current maintainers,
don&apos;t say that in the message.  Just dispassionately state what led
you to the decision to fork, and that you mean no ill will toward the
project from which you&apos;re forking.  Assuming that you do consider it a
fork (as opposed to an emergency preservation of the original
project), emphasize that you&apos;re forking the code and not the name, and
choose a name that does not conflict with the project&apos;s name.  You can
use a name that contains or refers to the original name, as long as it
does not open the door to identity confusion.  Of course it&apos;s fine to
explain prominently on the fork&apos;s home page that it descends from the
original program, and even that it hopes to supplant it.  Just don&apos;t
make users&apos; lives harder by forcing them to untangle an identity
dispute.</para>

<para>Finally, you can get things started on the right foot by
automatically granting all committers of the original project commit
access to the fork, including even those who openly disagreed with the
need for a fork.  Even if they never use the access, your message is
clear: there are disagreements here, but no enemies, and you welcome
code contributions from any competent source.</para>

</sect2>

</sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->

