

<title>Technische Infrastruktur</title>

<simplesect>

<para>Freie Software Projekte verlassen sich auf Technologien, welche
die selektive Aufnahme und integration von Information unterstützen.
Je gewandter Sie mit diesen Technologien umgehen und andere dazu
bewegen können, sie zu benutzen, desto erfolgreicher wird ihr Projekt
sein. Dies stimmt um so mehr, sobald Ihr Projekt wächst. Eine gute
Verwaltung von Informationen, ist es was Open Source Projekte daran
hindert, unter der Last von dem Gesetz von Brooks,<footnote><para>
Aus seinem Buch <citetitle>The Mythical Man Month</citetitle>, 1975.
Siehe <ulink url="http://en.wikipedia.org/wiki/The_Mythical_Man-Month"/>
und <ulink url="http://en.wikipedia.org/wiki/Brooks_Law"/>.</para>
</footnote> zusammen zu brechen, welches besagt, dass hinzufügen von 
Arbeitskraft zu einem späten Projekt, es noch weiter verspätet. Er
beobachtete, dass die Komplexität eines Projekts mit dem <emphasis>
Quadrat</emphasis> der Anzahl der Teilnehmer zunimmt. Wenn nur wenige
beteiligt sind, kann jeder leicht mit jedem reden, wenn aber hunderte
beteiligt sind, ist es nicht weiter möglich, dass jeder darüber
Bescheid weiß, was jeder Andere macht. Wenn es bei der Verwaltung eines
freien Software Projekts darum geht, jedem das Gefühl zu geben in einem
Raum mit den Anderen zu sein, stellt sich die offensichtliche Frage:
Was passiert wenn alle in einem gedrängten Raum versuchen auf ein mal
zu reden?</para>

<para>Dieses Problem ist nicht neu. In nicht metaphorisch gesehene
gedrängte Räume ist die Lösung wie in einem Parlament vor zu gehen:
Es gibt formelle Richtlinien für Diskussionen in Echtzeit mit großen
Gruppen, um sicher zu stellen, dass wichtige Meinungsverschiedenheiten
in Fluten von "ich-auch" Kommentaren, nicht verloren gehen, für die
Bildung von Untergremien und woran man erkennt, wann Diskussionen
gehlaten werden, usw. Ein wichtiger Teil der Parlamentarischen
Diskussion ist zu spezifizieren, wie die Gruppe mit Verwaltungssystem
für Informationen umgeht. Manche Anmerkungen werden "fürs Protokoll"
gemacht, andere nicht. Das Protokoll selbst ist Gegenstand direkter
Änderungen, und wird nicht als wörtliche Niederschrift der Ereignisse 
verstanden, sondern als Niederschrift von Ereignisse auf die sich die 
Gruppe <emphasis>einigen</emphasis> konnte. Das Protokoll ist nicht
monolitisch, sondern nimmt verschiedene Formen an, für verschieden
Zwecke. Es umfasst, die Minuten der einzelnen Sitzungen, die Sammlung
aller Minuten, aller Sitzungen, Zusammenfassungen, Tagesordnungen und
ihre Erläuterungen, Gutachten von Ausschüssen, von nicht anwesenden
Korrespondenten, listen von Abläufen, usw.</para>

<para>Da das Internet nicht wirklich ein Raum ist, müssen wir uns
keine Sorgen darum machen, die Teile der parlamentarischen Diskussion
zu replizieren, die manche Leute ruhig hält, während andere Reden.
Wenn es aber um Techniken zur Verwaltung von Informationen geht, sind
gut betriebene Open Source Projekte wie parlamentarische Diskussionen
auf Steroiden. Weil fast die gesamte Kommunikation in Open Source
Projekten in schriftlicher Form abläuft, haben sich durchdachte 
Systeme entwickelt, um Daten angemessen zu kennzeichnen und an die
richtigen Stellen zu leiten; um Wiederholungen zu minimieren, damit
Diskussionen nicht aus einander laufen; um Daten zu speichern und
ab zu rufen; um schlechte oder veraltete Informationen zu korrigieren;
und um separate Informationen mit einander zu verbinden, wenn neue
Korrelationen beobachtet werden. Aktive Teilnehmer in Open Source
Projekten verinnerlichen viele dieser Techniken und werden oft komplexe
manuelle Aufgaben durchführen, um sicher zu stellen, dass Information
an die richtigen Stellen geleitet werden. Diese Bestrebungen hängen
aber von der Untertützung, durch ausgeklügelter Software ab. Die
Kommunikationsmedien sollten so viel wie möglich diese Aufgaben selber
durchführen und sollten Information für Menschen so bequem wie möglich
aufbereiten. In der Praxis, werden Menschen natürlich an vielen Stellen
eingreifen müssen, und es ist wichtig, dass die Software diese 
Eingriffe so bequem wie möglich macht. Im allgemeinen sollte aber, wenn
die Menschen sich bemühen Informationen sorgfältig zu Kennzeichnen und
die an den richtigen Stellen zu leiten, die Software so konfiguriert 
sein, dass es den größt möglichen nutzen aus diesen Metadaten zieht.
</para>

<para>Die Ratschläge in diesem Kapitel, ist sehr Praxisnah und basiert
auf spezifischer Software und Nutzungsverhalten. Es geht hierbei aber
nicht nur darum eine bestimmte Ansammlung an Techniken zu zeigen. Es
geht auch darum, mittels vieler kleiner Beispiele, die beste
Gesamteinstellung die in Ihrem Projekt eine gute Informationsverwaltung
fördert zu demonstrieren. Diese Einstellung wird eine Kombination von
technischen Fähigkeiten und soziale Kompetenzen beinhalten. Die
sozialen Kompetenzen sind nötig, da die menschliche Gemeinschaft auch
Wartung erfordert: Es ist nicht immer sofort ersichtlich, wie diese
Hilfsmittel am besten genutzt werden und im manchen Fällen, haben
Projekte sich widersprechende Konventionen (zum Beispiel, siehe die
Diskussion um die Einstellung des <systemitem>Reply-to</systemitem>
headers bei ausgehende Mailing List Nachrichten, in <xref 
linkend="mailing-lists"/>). Jeder der mit Projekt etwas zu tun hat,
wird zur richtigen Zeit und an der richtigen Stelle, dazu ermutigt 
werden müssen, seinen Teil dazu bei zu tragen, die Information des
Projekts organisiert zu halten. Je größer die Beteiligung des
Freiwilligen, desto komplexer und spezialisierter die Techniken die
man von ihm erwarten kann zu lernen.</para>

<para>Es gibt keine schablonenhafte Lösung für Informationsverwaltung.
Es gibt zu viele Variablen. Es kann sein das Sie endlich alles richtig
konfiguriert bekommen, genau wie Sie es haben wollen, und die meisten
Freiwilligen dazu gebracht haben sich zu beteiligen, dann aber wird
der Wachstum des Projekts manche dieser Praktiken nicht skallierbar
machen. Oder das Wachstum wird sich stabilisieren und bei den Entwickler
und Nutzergemeinschaften wird eine bequeme Beziehung mit der technischen
Infrastruktur einsetzen, dann aber wird jemand eine völlig neues
Verwaltungssystem für Informationen entwickeln und es Neuankömmlinge
werden ziemlich bald anfangen zu fragen, warum Ihr Projekt dieses nicht
benutzt-dies geschiedt zum Beispiel gerade mit vielen freien Software
Projekte, die vor Erfindung des wiki entstanden sind (siehe <ulink
url="http://en.wikipedia.org/wiki/Wiki"/>). Viele Fragen sind 
Ansichtssache und haben mit Kompromissen zwischen dem Komfort 
derjenigen die die Informationen Produzieren und dem Komfort derjenigen
die es Konsumieren zu tun, oder mit der Zeit die erforderlich ist, die
Software zur verwaltung der Informationen ein zu richten und dem Nutzen
den es dem Projekt bringt.</para>

<para>Hüten Sie sich vor der Verlockung all zu sehr zu automatisieren
was wirklich die Aufmerksamkeit eines Menschen erfordert. Technische
Infrastruktur ist wichtig, aber was ein freies Software Projekt 
wirklich zum funktionieren bringt, ist die Fürsorge-und die kluge
formulierung dieser Fürsorge- der beiteiligten Menschen. Die technische
Infrastruktur ist haupsächlich dazu da, um Menschen dazu eine bequeme
Möglichkeit zu geben.</para>

</simplesect>


<!-- ======================== SECTION ============================== -->
<sect1 id="tools-needed">
<title>Was ein Projekt braucht</title>

<para>Die meiste Open Source Projekte bieten zumindest eine minimale,
standardmäßigen Satz an Hilfsmittel, um Informationen zu Verwalten:
</para>

<variablelist>

   <varlistentry><term>Webseite</term>
     <listitem>
     <para>Primär, eine zentralisierte, eingleisiges Informationskanal
	von dem Projekt hinaus zu der Öffentlichkeit. Die Webseite
	kann auch als administrative Schnittstelle zu anderen
	Hilfsmittel des Projekts dienen.</para>
     </listitem>
   </varlistentry>

   <varlistentry><term>Nachrichten Verteiler</term>
     <listitem>
       <para>Für gewöhnlich das aktivste kommunikations Forum in einem
	Projekt, und das "Protokollmedium".</para> 
     </listitem>
   </varlistentry>

   <varlistentry><term>Versionsverwaltung</term>
     <listitem>
       <para>Ermögliche es den Entwicklern, Änderungen am Code zu
	bequem zu verwalten, unter anderem auch rückgängig zu machen
	und durch Meldungen über Änderungen, jeden zu ermöglichen,
	mit zu verfolgen, was mit dem Code geschiedt.</para>
     </listitem>
   </varlistentry>

   <varlistentry><term>Bug-Tracker</term>
     <listitem>
       <para>Ermöglicht es den Entwicklern im Auge zu behalten, woran
	sie gerade arbeiten, mit einander zu koordinieren, und neue
	Versionen zu Planen. Ermöglicht es jedem den Status von Fehler
	zu überprüfen und Informationen über Fehler fest zu halten 
	(z.B. wie man einen ihn reproduziert). Kann auch dazu benutzt
	werden, um Aufgaben, neue Versionen und Funktionen usw. zu
	verfolgen.</para>
     </listitem>
   </varlistentry>

<!--
   <varlistentry><term>Diskussionsforen</term>
     <listitem>
       <para><remark>Basically, bulletin board systems.  These are not
             as widespread as one would expect, and where they are
             found, they're not used as much as one would expect.  Why?
             Are they worth mentioning at all?</remark></para>
     </listitem>
   </varlistentry>
-->

   <varlistentry><term>Echtzeit chats</term>
     <listitem>
       <para>Ein Ort für schnelle, oberflächliche Diskussionen und
	dem Austausch von Fragen und Antworten. Nicht immer komplett
	archiviert.</para>
     </listitem>
   </varlistentry>

</variablelist>

<para>Jedes dieser Hilfsmittel ist dazu gedacht, einen bestimmten
Bedarf zu decken, ihre Funktionen sind aber auch mit einander
verwandt und müssen so eingerichtet werden, dass sie zusammen 
funktionieren. Weiter unten, werden wir untersuchen, wie man sie so
einrichten kann und viel wichtiger noch, wie man Leute dazu bewegt
sie zu benutzen. Die Webseite wird erst zum Schluss behandelt, da es
eher als Klebstoff fungiert denn als eigenständig zu sehendes
Hilfsmittel.</para>

<para>Sie eine Menge Kopfschmerzen ersparen, die durch die Einrichtung
dieser Hilfsmittel entstehen, mit Hilfe von Hosting Bündel: Ein Server
der vorkonfigurierte Seiten und Vorlagen anbietet, sowie alle
zugehörigen Hilfsmittel, um ein freies Software Projekt zu betreiben.
Siehe <xref linkend="canned-hosting"/><phrase output="printed"> später
in diesem Kapitel</phrase> welches die Vor- und Nachteile von Hosting
Bündel behandelt.</para>

</sect1>


<!-- ========================== SECTION =========================== -->
<sect1 id="mailing-lists">
<title>Nachrichten Verteiler</title>

<para>Nachrichten Verteiler sind das Tägliche Brot der Kommunikation
im Projekt. Wenn der Nutzer irgend einem Forum außer der Webseite,
wird es wahrscheinlich einer der Nachdichten Verteiler des Projekts
sein. Vor Sie aber den mit dem Verteiler zu tun haben, werden Sie mit
seiner Benutzerschnittstelle-also der Mechanismus, mit dem man sich
bei dem Verteiler anmeldet. Was uns zur ersten Regel von Nachrichten
Verteiler bringt:</para>

<blockquote>
   <para><emphasis>Versuchen Sie nicht Nachrichten Verteiler per Hand
	zu verwalten-Besorgen Sie sich dazu eine entsprechende
	Software.</emphasis></para>
</blockquote>

<para>Es wird verlockend sein, dies nach hinten zu stellen. Am Anfang
mag es überflüssig erscheinen diese Software ein zu richten. Kleine
Verteiler mit geringem Nachrichten verkehr händisch zu verwalten mag
verlockend einfach erscheinen: Man richtet einfach eine Adresse für
die Anmeldung ein, welche Nachrichten an Sie weiterleitet und wenn
jemand eine Nachricht sendet, tragen Sie seine Adresse in einer Text
Datei ein (oder aus), welche alle Adressen beinhaltet. Was könnte
einfacher sein?</para>

<para>Der Haken bei einer guten Verwaltung eines Verteilers-was viele
mittlerweile erwarten vorzufinden- überhaupt nicht einfach ist. Es
geht nicht nur darum Leute an und ab zu melden wenn sie eine Anfrage
dazu machen. Es geht auch um Moderation um spam zu verhindern, eine
Zusammenfassung der Nachrichten, statt jede einzeln, standard 
Informationen über den Verteiler und das Projekt, mittels 
automatisierter Antworten, und verschiedene weiter Sachen. Ein Mensch
der die Adresse eines Verteilers beobachtet, kann nur eingeschränkten
Mindestmaß an Funktionalität bieten, und selbst dann nicht so 
zuverlässig und schnell wie es Software könnte.</para>

<para>Moderne Verwaltungssoftware für Verteiler bietet für gewöhnlich
mindestens folgende Funktionen:</para>

<variablelist>

  <varlistentry><term>Sowohl email- als auch web basierende Anmeldung</term>
    <listitem>
      <para>Wenn ein Nutzer sich beim Verteiler Anmeldet, sollte er
	<emphasis>umgehend</emphasis> eine automatisierte Willkommens
	Nachricht als Antwort zugesandt bekommen, welches beschreibt 
	wozu man sich angemeldet hat, wie man weiter mit der Verteiler
	Software interagieren kann um (am wichtigsten) wie man sich 
	abmeldet. Diese automatische Antwort kann natürlich bearbeitet
	werden, um Projekt spezifische Informationen zu beinhalten, wie
	z.B. die Webseite des Projekts, wo man die FAQ findet, usw.
	</para>
    </listitem>
  </varlistentry>

  <varlistentry><term>Nachrichten in zusammen gefasster Form oder in
	Form von Einzelnachrichten</term>
    <listitem>
      <para>Im Zusammenfassungs Modus, erhält der Teilnehmer, eine 
	Email am Tag, welche die gesamte Aktivität auf der Liste für
	den Tag beinhaltet. Für diejenigen die die Liste nur neben bei
	mitverfolgen, ohne sich selbst zu beteiligen, ist die
	zusammengefasste Form oft vorzuziehen, da es ihnen erlaubt alle
	Themen auf einmal durchzusehen und eine Ablenkung durch 
	plötzlich eintreffende Emails vermeiden können.</para>
    </listitem>
  </varlistentry>

  <varlistentry><term>Moderations Funktionen</term>
    <listitem>
      <para>"Moderieren" bedeutet, sicherzustellen, dass sie 
            a)&nbsp;nicht&nbsp;spam sind, und b)&nbsp;zum&nbsp;Thema
	gehören, vor Sie an die gesamte Liste gesandt werden. 
	Moderation hat notwendigerweise, mit Menschen zu tun, aber
	Software kann eine Menge dazu beitragen, die Sache einfacher
	zu machen. Es wird später mehr über Moderation gesagt.</para>
    </listitem>
  </varlistentry>

  <varlistentry><term>Administrative Schnittstellen</term>
    <listitem>
      <para>Unter anderem, ermöglichen diese einem Administrator auf
	einfache Art veraltete Adressen zu löschen. Was dringend
	werden kann, wenn die Adresse eines Empfängers anfängt "Ich
	bin nicht mehr bei dieser Adresse" als Antwort auf jede
	Nachricht zurück an den Verteiler zu Senden. (Manche Verteiler
	Software kann solche Sachen erkennen, und die Person 
	automatisch abmelden.)</para>
    </listitem>
  </varlistentry>

  <varlistentry><term>Manipulation des Nachrichten Kopfs</term>
    <listitem>
      <para>Viele Leute haben ausgeklügelte Filter und Regel für
	Antworten in ihren Email Programmen eingerichtet. Nachrichten
	Verteiler Software kann bestimmte Einstellungen im 
	Nachrichtenkopf manipulieren welche diese ausnutzen können
	(mehr dazu später).</para>
    </listitem>
  </varlistentry>

  <varlistentry><term>Archivierung</term>
    <listitem>
      <para>Alle Nachrichten an die Verteiler werden gespeichert und
	im Netz verfügbar gemacht; alternativ bietet manche Verteiler
	Software spezielle Schnittstellen an, um externe Archivierungs
	Software einzubinden, wie z.B. (<ulink 
	url="http://www.mhonarc.org/"/>). Die <xref
	linkend="using-archives"/><phrase output="printed"> im Kapitel
	<xref linkend="communications"/></phrase> beschrieben, ist
	Archivierung äußerst wichtig.</para>
    </listitem>
  </varlistentry>

</variablelist>

<para>Der Sinn des ganzen ist lediglich um zu betonen, dass die
Verwaltung eines Email Verteilers ein komplexes Problem ist, mit dem
sich schon viele beschäftigt haben und welches weitestgehend gelöst 
ist. Sie müssen sicherlich kein Experte darin werden. Aber Sie
sollten sich darüber im klaren sein, dass man immer mehr lernen kann,
und dass die Verwaltung des Verteilers Sie von Zeit zu Zeit 
beschäftigen wird, im Laufe vom Betrieb eines freien Software
Projekts. Im weiteren werden wir ein paar der häufigsten Punkte
beim konfigurieren eines Email Verteilers, angehen.</para>

<!-- ========================== subsection =========================== -->
<sect2 id="spam-prevention">
<title>Verhütung vor Spam</title>

<para>Zwischen der Zeit, in der dieser Satz geschrieben wird, bis er
veröffentlicht wird, wird das internet weite Spam Problem wahrscheinlich
doppelt so schlimm geworden sein-oder zumindest wird es sich
so anfühlen. Es gab eine Zeit, nicht all zu lange her, in der man
einen Nachrichten Verteiler betreiben konnte, ohne überhaupt irgend
welche Maßnahmen zur Verhütung vor Spam vornehmen zu müssen. 
Gelegentlich verirrte sich eine Nachricht, am selten genug, um nur
eine geringes Ärgernis zu sein. Diese Era is für immer vorbei.
Heutzutage wird ein Verteiler der keine Maßnahmen vornimmt, um Spam
zu verhindern, schnell von Werbe Müll überflutet, bis zum Punkt,
dass es nicht mehr benutzbar ist. Verhütung vor Spam ist Pflicht.
</para>

<para>Wir unterteilen Verhütung vor Spam in zwei Kategorien: Spam
Nachrichten daran hindern, auf Ihren Verteiler auf zu tauchen, und
zu verhindern, dass Ihr Verteiler eine Quelle für Adressen für
Spam harvester wird. Erstes ist wichtiger, also untersuchen wir es
zuerst.</para>

<sect3 id="spam-filtering">
<title>Filterung von Nachrichten</title>

<para>Es gibt drei grundsätzliche Arten spam zu vermeiden und die
meiste Nachrichten Verteiler Software biete alle drei an. Sie werden
am besten zusammen genutzt:</para>

<orderedlist>

  <listitem><para><emphasis role="bold">Es sollten nur Nachrichten von
	angemeldeten Nutzern automatisch akzeptiert werden.</emphasis>
	</para>

	<para>Diese Einstellung ist weitestgehend effektiv und bedarf
	nur geringer administrativem Aufwand, da es für gewöhnlich nur
	eine kleine Änderung an der Konfiguration der Software des
	Verteilers bedeutet. Beachten Sie aber, dass Nachrichten die
	keine automatisierte Zustimmung bekommen nicht einfach 
	verworfen werden sollten. Aus zwei Gründen, sollten sie statt
	dessen, für weitere Moderation durch gereicht werden. Erstens,
	wollen Sie auch nicht Angemeldete erlauben Nachrichten an den
	Verteiler zu senden, schließlich sollte eine Person mit einer
	Frage oder einen Vorschlag, sich nicht gleich anmelden müssen
	um eine einzige Nachricht zu senden. Zweitens kann es vor
	kommen, dass auch angemeldete Benutzer von einer anderen Email
	Adresse als der mit der sie angemeldet sind, Nachrichten 
	verschicken. Email Adressen sind keine zuverlässige 
	Möglichkeit Menschen zu identifizieren und sollten nicht als
	solches behandelt werden.</para>
            </listitem>

  <listitem><para><emphasis role="bold">Filtern Sie Nachrichten
	mittels einer Software für Spam Filterung</emphasis></para>

	<para>Wenn die Software des Verteilers es ermöglicht (was die
	Meisten tun), können Sie Nachrichten mit einer Software zur
	Spam Filterung filtern lassen. Automatisierte Spam Filterung
	ist nicht perfekt, und wird es nie sein, da es einen nie
	endenden Wettrüsten zwischen Spammer und den Autoren der
	Filter Software gibt. Es kann aber einen großen Teil des
	Spam reduzieren, welches zu den Moderatoren durchkommt und
	da jede solche Verringerung zur Folge hat, dass der Moderator
	weniger Zeit damit verbringen muss Nachrichten zu untersuchen,
	ist jede automatische Filterung dieser Art von Vorteil.</para>

	<para>Für eine detailierte Anleitung wie man einen Spam Filer
	einrichtet, ist hier nicht genug Platz. Sie werden dafür die
	Dokumentation Ihrer Verteiler Software aufsuchen müssen (siehe
	<xref linkend="mailing-list-software"/><phrase
	output="printed"> später in diesem Kapitel</phrase>).
	Nachrichten Verteiler Software kommt oft mit eingebauten
	Möglichkeiten um Spam zu verhindern, es kann aber sein, dass
	Sie weitere Filter von einem dritten Anbieter hinzufügen
	wollen. Mit diesen Beiden habe ich gute Erfahrungen gemacht:
	SpamAssassin (<ulink url="http://spamassassin.apache.org/"/>)
	und SpamProbe (<ulink 
	url="http://spamprobe.sourceforge.net/"/>). Was allerdings
	kein Urteil über andere Open Source Filter für Spam sein
	soll, von denen einige anscheinend auch ziemlich gut sind. Ich
	habe zufällig diese Beiden benutzt und war mit ihnen
	zufrieden.</para>
  </listitem>

  <listitem><para><emphasis role="bold">Moderation.</emphasis></para>
	<para>Die Letzte Stufe, für Nachrichten die nicht von einem
	angemeldeten Benutzer kommen und es an den Spam Filter vorbei
	schaffen, ist die <firstterm>Moderation</firstterm>: Die
	Nachricht wird an eine besondere Adresse geleitet, wo es von
	einem Menschen untersucht wird, der sie entweder annimmt oder
	ablehnt.</para>

	<para>Eine Nachricht zu akzeptieren kann eine von zwei Formen
	annehmen: Sie können die Nachricht nur dieses eine Mal 
	annehmen, oder Sie können die Software anweisen, es und all
	weiteren Nachrichten von dieser Adresse anzunehmen. Letzteres
	ist fast immer anzuraten, um die zukünftige Bürde der 
	Moderation zu verringern. Wie man Nachrichten annimmt, kann
	sich von System zu System unterscheiden, für gewöhnlich reicht
	es aber an eine bestimmte Adresse mit einem Befehl wie "accept"
	de:"annehmen" (um nur diese eine Nachricht zu erlauben) oder
	"allow" de:"erlauben" (um diese und alle weiteren Nachrichten
	zu erlauben).</para>

	<para>Um eine Nachricht abzulehnen, reicht es für gewöhnlich,
	sie zu ignorieren. Wenn die Verteiler Software niemals eine
	Bestätigung erhält, dass etwas gültig ist, wird sie diese
	Nachricht nicht verteilen, als erreicht man das erwünschte
	Ergebnis indem man einfach die Nachricht liegen lässt. In 
	manchen Fällen haben Sie auch die Möglichkeit mit "reject"
	de:"ablehnen" oder "deny" de:"verweigern" an den Verteiler
	zu antworten, was dazu führt, dass alle weiteren Nachrichten
	von dieser Adresse automatisch abgelehnt werden ohne
	moderiert zu werden. Es gibt selten einen Grund das zu tun,
	da es bei der Moderation meistens darum geht, Spam zu
	vermeiden und Spammer neigen eh nicht dazu zwei mal von der
	selben Adresse zu senden.</para>
            </listitem>
</orderedlist>

<para>Benutzen Sie Moderation allerdings <emphasis>ausschließlich
</emphasis> um Spam und Nachrichten zu filtern, die ganz klar nicht
zum Thema gehören wie z.B. wenn jemand aus versehen eine Nachricht 
an den falschen Verteiler schickt. Das moderations System wird Ihnen
für gewöhnlich eine Möglichkeit geben direkt an den Absender eine
Nachricht zu schicken, nutzen Sie aber diese nicht um Fragen zu
beantworten die in Wirklichkeit auf den Verteiler gehören, selbst 
wenn Ihnen die Antwort sofort einfällt. Das zu tun, würde der
Gemeinschaft des Projekts nur die Möglichkeit entziehen sich ein
klares Bild darüber zu machen, welche Fragen gestellt werden und
Sie der Gelegenheit berauben, diese Fragen selber zu beantworten
und/oder die Antworten anderer zu sehen. Die Moderation eines
Nachrichten Verteilers sollte sich strengstens darauf beschränken
ihn von Werbemüll und Irrelevante Nachrichten frei zu halten und
sonst nichts.</para>

</sect3>

<sect3 id="address-hiding">
<title>Verschleierung von Adressen in Archiven</title>

<para>Um zu verhindern, dass Ihr Verteiler zu einer Quelle von Email
Adressen für Spammer wird, gibt es die gebräuchliche Methode
Adressen in den Archiven zu verschleiern, in dem man z.B.</para>

    <blockquote>
      <para><literal>hmustermann@einedomain.de</literal></para>
    </blockquote>

<para>mit</para>

    <blockquote>
      <para><literal>hmustermann_AT_einedomain.de</literal></para>
    </blockquote>

<para>oder</para>

    <blockquote>
      <para><literal>hmustermannKEINSPAM@einedomain.de</literal></para>
    </blockquote>

<para>oder irgend (für Menschen) etwas ähnlich offensichtliches
ersetzt. Da Spam Harvester oft nach dem Prinzip funktionieren,
Webseiten ab zu grasen-auch die Archive Ihres Verteilers- und nach
Sequenzen die "@" beinhalten suchen, ist diese Art der Verschleierung
eine effektive Methode Email Adressen vor Spammer zu verstecken oder
unbrauchbar zu machen. Was natürlich nichts dazu beiträgt, zu
verhindern, dass Spam an den Verteiler selbst geschickt wird, aber es
kann die Menge an Spam reduzieren, die direkt an die persönlichen
Adressen der Nutzer des Verteilers gesandt wird.</para>

<para>Die Verschleierung von Adressen, kann kontrovers sein. Manche
finden, dass es eine gute Idee ist, und werden überrascht sein wenn
Ihre Archive es nicht automatisch erledigen. Andere denken es ist eine
zu große Unbequemlichkeit (da Menschen auch die Adresse wieder zurück
übersetzen müssen, vor sie genutzt werden können). Manche behaupten
ab und zu, dass es nicht effektiv sei, da die Harvester theoretisch
jedes konsistente Muster zur Verschleierung, ausgleichen könnten. Es
gibt jedoch empirische Beweise, dass die Verschleierung von Adressen
<emphasis>tatsächlich</emphasis> effektiv ist, wie <ulink
url="http://www.cdt.org/speech/spam/030319spamreport.shtml"/> zeigt.
</para>

<para>Idealerweise, würde die Verteiler Software diese Entscheidung
jedem Nutzer selber überlassen, entweder durch eine extra Ja/Nein
Angabe im Nachrichten Kopf oder in den Einstellungen von seinem
Verteiler Konto. Ich kenne allerdings keine Software, welche diese
Entscheidung für jede Nachricht oder jeden Nutzer anbietet, also
wird vorerst der Administrator des Verteilers, diese Entscheidung
für alle übernehmen müssen(angenommen die Software zur Archivierung
bietet diese Einstellung überhaupt an, was nicht immer der Fall ist).
Ich tendiere ein wenig dazu die Verschleierung an zu schalten 
schalten. Manche Leute sind sehr vorsichtig dabei Ihre Adresse nicht
auf Webseiten oder irgend eine andere Stelle zu platzieren, wo ein
Spam Harvester sie finden könnte, und sie wären enttäuscht, wenn all
ihre Bemühungen vom Archiv eines Verteilers zunichte gemacht würden;
auf der anderen Seite ist der Aufwand welches die Verschleierung
bei den Nutzern verursacht nur sehr gering, da es trivial ist eine
Verschleierte Adresse wieder in eine gültige zu verwandeln, wenn man
die Person erreichen will. Behalten Sie aber im Hinterkopf, dass es
immer noch ein Wettrüsten ist: Bis Sie diese Zeilen lesen kann es
durchaus sein, dass die Harvester sich so weit entwickelt haben, dass
Sie die häufigsten Methoden der Verschleierung erkennen können und wir
müssen uns wieder etwas neues ausdenken.</para>

</sect3>

</sect2>

<!-- ========================== subsection =========================== -->
<sect2 id="header-management">
<title>Identifizierung und Handhabung des Nachrichten Kopfs</title>

<para>Die Nutzer des Verteilers, wollen oft die Nachrichten davon in
Projekt spezifische Ordner, von ihren anderen Emails getrennt
sortieren. Ihre Email Software kann dies automatisch durchführen,
indem es die <firstterm>Header</firstterm> der Emails liest. Header
sind die Felder im Kopf der Email den Absender, Empfänger, Betreff, 
Datum und verschiedene andere Informationen über die Nachricht angeben.
Bestimmte Header sind weit verbreitet und effektiv gesehen 
Pflicht Angaben:</para>

<screen>
From (Von): ...
To (An): ...
Subject (Betreff): ...
Date (Datum): ...
</screen>

<para>Andere sind Optional, wenn auch fast standard. Emails müssen
zum Beispiel wenn man es genau nimmt, nicht den
</para>

<screen>
Reply-to (Antwort An): absender@email.adresse.hier
</screen>

<para>Header angeben, haben es aber trotzdem, da es den Empfängern
eine narrensichere Möglichkeit gibt, den Author zu erreichen (was
besonders nützlich ist, wenn der Author die Email von einer anderen
Adresse senden musste, als die an der Antworten gerichtet sein
sollten).</para>

<para>Manche Email Programme bieten einfach zu nutzende Schnittstellen,
um Emails, mit unterschiedlichen Mustern im Betreff, anders ab zu
legen. Was zu Anfragen führt, dass die Software des Nachrichten
Verteilers einen automatischen Präfix vor jedem Betreff setzen soll,
damit Ihr Email Programm danach suchen kann, und es automatisch in den
richtigen Ordner ablegen kann. Die Idee ist, dass der Author folgendes
schreiben würde:</para>

<screen>
Betreff: Erstelle die Version 2.5.
</screen>

<para>die Nachricht aber wie folgt vom Verteiler verschickt würde:
</para>

<screen>
Betreff: [diskussion@verteiler.beispiel.org] Erstelle die Version 2.5.
</screen>

<para>Obwohl die meiste Verteiler Software diese Möglichkeit bietet,
empfehle ich diese Option nicht an zu schalten. Das Problem welches es
löst, kann viel einfacher auf eine sehr viel weniger aufdringliche Art
gelöst werden, und der Preis den man durch verlorenen Platz im Betreff
verliert ist viel zu hoch. Erfahrene Nutzer von Nachrichten Verteiler,
suchen die Betreff Zeilen der im laufe des Tages eingetroffenen Emails
ab, und entscheiden anhand dessen, ob sie eine Nachricht lesen oder
darauf eine Antwort schreiben. Den Namen des Verteilers vor dem
eigentlichen Betreff zu setzen kann die rechte Seite des Betreffs über
den Bildschirmrand hinaus schieben, und damit unsichtbar macht. Die
Informationen, auf die sich die Leser Verlassen, um zu entscheiden,
welche Nachrichten Sie öffnen sollen, geht damit zum Teil verloren
und verringert dadurch insgesamt, für jeden den Nutzen des Verteilers.
</para>

<para>Anstatt die Betreffzeile zu verunstalten, bringen Sie Ihren
Nutzern bei, andere standardmäßig angegebene Header zu verwenden,
angefangen mit dem To (de. An) Header, welches die Adresse des 
Verteilers angeben sollte:</para>

<screen>
An: &lt;diskussion@verteiler.beispiel.org&gt;
</screen>

<para>Jede Email Software die nach Betreff filtern kann, sollte auch
in der Lage sein, ebenso einfach nach dem To Header filtern können.
</para>

<para>Es gibt ein paar weitere optionale, aber standardmäßig vorhandene
Header, die für Nachrichten Verteiler erwartet werden. Nach ihnen zu
filtern ist noch zuverlässiger als die "To" oder "Cc" Header; da diese
Header von der Verteiler Software zu jedem Nachrichten Kopf hinzugefügt
werden, verlassen sich unter Umständen manche Nutzer auf sie:</para>

<screen>
list-help: &lt;mailto:discuss-help@lists.example.org&gt;
list-unsubscribe: &lt;mailto:discuss-unsubscribe@lists.example.org&gt;
list-post: &lt;mailto:discuss@lists.example.org&gt;
Delivered-To: mailing list discuss@lists.example.org
Mailing-List: contact discuss-help@lists.example.org; run by ezmlm
</screen>

<para>Zum größten Teil sind diese selbst erklärend. Siehe <ulink
url="http://www.nisto.com/listspec/list-manager-intro.html"/> für eine
weiter gehende Erklärung, oder <ulink 
url="http://www.faqs.org/rfcs/rfc2369.html"/> wenn Sie die 
ausführliche formale Spezifikation brauchen.
</para>

<para>Beachten Sie auch, dass diese Header auch implizieren, dass wenn
Sie einen Verteiler mit dem Namen "list" haben, Sie auch administrative
Adressen mit den Namen "list-help" und "list-unsubscribe" zur
Verfügung stellen. Zusätzlich dazu, ist es üblich eine Adresse namens
"list-subscribe", um dem Verteiler bei zu treten und "list-owner", 
um seine Administratoren zu erreichen. Je nachdem welche Software Sie
für Ihren Verteiler verwenden, werden diese und verschiedene Andere
eingerichtet sein; die Dokumentation wird dazu weiter Angaben haben.
Eine komplette Liste all dieser speziellen Adressen wird für gewöhnlich
jedem Nutzer, als Teil der "Willkommens Nachricht", bei der Anmeldung
zugeschickt. Sie werden selber wahrscheinlich eine Kopie dieser Email
bekommen. Wenn nicht, dann bitten Sie jemand anderen um eine Kopie,
damit Sie wissen was Ihre Nutzer sehen, wenn sie dem Verteiler
beitreten. Behalten Sie es in Griffweite, um Fragen bezüglich den
Funktionen des Verteilers beantworten zu können, besser noch, stellen
Sie es irgendwo auf Ihre Webseite, sodass wenn Leute ihre eigene Kopie
der Anleitung verlieren, und Fragen "Wie kann ich mich Abmelden?", Sie
einfach auf eine URL weisen können.</para>

<para>Manche Verteiler Software bietet die Option, an jede Nachricht,
eine Anleitung zum abmelden anzuhängen. Wenn diese Option verfügbar
ist, schalten Sie sie an. Es verbraucht nur ein paar zusätzliche
Zeilen pro Nachricht, an einer harmlosen Stelle, und kann viel Zeit
ersparen, indem es die Anzahl der Nutzer reduziert, die an Sie&mdash;
oder schlimmer noch, an den Verteiler&mdash; Anfragen schicken wie
man sich abmelden kann.</para>

</sect2>

<!-- ========================== subsection =========================== -->
<sect2 id="reply-to">
<title>Die Große Reply-to Debatte</title>

<para>Vorhin, bei <xref linkend="avoid-private-discussions"/>, habe
ich betont, wie wichtig es ist Diskussionen in den öffentlichen Foren
zu halten und erwähnte, dass aktive Maßnahmen manchmal nötig sind, um
zu Sie daran zu hindern in private Unterhaltungen ab zu gleiten;
desweiteren, geht es in diesem Kapitel darum, die 
Kommunikationssoftware so weit zu konfigurieren, dass es einem
möglichst viel Arbeit abnimmt. Es wäre deshalb anzunehmen, dass wenn
die Verteiler Software eine Möglichkeit bietet, alle Nachrichten auf
den Verteiler zu halten, sie anzuschalten, die offensichtliche Wahl
wäre.</para>

<para>Nun ja, nicht ganz. Es gibt solch eine Funktion, allerdings hat
es ein paar schwerwiegende Nachteile. Die Frage ob man sie benutzen
soll oder nicht, ist einer der am heißesten debattierten, bei der
Verwaltung von Nachrichten Verteilern&mdash;zugegebenermaßen, nicht
unbedingt eine Kontroverse die es auf die Titelseite ihres lokalen
Nachrichtenblatts schaffen würde, aber Sie kann von Zeit zu Zeit
in einem freien Software Projekt aufflammen. Unten werde ich die
Funktion beschreiben, die Hauptargumente beider Seiten erläutern und
die beste Empfehlung geben, die ich kann.</para>

<para>Die Funktion selbst ist relativ einfach: Wenn Sie wollen, kann
die Verteiler Software automatisch, den Reply-to (de. Antwort an)
Header auf die Adresse des Verteilers setzen. Was so viel heißt,
dass egal was der Author der Nachricht in den Reply-to Header
schreibt (bzw. wenn Sie es gar nicht erst mitschicken), wird bei den
Empfängern in dem Header, die Adresse des Verteilers zu sehen sein:
</para>

<screen>
Reply-to: discuss@lists.example.org
</screen>

<para>Oberflächlich betrachten, erscheint dies eine gute Sache zu
sein. Praktisch jede Email Software beachtet den Reply-to Header,
jetzt, wenn jemand auf eine Nachricht antwortet, wird Ihre Nachricht
an den gesamten Verteiler gerichtet sein, und nicht nur den Author
der ursprünglichen Nachricht. Natürlich kann der Antwortende immer 
noch händisch den Empfänger ändern, wichtig ist aber, dass
<emphasis>standardmäßig</emphasis> Antworten an den Verteiler
gerichtet sind. Es ist ein perfektes Beispiel dafür, Technologie dazu
zu nutzen um Zusammenarbeit zu unterstützen.</para>

<para>Leider, gibt es ein paar Nachteile. Das Erste ist bekannt als
das <firstterm>Ich Finde den Weg Nachhause Nicht</firstterm> Problem:
Manchmal wird der ursprüngliche Absender seine "echte" Email Adresse
in den Reply-to Header setzen, da sie aus bestimmte Gründen die
Nachricht von einer anderen Adresse absenden, als sie Antworten
empfangen möchten. Wer immer von der gleichen Adresse sendet und
Empfängt, wird dieses Problem nicht haben, und viele sind überrascht,
dass es das Problem überhaupt gibt. Für jene mit ungewöhnlichen Email
Konfigurationen, oder die keinen Einfluss auf das aussehen ihrer 
Emails haben (vielleicht weil sie von der Arbeit aus versenden und
keinen Einfluss auf die IT-Abteilung haben), kann der Reply-to Header,
die einzige Möglichkeit sein, sicherzustellen, dass Antworten den Weg
zu ihnen finden. Wenn eine solche Person, an einen Verteiler schreibt,
bei dem er nicht angemeldet ist, wird ihre Reply-to Einstellung zu
einer unabdingbaren Information. Wenn die Verteiler Software sie
überschreibt, kann es passieren, dass sie niemals die Reaktionen auf
ihre Nachricht zu Gesicht bekommt.</para>

<para>Der Zweite Nachteil hat mit Annahmen zu tun, was meiner Meinung
nach das stärkste Argument gegen die Verunstaltung von Reply-to ist.
Die meisten erfahrenen Email Nutzer, sind an zwei grundsätzliche Arten
zu antworten gewohnt: <firstterm>reply-to-all (de. Antwort-an-alle)
</firstterm> und <firstterm>reply-to-author (de. Antwort-an-Author)
</firstterm>. Alle modernen Email Programme bieten diese beiden 
separaten Möglichkeiten an. Nutzer wissen, dass um an alle eine
Antwort zu schicken(d.H. inklusive jene auf dem Verteiler), sie die
reply-to-all wählen sollten, und um eine private Nachricht an den
Author zu schicken, Sie reply-to-author wählen sollten. Auch wenn Sie
wo immer möglich zu offenen Diskussionen ermutigen sollten, gibt es
doch Situationen, bei denen der Antwortende eine private Nachricht
vorzieht&mdash;zum Beispiel wenn sie etwas vertrauensvolles an den
Author schreiben wollen, was unangemessen für den öffentlichen
Verteiler wäre.</para>

<para>Wenn man nun in Erwägung zieht, was passiert wenn der Verteiler
den ursprünglichen Reply-to Eintrag bearbeitet und der antwortende
auf den reply-to-author Knopf drückt, in der Erwartung eine private
Nachricht an den Absender zu schicken. Aufgrund von dem Erwarteten
Verhalten, wird er unter Umständen nicht nochmal auf die Adresse des
Empfängers in der neuen Nachricht achten. Er hat dabei vielleicht eine
geheime, vertrauensvolle Nachricht verfasst, eine die Peinliche Sachen
über ein Mitglied des Verteilers sagt und drückt nun auf absenden.
Seine Nachricht taucht nun unerwartet, ein paar Minuten später 
<emphasis>auf dem Verteiler auf!</emphasis> Zugegeben, theoretisch
hätte er sorgfältig auf das Empfänger Feld achten sollen, und keine
Annahmen über den Reply-to Header machen sollen. Autoren setzen aber
fast immer Reply-to auf ihre eigene persönliche Adresse (oder vielmehr
tut dies ihre Email Software), und viele die schon seit langem Email
benutzen, erwarten es mittlerweile. Das geht sogar so weit, dass wenn
jemand absichtlich reply-to auf irgend eine andere Adresse setzt, als
den Verteiler, er es explizit in dem Nachrichtentext erwähnt, damit
Leute sich nicht darüber wundern was passiert wenn sie antworten.
</para>

<para>Aufgrund der möglicherweise schwerwiegenden Folgen dieses
unerwarteten Verhaltens, bevorzuge icht es die Verteiler Software so
zu konfigurieren, dass sie niemals den reply-to header anfassen. Es
ist ein Beispiel, bei dem die Nutzung von Techniken um zur 
Zusammenarbeit zu ermutigen, wie es mir erscheint, potentiell
gefährliche Nebenwirkungen. EWs gibt jedoch auch starke Argumente auf
der Gegenseite dieser Debatte. Welchen Weg Sie auch wählen, werden Sie
ab und zu Leute bekommen die danach fragen, warum Sie den anderen Weg
nicht gewählt haben. Da Sie sowas niemals zu dem Hauptthema einer
Diskussion auf ihrem Verteiler werden lassen wollen, kann es 
angebracht sein, hierfür eine vorher formulierte Antwort parat zu
haben, derart formuliert, dass sie die Diskussion eher beendet als
anfeuert. Stellen Sie klar, dass Sie <emphasis>nicht</emphasis> darauf
bestehen, dass Ihre Entscheidung, welche auch immer, offensichtlich die
einzig Richtige und sinnvolle ist (selbst wenn Sie denken, dass dies der
Fall ist). Statt dessen, deuten Sie darauf hin, wie alt diese Debatte
ist, dass es gute Argumente auf beiden Steiten gibt, keine Entscheidung
alle zufriedenstellen wird und dass Sie einfach die Ihnen best
mögliche Entscheidung getroffen haben. Bitten Sie höfflich darum das
Thema nicht weiter zu führen, es sei denn jemand hat etwas wirklich
neues zu sagen. Halten Sie sich danach aus dem Thread und hoffen Sie,
dass es eines natürlichen Todes stirbt.</para>

<para>Jemand wird vielleicht vorschlagen eine Wahl darüber zu halten.
Wenn Sie möchten, können Sie das tun, ich persönlich finde es in
diesem Fall jedoch als unzureichend einfach Köpfe zu zählen.
Für jemand der ein gewisses Verhalten erwartet, wäre die Strafe
unangemessen hoch (versehentlich eine private Nachricht an den
Verteiler senden), und die Unbequemlichkeit für die übrigen Teilnehmer
ist relativ gering (ab und zu jemand daran erinnern an den ganzen
Verteiler zu antworten statt nur an Ihnen), weshalb es nicht klar ist,
dass die Mehrheit, auch wenn sie die Mehrheit ist, eine Minderheit in
solch eine Gefahr bringen sollte.</para>

<para>Ich habe nicht alle Aspekte dieses Themas hier angesprochen,
sondern nur die vorrangig wichtigen. Für eine vollständige, 
Untersuchung dies Themas, verweise ich auf folgende zwei annerannte
Dokumente, die bei dieser Debatte immer wieder zitiert werden:

<itemizedlist>
  <listitem>
     <para><emphasis role="bold">Lasse Reply-to in ruhe</emphasis>,
     <emphasis>von Chip Rosenthal</emphasis></para>
     <para><ulink
        url="http://www.unicom.com/pw/reply-to-harmful.html"/></para>
  </listitem>
  <listitem>
     <para><emphasis role="bold">Setze Reply-to auf den Verteiler
	</emphasis>,
     <emphasis>von Simon Hill</emphasis></para>
     <para><ulink
        url="http://www.metasystema.net/essays/reply-to.mhtml"/></para>
  </listitem>
</itemizedlist>

</para>

<para>Trotz meiner angedeuteten leichten Präferenz, denke ich nicht,
dass es auf diese Frage eine "richtige" Antwort gibt, und bin gerne
auch auf vielen Verteilern, die Reply-to <emphasis>setzen</emphasis>.
Das wichtigste was Sie machen können, ist sich frühzeitig auf den
einen oder anderen Weg festzulegen, und zu versuchen sich nachher
nicht zu Debatten darüber verleiten zu lassen.</para>

<sect3 id="reply-fantasies">
<title>Zwei Fantasien</title>

<para>Eines Tages, wird jemand die geniale Idee einfallen ein
<firstterm>reply-to-list</firstterm> Schlüssel in einer Email Software
zu implementieren. Es würde irgend welche der vorher erwähnten
spezifisch Header, um die Adresse des Nachrichten Verteilers
herauszufinden und direkt bzw. nur an den Verteiler zu antworten, 
ohne irgend welche sonstige Adressen zu benutzen, da diese höchst 
wahrscheinlich sowieso bei dem Verteiler angemeldet sind. Mit der
Zeit werden andere Email Programme diese Funktion mit übernehmen und
diese ganze Debatte wird verschwinden. (Tatsächlich hat die Email
Software <ulink url="http://www.mutt.org/">Mutt</ulink> eine solche
Funktion.<footnote><para> Kurz nachdem dieses Buch erschien, schrieb
mir <ulink url="http://www.michaelbernstein.com/">Michael Bernstein
</ulink> um zu sagen: "Es gibt weitere Email Programme abgesehen von
Mutt, die eine reply-to-list Funktion implementiert haben. Zum
Beispiel, stellt Evolution diese Funktion über die Tastenkombination
(Strg+L) zur Verfügung, jedoch nicht als Knopf."</para></footnote>)
</para>

<para>Eine noch bessere Lösung wäre es, die Änderung von Reply-to,
jedem Benutzer selber zu überlassen. Diejenigen, die wollen, dass der
Verteiler ihre Reply-to Header ändern (entweder bei ihren eigenen
Nachrichten oder bei denen von Anderen) könnten darum bitten, und
solche die es nicht wollen, könnten darum bitten das es in ruhe
gelassen wird. Ich kenne jedoch keine Verteiler Software die sowas für
jeden Benutzer einzeln einstellen lässt. Es scheint, dass wir zur Zeit
mit einer Globalen Einstellung leben müssen.</para>

</sect3>

</sect2>

<!-- ========================== subsection =========================== -->
<sect2 id="archiving">
<title>Archivierung</title>

<para>Die technischen Details zu der Einrichtung eines Verteiler 
Archivs sind für die Software, welche der Verteiler benutzt spezifisch
und liegen nicht im Rahmen von diesem Buch. Wenn Sie ein Programm zur
Archivierung wählen oder konfigurieren, sollten Sie auf folgende 
Qualitäten achten:</para>

<variablelist>

  <varlistentry><term>Zeitnahe Aktualisierung</term>
    <listitem>
      <para>Teilnehmer werden oft auf eine archivierte Nachricht die
	in den vor ein oder zwei stunden gemacht wurde verweisen
	wollen. Wenn möglich sollte die Software jede Nachricht
	sofort archivieren, sodass in dem Moment, indem es vom
	Verteiler versandt wird, es in dem Archiv vorhanden ist. Wenn
	diese Option nicht verfügbar ist, versuchen Sie die Software
	zumindest so einzustellen, dass es sich ca. jede Stunde 
	aktualisiert. (Standardmäßig, lässt mache Software die
	Aktualisierung ein Mal jede Nacht laufen, was aber in der
	Praxis eine viel zu große Verzögerung, für einen aktiven
	Nachrichten Verteiler verursacht.)</para>
    </listitem>
  </varlistentry>

  <varlistentry><term>Referentielle Stabilität</term>
    <listitem>
      <para>Sobald eine Nachricht bei einer bestimmten URL archiviert
	wurde, sollte sie von genau dieser URL immer abrufbar sein,
	oder zumindest so nahe daran wie möglich. Selbst wenn die
	Archive neu aufgebaut werden, aus einem Backup wieder 
	eingespielt werden, oder sonstwie repariert werden, sollten
	alle öffentlich bekannt gemachten URLs weiterhin gleich 
	bleiben. Stabile Referenzen ermöglichen es Suchmaschinen die
	Archive zu indexieren, was für Nutzer die nach Antworten
	suchen ein großer Segen ist. Stabile Referenzen sind auch
	deshalb wichtig, da Nachrichten oftmals vom Bug Tracker aus
	(siehe <xref linkend="bug-tracker"/>)<phrase output="printed">
	später in diesem Kapitel</phrase> oder von anderen Dokumenten
	des Projekts verlinkt sind.</para>

      <para>Idealerweise, würde die Software des Nachrichten 
	Verteilers eine URL der jeweiligen Nachricht im Archiv, mit 
	ihr im Header versenden, oder zumindest den URL Teil, spezifisch
	zur Nachricht. So können diejenigen, die eine Kopie der
	Nachricht erhalten haben, wissen wo es im Archiv zu finden ist,
	ohne die Archive selbst aufsuchen zu müssen, was hilfreich wäre,
	weil jeder Vorgang der mit dem Browser zu tun hat, automatisch
	zeitaufwändig ist. Ich weiß nicht ob, irgend eine Verteiler
	Software diese Funktion anbietet; diejenigen die ich benutzt
	habe, können es leider nicht. Es ist allerdings etwas nach dem
	man suchen sollte (oder falls Sie Nachrichten Verteiler 
	Software schreiben, wäre es bitte eine Funktion die Sie zur
	Implementierung erwägen könnten).</para>
    </listitem>
  </varlistentry>

  <varlistentry><term>Sicherungskopien</term>
    <listitem>
      <para>Es sollte einigermaßen offensichtlich sein, wie man die
	Archive sichert, und der Vorgang um sie wieder her zu stellen,
	sollte nicht zu schwierig sein. Mit anderen Worten, behandeln
	Sie Ihr Archiv nicht wie eine Blackbox. Sie (oder jemand aus
	Ihrem Projekt) sollte wissen wo es die Nachrichten speichert,
	und wie die Seiten des Archivs wiederherzustellen sind, falls
	es jemals nötig werden sollte. Diese Archive sind wertvolle
	Daten&mdash;ein Projekt welche sie verliert, verliert auch
	einen großen Teil seiner kollektiven Erinnerung.</para>
    </listitem>
  </varlistentry>

  <varlistentry><term>Thread Unterstützung</term>
    <listitem>
      <para>Es sollte möglich sein, von jeder individuellen Nachricht
	aus, zum dem <firstterm>thread</firstterm> (eine Gruppe
	verwandter Nachrichten) zu gehen, von dem die ursprüngliche
	Nachricht ein ein Teil ist. Jeder Thread sollte auch seine
	eigene URL haben, separat von den URLs der individuellen
	Nachrichten in dem Thread.</para>
    </listitem>
  </varlistentry>

  <varlistentry><term>Durchsuchbarkeit</term>
    <listitem>
      <para>Ein Archiv welches die Durchsuchung der Nachrichten&mdash;
	sowohl des Textkörpers als auch der Betreffzeile&mdash; ist
	nahezu nutzlos. Beachte, dass manche Archive die Suchfunktion
	unterstützen, indem sie einfach die Arbeit an externe
	Suchmaschinen wie <ulink url="http://www.google.com/">Google
	</ulink> auslagern. Das ist zwar akzeptable aber eine direkte 
	Suchfunktion ist für gewöhnlich besser abgestimmt, da es dem
	Suchenden erlaubt zu spezifizieren, ob zum Beispiel nur die
	Betreffzeile durchsucht werden soll oder der gesamte Text.
	</para>
    </listitem>
  </varlistentry>

</variablelist>

<para>Obiges ist nur eine Checkliste, um Ihnen dabei zu unterstützen
eine Software für die Archivierung zu evaluieren und einzurichten.
Leute dazu zu bringen es tatsächlich zu <emphasis>benutzen
</emphasis>, zum Vorteil des Projekts wird in späteren Kapiteln
behandelt, spezifisch in <xref linkend="using-archives"/>.</para>

</sect2>

<!-- ========================== subsection =========================== -->
<sect2 id="mailing-list-software">
<title>Software</title>

<para>Hier sind einige Open Source Programme für die Verwaltung eines
Verteilers und zur Archivierung. Wenn die Seite die Ihr Projekt
benutzt, bereits eine standardmäßige Einrichtung hat, werden Sie sich
unter Umständen niemals für eines entscheiden müssen. Wenn Sie sie
aber selber einrichten müssen, sind diese einige Möglichkeiten. Die
die ich tatsächlich benutzt habe, sind Mailman, Etmlm, MHonArc, und 
Hypermail, was aber nicht bedeutet, dass Andere nicht auch gut sind
(und natürlich, gibt es auch wahrscheinlich andere Programme die ich
nur nicht gefunden habe, also betrachten Sie diese nicht als eine
vollständige Liste.</para>

<para>Nachrichten Verteiler Software:</para>

<itemizedlist>
 <listitem>
   <para><emphasis role="bold">Mailman</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://www.list.org/"/></para>
   <para>(Hat einen eingebauten Archivierer und Möglichkeiten um externe
	einzubinden.)</para>
 </listitem>
</itemizedlist>

<para>Software zur Archivierung:</para>

<itemizedlist>
 <listitem>
   <para><emphasis role="bold">MHonArc</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://www.mhonarc.org/"/></para>
 </listitem>
 <listitem>
   <para><emphasis role="bold">Hypermail</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://www.hypermail.org/"/></para>
 </listitem>
 <listitem>
   <para><emphasis role="bold">Lurker</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://sourceforge.net/projects/lurker/"/></para>
 </listitem>
 <listitem>
   <para><emphasis role="bold">Procmail</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://www.procmail.org/"/></para>
   <para>(Belgelit Software zu SmartList, welches ein allgemeines 
	System für Mail Verarbeitung ist und anscheinend auch als
	Archivierer konfiguriert werden kann.)</para>
 </listitem>
</itemizedlist>

</sect2>

</sect1>


<!-- ========================== SECTION =========================== -->
<sect1 id="vc">
<title>Versionsverwaltung</title>

<para>Ein System für die <firstterm>Versionsverwaltung</firstterm>
(en. Version Control) ist eine Kombination verschiedener Technologien 
und Verfahren um Änderung an den Dateien eines Projekts, insbesondere
den Quellcode, die Dokumentation und die Webseiten, zu verfolgen und
verwalten. Wenn Sie noch nie Versionsverwaltung benutzt haben, ist
das Erste was Sie tun sollen, jemand finden, der es bereits getan hat
und sie dazu bringen dem Projekt beizutreten. Heutzutage, wird jeder
erwarten, dass zumindest Ihr Quellcode und Versionsverwaltung steht,
und keiner wird Ihr Projekt ernst nehmen, wenn es Versionsverwaltung
nicht wenigstens mit einem minimum an Kompetenz benutzt.</para>

<para>Der Grund warum Versionsverwaltung so Allgegenwärtig ist, ist
dass es beim betrieb eines Projekts, in nahezu jedem Aspekt Hilft: 
Kommunikation zwischen Entwickler, Veröffentlichung neuer Versionen,
Bug Verwaltung, Code Stabilität und experimentelle Entwicklungen sowie
die Zuordnung und Authorization von Änderungen von bestimmten 
Entwicklern. Das Versionsverwaltungssystem bereitet eine zentrale Kraft
für all diese Bereiche. Der Kern der Versionsverwaltung ist die
Verwaltung von Änderungen (en. <firstterm>change management</firstterm>:
jede einzelne Änderung die an den Dateien eines Projkets identifizieren,
ihnen Metadaten anzuhängen wie Datum der Änderung und den Author, und
diese Tatsachen jedem der Fragt, egal wie danach gefragt wird
wiederzugeben. Es ist ein Mechanismus zur Kommunikation, bei dem eine
Änderung die grundlegende Einheit für Information ist.</para>

<para>Dieser Abschnitt behandelt nicht jeden Aspekt der Benutzung eines
Versionsverwaltungssystems. Es ist derart Umfassend, dass es im 
Buch durchweg immer wieder angesprochen werden muss. Hier werden wie
uns darauf konzentrieren, ein Versionsverwaltungssystem derart 
auszuwählen und einzurichten, dass es später die gemeinschaftliche
Entwicklung unterstützen wird.</para>

<!-- ========================== subsection =========================== -->
<sect2 id="vc-vocabulary">
<title>Vokabular der Versionsverwaltung</title>

<para>Dieses Buch kann Ihnen nicht beibringen Versionsverwaltung zu
benutzen, wenn Sie es noch nie zuvor benutzt haben, aber es wäre
unmöglich das Thema zu behandeln, ohne ein paar spezifische Begriffe.
Diese Begriffe sind unabhängig vom Versionsverwaltungssystem nützlich:
Sie sind die grundsätzlichen Nomen und Verben der Zusammenarbeit im
Netzwerk und sie werden allgemein im verlaufe des Buches benutzen.
Selbst wenn es keine Versionsverwaltung gäbe, gäbe es immer noch das
Problem der Verwaltung von Änderungen und diese Wörter geben uns eine
Sprache um präzise und prägnant über das Problem zu reden.</para>

<variablelist>

 <varlistentry id="vc-vocabulary-commit">
  <term><firstterm>commit</firstterm></term>
  <listitem><para>Eine Änderung an dem Projekt vornehmen; formeller
	gesagt, eine Änderung in der Datenbank der Versionsverwaltung
	zu speichern, derart, dass es in Zukünftige Versionen des
	Projekts eingebunden werden kann. "Commit" (de. festlegen)
	kann sowohl als Nomen, als auch als Verb benutzt werden. Als
	Nomen, ist es im wesentlichen synonym mit Änderung. Zum 
	Beispiel: "Ich habe habe eben einen Fix für den Bug der von
	Nutzern von Max OS X, server Abstürze verursacht hat committed,
	Jay könntest du dir bitte den Commit anschauen und überprüfen,
	dass ich nicht den Allocator dort nicht missbrauche?"</para>
	</listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-log-message">
  <term><firstterm>log&nbsp;message</firstterm></term>
  <listitem><para>Ein Kommentar der an jedem Commit angehängt wird,
	der die Art der Änderung und sein Nutzen beschreibt. Log
	Nachrichten sind mitunter die wichtigsten Dokumente in einem
	Projekt: Sie sind die Brücke zwischen der äußerst technischen
	Sprache der einzelnen Code Änderungen und der eher Nutzer
	orientierten Sprache der Funktionen, Bugfixes und Projekt
	Fortschritt. Später in diesem Abschnitt werden wir uns Wege
	anschauen, log Nachrichten an das richtige Publikum zu 
	verteilen; sowie, <xref linkend="codifying-tradition"/>
	<phrase output="printed"> im Kapitel <xref
	linkend="communications"/></phrase> welches in Methoden
	beschreibt Beteiligte dazu anzuregen kurze prägnante und
	nützliche log Nachrichten zu schreiben.</para></listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-update">
  <term><firstterm>update</firstterm></term>
  <listitem><para>Danach zu fragen, dass die Änderungen (commits) in
	der eigenen lokalen Kopie des Projekts eingebunden werden; bzw.
	Ihre Kopie zu aktualisieren. Dies ist ein sehr häufiger 
	Vorgang; die meisten Entwickler aktualisieren ihren Code
	mehrmals am Tag um sicherzustellen, dass sie die ungefähr das
	Selbe am laufen haben, wie die Anderen Entwickler, und so dass
	falls Sie einen Fehler finden, sie sich ziemlich sicher sein
	können das es bisher noch nicht behoben wurde. Zum Beispiel:
	"Hallo, ich habe bemerkt, dass der Code für die Indexierung
	immer das letzte Byte falle lässt. Ist das ein neuer Bug?"
	"Ja, aber es wurde letzte Woche behoben&mdash;versuch mal
	einen Update zu machen, dann sollte es verschwinden."</para>
  </listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-repository">
  <term><firstterm>repository</firstterm></term> <listitem><para>Eine
	Datenbank in dem Änderungen gespeichert werden. Manche
	Versionsverwaltungssysteme sind zentralisiert: Es gibt eine
	Haupt repository, welche alle Änderungen am Projekt speichert.
	Andere sind dezentralisiert: jeder Entwickler hat seine eigene
	repository, und Änderungen können beliebig hin und her 
	getauscht werden. Das Versionsverwaltungssystem verfolgt die
	Abhängigkeiten zwischen den Änderungen und wenn es Zeit wird
	einen Release zu machen, wird einem bestimmter Satz von 
	Änderungen für die neue Version zugestimmt. Die Frage welche
	der beiden besser ist, ist eine der andauernden Heiligen
	Kriege der Software Entwicklung; Versuchen Sie nicht in die
	Falle zu treten, sich auf Ihren Nachrichten Verteiler darüber
	zu streiten.</para></listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-checkout">
  <term><firstterm>checkout</firstterm></term>
  <listitem><para>Der Vorgang, eine Kopie des Projekts vom Repository
	zu beschaffen. Ein Checkout produziert für gewöhnlich eine
	Verzeichnisstruktur welches als "working copy" (siehe unten) 
	bezeichnet wird, von dem aus Änderungen wieder zurück an die
	Repository committed werden können. Bei manchen 
	dezentralisierten Versionsverwaltungssystemen ist jede Working
	Copy selbst eine Repository, und Änderungen können an jede
	Repository hoch-(oder herunter-) geladen werden, die bereit
	ist sie anzunehmen.</para></listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-working-copy">
  <term><firstterm>working copy</firstterm></term>
  <listitem><para>(de. Arbeitskopie) Der private Verzeichnisbaum eines
	Entwicklers, welches die Source Code Dateien des Projekts und
	möglicherweise seine Webseiten oder andere Dokumente beinhaltet.
	Eine Arbeitskopie enthält auch ein wenig Metadaten, die von dem
	Versionsverwaltungssystem benutzt werden, um zu Kennzeichen 	
	woher von welchem Repository sie kommt, welche "revision" (siehe
	Unten) der Dateien vorliegen, usw. Im allgemeinen hat jeder
	Entwickler seine eigene Arbeitskopie, in welcher er seine
	Änderungen macht und testet, und von dem aus er committed.
	</para></listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-revision">
  <term><firstterm>revision</firstterm>,
        <firstterm>change</firstterm>,
        <firstterm>changeset</firstterm></term>
  <listitem><para>Eine "revision" ist für gewöhnlich eine bestimmte
	Version von einer Datei oder einem Verzeichnisses. Wenn das
	Projekt zum Beispiel mit der revision 6 der Datei D anfängt, 
	und dann jemand eine Änderung an D committed, entsteht die
	revision 7 von D. Manche Systeme benutzen "revision", "change"
	(de. Änderung) oder "changeset" (de. Satz von Änderungen) auch
	um einen ganzen Satz an Änderungen die zusammen committed
	wurden als Einheit zu bezeichnen.</para> 

	<para>Diese Begriffe haben ab und zu eine Bestimmte technische
	Bedeutung bei verschiedenen Versionsverwaltungssystemen, im
	allgemeinen ist die Idee immer die gleiche: Sie ermöglichen
	es genau über bestimmte Zeitpunkte in der Geschichte der Datei
	zu reden (wie, direkt vor und nachdem ein Bug behoben wurde).
	Beispielsweise: "Ja, sie hat das in revision 10 behoben" oder
	"Sie hat das in revision 10 von foo.c behoben."</para>

	<para>Wenn man von einer Datei oder einer Sammlung von Dateien
	spricht ohne eine bestimmte revision anzugeben, wird im
	Allgemeinen angenommen, dass man von der aktuellsten revision
	spricht.</para></listitem>
 </varlistentry>

  <sidebar id="version-vs-revision">
  <title>"Version" kontra "Revision"</title>
  <para>Das Wort <firstterm>Version</firstterm> wird manchmal als
	synonym für "revision" benutzt, ich werde es jedoch in diesem
	Buch nicht auf diese Art verwenden, da es zu leicht zu
	verwechseln ist mit "version" im sinne einer bestimmten
	Version einer Software&mdash;also, mit einer Versionsnummer
	wie "Version 1.0". Da jedoch, der Begriff Versionsverwaltung
	bereits geläufig ist, werden ich es weiterhin benutzen.</para>
  </sidebar>

 <varlistentry id="vc-vocabulary-diff">
  <term><firstterm>diff</firstterm></term>
  <listitem><para>(kurz für difference de. Unterschied) Eine textuelle
	Representation einer Änderung. Ein diff zeigt welche Zeilen
	geändert wurden und wie, sowie ein paar zusätzliche umgebende
	Zeilen um einen Bezug zu haben. Ein Entwickler der bereits ein
	wenig mit dem Code vertraut ist, kann für gewöhnlich ein diff
	lesen und verstehen was die Änderung gemacht hat und sogar ein
	Bugs bemerken.</para></listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-tag">
  <term><firstterm>tag</firstterm></term>
  <listitem><para>(de. Etikett) Eine Kennzeichnung einer bestimmen
	Sammlung von Dateien an bestimmten Revisionen. Tags werden
	üblicherweise benutzt um interessante Revisionen des Projekts
	zu erhalten. Für jede neue öffentliche Version wird zum Beispiel
	ein neuer "Tag" gemacht, damit man sich genau den selben Satz
	von Dateien/Revisionen aus dem Versionsverwaltungssystem
	beschaffen kann. Häufige "Tag" Bezeichnungen sind sowas wie
	<literal>Version_1_0</literal>, <literal>Auslieferung_00456
	</literal>, usw.</para></listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-branch">
  <term><firstterm>branch</firstterm></term>
  <listitem><para>(de. Ast) Eine Kopie des Projekts, welche zwar unter
	Versionsverwaltung steht aber isoliert is, damit Änderungen 
	nicht das Übrige Projekt beeinflussen und umgekehrt, außer
	wenn Änderungen absichtlich von einer Seite zur Anderen
	"gemerged" werden (siehe unten). Ein Branch kann man auch als
	Entwicklungszweig bezeichnen. Selbst wenn ein Projekt nicht
	explizit irgend welche Branches hat, betrachtet man dennoch
	den "main branch" auch "main line" oder "<firstterm>trunk
	</firstterm>" als den Zweig auf dem die Entwicklung stattfindet.  
	</para>

	<para>Branches bieten eine Möglichkeit verschiedene Linien der
	Entwicklung von einander zu trennen. Ein Branch kann zum
	Beispiel für Experimentelle Entwicklung benutzt werden, die
	für den Haupt Branch zu instabil wären. Oder umgekehrt kann
	ein Branch als Ort benutzt werden um eine neue Version zu 
	stabilisieren. Während der Entwicklung, würde die reguläre
	Entwicklung im Haupt Branch ohne Unterbrechung weitergehen
	können; währenddessen werden auf dem Branch der neuen Version
	keine Änderungen mehr zugelassen, außer sie werden von einem 
	Release Manager genehmigt. Auf diese Art, muss eine neue
	Version nicht die laufende Entwicklungsarbeit stören. Siehe
	<xref linkend="branches"/><phrase output="printed">später in
	diesem Kapitel</phrase> für eine detailliertere Erörterung 
	von Branching.</para></listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-merge">
  <term><firstterm>merge (auch port)</firstterm></term>
  <listitem><para>(de. Zusammenführung) Eine Änderung von einem Branch
	in einen Anderen übernehmen. Was auch merging von dem trunk in
	einen anderen Branch oder umgekehrt bedeuten kann. Tatsächlich
	sind das sogar die häufigsten Merges; es ist selten eine
	Änderung zwischen zwei Branches zu mergen, die nicht beide
	Haupt-Zweige sind. Siehe <xref linkend="vc-singularity"/>
	für mehr zu dieser Art von merging.</para>

	<para>"Merge" hat eine zweite, verwandte Bedeutung: Es ist das,
	was das Versionsverwaltungssystem macht, wenn zwei Leute die
	gleiche Datei bearbeitet haben, aber derart, dass sie sich nicht
	überlappen. Da die Änderungen nicht mit einander kollidieren,
	sobald einer der beiden seine Kopie der Datei aktualisiert
	(welches bereits ihre eigenen Änderungen enthält), werden die
	Änderungen der anderen Person gemerged. Das kommt sehr häufig
	vor, besonders in Projekten, bei dem mehrere Entwickler am
	gleichen Code hacken. Wenn zwei verschiedene Änderungen
	<emphasis>doch</emphasis> überlappen, gibt es einen
	"conflict"; siehe unten.</para>
  </listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-conflict">
  <term><firstterm>conflict</firstterm></term>
  <listitem><para>Was geschieht wenn zwei Personen gleichzeitig
	unterschiedliche Änderungen an der gleichen Stelle im Code
	vornehmen. Alle Versionsverwaltungssysteme erkennen Konflikte
	automatisch, und benachrichtigen mindestens einer der 
	beteiligten Menschen, dass ihre Änderungen mit denen eines
	Anderen Kollidieren. Es ist dann die Aufgabe des Menschen den
	Konflikt zu beseitigen (en. resolve) und es an das
	Versionsverwaltungssystem zu vermitteln.</para></listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-lock">
  <term><firstterm>lock</firstterm></term>
  <listitem><para>(de. Schloss/Sperre) Eine Möglichkeit eine exklusive
	Absicht auf eine Datei oder ein Verzeichnis zu erklären. Zum
	Beispiel: "Ich kann gerade keine Änderungen an den Webseiten 
	committen. Es scheint das Alfred all gesperrt hat (en. locked)
	während er die Hintergrundbilder repariert". Nicht alle
	Versionsverwaltungssysteme bieten überhaupt die Möglichkeit
	zur Sperrung überhaupt an, und von denen die es tun, erfordern
	nicht alle, dass sie auch benutzt wird. Das liegt daran, dass
	parallele, gleichzeitige Entwicklung der Normalfall ist, und
	Personen eine Datei für andere zu Sperren (gewöhnlicherweise)
	diesem Ideal entgegensteht.</para>

  <para>Von Versionsverwaltungssystemen die einen lock erfordern um einen
	commit zu machen, sagt man, dass sie das
	<firstterm>lock-modify-unlock</firstterm> Modell benutzen. Solche
	die es nicht erfordern nutzen das <firstterm>copy-modify-merge
	</firstterm> Modell. Eine ausgezeichnete tiefgehende Erklärung
	und Vergleich der beiden Modelle kann man bei <ulink
	url="http://svnbook.red-bean.com/svnbook-1.0/ch02s02.html"/>
	finden. Im allgemeinen, ist die copy-modify-merge Methode besser
	für die Open Source Entwicklung, und alle 
	Versionsverwaltungssysteme in diesem Buch unterstützen es.</para>
	</listitem>
 </varlistentry>

</variablelist>

</para>

</sect2>


<!-- ========================== subsection =========================== -->
<sect2 id="vc-choosing">
<title>Die Wahl eines Versionsverwaltungssystems</title>

<para>Bis dato, ist das Versionsverwaltungssystem der Wahl in der Welt
der freien Software das <firstterm>Concurrent Versions System
</firstterm> oder auch <firstterm>CVS</firstterm> (<ulink 
url="http://www.cvshome.org/"/>). CVS gibt es schon seit langem. Die
meisten Erfahrenen Entwickler sind bereits damit vertraut, es erledigt
die Aufgabe mehr oder weniger gut und da es der Standard ist, werden
Sie keine langen Debatten darüber führen müssen ob es die richtige
Wahl war. CVS hat jedoch einige Nachteile. Es bietet keine einfache
Möglichkeit an sich auf Änderungen an mehreren Dateien gleichzeitig
zu beziehen; es erlaubt es nicht Dateien umzubenennen oder zu kopieren
die unter Versionsverwaltung stehen (was besonders nervt, wenn Sie Ihr
Code neu organisieren wollen, nachdem Sie das Projekt gestartet haben);
es bietet nur dürftige Unterstützung für Merging an; es kann nicht
sonderlich gut mit großen oder binären Dateien umgehen; und manche
Vorgänge sind langsam, wenn sie mit großen Dateimengen zu tun haben.
</para>

<para>Keiner der Fehler von CVS ist fatal, und es ist immer noch 
ziemlich beliebt. In den letzten Jahren sind jedoch ein paar neue
Versionsverwaltungssysteme erschienen, und freie Software Projekte
fangen an sie aus zu probieren. <xref linkend="vc-systems"/> listet
alle mir bekannten auf. Wie diese Liste klar macht, kann die
Entscheidung für ein Versionsverwaltungssystem zu einer lebenslangen
Forschungsprojekt werden. Möglicherweise wird Ihnen die Entscheidung
erspart bleiben weil es von Ihrer Hosting Seite gemacht für Sie
getroffen wurde. Wenn Sie sich aber für eine entscheiden müssen,
befragen Sie andere Entwickler, finden Sie heraus womit Andere bereits
Erfahrung haben, wählen Sie eine aus und halten Sie sich daran. Jedes
stabile, ausgereifte Versionsverwaltungssystem reicht aus; Sie müssen
sich keine Sorgen darüber machen, dass Sie eine furchtbar schlechte
Entscheidung treffen werden. Wenn Sie sich einfach nicht entscheiden
können, dann nehmen Sie CVS. Es ist immer noch die Norm und wird es
auch wahrscheinlich ein paar Jahre lang bleiben. Viele andere Systeme
unterstützen auch die Konvertierung in eine Richtung von CVS, also
können Sie sich später auch umentscheiden.</para>

</sect2>


<!-- ========================== subsection =========================== -->
<sect2 id="vc-using">
<title>Nutzung des Versionsverwaltungssystems</title>

<para>Die Empfehlungen in diesem Abschnitt sind nicht auf ein
bestimmtes Versionsverwaltungssystem ausgelegt, und sollten in jeder
von ihnen einfach zu implementieren sein. Für weitere Details, 
schlagen Sie in der Dokumentation Ihres Systems nach.</para>

<sect3 id="version-everything">
<title>Versioniere Alles</title>

<para>Halten Sie nicht nur den Quellcode Ihres Projekts under
Versionsverwaltung, sondern auch die Webseiten, Dokumentation, FAQ,
design notizen, und alles andere, welches jemand vielleicht bearbeiten
möchte. Behalten Sie alles direkt bei dem Quellcode, in der selben
repository. Jedes Stück Information, welches es sich lohnt nieder zu
schreiben, ist es auch wert versioniert zu werden&mdash;also, jedes
Stück Information welches sich Ändern könnte. Sachen die sich nicht
Ändern, sollten archiviert und nicht versioniert werden. Eine Email
ändert sich zum Beispiel nicht, nachdem sie abgeschickt wurde; 
deshalb würde es keinen Sinn machen es zu versionieren (es sei denn es
wird zum Teil einer größeren, sich entwickelnden Dokument).</para>

<para>Der Grund warum es wichtig ist alles an einem Ort zu 
versionieren ist, ist der, dass Personen nur eine Methode lernen
müssen um Änderungen einzureichen. Oftmals, wird ein Beteiligter 
damit anfangen Änderungen an den Webseiten oder der Dokumentation zu
machen, und gehen später dazu über kleine Beiträge zum Quellcode zu
machen. Wenn das Projekt das selbe System für alle Beiträge
verwendet, müssen Leute nur eine Methode lernen. Alles zusammen zu
versionieren, bedeutet auch, dass neue Funktionen gleich mit ihren 
zugehörigen Aktualisierungen an der Doku committed werden können,
dass ein Branch des Codes auch ein Branch der Doku zur Folge hat, usw.
</para>

<para>Behalten Sie <firstterm>generierte Dateien</firstterm> nicht
unter Versionsverwaltung. Sie sind nicht wirklich bearbeitbare Daten,
da sie aus anderen Dateien erzeugt werden. Manche build systeme
erzeugen zum Beispiel <filename>configure</filename> aus der Vorlage
<filename>configure.in</filename>. Um eine Änderung an <filename>
configure</filename> vorzunehmen, würde man <filename>configure.in
</filename> bearbeiten und es daraus neu erzeugen; weßhalb lediglich
die Vorlage <filename>configure.in</filename> "bearbeitbar" ist.
Versionieren Sie lediglich die Vorlage&mdash;wenn Sie die erzeugten
Dateien auch versionieren, wird man zwangsläufig vergessen sie neu
zu erzeugen, sobald man eine Änderung an einer Vorlage committed.
Die daraus resultierende Inkonsistenzen werden endlose Verwirrung 
stiften. <footnote><para>Eine andere Meinung im Bezug auf die 
Versionierung von <filename>configure</filename> Dateien, kann man in 
"<citetitle>configure.in and version control</citetitle>" bei 
<ulink url="http://versioncontrolblog.com/2007/01/08/configurein-and-version-control/"/>
von Alexey Makhotkin finden.</para></footnote></para>

<para>Zu der Regel, dass alle bearbeitbare Dateien unter 
Versionsverwaltung gestellt sein sollten, gibt es eine Ausnahme: den
Bug Tracker. Bug Datenbanken enthalten eine Menge bearbeitbarer Daten,
können aber aus technischen Gründen diese Daten im allgemeinen nicht
im Versionsverwaltungssystem speichern. (Manche Tracker haben eigene
primitive Versionierungs Funktionen, jedoch unabhängig von der
Haupt Repository des Projekts.)</para>

</sect3>

<sect3 id="vc-browsing">
<title>Durchsuchbarkeit</title>

<para>Die Repository des Projekts sollte vom Web aus durchsuchbar
sein. Das bedeutet nicht nur die neuste Version der einzelnen Dateien
einsehen zu können, sondern auch in der Zeit zurück zu gehen und
frühere Versionen der Dateien zu sehen, die Unterschiede zwischen
den verschiedenen Versionen der Dateien sehen zu können, die log
Nachrichten bestimmter Änderungen lesen zu können, usw.</para>

<para>Wenn sich Ihr Projekt durchsuchen lässt, entsteht eine
leichtgewichtiges Portal zu Ihren Daten. Wenn die Repository nicht aus
dem Web durchsucht werden kann, dann wird jemand der eine bestimmte
Datei untersuchen will (sagen wir, um nachzuschauen ob ein bestimmter
Bugfix es in den Code geschafft hat), müsste zuerst lokal einen Client
für die Versionsverwaltung installieren, was ihre einfache Anfrage von
zwei Minuten zu einer halbstündigen Aufgabe machen könnte.</para>

<para>Mit Durchsuchbarkeit meint man auch implizit feststehende URLs 
für Bestimmte Versionen von Dateien und um die derzeit neuste Version 
zu sehen. Was sehr nützlich sein in technischen Diskussionen sein kann,
oder wenn man Personen zu einer bestimmten Dokumentation weisen will.
Man könnte zum Beispiel anstatt "Tipps, wie du den Server debuggen 
kannst, findest du in der www/hacking.html Datei in deiner Arbeitskopie",
"Tipps, wie du den Server debuggen kannst, findest du bei <emphasis>
http://svn.collab.net/repos/svn/trunk/www/hacking.html</emphasis>"
sagen, womit man eine URL gibt, die immer auf die neuste Version der
Datei zeigt. Die URL ist besser, da sie nicht mehrdeutig ist, und die
Frage vermeidet, ob der Angesprochene eine aktuelle Arbeitskopie hat.
</para>

<para>Manche Versionsverwaltungssysteme haben eine eingebaute Funktion
um die Repository online zu durchsuchen, während andere sich auf
Software von dritten Parteien hierfür verlassen. Drei Beispiele 
hierfür sind <firstterm>ViewCVS</firstterm> (<ulink
url="http://viewcvs.sourceforge.net/"/>), <firstterm>CVSWeb</firstterm>
(<ulink url="http://www.freebsd.org/projects/cvsweb.html"/>), und
<firstterm>WebSVN</firstterm> (<ulink
url="http://websvn.tigris.org/"/>). Ersteres funktioniert sowohl mit
CVS als auch Subversion, das Zweite nur mit CVS und Letzteres nur mit
Subversion.</para>

</sect3>

<sect3 id="commit-emails">
<title>Commit Emails</title>

<para>Jeder Commit zu der Repository sollte eine Email erzeugen, die
zeigt, wer sie gemacht hat, wann sie es gemacht haben, welche Dateien
und Verzeichnisse sich geändert haben und inwiefern sie sich geändert
haben. Die Email sollte an einem speziellen Verteiler gehen, separat
von der zu dem die Beteiligten Nachrichten schicken. Entwickler und
andere interessierte Beteiligte sollten dazu ermutigt werden sich auf
dem Commit Verteiler anzumelden, da es die effektivste Art ist sich
über die Ereignisse auf Code Ebene des Projekts am laufenden zu halten.
Abgesehen von den offensichtlichen technischen Vorteilen welches die
Überprüfung durch andere Entwickler bringt (see 
<xref linkend="code-review"/>), können die Commit Emails dazu 
beitragen einen Gemeinschaftssinn entstehen zu lassen, da sie eine
gemeinsame Umgebung schaffen, in dem Personen auf Ereignisse(Commits)
von denen sie wissen das Andere sie auch wahrnehmen, reagieren können. 
</para>

<para>Wie man spezifisch Commit Emails einrichtet, hängt von Ihrem 
Versionsverwaltungssystem ab, für gewöhnlich gibt es aber hierfür
einen Script oder eine andere gebündelte Möglichkeit. Wenn Sie
Schwierigkeiten bekommen es zu finden, dann schauen Sie in Ihrer
Dokumentation nach <firstterm>hooks</firstterm>, insbesondere nach
<firstterm>post-commit hook</firstterm>, bei CVS auch <firstterm>
loginfo hook</firstterm> genannt. Diese Commit hooks sind eine
allgemeine Möglichkeit, nach als Reaktion auf jeden Commit befehle
Aufzurufen. Der Hook wir von einem einzelnen Commit ausgelöst, ihm
werden alle Informationen über den Commit übergeben, und es ist ihm
dann freigestellt, was er damit anfängt&mdash; zum Beispiel eine
Email abzuschicken.</para>

<para>Bei gebündelten Systemen für Commit Emails, werden Sie unter
Umständen, einige standardmäßige Verhalten Ändern wollen:</para>

<orderedlist>

  <listitem>
  <para>Manchmal beinhalten die Commit Emails nicht die tatsächlichen
	Diffs und geben anstatt dessen eine URL an, bei dem man die 
	Änderungen über das Web Portal der Repository einsehen kann.
	Obwohl es gut ist eine URL zu geben, auf die man später	
	verweisen kann, ist es auch <emphasis>sehr</emphasis> wichtig,
	dass die Diffs selber auch mit in den Emails enthalten sind.
	Emails zu lesen, gehört schon zum Alltag der Leute, wenn also
	die Änderungen gleich in der Email zu lesen sind, werden
	Entwickler sie gleich auf der Stelle untersuchen, ohne ihre
	Email Software verlassen zu müssen. Wenn sie erst auf eine URL
	klicken müssen, werden es die Meisten bleiben lassen, da es
	eine weitere Aktion erfordert anstatt einer Fortsetzung von
	dem was sie bereits angefangen hatten. Desweiteren, wenn der
	Entwickler etwas über die Änderung fragen will, geht es viel
	schneller auf die Email zu antworten, und eine Bemerkung an
	entsprechender Stelle zu schreiben, als eine Webseite zu
	besuchen und mühselig den Diff aus dem Web browser heraus
	in das Email Programm zu kopieren.</para>

  <para>(Wenn der Diff natürlich riesig ist, wie zum Beispiel wenn eine
	große Menge von neuem Code dem Repository hinzugefügt wurde,
	macht es natürlich Sinn den Diff weg zu lassen und nur die URL
	anzubieten. Die meisten Systeme für Commit Emails können diese
	Art der Limitierung automatisch. Wenn Ihres es nicht kann, ist
	es immer noch besser, die Diffs mitzuschicken und mit 
	gelegentlich riesigen Emails zu leben, als die Diffs komplett 
	aus zu schalten. Bequeme Möglichkeiten zur Überprüfung und
	Bewertung sind ein Eckstein der gemeinschaftlichen Entwicklung,
	und deshalb unerlässlich.)</para>
  </listitem>

  <listitem><para>Der Reply-to Header der Commit Emails sollte an den
	Email Verteiler für Entwickler gehen, nicht an den Commit
	Verteiler. Wenn also jemand sich eine Commit Email durchgelesen
	und bewertet hat, und daraufhin eine Antwort schreibt, sollte
	die Antwort an den Entwickler Verteiler für Menschen gehen, wo
	technische Angelegenheiten normalerweise diskutiert werden. Es
	gibt hierfür ein paar Gründe. Erstens, wollen Sie alle 
	technischen Diskussionen auf einen Verteiler behalten, Leute
	erwarten nämlich, dass sie dort gehalten werden und so auch nur
	ein Archiv durchsucht werden muss. Zweitens, wird der Commit
	Verteiler als Dienst beworben um Commits zu verfolgen, und
	nicht um Commits zu verfolgen <emphasis>und</emphasis>
	gelegentlich auch technische Diskussionen. Diejenigen die sich
	auf den Commit Verteiler angemeldet haben, wollen nichts 
	anderes als Commit Emails; wenn ihnen also anderes Material
	mittels diesem Verteiler zugesandt wird, brich das ein 
	unausgesprochenes Übereinkommen. Viertens, schreiben Beteiligte
	oft Programme, welche die Commit Emails lesen und verarbeiten
	(um sie zum Beispiel auf einer Webseite anzuzeigen). Diese
	Programme sind auf konsistent formatierte Commit Emails
	ausgelegt, nicht jedoch auf inkonsistente von Menschen 
	geschriebene Emails.</para>

  <para>Bemerke, dass dieser Ratschlag, Reply-to unzuschreiben nicht
	den Empfehlungen aus <xref linkend="reply-to"/>
	<phrase output="printed"> in einem Früheren Abschnitt dieses
	Kapitels</phrase> widerspricht. Es ist immer in Ordnung, wenn
	der <emphasis>Absender</emphasis> einer Nachricht Reply-to
	setzt. In diesem Fall, ist der Absender das 
	Versionsverwaltungssystem selbst, und es setzt Reply-to um
	anzudeuten, dass der angemessene Ort für Antworten der
	Entwickler Verteiler ist, und nicht der Commit Verteiler.</para>

  </listitem>

</orderedlist>

<sidebar id="cia">
<title>CIA: Eine andere Möglichkeit Änderungen bekannt zu machen</title>

<para>Commit Emails sind nicht die einzige Möglichkeit um Nachrichten
über Änderungen zu verbreiten. Neulich wurde eine weiter Möglichkeit
namens CIA (<ulink url="http://cia.navi.cx/"/>) entwickelt. CIA
fasst Commit Statistiken zusammen und Verbreitet sie in Echtzeit. 
Die verbreitetste Art CIA zu benutzen ist, Commit Benachrichtigungen
an IRC zu senden, damit Leute die sich in IRC angemeldet haben, in
Echtzeit mitbekommen, wann Änderungen Committed werden. Obwohl sie
nicht ganz so nützlich ist wie Commit Emails, da Beteiligte vielleicht
oder vielleicht auch nicht anwesend sein könnten wenn eine Commit
Nachricht auftaucht, ist diese Methode von immensem <emphasis>sozialen
</emphasis> nutzen. Leute bekommen das Gefühl ein Teil von etwas 
lebendig und aktivem zu sein, und dass der Fortschritt vor ihren
Augen geschieht.</para>

<para>Es funktioniert so, dass Sie die CIA Anwendung vom post-commit
hook aus aufrufen. Es formatiert die Commit Information in eine XML
Nachricht, und sendet es an einen zentralen Server (typischer weise 
<literal>cia.navi.cx</literal>). Der Commit Server verteilt diese
Information dann an andere Foren.</para>

<para>CIA kann auch konfiguriert werden um <ulink
url="http://www.xml.com/pub/a/2002/12/18/dive-into-xml.html">RSS</ulink>
feeds herauszugeben. Für weitere Details, schlagen Sie die Dokumentation
bei <ulink url="http://cia.navi.cx/"/> nach.</para>

<para>Sie können von CIA ein Bild machen, indem Sie mit Ihrem IRC
Client <literal>#commits</literal> auf dem Server <literal>
irc.freenode.net</literal> beitreten.</para>

</sidebar>

</sect3>

<sect3 id="branches">
<title>Um Engpässe zu vermeiden, benutzen Sie Branching</title>

<para>Manche die nicht Experten in Versionsverwaltung sind, scheuen
sich vor Branching und Merging. Das ist wahrscheinlich ein
Nebeneffekt vom Erfolg von CVS: Die Schnittstellen von CVS um 
Branches und Merges zu machen sind nicht ganz eingängig, weshalb
viele sich angeeignet haben diese Operationen komplett zu vermeiden.
</para>

<para>Wenn Sie zu diesen Leuten zählen, nehmen sich sich vor alle
Ängste die Sie vielleicht haben zu besiegen und nehmen Sie sich die
Zeit um zu lernen, wie man Branches und Merges macht. Es sind keine
schwierigen Vorgänge wenn man sich erst einmal an sie gewöhnt hat,
und sie werden zunehmend wichtiger, sobald ein Projekt mehr
Entwickler aufnimmt.</para>

<para>Branches sind wichtig, da sie eine knappe Resource&mdash;der
Arbeitsraum in dem Code von einem Projekt&mdash; zu einer im
Überfluss vorhandenen macht. Normalerweise, arbeiten alle
Entwickler im gleichen Sandkasten und bauen an der gleichen Burg.
Wenn jemand eine neue Zugbrücke anbauen will, nicht aber jeden davon
überzeugen kann, dass es eine Verbesserung wäre, ermöglicht ein
Branch es ihr in einer isolierten Ecke zu gehen und es aus zu
probieren. Wenn es funktioniert, kann sie die anderen Entwickler
dazu einladen, sich das Ergebnis anzuschauen. Wenn jeder zustimmt,
dass das Ergebnis gut ist, können sie das Versionsverwaltungssystem
anweisen die Zugbrücke vom Branch in die Haupt Burg zu übernehmen
("mergen").</para>

<para>Es ist einfach zu sehen, wie diese Fähigkeit die 
gemeinschaftliche Entwicklung fördert. Menschen brauchen die
Freiheit neue Sachen auszuprobieren, ohne das Gefühl zu bekommen die
Arbeit anderer zu stören. Gleichermaßen wichtig, gibt es Zeiten,
wann Code von der Alltäglichen Entwicklung isoliert werden muss, um
einen Bug zu beheben oder eine neue Version stabil zu bekommen
(siehe <xref linkend="stabilizing-a-release"/> und <xref 
linkend="release-lines"/><phrase output="printed"> im Kapitel
<xref linkend="development-cycle"/></phrase>) ohne sich über ein
bewegliches Ziel Gedanken zu machen.</para>

<para>Benutzen Sie Branches freizügig, und ermutigen Sie andere dazu
sie zu benutzen. Stellen Sie aber auch sicher das jeder Branch nur so
lange in Aktiv bleibt wie nötig. Jeder aktive Branch zieht ein klein
Wenig Aufmerksamkeit der Gemeinschaft ab. Selbst diejenigen die nicht
an einem Branch arbeiten, halten immer noch einen oberflächlichen 
Überblick über die Ereignisse darin. Diese Aufmerksamkeit ist natürlich
wünschenswert, und Commit Emails sollten auch für Branches versandt
werden, genau wie für jeden anderen Commit. Branches sollten jedoch
nicht zu einer Methode werden die Entwickler Gemeinschaft zu spalten.
Mit seltenen Ausnahmen, sollte es das Ziel von jedem Branch sein,
letztendlich wieder zurück in die Haupt Line zu gehen und danach zu
verschwinden.</para>

</sect3>

<sect3 id="vc-singularity">
<title>Einzigartigkeit von Information</title>

<para>Merges haben eine wichtige Begleitfolge: Die selbe Änderung
sollte niemals doppelt committed werden. Das heißt, das jede Änderung
das Versionsverwaltungssystem nur genau ein mal in die Repository
eingehen sollte. Die Revision (oder der Satz an Revisionen) in dem
die Änderung eingepflegt wurde, ist von da an seine einzigartige 
Kennung. Wenn es auf andere Branches als den bei dem es eingegangen
ist, angewandt werden muss, sollte es von der ursprünglichen Revision
aus in diese anderen Ziele gemerged werden&mdash;im Gegensatz dazu
sollte man nicht identische aber separate Änderungen committen, die
zwar den gleichen Effekt auf den Code haben würden aber eine genaue
Buchführung unmöglich machen würden.</para>

<para>Die praktischen Auswirkungen von dieser Empfehlung unterscheiden
sich von einem Versionsverwaltungssystem zum anderen. Manche Systeme
erfassen Merges als besondere Ereignisse, grundsätzlich unterschiedlich 
zu einem Commit, und tragen ihre eigene Metadaten bei sich. Bei 
anderen, werden die Ergebnisse von Merges genau so committed wie jede
andere Änderung, also ist die bevorzugte Art einen "merge commit" von
einem "Änderungscommit" zu Unterscheiden die Log Nachricht. In der Log
Nachricht von einem Merge sollte nicht die Nachricht der Ursprünglichen
Änderung wiederholt werden. Statt dessen, sollten Sie lediglich 
angeben, das es sich um einen Merge handelt, und die Revisionsnummer
der Ursprünglichen Änderung angeben und höchstens einen Satz um die
Auswirkungen der Änderung zusammen zu fassen. Wenn jemand die
komplette Log Nachricht sehen will, sollte sie die ursprünglich
Revision nachschlagen.</para>

<para>Der Grund warum es wichtig ist, es zu vermeiden, die Log
Nachrichten zu wiederholen ist, dass Log Nachrichten manchmal geändert
werden, nachdem sie committed wurden. Wenn die Log Nachricht einer
Änderung bei jedem Merge wiederholt würde, wären selbst wenn die
Ursprüngliche Nachricht korrigiert würde alle Kopien unverändert&mdash; 
wodurch im nachhinein nur Verwirrung entsteht.</para>

<para>Dasselbe Prinzip gilt bei Zurückdrehen einer Änderung. Wenn eine
Änderung wieder vom Code entfernt wird, sollte die Log Nachricht der
Revision, lediglich festhalten, dass eine Änderung einer bestimmten
Revision rückgängig gemacht wird und <emphasis>nicht</emphasis> eine
Beschreibung der tatsächlichen Änderungen am Code, da die Änderungen
aus der ursprünglichen Log Nachricht gelesen werden und geändert werden
können. Selbstverständlich, sollte der Log auch den Grund für die
Entfernung nennen, sollte aber nichts aus dem ursprünglichen Log
wiederholen. Wenn möglich, gehen Sie zurück und Ändern Sie den Log
der ursprünglichen Änderung und weisen Sie darauf hin, das es 
zurückgedreht wurde.</para>

<para>Die vorhergehenden Passagen implizieren, dass Sie eine konsistent
und gleichbleibende Syntax verwenden um sich auf Revisionen zu 
beziehen. Das ist nicht nur hilfreich in den Logs sondern auch in 
Emails, dem Bug Tracker und anderswo. Wenn Sie CVS verwenden, schlage
ich "<literal>path/to/file/in/project/tree:REV</literal>" vor,
wobei REV eine CVS Revisionsnummer wie "1.76" angibt. Wenn Sie
Subversion verwenden, ist die standard syntax für die Revision 1729
"r1729" (Datei Pfade werden bei Subversion nicht benötigt, da es 
globale Revisionsnummern verwendet). Bei anderen Systemen, gibt es für 
gewöhnlich eine standardmäßige Syntax um einen Satz von Änderungen zu
bezeichnen. Konsistente Bezeichnung von Änderungen erleichtert die 
Buchhaltung eines Projekts ungemein (was wir in <xref 
linkend="communications"/> und <xref linkend="development-cycle"/>) 
sehen werden, und da ein großer Teil der Buchhaltung von Freiwilligen
erledigt wird, muss es so einfach wie Möglich sein.</para>

<para>Siehe auch
<xref
linkend="releases-and-daily-development"/><phrase
output="printed"> im Kapitel
<xref linkend="development-cycle"/></phrase>.</para>

</sect3>

<sect3 id="vc-authz">
<title>Authorization</title>

<para>Die meisten Versionsverwaltungssysteme bieten eine Funktion an,
wonach bestimmten Personen erlaubt oder verboten werden kann Commits
an bestimmte Bereiche einer Repository zu machen. Nach dem Prinzip,
wenn man den Leuten einen Hammer reicht, sie anfangen überall Nägel zu
sehen, wird diese Funktion von vielen Projekten Hemmungslos benutzt.
Sie erlaben vorsichtig Beteiligte lediglich dorthin zu committen, wo
vorher zugestimmt wurde und es wird sichergestellt, das sie sonst
nirgends committen können. (Siehe 
<xref linkend="committers"/><phrase output="printed"> im Kapitel
<xref linkend="managing-volunteers"/></phrase> welches beschreibt,
wie Projekte entscheiden wer wohin comitten kann.)</para>

<para>Es ist wahrscheinlich nicht all zu schädlich solch eine enge
Einschränkung auszuüben, eine lockere Haltung ist aber auch in Ordnung.
Manche Projekte benutzen einfach einen System basierend auf Ehre: Wenn
einer Person commit Zugriff gewährt wird, wenn auch nur für einen
Teilbereich der Repository, ist was sie tatsächlich erhalten, ein
Schlüssel um überall im Projekt zu committen. Sie werden einfach darum
gebeten, ihre Commits auf ihren Bereich zu beschränken. Bedenken Sie,
dass hierin keine echte Gefahr droht: in einem aktiven Projekt, werden
sowieso alle commits überprüft. Wenn jemand in einem Bereich committed,
welches er nicht soll, werden es andere bemerken, und etwas sagen. Wenn
eine Änderung rückgängig gemacht werden muss, ist das auch kein Problem 
&mdash;es ist eh alles unter Versionsverwaltung, also kann man einfach
einen Revert machen.</para>

<para>Es gibt mehrere Vorteile bei der lockeren Herangehensweise.
Erstens, gibt es einen weiteren Aufwand um Entwickler zusätzliche 
Rechte einzuräumen, sobald sie sich auf andere Bereich ausweiten
(was im für gewöhnlich der Fall ist, wenn sie beim Projekt bleiben).
Sobald die Entscheidung getroffen wurde, kann die Person gleich 
anfangen Änderungen im neuen Bereich zu commiten.</para>

<para>Zweitens, kann die Erweiterung viel feiner granuliert 
vorgenommen werden. Allgemein wird ein Committer im Bereich X der sich
auf dem Bereich Y ausweiten will, anfangen Patches für Y einzureichen, 
und darum bitten, dass sie überprüft werden. Wenn jemand der bereits
Zugriff auf dem Bereich Y hat, solch einen Patch sieht und ihm
zustimmt, können sie dem Author einfach sagen, dass sie die Änderung
gleich selber commiten können(natürlich mit Namen vom Überprüfenden
bzw Zustimmenden im Log). Auf diese Art, kommt der Commit von 
demjenigen, der es auch geschrieben hat, was sowohl aus Sicht der 
Informationsverwaltung als auch aus Sicht der Anerkennung vorzuziehen
ist.</para>

<para>Zuletzt und vielleicht am wichtigsten, regt ein System welches
auf Ehre basiert, eine Atmosphäre der Ehre und des gegenseitigen 
Respekts an. Jemandem Commit zugriff auf ein Teilgebiet zu geben ist 
eine Aussage darüber wie gut sie technisch vorbereitet sind&mdash; es
sagt: "Wir sehen, dass du die Kenntnisse hast, um auf einem Gebiet
Commits zu machen, also leg los". Strickte Authorization auf zu erlegen
sagt aber: "Wir behaupten nicht nur, dass deine Kenntnisse begrenzt 
sind, wird sind auch ein wenig verdächtig im Bezug auf deine <emphasis>
Absichten</emphasis>". Das ist nicht eine Behauptung die sie machen
wollen, wenn Sie es vermeiden können. Jemand an dem Projekt als
Committer zu beteiligen, ist eine Gelegenheit sie in einem Kreis
gegenseitigem Vertrauens mit aufzunehmen. Eine gute Methode dieses zu
erreichen ist, ihnen mehr Macht zu geben als sie benutzen sollen, und
sie darüber zu informieren, dass es an ihnen ist sich innerhalb der
genannten Grenzen zu halten.</para>

<para>Das Subversion Projekt arbeitet schon seit vier Jahren, nach
dem Ehren Prinzip, mit 33 voll und 43 teil berechtigten committer
zur Zeit dieses schreibens. Die einzige Unterscheidung die das
System macht, ist zwischen Commiter und nicht Commiter; weitere
Unterteilungen werden alleine durch Menschen aufrechterhalten. Dennoch
hatten wir nie ein Problem damit, dass jemand außerhalb von seinem
Bereich committed hat. Es gab ein zwei mal Missverständnisse über das
Ausmaß der Commit Berechtigungen, was jedoch immer schnell und
freundlich aufgelöst wurde.</para>

<para>Obviously, in situations where self-policing is impractical, you
must rely on hard authorization controls.  But such situations are
rare.  Even when there are millions of lines of code and hundreds or
thousands of developers, a commit to any given code module should
still be reviewed by those who work on that module, and they can
recognize if someone committed there who wasn't supposed to.  If
regular commit review <emphasis>isn't</emphasis> happening, then the
project has bigger problems to deal with than the authorization system
anyway.</para>

<para>In summary, don't spend too much time fiddling with the version
control authorization system, unless you have a specific reason to.  It
usually won't bring much tangible benefit, and there are advantages to
relying on human controls instead.</para>

<para>None of this should be taken to mean that the restrictions
themselves are unimportant, of course.  It would be bad for a project
to encourage people to commit in areas where they're not qualified.
Furthermore, in many projects, full (unrestricted) commit access has a
special status: it implies voting rights on project-wide questions.
This political aspect of commit access is discussed more in <xref
linkend="electorate"/><phrase output="printed"> in
<xref linkend="social-infrastructure"/></phrase>.</para>

</sect3>

</sect2>

</sect1>


<!-- ========================== SECTION =========================== -->
<sect1 id="bug-tracker">
<title>Bug Tracker</title>

<para>Bug tracking is a broad topic; various aspects of it are
discussed throughout this book.  Here I'll try to concentrate mainly
on setup and technical considerations, but to get to those, we have to
start with a policy question: exactly what kind of information should
be kept in a bug tracker?</para>

<para>The term <firstterm>bug tracker</firstterm> is misleading.  Bug
tracking systems are also frequently used to track new feature
requests, one-time tasks, unsolicited patches&mdash;really anything
that has distinct beginning and end states, with optional transition
states in between, and that accrues information over its lifetime.
For this reason, bug trackers are also called <firstterm>issue
trackers</firstterm>, <firstterm>defect trackers</firstterm>,
<firstterm>artifact trackers</firstterm>, <firstterm>request
trackers</firstterm>, <firstterm>trouble ticket systems</firstterm>,
etc.  See <xref linkend="bug-trackers"/> for a list of software.
</para>

<para>In this book, I'll continue to use "bug tracker" for the
software that does the tracking, because that's what most people call
it, but will use <firstterm>issue</firstterm> to refer to a single
item in the bug tracker's database.  This allows us to distinguish
between the behavior or misbehavior that the user encountered (that is,
the bug itself), and the tracker's <emphasis>record</emphasis> of the
bug's discovery, diagnosis, and eventual resolution.  Keep in mind
that although most issues are about actual bugs, issues can be used to
track other kinds of tasks too.</para>

<para>The classic issue life cycle looks like this:

<orderedlist>
  <listitem><para>Someone files the issue.  They provide a summary, an
            initial description (including a reproduction recipe, if
            applicable; see
            <xref
            linkend="users-to-volunteers"/><phrase
            output="printed"> in
            <xref linkend="managing-volunteers"/></phrase> for
            how to encourage good bug reports), and whatever other
            information the tracker asks for.  The person who files
            the issue may be totally unknown to the project&mdash;bug
            reports and feature requests are as likely to come from
            the user community as from the developers.</para>

            <para>Once filed, the issue is in what's called an
            <firstterm>open</firstterm> state.  Because no action has
            been taken yet, some trackers also label it as
            <firstterm>unverified</firstterm> and/or
            <firstterm>unstarted</firstterm>.  It is not assigned to
            anyone; or, in some systems, it is assigned to a fake
            user to represent the lack of real assignation.  At this
            point, it is in a holding area: the issue has been
            recorded, but not yet integrated into the project's
            consciousness.</para>
  </listitem>
  <listitem><para>Others read the issue, add comments to it, and
            perhaps ask the original filer for clarification on some
            points.</para>
  </listitem>
  <listitem><para>The bug gets <firstterm>reproduced</firstterm>.
            This may be the most important moment in its
            life cycle.  Although the bug is not actually fixed yet,
            the fact that someone besides the original filer was able
            to make it happen proves that it is genuine, and, no less
            importantly, confirms to the original filer that they've
            contributed to the project by reporting a real bug.</para>
  </listitem>
  <listitem><para>The bug gets <firstterm>diagnosed</firstterm>: its
            cause is identified, and if possible, the effort required
            to fix it is estimated.  Make sure these things get
            recorded in the issue; if the person who diagnosed the
            bug suddenly has to step away from the project for a
            while (as can often happen with volunteer developers),
            someone else should be able to pick up where she left
            off.</para>

            <para>In this stage, or sometimes the previous one, a
            developer may "take ownership" of the issue and
            <firstterm>assign</firstterm> it to herself (<xref
            linkend="delegation-assignment"/><phrase
            output="printed"> in
            <xref linkend="managing-volunteers"/></phrase>
            examines the assignment process in more detail).  The issue's
            <firstterm>priority</firstterm> may also be set at this
            stage.  For example, if it is so severe that it should
            delay the next release, that fact needs to be identified
            early, and the tracker should have some way of noting
            it.</para>
  </listitem>
  <listitem><para>The issue gets scheduled for resolution.
            Scheduling doesn't necessarily mean naming a date by which
            it will be fixed.  Sometimes it just means deciding which
            future release (not necessarily the next one) the bug
            should be fixed by, or deciding that it need not block any
            particular release.  Scheduling may also be dispensed
            with, if the bug is quick to fix.</para>
  </listitem>
  <listitem><para>The bug gets fixed (or the task completed, or
            the patch applied, or whatever).  The change or set of
            changes that fixed it should be recorded in a comment in
            the issue, after which the issue is
            <firstterm>closed</firstterm> and/or marked as
            <firstterm>resolved</firstterm>.</para>
  </listitem>
</orderedlist>

</para>

<para>There are some common variations on this life cycle.  Sometimes
an issue is closed very soon after being filed, because it turns out
not to be a bug at all, but rather a misunderstanding on the part of
the user.  As a project acquires more users, more and more such
invalid issues will come in, and developers will close them with
increasingly short-tempered responses.  Try to guard against the
latter tendency.  It does no one any good, as the individual user in
each case is not responsible for all the previous invalid issues; the
statistical trend is visible only from the developers' point of view,
not the user's.  (In
<xref linkend="bug-filtering"/><phrase output="printed"> later
in this chapter,</phrase> we'll look at
techniques for reducing the number of invalid issues.)  Also, if
different users are experiencing the same misunderstanding over and
over, it might mean that that aspect of the software needs to be
redesigned.  This sort of pattern is easiest to notice when there is
an issue manager monitoring the bug database; see
<xref linkend="issue-manager"/><phrase output="printed"> in
<xref linkend="managing-volunteers"/></phrase>.</para>

<para>Another common life cycle variation is for the issue to be closed
as a <firstterm>duplicate</firstterm> soon after Step 1.  A duplicate
is when someone files an issue that's already known to the project.
Duplicates are not confined to open issues: it's possible for a bug to
come back after having been fixed (this is known as a
<firstterm>regression</firstterm>), in which case the preferred course
is usually to reopen the original issue and close any new reports as
duplicates of the original one.  The bug tracking system should keep
track of this relationship bidirectionally, so that reproduction
information in the duplicates is available to the original issue, and
vice versa.</para>

<para>A third variation is for the developers to close the issue,
thinking they have fixed it, only to have the original reporter reject
the fix and reopen it.  This is usually because the developers simply
don't have access to the environment necessary to reproduce the bug,
or because they didn't test the fix using the exact same reproduction
recipe as the reporter.</para>

<para>Aside from these variations, there may be other small details of
the life cycle that vary depending on the tracking software.  But the
basic shape is the same, and while the life cycle itself is not
specific to open source software, it has implications for how open
source projects use their bug trackers.</para>

<para>As Step 1 implies, the tracker is as much a public face of the
project as the mailing lists or web pages.  Anyone may file an issue,
anyone may look at an issue, and anyone may browse the list of currently
open issues.  It follows that you never know how many people are
waiting to see progress on a given issue.  While the size and skill of
the development community constrains the rate at which issues can be
resolved, the project should at least try to acknowledge each issue the
moment it appears.  Even if the issue lingers for a while, a response
encourages the reporter to stay involved, because she feels that a
human has registered what she has done (remember that filing an
issue usually involves more effort than, say, posting an email).
Furthermore, once an issue is seen by a developer, it enters the
project's consciousness, in the sense that that developer can be on
the lookout for other instances of the issue, can talk about it with
other developers, etc.</para>

<para>The need for timely reactions implies two things:

<itemizedlist>
  <listitem>
    <para>The tracker must be connected to a mailing list, such that
    every change to an issue, including its initial filing, causes a
    mail to go out describing what happened.  This mailing list
    is usually different from the regular development list, since not
    all developers may want to receive automated bug mails, but (just
    as with commit mails) the Reply-to header should be set to the
    development mailing list.</para>
  </listitem>
  <listitem>
    <para>The form for filing issues should capture the reporter's
    email address, so she can be contacted for more information.
    (However, it should not <emphasis>require</emphasis> the
    reporter's email address, as some people prefer to report issues
    anonymously.  See
    <xref linkend="anonymity"/><phrase output="printed"> later
    in this chapter</phrase> for more on the importance of
    anonymity.)</para>
  </listitem>
</itemizedlist>

</para>

<sect2 id="bug-tracker-mailing-list-interaction">
<title>Interaction with Mailing Lists</title>

<para>Make sure the bug tracker doesn't turn into a discussion forum.
Although it is important to maintain a human presence in the bug
tracker, it is not fundamentally suited to real-time discussion.
Think of it rather as an archiver, a way to organize facts and
references to other discussions, primarily those that take place on
mailing lists.</para>

<para>There are two reasons to make this distinction.  First, the bug
tracker is more cumbersome to use than the mailing lists (or than
real-time chat forums, for that matter).  This is not because bug
trackers have bad user interface design, it's just that their
interfaces were designed for capturing and presenting discrete states,
not free-flowing discussions.  Second, not everyone who should be
involved in discussing a given issue is necessarily watching the bug
tracker.  Part of good issue management (see
<xref linkend="share-management"/><phrase output="printed"> in
<xref linkend="managing-volunteers"/></phrase>) is to make sure
each issue is brought to the right peoples' attention, rather than
requiring every developer to monitor all issues.  In
<xref linkend="bug-tracker-usage"/><phrase output="printed"> in <xref linkend="communications"/>,</phrase> we'll look at ways to make
sure people don't accidentally siphon discussions out of appropriate
forums and into the bug tracker.</para>

<para>Some bug trackers can monitor mailing lists and automatically
log all emails that are about a known issue.  Typically they do this
by recognizing the issue's identifying number in the subject line of
the mail, as part of a special string; developers learn to include
these strings in their mails to attract the tracker's notice.  The bug
tracker may either save the entire email, or (even better) just record
a link to the mail in the regular mailing list archive.  Either way,
this is a very useful feature; if your tracker has it, make sure
both to turn it on and to remind people to take advantage of
it.</para>

</sect2>

<sect2 id="bug-filtering">
<title>Pre-Filtering the Bug Tracker</title>

<para>Most issue databases eventually suffer from the same problem: a
crushing load of duplicate or invalid issues filed by well-meaning but
inexperienced or ill-informed users.  The first step in combatting
this trend is usually to put a prominent notice on the front page of
the bug tracker, explaining how to tell if a bug is really a bug, how
to search to see if it's already been filed, and finally, how to
effectively report it if one still thinks it's a new bug.</para>

<para>This will reduce the noise level for a while, but as the number
of users increases, the problem will eventually come back.  No
individual user can be blamed for it.  Each one is just trying to
contribute to the project's well-being, and even if their first bug
report isn't helpful, you still want to encourage them to stay
involved and file better issues in the future.  In the meantime,
though, the project needs to keep the issue database as free of junk
as possible.</para>

<para>The two things that will do the most to prevent this problem
are: making sure there are people watching the bug tracker who have
enough knowledge to close issues as invalid or duplicates the moment
they come in, and requiring (or strongly encouraging) users to confirm
their bugs with other people before filing them in the tracker.</para>

<para>The first technique seems to be used universally.  Even projects
with huge issue databases (say, the Debian bug tracker at
<ulink url="http://bugs.debian.org/"/>, which contained 315,929 issues
as of this writing) still arrange things so that
<emphasis>someone</emphasis> sees each issue that comes in.  It may be
a different person depending on the category of the issue.  For
example, the Debian project is a collection of software packages, so
Debian automatically routes each issue to the appropriate package
maintainers.  Of course, users can sometimes misidentify an issue's
category, with the result that the issue is sent to the wrong person
initially, who may then have to reroute it.  However, the important
thing is that the burden is still shared&mdash;whether the user
guesses right or wrong when filing, issue watching is still
distributed more or less evenly among the developers, so each issue is
able to receive a timely response.</para>

<para>The second technique is less widespread, probably because it's
harder to automate.  The essential idea is that every new issue gets
"buddied" into the database.  When a user thinks he's found a problem,
he is asked to describe it on one of the mailing lists, or in an IRC
channel, and get confirmation from someone that it is indeed a bug.
Bringing in that second pair of eyes early can prevent a lot of
spurious reports.  Sometimes the second party is able to identify that
the behavior is not a bug, or is fixed in recent releases.  Or she may
be familiar with the symptoms from a previous issue, and can prevent a
duplicate filing by pointing the user to the older issue.  Often it's
enough just to ask the user "Did you search the bug tracker to see if
it's already been reported?"  Many people simply don't think of that,
yet are happy to do the search once they know someone's
<emphasis>expecting</emphasis> them to.</para>

<para>The buddy system can really keep the issue database clean, but
it has some disadvantages too.  Many people will file solo anyway,
either through not seeing, or through disregarding, the instructions
to find a buddy for new issues.  Thus it is still necessary for
volunteers to watch the issue database.  Furthermore, because most new
reporters don't understand how difficult the task of maintaining the
issue database is, it's not fair to chide them too harshly for
ignoring the guidelines.  Thus the volunteers must be vigilant, and
yet exercise restraint in how they bounce unbuddied issues back to
their reporters.  The goal is to train each reporter to use the
buddying system in the future, so that there is an ever-growing pool
of people who understand the issue-filtering system.  On seeing an
unbuddied issue, the ideal steps are:</para>

<orderedlist>
  <listitem>
    <para>Immediately respond to the issue, politely thanking the user
          for filing, but pointing them to the buddying guidelines
          (which should, of course, be prominently posted on the web
          site).</para>
  </listitem>
  <listitem>
    <para>If the issue is clearly valid and not a duplicate, approve it
          anyway, and start it down the normal life cycle.  After all,
          the reporter's now been informed about buddying, so there's
          no point wasting the work done so far by closing a valid
          issue.</para>
  </listitem>
  <listitem>
    <para>Otherwise, if the issue is not clearly valid, close it, but
          ask the reporter to reopen it if they get confirmation from
          a buddy.   When they do, they should put a reference to the
          confirmation thread (e.g., a URL into the mailing list
          archives).</para>
  </listitem>
</orderedlist>

<para>Remember that although this system will improve the signal/noise
ratio in the issue database over time, it will never completely stop
the misfilings.  The only way to prevent misfilings entirely is to
close off the bug tracker to everyone but developers&mdash;a cure that
is almost always worse than the disease.  It's better to accept that
cleaning out invalid issues will always be part of the project's
routine maintenance, and to try to get as many people as possible to
help.</para>

<para>See also
<xref linkend="issue-manager"/><phrase output="printed"> in
<xref linkend="managing-volunteers"/></phrase>.</para>

</sect2>

</sect1>

<!-- ========================== SECTION =========================== -->
<sect1 id="irc">
<title>IRC / Real-Time Chat Systems</title>

<para>Many projects offer real-time chat rooms using <firstterm>Internet
Relay Chat</firstterm> (<firstterm>IRC</firstterm>), forums where users
and developers can ask each other questions and get instant responses.
While you <emphasis>can</emphasis> run an IRC server from your own
web site, it is generally not worth the hassle.  Instead, do what
everyone else does: run your IRC channels at Freenode
(<ulink url="http://freenode.net/"/>).  Freenode gives you the control
you need to administer your project's IRC
channels,<footnote><para>There is no requirement or expectation that
you donate to Freenode, but if you or your project can afford it,
please consider a contribution.  They are a tax-exempt charity in the
U.S., and they perform a valuable service.</para></footnote> while
sparing you the not-insignificant trouble of maintaining an IRC server
yourself.</para>

<para>The first thing to do is choose a channel name.  The most
obvious choice is the name of your project&mdash;if that's available
at Freenode, then use it.  If not, try to choose something as close to
your project's name, and as easy to remember, as possible.  Advertise
the channel's availabity from your project's web site, so a visitor
with a quick question will see it right away.  For example, this
appears in a prominently placed box at the top of Subversion's home
page:</para>

  <blockquote>
    <para><emphasis>If you're using Subversion, we recommend that you
    join the</emphasis> <literal>users@subversion.tigris.org</literal>
    <emphasis>mailing list, and read the <ulink
    url="http://svnbook.red-bean.com/">Subversion Book</ulink> and
    <ulink
    url="http://subversion.tigris.org/faq.html">FAQ</ulink>.
    You can also ask questions on IRC at</emphasis>
    <literal>irc.freenode.net</literal>
    <emphasis>channel</emphasis>&nbsp;<literal>#svn</literal>.</para>
  </blockquote>

<para>Some projects have multiple channels, one per subtopic.  For
example, one channel for installation problems, another for usage
questions, another for development chat, etc. (<xref
linkend="growth"/><phrase output="printed"> in
<xref linkend="communications"/></phrase> discusses and how to
divide into multiple channels).  When your project is young, there
should only be one channel, with everyone talking together.  Later, as
the user-to-developer ratio increases, separate channels may become
necessary.</para>

<para>How will people know all the available channels, let alone which
channel to talk in?  And when they talk, how will they know what the
local conventions are?</para>

<para>The answer is to tell them by setting the <firstterm>channel
topic</firstterm>.<footnote><para>To set a channel topic, use the
<literal>/topic</literal> command.  All commands in IRC start with
"<literal>/</literal>".  See <ulink url="http://www.irchelp.org/"/> if
you're not familiar with IRC usage and administration; in particular,
<ulink url="http://www.irchelp.org/irchelp/irctutorial.html"/> is an
excellent tutorial.</para></footnote>  The channel topic is a brief
message each user sees when they first enter the channel.  It gives
quick guidance to newcomers, and pointers to further information.  For
example:</para>

<screen>
You are now talking on #svn

Topic for #svn is Forum for Subversion user questions, see also
http://subversion.tigris.org/. || Development discussion happens in
#svn-dev. || Please don't paste long transcripts here, instead use
a pastebin site like http://pastebin.ca/. || NEWS: Subversion 1.1.0
is released, see http://svn110.notlong.com/ for details.
</screen>

<para>That's terse, but it tells newcomers what they need to know.  It
says exactly what the channel is for, gives the project home page (in
case someone wanders into the channel without having first been to the
project web site), mentions a related channel, and gives some guidance
about pasting.</para>

<sidebar id="paste-sites">
<title>Paste Sites</title>

<para>An IRC channel is a shared space: everyone can see what everyone
else is saying.  Normally, this is a good thing, as it allows people
to jump into a conversation when they think they have something to
contribute, and allows spectators to learn by watching.  But it
becomes problematic when someone has to provide a large quantity of
information at once, such as a debugging session transcript, because
pasting too many lines of output into the channel will disrupt other
conversations.</para>

<para>The solution is to use one of the
<firstterm>pastebin</firstterm> or <firstterm>pastebot</firstterm>
sites.  When requesting a large amount of data from someone, ask them
not to paste it into the channel, but instead to go to (for example)
<ulink url="http://pastebin.ca/"/>, paste their data into the form
there, and tell the resulting new URL to the IRC channel.  Anyone can
then visit the URL and view the data.</para>

<para>There are a number of free paste sites available now, too many
for a comprehensive list, but here are some of the ones I've seen used:
<ulink url="http://www.nomorepasting.com/"/>,
<ulink url="http://pastebin.ca/"/>,
<ulink url="http://nopaste.php.cd/"/>
<ulink url="http://rafb.net/paste/"/>
<ulink url="http://sourcepost.sytes.net/"/>,
<ulink url="http://extraball.sunsite.dk/notepad.php"/>,
and
<ulink url="http://www.pastebin.com/"/>.</para>

</sidebar>

<sect2 id="bots">
<title>Bots</title>

<para>Many technically-oriented IRC channels have a non-human member,
a so-called <firstterm>bot</firstterm> that is capable of storing and
regurgitating information in response to specific commands.
Typically, the bot is addressed just like any other member of the
channel, that is, the commands are delivered by "speaking to" the bot.
For example:</para>

<screen>
&lt;kfogel&gt; ayita: learn diff-cmd = http://subversion.tigris.org/faq.html#diff-cmd
&lt;ayita&gt;  Thanks!
</screen>

<para>That told the bot (who is logged into the channel as ayita) to
remember a certain URL as the answer to the query "diff-cmd".  Now we
can address ayita, asking the bot to tell another user about
diff-cmd:</para>

<screen>
&lt;kfogel&gt; ayita: tell jrandom about diff-cmd
&lt;ayita&gt;  jrandom: http://subversion.tigris.org/faq.html#diff-cmd
</screen>

<para>The same thing can be accomplished via a convenient shorthand:</para>

<screen>
&lt;kfogel&gt; !a jrandom diff-cmd
&lt;ayita&gt;  jrandom: http://subversion.tigris.org/faq.html#diff-cmd
</screen>

<para>The exact command set and behaviors differ from bot to bot.  The
above example is with <literal>ayita</literal>
(<ulink url="http://hix.nu/svn-public/alexis/trunk/"/>), of which
there is usually an instance running in <literal>#svn</literal> at
freenode.  Other bots include Dancer
(<ulink url="http://dancer.sourceforge.net/"/>) and Supybot
(<ulink url="http://supybot.com/"/>).  Note that no special server
privileges are required to run a bot.  A bot is a client program;
anyone can set one up and direct it to listen to a particular
server/channel.</para>

<para>If your channel tends to get the same questions over and over,
I highly recommend setting up a bot.  Only a small percentage of
channel users will acquire the expertise needed to manipulate the bot,
but those users will answer a disproportionately high percentage of
questions, because the bot enables them to respond so much more
efficiently.</para>

</sect2>

<sect2 id="irc-archiving">
<title>Archiving IRC</title>

<para>Although it is possible to archive everything that happens in an
IRC channel, it's not necessarily expected.  IRC conversations may be
nominally public, but many people think of them as informal,
semi-private conversations.  Users may be careless with grammar, and
often express opinions (for example, about other software or other
programmers) that they wouldn't want preserved forever in an online
archive.</para>

<para>Of course, there will sometimes be <emphasis>excerpts</emphasis>
that should be preserved, and that's fine.  Most IRC clients can log a
conversation to a file at the user's request, or failing that, one can
always just cut and paste the conversation from IRC into a more
permanent forum (most often the bug tracker).  But indiscriminate
logging may make some users uneasy.  If you do archive everything,
make sure you state so clearly in the channel topic, and give a URL to
the archive.</para>

</sect2>

</sect1>

<!-- ========================== SECTION =========================== -->
<sect1 id="wikis">
<title>Wikis</title>

<para>A <firstterm>wiki</firstterm> is a web site that allows any
visitor to edit or extend its content; the term "wiki" (from a
Hawaiian word meaning "quick" or "super-fast") is also used to refer
to the software that enables such editing.  Wikis were invented in
1995, but their popularity has really started to take off since 2000
or 2001, boosted partly by the success of Wikipedia (<ulink
url="http://www.wikipedia.org/"/>), a wiki-based free-content
encyclopedia.  Think of a wiki as falling somewhere between IRC and
web pages: wikis don't happen in realtime, so people get a chance to
ponder and polish their contributions, but they are also very easy to
add to, involving less interface overhead than editing a regular web
page.</para>

<para>Wikis are not yet standard equipment for open source projects,
but they probably will be soon.  As they are relatively new
technology, and people are still experimenting with different ways of
using them, I will just offer a few words of caution here&mdash;at
this stage, it's easier to analyze misuses of wikis than to analyze
their successes.</para>

<para>If you decide to run a wiki, put a lot of effort into having a
clear page organization and pleasing visual layout, so that visitors
(i.e., potential editors) will instinctively know how to fit in their
contributions.  Equally important, post those standards on the wiki
itself, so people have somewhere to go for guidance.  Too often, wiki
administrators fall victim to the fantasy that because hordes of
visitors are individually adding high quality content to the site,
the sum of all these contributions must therefore also be of high
quality.  That's not how web sites work.  Each individual page or
paragraph may be good when considered by itself, but it will not be
good if embedded in a disorganized or confusing whole.  Too often,
wikis suffer from:</para>

<itemizedlist>
  <listitem>
     <para><emphasis role="bold">Lack of navigational principles.</emphasis>
     A well-organized web site makes visitors feel like they know
     where they are at any time.  For example, if the pages are
     well-designed, people can intuitively tell the difference
     between a "table of contents" region and a "content" region.
     Contributors to a wiki will respect such differences too, but
     only if the differences are present to begin with.</para>
  </listitem>
  <listitem>
     <para><emphasis role="bold">Duplication of information.</emphasis>
     Wikis frequently end up with different pages saying similar
     things, because the individual contributors did not notice the
     duplications.  This can be partly a consequence of the lack of
     navigational principles noted above, in that people may not find
     the duplicate content if it is not where they expect it to
     be.</para>
  </listitem>
  <listitem>
     <para><emphasis role="bold">Inconsistent target audience.</emphasis>
     To some degree this problem is inevitable when there are so many
     authors, but it can be lessened if there are written guidelines
     about how to create new content.  It also helps to aggressively
     edit new contributions at the beginning, as an example, so that
     the standards start to sink in.</para>
  </listitem>
</itemizedlist>

<para>The common solution to all these problems is the same: have
editorial standards, and demonstrate them not only by posting them,
but by editing pages to adhere to them.  In general, wikis will
amplify any failings in their original material, since contributors
imitate whatever patterns they see in front of them.  Don't just
set up the wiki and hope everything falls into place.  You must also
prime it with well-written content, so people have a template to
follow.</para>

<para>The shining example of a well-run wiki is Wikipedia, though this
may be partly 
because the content (encyclopedia entries) is naturally well-suited to
the wiki format.  But if you examine Wikipedia closely, you'll see
that its administrators laid a <emphasis>very</emphasis> thorough
foundation for cooperation.  There is extensive documentation on how
to write new entries, how to maintain an appropriate point of view,
what sorts of edits to make, what edits to avoid, a dispute resolution
process for contested edits (involving several stages, including
eventual arbitration), and so forth.  They also have authorization
controls, so that if a page is the target of repeated inappropriate
edits, they can lock it down until the problem is resolved.  In other
words, they didn't just throw some templates onto a web site and hope
for the best.  Wikipedia works because its founders thought carefully
about how to get thousands of strangers to tailor their writing to a
common vision.  While you may not need the same level of preparedness
to run a wiki for a free software project, the spirit is worth
emulating.</para>

<para>For more information about wikis, see
<ulink url="http://en.wikipedia.org/wiki/Wiki"/>.  Also, the first
wiki remains alive and well, and contains a lot of discussion about
running wikis: see <ulink
url="http://www.c2.com/cgi/wiki?WelcomeVisitors"/>, 
<ulink url="http://www.c2.com/cgi/wiki?WhyWikiWorks"/>, and
<ulink url="http://www.c2.com/cgi/wiki?WhyWikiWorksNot"/> for
various points of view.</para>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="web-site">
<title>Web Site</title>

<para>There is not much to say about setting up the project web site
from a technical point of view: setting up a web server and writing
web pages are fairly simple tasks, and most of the important things to
say about layout and arrangement were covered in the previous chapter.
The web site's main function is to present a clear and welcoming
overview of the project, and to bind together the other tools (the
version control system, bug tracker, etc.).  If you don't have the
expertise to set up a web server yourself, it's usually not hard to
find someone who does and is willing to help out.  Nonetheless, to
save time and effort, people often prefer to use one of the canned
hosting sites.</para>

<sect2 id="canned-hosting">
<title>Canned Hosting</title>

<para>There are two main advantages to using a canned site.  The first
is server capacity and bandwidth: their servers are beefy boxes sitting
on really fat pipes.  No matter how successful your project gets,
you're not going to run out of disk space or swamp the network
connection.  The second advantage is simplicity.  They have already
chosen a bug tracker, a version control system, a mailing list manager,
an archiver, and everything else you need to run a site.  They've
configured the tools, and are taking care of backups for all the data
stored in the tools.  You don't need to make many decisions.  All you
have to do is fill in a form, press a button, and suddenly you've got
a project web site.</para>

<para>These are pretty significant benefits.  The disadvantage, of
course, is that you must accept <emphasis>their</emphasis> choices and
configurations, even if something different would be better for your
project.  Usually canned sites are adjustable within certain narrow
parameters, but you will never get the fine-grained control you would
have if you set up the site yourself and had full administrative
access to the server.</para>

<para>A perfect example of this is the handling of generated files.
Certain project web pages may be generated files&mdash;for example,
there are systems for keeping FAQ data in an easy-to-edit master
format, from which HTML, PDF, and other presentation formats can be
generated.  As explained in
<xref linkend="version-everything"/><phrase output="printed">
earlier in this chapter</phrase>,
you wouldn't want to version the generated formats, only the master
file.  But when your web site is hosted on someone else's server, it
may be impossible to set up a custom hook to regenerate the online
HTML version of the FAQ whenever the master file is changed.  The only
workaround is to version the generated formats too, so that they show
up on the web site.</para>

<para>There can be larger consequences as well.  You may not have as
much control over presentation as you would wish.  Some of the canned
hosting sites allow you to customize your web pages, but the site's
default layout usually ends up showing through in various awkward
ways.  For example, some projects that host themselves at SourceForge
have completely customized home pages, but still point developers to
their "SourceForge page" for more information.  The SourceForge page
is what would be the project's home page, had the project not used a
custom home page.  The SourceForge page has links to the bug tracker,
the CVS repository, downloads, etc.  Unfortunately, a SourceForge page
also contains a great deal of extraneous noise.  The top is a banner
ad, often an animated image.  The left side is a vertical arrangement
of links of little relevance to someone interested in the project.
The right side is often another advertisement.  Only the center of the
page is devoted to truly project-specific material, and even that is
arranged in a confusing way that often makes visitors unsure of what
to click on next.</para>

<para>Behind every individual aspect of SourceForge's design, there is
no doubt a good reason&mdash;good from SourceForge's point of view,
such as the advertisements.  But from an individual project's point of
view, the result can be a less-than-ideal web page.  I don't mean to
pick on SourceForge; similar concerns apply to many of the canned
hosting sites.  The point is that there's a tradeoff.  You get relief
from the technical burdens of running a project site, but only at the
price of accepting someone else's way of running it.</para>

<para>Only you can decide whether canned hosting is best for your
project.  If you choose a canned site, leave open the option of
switching to your own servers later, by using a custom domain name for
the project's "home address".  You can forward the URL to the canned
site, or have a fully customized home page at the public URL and hand
users off to the canned site for sophisticated functionality.  Just
make sure to arrange things such that if you later decide to use a
different hosting solution, the project's address doesn't need to
change.</para>

<sect3 id="canned-hosting-choosing">
<title>Choosing a canned hosting site</title>

<para>The largest and most well-known hosting site is <ulink
url="http://www.sourceforge.net/">SourceForge</ulink>.  Two other
sites providing the same or similar services are <ulink
url="http://savannah.gnu.org/">savannah.gnu.org</ulink> and <ulink
url="http://www.berlios.de/">BerliOS.de</ulink>.  A few organizations,
such as the <ulink url="http://www.apache.org/">Apache Software
Foundation</ulink> and <ulink
url="http://www.tigris.org/">Tigris.org</ulink><footnote><para>Disclaimer:
I am employed by <ulink
url="http://www.collab.net/">CollabNet</ulink>, which sponsors
Tigris.org, and I use Tigris regularly.</para></footnote>, give free
hosting to open source projects that fit well with their missions and
their community of existing projects.</para>

<para>Haggen So did a thorough evaluation of various canned hosting
sites, as part of the research for his Ph.D. thesis,
<citetitle>Construction of an Evaluation Model for Free/Open Source
Project Hosting (FOSPHost) sites</citetitle>.  The results are at
<ulink url="http://www.ibiblio.org/fosphost/"/>, and see especially
the very readable comparison chart at <ulink
url="http://www.ibiblio.org/fosphost/exhost.htm"/>.</para>

</sect3>

<sect3 id="anonymity">
<title>Anonymity and involvement</title>

<para>A problem that is not strictly limited to the canned sites, but
is most often found there, is the abuse of user login functionality.
The functionality itself is simple enough: the site allows each
visitor to register herself with a username and password.  From
then on it keeps a profile for that user, and project administrators
can assign the user certain permissions, for example, the right to
commit to the repository.</para>

<para>This can be extremely useful, and in fact it's one of the prime
advantages of canned hosting.  The problem is that sometimes user
login ends up being required for tasks that ought to be permitted to
unregistered visitors, specifically the ability to file issues in the
bug tracker, and to comment on existing issues.  By requiring a
logged-in username for such actions, the project raises the
involvement bar for what should be quick, convenient tasks.  Of
course, one wants to be able to contact someone who's entered data
into the issue tracker, but having a field where she can enter her
email address (if she wants to) is sufficient.  If a new user spots a
bug and wants to report it, she'll only be annoyed at having to fill
out an account creation form before she can enter the bug into the
tracker.  She may simply decide not to file the bug at all.</para>

<para>The advantages of user management generally outweigh the
disadvantages.  But if you can choose which actions can be done
anonymously, make sure not only that <emphasis>all</emphasis>
read-only actions are permitted to non-logged-in visitors, but also
some data entry actions, especially in the bug tracker and, if you
have them, wiki pages.</para>

</sect3>

</sect2>

</sect1>


<!-- ======================== SECTION ============================== -->


</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->

