<chapter id="technical-infrastructure">

<title>技术基础设施</title>

<simplesect>

<para>自由软件项目依赖于选择性捕获和信息集成的技术，对这些技术的使用越是熟练，并说服别人去使用这些技术，你的项目就越成功。随着项目的成长，这一点愈发正确。好的信息管理系统应该能够防止开源项目在布鲁克法则的重压下崩塌<footnote><para>摘自<citetitle>《人月神话》</citetitle>，1975。参见<ulink
url="http://en.wikipedia.org/wiki/The_Mythical_Man-Month"/>和<ulink
url="http://en.wikipedia.org/wiki/Brooks_Law"/>。</para></footnote>，也就是说向一个已经延期的项目增加人力，只能使项目延期更多。佛雷德.布鲁克观察到，项目的复杂性同参与人员数量的<emphasis>平方</emphasis>成正比。当项目中只有少数几个人时，大家可以容易的互相交谈。但当有上百人参与时，不可能让每个人都能知道别人正在做什么。如果说优秀的自由软件项目的管理是让每个人都感觉是在同一个屋子里共同工作，很明显问题在于：当在一间拥挤的房间内同一时间每个人都想发出声音，会发生什么？
 </para>

<para>这不是一个新问题。在现实中的拥挤房间中，解决方案是<firstterm>议会程序</firstterm>：我们需要正式的指导规则：包括如何在一个大型团队中进行即时的的讨论，如何保护重要的异议不会在一片“我也是”的回复中淹没，如何形成小组委员会，如何识别出何时作出决定。议会程序的一个重要组成部分是指明团队如何同它的信息管理系统互动，有些评论“为了被记录”而存在的，有些则不是，记录本身经常是被直接处理的，不能根据字面意义去理解，而是代表了团队已经确立达成<emphasis>共识</emphasis>。记录并非一成不变，为不同的目的会有不同的形式。它可以包括个人会议记录、每次会议的完整记录、摘要、议程及其注解、委员会报告，来自未出席通信者的报告，活动项目列表等等。
 </para>

<para>因为互联网并不是一个真实的房间，所以我们也无须担心复制诸如让部分人在别人讲话时保持安静之类的议会程序。但当它和信息管理技术接合时，一个运作良好的开源项目就会是打了兴奋剂的议会程序。由于开源项目中的交流都是通过书写方式完成的，由此发展出了复杂的系统：为了恰当导向和标记数据；为了避免会造成误解的重复；为了储存和检索数据；为了纠正错误和废弃的信息；以及为了在发现不相关信息的新关系时进行关联。开源项目中的活跃参与者已经将掌握了其中的很多技术，并且经常为了确保信息被正确的导向而进行复杂的手工任务，但是所有的努力都是依赖于复杂的软件支持。交流媒体应该尽可能地依靠自身完成发送、标签和记录工作，应该确保人尽可能方便地得到这些信息。当然在实际中，在整个过程中的很多方面还是需要人的干预，并且重要之处在于软件使得这种干预也是方便的。但总得来说，如果人能确保首次进入系统时信息的导向和标签都是正确的，软件应该被配置成可以充分利用这些元数据。
 </para>

<para>此章中的建议都是非常务实的，都是基于明确的软件和使用模式的经验。但这里不仅仅是教授实用的技术，而是通过许多小范例来演示一种总体态度，这种态度可以最大程度的促进你项目中的好的信息管理。这种态度包含了技术技巧同人力技巧的结合，并且技术技巧是关键，因为当新的需求出现时，信息管理软件总需要配置，以及一定量的持续维护和调整（例如，关于如何处理项目成长的讨论参加本章后面的<xref linkend="bug-filtering"/><phrase output="printed"></phrase>）。人
力技巧也是不可或缺的，因为人类社区也需要维护：如何利用这些工具的优势有时候不是立刻就很明显，在有些项目案例中甚至有冲突的习惯（例如，参见<xref linkend="mailing-lists"/>中的关于在外发的邮件列表通告中设置<systemitem>Reply-to</systemitem>头的讨论）。应该鼓励项目相关的每一个人在正确的时间、正确的地点尽自己的职责来保持项目信息组织的良好。贡献者参与的程度越深，就越能预期她能学习更复杂和专业的技术。
 </para>

<para>信息管理没有现成的解决方案，有着众多的不确定因素。你可能好不容易才把所有事情都按照自己的意愿完成配置，并且社区的大多数人参与进来，但随着项目的成长让某些实践不能扩展。或者本来你的项目正在稳步发展，技术基础架构也能使开发者和用户的社区关系融洽。但突然某些人出现，发明了一个全新的信息管理服务，很快新来的会质问为何你的项目不用它&mdash;例如很多在维基（参见 <ulink url="http://en.wikipedia.org/wiki/Wiki"/>）发明之前建立的自由软件项目就正面临这一问题。很多问题需要决断，比如权衡生产信息的方便性还是消费信息的方便性？或者权衡花在配置信息管理软件上的时间与其为项目带来的益处？</para>

<para>小心过度自动化的诱惑，请自动化那些真正需要人们关注的东西。技术基础架构是重要的，但推动一个自由软件项目运转的是参与的人的意愿&mdash;用智慧的方式表达的意愿&mdash;通过人的参与，技术基础架构只是为人门达到这个目标提供便利。
</para>

</simplesect>


<!-- ======================== SECTION ============================== -->
<sect1 id="tools-needed">
<title>一个项目需要什么</title>

<para>大部分开源项目至少提供了最低限度的标准工具用于管理信息：</para>

<variablelist>

   <varlistentry><term>网站</term>
     <listitem>
     <para>主要是一个集中将项目信息发布给公共的单向渠道，网站也可以作为其他项目工具的管理界面使用。</para>
     </listitem>
   </varlistentry>

   <varlistentry><term>邮件列表</term>
     <listitem>
       <para>通常会是项目中最活跃的通讯手段，是“可记录的媒介”。</para> 
     </listitem>
   </varlistentry>

   <varlistentry><term>版本控制</term>
     <listitem>
       <para>让开发者可以方便地管理代码的变更，包括回复和“变更转运”。让每一个人能看到代码的变化。</para>
     </listitem>
   </varlistentry>

   <varlistentry><term>Bug追踪</term>
     <listitem>
       <para>使开发者可以追踪他们正在工作的内容，互相协调，以及计划发布。让每个人都能查询bug的状况并且记录特定bug的信息（例如重现方法）。不仅能用于对bug的追踪，而且能用于任务、发布和新特性等等。</para>
     </listitem>
   </varlistentry>

<!--
   <varlistentry><term>Discussion forums</term>
     <listitem>
       <para><remark>Basically, bulletin board systems.  These are not
             as widespread as one would expect, and where they are
             found, they're not used as much as one would expect.  Why?
             Are they worth mentioning at all?</remark></para>
     </listitem>
   </varlistentry>
-->

   <varlistentry><term>即时聊天</term>
     <listitem>
       <para>一个可以快速和方便的进行讨论和问答的地方，缺点是并不总是能完整地归档。</para>
     </listitem>
   </varlistentry>

</variablelist>

<para>这个工具集中的每个工具满足了不同的需要，但它们的功能都是相关的，这些工具必须能协同工作。下面我们将检验它们怎样做到这一点，而最重要的是如何让人们使用它。网站将放在最后讨论，因为它更多的是扮演其他组件黏合剂的角色，而不是工具本身。</para>

<para>通过使用<firstterm>包装主机</firstterm>（<firstterm>canned hosting</firstterm>）你也许能避免很多选择工具和配置的头疼事。<firstterm>包装主机</firstterm>是一个提供预包装，模板化的网页部分，以及可运行一个自由软件项目的所有工具的服务器。关于包装主机优缺点的讨论可以看<phrase output="printed">本章后面的</phrase><xref linkend="canned-hosting"/>。</para>

</sect1>


<!-- ========================== SECTION =========================== -->
<sect1 id="mailing-lists">
<title>邮件列表</title>

<para>邮件列表有如项目交流的面包和黄油。如果用户在除了网页之外的地方浏览，最有可能是项目的某一个邮件列表。不过在体验邮件列表本身之前，他们将接触邮件列表的界面&mdash;也就是加入列表的（“订阅到（subscribe to）”）的机制，由此带出了邮件列表的#1法则：</para>

<blockquote>
   <para><emphasis>不要试图手工管理邮件列表&mdash;让软件来做。</emphasis></para>
</blockquote>

<para>放弃这一点充满诱惑，开始时就设置软件来管理邮件列表看起来有些小题大做了。手动管理小型低流量的邮件列表似乎是理所当然的：你只需设置一个指向自己的订阅地址，然后当有人向其发送邮件，你把他们的邮件地址加入（或是删除）一个保存了所有地址的文本文件中。还能比这更简单的吗？</para>

<para>问题在于，人们所期望的好的列表管理并非是如此简单。它不仅只是按用户的需求订阅或是退订而已，还包括防止垃圾邮件，提供发送邮件列表摘要而不是每条信息都发送的的形式，通过自动应答机提供标准列表和项目信息，以及许多其他事情。一个由人监控的订阅地址只能支持最小数量的简陋功能，而且在可靠性和反应速度上也不如软件。</para>

<para>现代化的列表管理软件至少提供了以下这些特性：</para>

<variablelist>

  <varlistentry><term>同时通过邮件和网页订阅</term>
    <listitem>
      <para>当一名用户订阅一个列表，她<i>应当</i>能立即收到一条表示欢迎的回复，告知她订阅了什么，下一步该如何使用邮件列表软件，并且（也是最重要的）告知如何退订。当然，这个回复还应该能被定制地加入诸如项目的站点，常见问题和回单等等项目的特定信息。</para>
    </listitem>
  </varlistentry>

  <varlistentry><term>可选择摘要或是每个信息单独发送的订阅模式</term>
    <listitem>
      <para>选择摘要模式，订阅者每天会收到一封包含当天所有列表活动的邮件。对那些并不紧跟列表，不会参与讨论的用户，摘要模式更合适他们，因为这允许他们在任何时刻一次检索所有的主题，避免了随机时间到来邮件的分神。</para>
    </listitem>
  </varlistentry>

  <varlistentry><term>审核特性</term>
    <listitem>
      <para>在邮件发送到整个列表之前的“审核”是检查邮件以确保：a)&nbsp;不是&nbsp垃圾邮件，以及b)&nbsp;符合&nbsp;主题。审核必须有人参与，但软件能很大程度的使之变得容易。后面还有关于审核的更多内容。</para>
    </listitem>
  </varlistentry>

  <varlistentry><term>管理界面</term>
    <listitem>
      <para>不管一些其他的作用，这个特性至少能让管理员轻松地进入列表并删除一个废弃的地址。当一个订阅者的地址开始自动地对每一封列表邮件发出“我已不在这个地址”的回复时，情况就变得非常紧急了。（有些邮件列表管理软件甚至能依靠自身捕获这种情况，并自动完成退订。）</para>
    </listitem>
  </varlistentry>

  <varlistentry><term>邮件头处理</term>
    <listitem>
      <para>许多人在自己的电邮客户端中设置了精密的过滤和回复规则，为了利用这些优势，邮件列表管理软件能为这些人添加和处理某一中标准的邮件头（更多详细参阅下面）。</para>
    </listitem>
  </varlistentry>

  <varlistentry><term>归档</term>
    <listitem>
      <para>发往被管理列表的所有邮件都会被保存，并且能够通过网页访问。有些邮件列表软件以可插入的形式提供外部归档工具如（<ulink url="http://www.mhonarc.org/"/>）的接口。就像<phrase output="printed"><xref linkend="communications"/>的</phrase><xref
            linkend="using-archives"/>所讨论的，归档很重要。</para>
    </listitem>
  </varlistentry>

</variablelist>

<para>所有这些的要点是为了强调邮件列表管理是一个复杂的问题，已经耗费了许多思考，而且大多数已经被解决。你确实无须成为一个专家，但你应该知道，虽然其中大部分已被解决，但总还有进步的空间，在运作一个自由软件项目的过程中列表的管理将一次次地占据你的注意力。下面我们将回答几个有关邮件列表配置的最常见问题。</para>

<!-- ========================== subsection =========================== -->
<sect2 id="spam-prevention">
<title>垃圾邮件防护</title>

<para>这段话从动笔到发布的时间间隔里，因特网上的垃圾邮件问题很可能又严重了一倍&mdash;或至少给人的感觉是如此。有那么一段时间，就在不久之前，当时可以完全无须任何的垃圾邮件防护措就能运转一个邮件列表。偶尔会有那么几封，但是非产罕见只构成小小的烦恼。好日子已经一去不复返了，现在如果邮件列表没有垃圾防护措施，很快就会被乱七八糟的邮件淹没，以至于不可用。垃圾防护需要。</para>

<para>垃圾防护分为两种类型：防止垃圾邮件出现在你的邮件列表中，防止你的邮件列表成为垃圾制造者的地址收割机获取的一个源。前者更重要，所以我们首先考察。</para>

<sect3 id="spam-filtering">
<title>过滤邮件</title>

<para>垃圾邮件防护有三种最基本的技术，大部分的邮件列表软件都会提供，最好能串联使用：</para>

<orderedlist>

  <listitem><para><emphasis role="bold">只自动允许来自列表订阅者的邮件。</emphasis></para>

            <para>只要使用就有效，因为通常只需要在在邮件列表软件的配置中做一点小小的改动，所以只需要很少的管理投入。但注意，那些不能自动认可的邮件不能简单地销毁了事。相反，必须传递给审核程序，有两个原因，首先你希望允许非订阅者的邮件。仅仅想问一个为问题或是提供建议的人不应该只为了发一封邮件而需要订阅整个列表。其次，有时甚至订阅者都有可能从非订阅时用的地址发出一封 邮件。邮件地址不是鉴别人的可靠方法，它不该被如此对待。</para>
            </listitem>

  <listitem><para><emphasis role="bold">通过垃圾过滤软件过滤邮件。</emphasis></para>

            <para>如果邮件列表软件允许（大部分是），你能用垃圾过滤软件来获得过滤后的邮件。由于在垃圾制造者和过滤器编写者之间进行着一场永不停息的军备竞赛，自动垃圾过滤从来不是也永远不会是完美的。然而，它可以大大减少进入审核队列的邮件数量，因为更长的列表需要更长的人工处理时间，一定程度的自动过滤总是有益的。</para>

            <para>这里没有空间来详细地介绍垃圾过滤的设置。你应该查阅你的邮件列表软件的文档（见<phrase
            output="printed">本章后面的</phrase><xref
            linkend="mailing-list-software"/>）寻求答案。列表软件通常会有一些内置的垃圾防护功能，但也许你想要添加一些第三方的过滤器。推荐你两个我有良好体验的软件：SpamAssassin
            (<ulink url="http://spamassassin.apache.org/"/>)
            和SpamProbe
            (<ulink url="http://spamprobe.sourceforge.net/"/>)。这并非是对众多的其他开源垃圾过滤器的不敬，其中的一些显然也是非常好的，只是这两个是我曾经亲身使用过的，并且它们让我很满意。</para>
  </listitem>

  <listitem><para><emphasis role="bold">审核</emphasis></para>
            <para>由于不是列表订阅者的原因而未能自动许可的邮件，就会根据设置进入垃圾过滤软件，最后一个阶段将是“审核”。邮件将被发送到一个特殊的地址，那里会有人来检查和决定是许可还是拒绝。</para>

            <para>许可一个邮件有两种形式：你可以只是这一次接受它，或你可以告诉列表软件为这一封邮件同一发送者以后的所有邮件开绿灯。为了减少以后的审核负担，你很可能会选择后者。具体如何许可在不同的系统之间有很大的差异，但是通常的形式是向一个特殊的地址发送一条带有
            命令“accept”（代表这一次许可）或是“allow”（允许这次以及以后的邮件）回复。</para>

            <para>拒绝通常只需简单的忽略所审核邮件即可，如果列表软件没有收到确认有效的邮件，它不会让邮件通过并出现在列表上，所以简单地扔掉审核邮件就能达到目的。有时你还有另外的选择，返回“reject”或是“deny”命令来杜绝以后来自同一个发送者的邮件进入审核程序。但这么做通常没什么意义，因为大部分需要审核处理的都是垃圾邮件，而垃圾邮件制造者不太会从同一个地址两次发出垃圾邮件。</para>
            </listitem>
</orderedlist>

<para>确保审核<emphasis>只</emphasis>被用在过滤垃圾邮件和明显是和主题无关的消息上，比如有时会有人意外地在一个错误的邮件列表中发送了邮件。审核系统通常给你一个直接同发送者联系的途径，但是不要用这种方式来回答属于邮件列表本身的问题，即使那些答案就在你的头脑之中。如果这么做了，将会剥夺项目社区了解人们正在问那些类型问题的具体形式，剥夺它们自己回答问题或者获得答案的机会。邮件列表审核除了严格确保列表中没有垃圾和同主题无关的邮件，没有其他了。</para>

</sect3>

<sect3 id="address-hiding">
<title>归档中的地址隐藏</title>

<para>为了防止你的邮件列表成为垃圾邮件发送者的地址源，一个常见的技术是混淆用户的邮件地址，例如通过替换</para>

    <blockquote>
      <para><literal>jrandom@somedomain.com</literal></para>
    </blockquote>

<para>with</para>

    <blockquote>
      <para><literal>jrandom_AT_somedomain.com</literal></para>
    </blockquote>

<para>or</para>

    <blockquote>
      <para><literal>jrandomNOSPAM@somedomain.com</literal></para>
    </blockquote>

<para>或一些类似的明显的（对人类来说）加密。因为垃圾邮件地址收割器通常会遍寻网络&mdash;包括你的邮件列表的网络归档&mdash;它们会查找包含“@”的字符串，对地址加密是为了让人们的邮件地址对垃圾邮件发送者来说不可见或不可用。这对防止垃圾邮件发送者将邮件直接发送到邮件列表本身，但它可以防止直接发送到用户个人地址的垃圾邮件的增加。</para>

<para>地址隐藏可能存在争议。许多人很喜欢，如果你的归档不能自动支持，他们会很惊讶。还有些人认为这样太不方便了（因为人们需要在使用之前转化地址）。有时候用户断定这样做不能产生预期的效果，因为收割器理论上可以弥补任何不变的加密模式。然而，有一个实验证据可以证明地址隐藏<emphasis>是</emphasis>有效的，见<ulink
url="http://www.cdt.org/speech/spam/030319spamreport.shtml"/>。</para>

<para>理想情况下，邮件列表软件为每个订阅者提供选择的机会，通过特别的yes/no头，或者通过订阅者列表帐户的参数选择设置。然而，我不知道有哪个软件提供了每订阅者或每邮件的选项，因此现在列表管理员必须为所有人作出决定（假定归档程序已经提供了这些特性，就不存在这个问题了）。我倾向于适度使用地址隐藏，一些人对于将自己的邮件发布到网页上或其他收割器可能会搜索的地方会非常小心，他们会因为邮件列表归档暴露它们关心的内容而感到失望，归档用户中的地址隐藏带来的不便是轻微的，因为如果你希望联系某个人，将混淆的邮件地址恢复非常容易。但是最后还是要牢记，这是一场军备竞赛：在你阅读到本文的事以后，收割器可能已经得到了进化，能够识别大多数常见的隐藏形式，我们可以想一些其他形式。</para>

</sect3>

</sect2>

<!-- ========================== subsection =========================== -->
<sect2 id="header-management">
<title>认证和头管理</title>

<para>列表订阅者经常希望能将从列表发送的邮件放置到项目特定的目录，和其他邮件分开。他们的邮件阅读软件可以自动检查邮件的<firstterm>头</firstterm>，这个头是在邮件的顶部，用来指明发送者、接收者、主题、日期和其他邮件相关的其他东西。某些头是众所周知的，而且是必须有的：</para>

<screen>
From: ...
To: ...
Subject: ...
Date: ...
</screen>

<para>还有一些是可选的，尽管也是非常标准的。例如，邮件不必有</para>

<screen>
Reply-to: sender@email.address.here
</screen>

<para>头，但大多数情况下都有，因为这可以保证接收者（当作者必须从一个不能接收邮件地址发送邮件的时候这特别有用）能够联系到原作者。</para>

<para>一些邮件阅读软件提供了基于主题头模式的易用界面，可以用来过滤邮件。这导致人们会要求邮件列表为所有的主题提供自动前缀，所以他们可以设置的阅读器查找前缀并自动将文件归入正确的文件夹。如果原来的作者是这样写：</para>

<screen>
Subject: Making the 2.5 release.
</screen>

<para>但是列表中显示的邮件会是：</para>

<screen>
Subject: [discuss@lists.example.org] Making the 2.5 release.
</screen>

<para>尽管大多数列表管理软件提供这个选项，然而我强烈反对开启这个功能。因为这个问题可以通过更自然的方式轻松解决，而且主题字段消耗的空间也太多了。有经验的邮件列表用户通常会扫视每天的列表邮件的主题，以决定阅读和/或回复哪些邮件。主题中前置的列表名称会将主题的正式内容脱离屏幕，无法看到。这混淆了人们赖以决定是否打开邮件的信息，从而减弱了邮件列表的整体功能。</para>

<para>我们不会处理主题头，而是让你的用户利用其他标准的头，以To头说起，可以用来说明邮件列表名称：</para>

<screen>
To: &lt;discuss@lists.example.org&gt;
</screen>

<para>任何可以过滤主题的邮件阅读器一定也能轻易的处理To。</para>

<para>还有一些其它的邮件列表期望的可选但标准的头，根据这些头过滤比利用“To”或“Cc”头更加可靠；因为这些头是邮件列表软件本身为每个邮件添加的，一些用户会依赖他们的出现：</para>

<screen>
list-help: &lt;mailto:discuss-help@lists.example.org&gt;
list-unsubscribe: &lt;mailto:discuss-unsubscribe@lists.example.org&gt;
list-post: &lt;mailto:discuss@lists.example.org&gt;
Delivered-To: mailing list discuss@lists.example.org
Mailing-List: contact discuss-help@lists.example.org; run by ezmlm
</screen>

<para>绝大部分是自解释的，更多解释可以看<ulink
url="http://www.nisto.com/listspec/list-manager-intro.html"/>，或者如果你觉得不够详细，正式的规范可以看<ulink url="http://www.faqs.org/rfcs/rfc2369.html"/>。
</para>

<para>如果你有一个名为“list”的邮件列表，请注意这些头是如何暗示的，然后你也有了管理地址“list-help”和“list-unsubscribe”。除此之外，用来加入的“list-subscribe”和接触列表管理员的“list-owner”也非常常见。取决于你所使用的管理软件，也可能会设置一些其它的管理地址；文档应该会有详细介绍。通常情况下，每个新用户在订阅时都会收到自动的“欢迎邮件”，其中会完整解释所有的特别地址。你可能有这个欢迎邮件的一份拷贝，如果你没有，可以问其他人获取一份拷贝，这样你就知道当你的用户到来时，他们会看到什么。手中有一份拷贝，你就可以回答邮件列表功能的问题，更好一点，可以放置到网页上。这样当有人丢失了自己的指导并询问“我如何从列表退订时？”，你就可以将URL发送个他。</para>

<para>一些邮件列表软件会在每个邮件的底部追加退订信息，如果有这个选项，请打开它。这样只会导致每个邮件有一段额外的行，在一个无害的位置，可以帮助你节省很多时间，减少了给你发邮件询问如何退订的人数&mdash;更坏的情况，发送到列表的数量！</para>

</sect2>

<!-- ========================== subsection =========================== -->
<sect2 id="reply-to">
<title>伟大的Reply-to争论</title>

<para>在前面的<xref linkend="avoid-private-discussions"/>，我强调了保持在公共论坛讨论的重要性，谈论了如何防止私下邮件讨论的一些主动措施，除此之外，本章将会讨论如何设置项目交流软件来更好的做这件事。因为如果邮件列表管理软件提供了一个方法来自动导致讨论保持在列表中，你会认为开启这个功能是显而易见的选择。</para>

<para>好的，有时候也不是如此认为。尽管有这个特性，但是它却有严重的缺陷。问题是无论你是否在邮件列表管理中使用这个功能都会成为最热的讨论&mdash;诚然，这不大可能成为你城市里的晚间新闻那样的论战，但它会在自由软件项目中一次次的爆发。下面，我将描述这个特性，提供两方面的主要论点，提出我能作出的建议。</para>

<para>这个特性本身非常简单：如果你愿意，邮件列表软件可以在每个邮件中自动设置转向到邮件列表的Reply-to头，也就是无论原来的发送者设置了什么Reply-to头（或者他们没有设置），当邮件列表的订阅者看到邮件时，它的头将会包含列表地址：</para>

<screen>
Reply-to: discuss@lists.example.org
</screen>

<para>从表面上看非常好。因为实际上所有的邮件阅读软件会注意到Reply-to头，这样当任何人回复邮件时，他们的回复都会自动来到整个列表，而不仅仅是邮件的发送者。虽然回复者仍然可以手工修改回复的地址，但重要的是<emphasis>缺省的</emphasis>回复会指向列表。这是通过技术鼓励协作的完美实例。</para>

<para>不幸的是，也有一些缺点。首先是<firstterm>找不到回家的路</firstterm>问题：有时候原来的发送者会把“真正的”邮件地址存放到Reply-to字段，通常是某种原因他们不能通过发送邮件的地址接收邮件。一直从同一个地址读取和发送的人们不会有这种问题，甚至会惊讶有这种情况。但是对于有特别的邮件设置，或者不能设置他们所看邮件的From地址（或许因为他们在工作时发送，而且不能通过IT部门修改配置）时，使用Reply-to可能是保证回复能够收到的唯一方法 。当此类人在未订阅的邮件列表中发送邮件时，她的Reply-to设置就成为了关键信息。如果列表软件覆盖了它，她可能就看不到回复了。</para>

<para>第二个可以预期的缺点，从我的观点来看是Reply-to处理最有力的反对论点。大多数有经验的邮件用户会习惯于两个回复的基本方法：<firstterm>reply-to-all</firstterm>和<firstterm>reply-to-author</firstterm>。所有现代的邮件阅读软件对于两个动作都有单独的按键，用户知道如果是回复到所有人（也包括列iboa），他们会选择reply-to-all，如果是私下回复到作者，他们应该选择reply-to-author。尽管你希望鼓励人们尽可能回复到列表，但确实有情况回复者需要有权利私下回复&mdash;例如，他们希望和邮件的原作者说一些机密的事情，可能不适合出现在公共列表中。</para>

<para>现在考虑一下如果列表覆盖了发送者的Reply-to时会发生什么，回复者点reply-to-author，希望向原发送者私下发送一个邮件。因为那是预期的行为，他可能就不会小心查看新邮件的接收地址。他编写了他的私人的、机密信息，可能会说一些对列表中的人来说很尴尬的内容，并点击发送键。出乎意料的是，几分钟之后他的信息出现<emphasis>邮件列表中！</emphasis>诚然，他应该仔细查看接收字段，对于Reply-to头不要有任何设想值。但是作者几乎会肯定将Reply-to设置为他们的个人地址（更确切地说，他们的软件做了设置），许多资深的邮件用户都会期望这样。实际上，如果一个人直接将Reply-to设置为其他地址，他通常会邮件的正文提及这一点，这样人们就不会为回复所发生的事情感到惊讶了。
</para>

<para>因为可能出现的严重后果，我的观点是保证列表管理软件决不要碰Reply-to头。这是一个使用技术来鼓励协作的实例，但是对我来说有潜在的危险副作用。然而，在论战的另一面也有强有力的论据，无论你选择何种方式，你都会在列表中看到有人问你为什么不选择另一种方式。因为你肯定不希望这成为邮件列表中的主要讨论，所以最好准备好回应，诸如此类结束讨论而不是鼓励讨论。请确认你<emphasis>不是</emphasis>坚持认定你的决定，也就是无论是哪个，它都应该明显是唯一正确和明智的选择（即使你认为那是一个事实）。相反，指出这是一个老争论了，两方面都有好的论点，没有能够满足所有用户的选择，因而你只是做出了你能做出的最佳决定。有礼貌的告知不要再炒冷饭了，除非有一些独特的新内容，然后不必再参与讨论并希望它能够自然死亡。</para>

<para>有些人会建议开展一个投票，如果你愿意你可以这样做，但是这个情况下我不认为这是一个满意的解决方案。对于某个人因为出人意料的行为模式的惩罚是巨大的（不小心的将私有邮件发送到公共列表），而对于所有其他人的不便是相对轻微的（偶尔需要提醒某人回复到整个列表而不仅仅是你），多数票是什么并不清楚，即使能得到多数票，少数者应该承担这样的危险吗？</para>

<para>这里我没有涉及问题的所有方面，仅仅包含了看起来最重要的。完整的讨论，请看这两篇权威的文档，当人们遇到争论时经常会对其引用：

<itemizedlist>
  <listitem>
     <para><emphasis role="bold">勿动eply-to</emphasis>,
     <emphasis>Chip Rosenthal</emphasis></para>
     <para><ulink
        url="http://www.unicom.com/pw/reply-to-harmful.html"/></para>
  </listitem>
  <listitem>
     <para><emphasis role="bold">把Reply-to设置为列表地址</emphasis>,
     <emphasis>Simon Hill</emphasis></para>
     <para><ulink
        url="http://www.metasystema.net/essays/reply-to.mhtml"/></para>
  </listitem>
</itemizedlist>

</para>

<para>无论你偏爱上面的哪一条，我不认为此问题有所谓的“正确”答案，也会很乐意参与到<emphasis>设置</emphasis>Reply-to的许多列表，最重要的事情是你尽早确立一种方式，之后再也不要陷入到争论之中。</para>

<sect3 id="reply-fantasies">
<title>两个幻想</title>

<para>将来有一天，有些聪明人会在邮件阅读器实现一个<firstterm>reply-to-list</firstterm>键，它可以使用前面提到的一些自定义的列表头来指出邮件列表的地址，然后会将回复仅指向到邮件列表，同时消除所有的其他接收地址，因此，无论如何大多数都是订阅列表的地址。最终，其他邮件阅读器也会采用这个特性，整个争论也就偃旗息鼓。（实际上，<ulink url="http://www.mutt.org/">Mutt</ulink>邮件阅读器已经提供了这个特性<footnote><para>在本书出现后不久，<ulink url="http://www.michaelbernstein.com/"
>Michael Bernstein</ulink>告诉我：“也有一些Mutt之外的其他客户端实现了reply-to-list功能，例如，Evolution的一个快捷键有这个功能，但不是一个按钮（Ctrl+L）。”</para></footnote>）</para>

<para>一个更好的解决方案是让每个订阅者自己选择是否进行Reply-to处理，如果希望经过Reply-to处理（自己与他人的邮件），可以要求，而如果不希望，则可以设置为Reply-to不变。然而，我不知道有任何列表管理软件提供这个每订户基础的设置，我们还是只能使用全局设置。</para>

</sect3>

</sect2>

<!-- ========================== subsection =========================== -->
<sect2 id="archiving">
<title>归档</title>

<para>设置邮件列表归档的技术细节特定于运转列表的软件，超出了本书的范围，当选择归档时，考虑这些特性：</para>

<variablelist>

  <varlistentry><term>立刻更新</term>
    <listitem>
      <para>人们经常会参考在上个小时所做的归档发表，如果可能，归档器必须能够立刻归档每个发布，这样发表出现在邮件列表时，它也就出现在了归档中。如果没有这个特性，至少应该将其设置为每小时更新一次。（缺省情况下，一些归档器会每夜更新，对于一个活跃的邮件列表这有点太滞后了。）</para>
    </listitem>
  </varlistentry>

  <varlistentry><term>参考稳定性</term>
    <listitem>
      <para>一旦一个信息已经归档到特定URL，它应该在相同的可访问URL，并尽可能的永远保持。即使归档重建，从备份中恢复，或者其他修正，任何已经公开的URL应该保持相同。稳定引用可以让Internet上的搜索引擎能够索引归档，可以方便用户查找答案，稳定引用也非常重要，因为邮件列表经常会被bug跟踪（见<phrase output="printed">本章后面的</phrase><xref
            linkend="bug-tracker"/>）或其他项目文档中引用。</para>

      <para>理想情况下，邮件列表应该能够包含一个信息归档的地址，或者至少在分发到接收者的信息头上有URL的信息特定的部分。这样人们就有了信息的拷贝，已经知道了归档的位置，而无须实际访问归档，这样做很有用，因为任何操作需要需要花费网络浏览器的时间的。我不知道是否有邮件列表软件实际支持这个特性；不幸的是，我用过的都不行。然而，这是我要寻找的（或者，如果你写邮件列表软件，这应该是一个可以考虑实现的特性）。</para>
    </listitem>
  </varlistentry>

  <varlistentry><term>备份</term>
    <listitem>
      <para>如何备份归档必须相当清楚，而恢复方法也不能太难。换一句话说，不要把归档器当作黑盒子，你（或者你项目中的某个人）应当知道信息存放在什么地方，以及如何在必要时从信息存放处重新生成归档页。这些归档是珍贵的数据&mdash;失去了它们，就像失去了项目集体记忆中美好的一部分。</para>
    </listitem>
  </varlistentry>

  <varlistentry><term>线索（thread）支持</term>
    <listitem>
      <para>应该能够从任意单独的信息进入原来信息所归属的<firstterm>线索</firstterm>（一组关联的信息），每个线索必须拥有自己的URL，与线索中的单独信息区分开来。</para>
    </listitem>
  </varlistentry>

  <varlistentry><term>可搜索性</term>
    <listitem>
      <para>一个不支持搜索的归档器&mdash;针对信息内容、以及作者和主题&mdash;接近于无用。注意某些归档器只是将此工作交给了诸如<ulink
            url="http://www.google.com/">Google</ulink>的第三方搜索引擎，这是可以接受的，但是直接的搜索支持通常会更加易于调整，例如我们可以指定搜索匹配的是主题行还是正文。</para>
    </listitem>
  </varlistentry>

</variablelist>

<para>上面是一个技术检查列表，可以帮助你评估和设置归档器，本章后面将讨论如何让人们<emphasis>利用</emphasis>归档器来对项目有益，特别是在<xref linkend="using-archives"/>。</para>

</sect2>

<!-- ========================== subsection =========================== -->
<sect2 id="mailing-list-software">
<title>软件</title>

<para>这里是一些可以进行列表管理和归档的开源工具，如果你的项目主机已经有缺省的设置，你可能无法决定一个工具。但是如果你必须安装一个，这些是可以选择的。我实际使用过的包括ailman、Ezmlm、MHonArc和Hypermail，这并不是意味着其他工具不好（当然可能有其他一些工具只是我碰巧没有找到，所以不要把这当作完全的列表）。</para>

<para>邮件列表管理软件：</para>

<itemizedlist>
 <listitem>
   <para><emphasis role="bold">Mailman</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://www.list.org/"/></para>
   <para>（有内置的归档器，以及外挂其他归档器的钩子。）</para>
 </listitem>
 <listitem>
   <para><emphasis role="bold">SmartList</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://www.procmail.org/"/></para>
   <para>（专门用于Procmail邮件处理系统。）</para>
 </listitem>
 <listitem>
   <para><emphasis role="bold">Ecartis</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://www.ecartis.org/"/></para>
 </listitem>
 <listitem>
   <para><emphasis role="bold">ListProc</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://listproc.sourceforge.net/"/></para>
 </listitem>
 <listitem>
   <para><emphasis role="bold">Ezmlm</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://cr.yp.to/ezmlm.html"/></para>
   <para>（设计与<ulink
         url="http://cr.yp.to/qmail.html">Qmail</ulink>邮件投递系统协同工作。）</para> 
 </listitem>
 <listitem>
   <para><emphasis role="bold">Dada</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://mojo.skazat.com/"/></para>
   <para>（不管网站因为什么奇怪的想法希望掩盖这个事实，这确实是一个自由软件，使用GNU许可证发布，也有内置的归档器。）</para>
 </listitem>
</itemizedlist>

<para>邮件列表归档软件：</para>

<itemizedlist>
 <listitem>
   <para><emphasis role="bold">MHonArc</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://www.mhonarc.org/"/></para>
 </listitem>
 <listitem>
   <para><emphasis role="bold">Hypermail</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://www.hypermail.org/"/></para>
 </listitem>
 <listitem>
   <para><emphasis role="bold">Lurker</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://sourceforge.net/projects/lurker/"/></para>
 </listitem>
 <listitem>
   <para><emphasis role="bold">Procmail</emphasis>&nbsp;&mdash;&nbsp;<ulink
         url="http://www.procmail.org/"/></para>
   <para>（SmartList的伴侣软件，也可以是普通的邮件处理系统，很显然，被配置为归档器。）</para>
 </listitem>
</itemizedlist>

</sect2>

</sect1>


<!-- ========================== SECTION =========================== -->
<sect1 id="vc">
<title>版本控制</title>

<para>一个<firstterm>版本控制系统</firstterm>（或<firstterm>修订控制系统</firstterm>）是跟踪和控制项目文件变更的技术与实践的组合，包括源代码、文档和网页。如果你以前从来没有使用过版本控制，那你最好赶快找一个有经验的人加入。现今，所有的人都希望你的项目源代码存放在版本控制下，如果不使用版本控制，人们将会轻视项目。</para>

<para>版本控制如此广泛的原因是因为它实际上能帮助运营一个项目的所有方面：内部开发者交流、发布管理、缺陷管理、代码稳定性和试验开发投入，以及对某个变更所属开发者的归因和授权。版本控制系统为这些领域提供了一个集中的协调力量。版本控制的核心是<firstterm>变更管理</firstterm>：识别对项目文件的每一个不相关的变更，使用元数据例如变更的日期和作者来注解每个变更，然后在无论使用什么方法，任何人询问时，重放这个事实。这是变更是信息的基本单元的交流机制。</para>

<para>这个部分不会讨论使用版本控制的所有方面，它是如此包罗万象，我们不得在本书不时不时的提及。因此，我们会通过促进协作开发的方式，专注于版本控制系统的选择和设置。</para>

<!-- ========================== subsection =========================== -->
<sect2 id="vc-vocabulary">
<title>版本控制词汇表</title>

<para>如果你没有用过版本控制，本书不会教你如何使用，但是如果没有一些关键术语，我们就无法讨论。这些术语独立于任何特定的版本控制系统：它们是网络交互的基本名词和动词，将会在本书剩下的部分适用，即使这个世界上没有版本控制，变更管理的问题也会存在，这些术语给了我们简明的讨论这些问题提供了一种语言。

<variablelist>

 <varlistentry id="vc-vocabulary-commit">
  <term><firstterm>提交（commit）</firstterm></term>
  <listitem><para>对项目做出一个变更；更正式的，以此方式在版本控制数据库存储一个变更，可以成为项目以后发布的一部分。“提交”可以作为名词或动词，作为名词，从本质上讲可以看作是“变更（change）”同义词。例如：“我刚刚为报告的Mac OS X上的服务器宕机bug提交了一个修订，Jay，你能评审一下提交并看一下我有没有误用内存分配？”</para></listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-log-message">
  <term><firstterm>日志信息（log&nbsp;message）</firstterm></term>
  <listitem><para>每次提交所附的注释，描述了提交的性质和目的，日志信息是任何项目最重要的文档：它是单个代码变更的高度技术语言与特性、bug修订和项目进展这类更面向用户语言的桥梁。本节的后半部分，我们会关注将日志信息发布给适当读者的方法；另外，<phrase output="printed"><xref linkend="communications"/>的</phrase><xref
  linkend="codifying-tradition"/>将会讨论鼓励贡献者填写简明和有用日志信息的方法。</para></listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-update">
  <term><firstterm>更新（update）</firstterm></term>
  <listitem><para>请求将其他人的变更（提交）和项目的本地拷贝进行组合；也就是将你的拷贝“保持最新”。这是一个非常常见的操作；大多数开发者每天都会多次更新代码，因此，可以确认他们运行的代码与别人的相同，因此他们看到一个bug，他们可以确信它还没有被修正。例如：“嗨，我发现索引代码一直会丢掉最后一个字节，这是一个新的bug吗？”“是的，但已经在上周修正了&mdash;更新一下，一定是好了。”</para></listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-repository">
  <term><firstterm>版本库（repository）</firstterm></term> <listitem><para>一个存放变更的数据库。一些版本控制是集中式的：有一个单独的主版本库，会存放项目的所有变更。也有一些分布式的系统：每个开发者都有自己的版本库，变更可以在版本库之间任意交换。版本控制系统跟踪了变更之间的依赖关系，当需要发布时，确认一部分变更集进入发布。集中式还是分布式的问题也是一场不朽的软件开发圣战；也要防止落入在你的项目列表中讨论这个问题的陷阱。</para></listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-checkout">
  <term><firstterm>检出（checkout）</firstterm></term>
  <listitem><para>从版本库获取项目拷贝的过程，一个检出通常会产生一个叫做“工作拷贝”（看后面）的目录树，可以从这个目录将变更提交回原来的版本库。在一些分布式的版本控制系统，每个工作拷贝本身都是一个版本库，变更可以推出（拖入）到任何愿意接受的版本库。</para></listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-working-copy">
  <term><firstterm>工作拷贝（working copy）</firstterm></term>
  <listitem><para>一个包含项目源代码文件或者网页及其他文档的开发者的私有目录树，一个工作拷贝也可能会包含由版本控制系统管理的元数据信息，可以说明工作拷贝所对应的版本库，以及所展现文件的“修订版本（看后面）”等等。通常情况下，每个开发者都有自己的工作拷贝，他可以在其中进行变更以及测试，并提交。</para></listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-revision">
  <term><firstterm>修订版本（revision）</firstterm>,
        <firstterm>变更（change）</firstterm>,
        <firstterm>变更集（changeset）</firstterm></term>
  <listitem><para>一个“修订版本”通常是一个特定文件或目录的具体化身，例如，如果开始时一个项目有一个文件F，修订版本是6，然后如果有一个文件对文件F提交了一个变更，那么就会产生F的修订版本7。一些系统也使用“修订版本”，“变更”或“变更集”来引用作为一个逻辑概念的一组变更。</para> 

  <para>这些术语在不同的版本控制系统可能有不同的技术含义，但是大意基本相同：他们提供了一个方法可以精确的描述一个文件或一组文件历史中的精确一点（比方说，恰恰在一个bug修正之前或之后）。例如：“她在修订版本10修正了那个”或者“他在文件foo.c的修订版本10修正了那个。”</para>

  <para>当一个人在不指定特定修订版本的时候谈论一个文件或一组文件时，通常假定是指最近的修订版本。</para></listitem>
 </varlistentry>

  <sidebar id="version-vs-revision">
  <title>“版本”对“修订版本”</title>
  <para><firstterm>版本</firstterm>有时候作为“修订版本”的同义词使用，但是在本书我不会这样使用，因为这太容易与一个软件的版本混淆&mdash;也就是软件的发布或版本号，例如在“版本 1.0（Version 1.0）”。不管怎样，因为短语“版本控制”已经标准化了，所以我会继续将其视为“修订版本控制”和“变更控制”的同义词。</para>
  </sidebar>

 <varlistentry id="vc-vocabulary-diff">
  <term><firstterm>区别（diff）</firstterm></term>
  <listitem><para>变更的文本化展现，一个区别显示了哪些行发生了怎样的改变，以及围绕上下文两端的几行。一个已经熟悉代码的开发者通常可以阅读区别，并理解变更完成的事情，甚至发现bug。</para></listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-tag">
  <term><firstterm>标签（tag）</firstterm></term>
  <listitem><para>一组特定修订版本的文件的标签，标签通常用来保存人们感兴趣的项目快照。例如，为每个公开发布使用标签，这样人们就可以从版本控制系统获取发布对应的文件/修订版本。常见的标签名称有<literal>Release_1_0</literal>、<literal>Delivery_00456</literal>等等。</para></listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-branch">
  <term><firstterm>分支（branch）</firstterm></term>
  <listitem><para>项目的一个拷贝，在版本控制之下，但却是孤立的，所以分支上的变更不会影响项目的其他部分，或者相反，除非你故意将变更“合并（merged）”过去（看后面）。分支也被称为“开发线（lines of development）”，即使当一个项目没有明确的分支，开发也可以被认为是发生在“主分支”，也称为“主线”或“<firstterm>主干（trunk）</firstterm>”。</para>

  <para>分支提供了一个将开发线隔离的方法，例如，一个分支可以用来进行对于主干不够稳定的实验开发，或者一个分支可以用来稳定新的发布。在发布过程中，有规律的开发可以继续不受干扰的在版本库的主线进行；与此同时，在发布分支，除非经过发布管理员的确认，不允许任何变更。通过这种方式，让发布不必干扰正在进行的开发工作，关于分支的详细讨论见<phrase output="printed">本章后面的</phrase><xref
  linkend="branches"/>。</para></listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-merge">
  <term><firstterm>合并（又名搬运）（merge (a.k.a. port)）</firstterm></term>
  <listitem><para>用来将变更从一个分支搬运到另一个。这包括从主干合并到分支，或者相反。实际上，这是最常见的合并类型；在两个非主分支之间搬运变更的情况很少见，关于此类合并的更多信息可以看<xref
  linkend="vc-singularity"/>。</para>

  <para>“合并”也有另一种相关的含义：也就是当两个人对于同一个文件作出没有交叠的变更时，版本控制系统所作的事情。因为两个变更没有互相干扰，当一个人更新其拷贝中的这个文件（已经包含他自己的变更）时，其他人的变更会自动合并进去。这非常常见，特别是当多个人编辑同一代码时。当两个变更<emphasis>确实</emphasis>交叠了，结果就是“冲突”了；看下面。</para>
  </listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-conflict">
  <term><firstterm>冲突（conflict）</firstterm></term>
  <listitem><para>当两个人希望对于代码的同一个地方作出不同的修改时，所有的版本控制系统会自动监测到冲突，并至少让一个人意识到他们的变更与其他人的冲突了。这依赖于<firstterm>解决（resolve）</firstterm>冲突的人，以及与版本控制系统解决的交流。</para></listitem>
 </varlistentry>

 <varlistentry id="vc-vocabulary-lock">
  <term><firstterm>锁定（lock）</firstterm></term>
  <listitem><para>对于某个文件或目录进行排他变更声明的方法，例如，“我现在不能对网页文件提交任何变更，似乎Alfred已经锁定了所有文件，因为他要修改背景图片。”不是所有的版本控制系统都提供了锁定特性，这是因为平行，同时开发是行为准则，而将人们锁定在文件之外违背了这个思想。</para>

  <para>需要锁定才能提交的版本控制系统，我们称之使用<firstterm>锁定-修改-解锁</firstterm>模型，而其他的我们称之为<firstterm>拷贝-修改-合并</firstterm>模型。两种模型的一个完美的深入解释和比较可以看<ulink
  url="http://svnbook.red-bean.com/svnbook-1.0/ch02s02.html"/>，通常情况下，拷贝-修改-合并适合于开源开发，在本书讨论的版本控制工具都支持这个模型。</para></listitem>
 </varlistentry>

</variablelist>

</para>

</sect2>


<!-- ========================== subsection =========================== -->
<sect2 id="vc-choosing">
<title>选择一个版本控制系统</title>

<para>在写本文的时候，自由软件世界中两个最流行的版本控制系统是<firstterm>并行版本系统</firstterm>（firstterm>CVS</firstterm>，<ulink url="http://www.cvshome.org/"/>）和<firstterm>Subversion</firstterm>（<firstterm>SVN</firstterm>，<ulink url="http://subversion.tigris.org/"/>）。</para>

<para>CVS已经存在很长时间了。大多数有经验的开发者已经熟悉了它，它或多或少满足了你的需要，而且因为它已经流行了很长时间了，你可能不会陷入它是否是正确选择的争论。CVS有一些缺点，它不支持简单的引用多个文件的变更；它不支持版本控制下的（这样如果你需要识别出项目开始后的代码树，会非常头痛）文件重命名和拷贝；它对合并的支持很弱；它处理大文件和二进制文件不佳；以及在操作很多文件时操作会非常慢。</para>

<para>CVS的这些缺陷都不是致命的，所以它一直非常流行。然而，最近几年Subversion逐渐被人们所接受，特别是在新创建的项目中。<footnote><para>关于这种增长的证据可以看<ulink url="http://cia.vc/stats/vcs"/>和<ulink url="http://subversion.tigris.org/svn-dav-securityspace-survey.html"/>。</para></footnote>如果你新开始一个项目，我推荐Subversion。</para>

<para>在另一方面，因为我参与了Subversion项目，我的客观性有理由值得怀疑。在最近几年，许多新的开源版本控制系统已经出现。<xref linkend="vc-systems"/>列出了所有我知道的，大体上根据流行性排序。就像列表说明的，决定使用何种版本控制系统可能成为一项终身的研究项目。有可能你也会省掉选择的过程，因为你的主站已经做出了选择。但如果你必须做出选择，请问文那些有经验的人，然后选择一个并使用起来。任何稳定的产品状态的版本控制系统可以实现；你不必担心会做出灾难性的错误决定，如果你无法下决心，那就Subversion吧。它学起来相对简单，在近几年里还应该保持标准的地位。</para>

</sect2>


<!-- ========================== subsection =========================== -->
<sect2 id="vc-using">
<title>使用版本控制系统</title>

<para>这一部分的建议不针对任何特定版本控制系统，对它们来说应当是很自然的实现。详细信息请参考特定系统的文档。</para>

<sect3 id="version-everything">
<title>版本化所有的东西</title>

<para>不要仅仅将项目的源代码纳入到版本控制下，也应该包括网页、文档、FAQ、设计注释和任何人们希望编辑的内容。让他们与源代码尽量接近，在同一个版本库树中。任何值得写下来的信息都应该纳入版本控制&mdash;也就是任何可能会变更的信息。不会发生变更的东西都应该归档，非版本化。例如，一个邮件一旦发布，就不会变更；因此，将其版本化没有任何意义（除非它成为一个较大的、进化文档的一部份）。</para>

<para>在一个地方版本化所有的东西的原因非常重要，这样人们只需要学习一种提交变更的方式。例如，经常是一个贡献者开始编辑一个网页或者文档，然后接着做一些代码变更。当项目对于所有的提交使用相同的提交方式时，人们只需要学习一次。一起版本化所有的东西也意味着随着文档的更新，新特性可以一起提交，而代码分支时也是对文档分支等等。</para>

<para>不要将<firstterm>生成的文件</firstterm>置入版本控制。那些应该不是可编辑的数据，因为它们是程序方式由其他文件产生的。例如，一些构建系统根据模板<filename>configure.in</filename>文件产生<filename>configure</filename>。为了改变<filename>configure</filename>，我们需要编辑<filename>configure.in</filename>，然后重新生成；因此，只有文件<filename>configure.in</filename>是“可编辑文件。”只版本化模板&mdash;如果你也版本化结果文件，人们在对模板进行修改后会不可避免的忘记重新生成它，结果的不一致会导致无休止的混淆。<footnote><para>对于版本化<filename>configure</filename>的不同意见，可以看Alexey Makhotkin的文章，在<ulink url="http://versioncontrolblog.com/2007/01/08/configurein-and-version-control/"/>的“<citetitle>configure.in and version
control</citetitle>”。</para></footnote></para>

<para>所有可编辑数据必须存放在版本控制下的规则也有一个不幸的例外：缺陷跟踪。Bug数据库保存了大量的可编辑数据，但是因为技术原因不能将数据存放在版本控制系统。（一些跟踪工具有一些原始的版本控制特性，然而，独立于项目的主版本库。）</para>

</sect3>

<sect3 id="vc-browsing">
<title>可浏览性</title>

<para>项目的版本库应该能够通过web浏览，这不仅是意味着浏览最新修订的能力，也包括回到过去查看早先的版本，查看修订之间的区别，以及阅读针对特定变更的日志信息等等。</para>

<para>可浏览性非常重要，因为它是一个轻量级的项目数据门户，如果不能通过web浏览版本库，那一个人如果希望检查特定的文件（例如，看一下某个bug修正是否已经进入代码），他必须在本地安装版本控制客户端，这会让一项只需要两分钟的任务变成一项半小时或更长的任务。</para>

<para>可浏览性也暗示了浏览文件特定修订版本的标准URL，以及任意给定时间最近的修订。在技术讨论或向人们指明作为证据时这非常有用。例如我们不会说“关于调试服务器的提示，可以看你工作拷贝中的www/hacking.html”，而会说“关于调试服务器的提示，可以看<emphasis>http://svn.collab.net/repos/svn/trunk/www/hacking.html</emphasis>，”，给定一个会一直指向<filename>hacking.html</filename>最新修订的URL。URL会更好，因为它不会导致混淆，也避免了地址是否有最新工作拷贝的问题。</para>

<para>一些版本控制系统包含内置的版本库浏览机制，而其他一些依赖于第三方的工具实现。这类工具有<firstterm>ViewCVS</firstterm>（<ulink
url="http://viewcvs.sourceforge.net/"/>）、<firstterm>CVSWeb</firstterm>（<ulink
url="http://www.freebsd.org/projects/cvsweb.html"/>）以及<firstterm>WebSVN</firstterm>（<ulink
url="http://websvn.tigris.org/"/>）。第一个可以支持CVS和Subversion，而第二个只支持CVS，而第三个只支持Subversion。</para>

</sect3>

<sect3 id="commit-emails">
<title>提交邮件</title>

<para>对版本库的每一次提交应当能够产生一个邮件，包含谁做出修改的、何时作出的修改、修改的文件和目录以及为什么修改。邮件必须发送到专注于提交邮件的特别邮件列表，在邮件列表中能够同人们的邮件区分开来。必须鼓励开发者和其他感兴趣的参与者订阅这个提交列表，这是从代码级别来跟踪项目的最有效方法。除了同级评审（见<xref linkend="code-review"/>）这一明显的技术益处，提交邮件帮助我们建立了一种社区意识，因为他们创建了一个共享环境，在其中人们可以对其他人也可见的事件（提交）作出反应。</para>

<para>设置提交邮件的具体方法依赖于你的版本控制系统，但通常有一些脚本或其他工具可以完成这个工作。如果你在寻找过程中遇到困难，可以查一下<firstterm>钩子（hooks）</firstterm>的文档，特别是<firstterm>post-commit hook</firstterm>，CVS中也称作<firstterm>loginfo hook</firstterm>。Post-commit钩子大意上就是对提交做出自动化的响应。这个钩子会由每个提交出发，并提供关于提交的所有信息，你可以自由的使用这些信息做任何事情&mdash;例如，发送一个邮件。</para>

<para>通过预先包装的提交邮件系统，你可能会希望修改一些缺省的行为：</para>

<orderedlist>

  <listitem>
  <para>一些提交邮件程序会在邮件中包含实际的区别，而不是提供在web上使用版本库浏览系统查看变更的URL。虽然提供URL非常好，这样后面就可以引用这个变更，但是在邮件本身中包含区别同样重要。阅读邮件已经成为人们的例行的一部分，如果变更的内容在提交邮件中，开发者可以立刻进行评审，不需要离开邮件阅读器。如果他们需要点击一个URL来评审变更，大多数人就不会作了，因为需要开始一个新动作，而不是延续一个已发生的动作。此外，如果评审者希望询问变更的某些事情，可以直接选择带原文回复并注解区别，这样就不必访问网页并辛勤的从web浏览器拷贝粘贴到邮件客户端。</para>

  <para>（当然，如果区别非常大，诸如大片的新代码正文添加到了版本库，那么省掉区别而只提供URL就比较有意义。大多数提交邮件程序可以自动执行这种限制，如果你的不支持，那包含区别也没有关系，只是偶尔会有些大邮件，比完全没有区别更好。便利的评审和回复是协作开发的奠基石，是否存在十分关键。）</para>
  </listitem>

  <listitem><para>提交邮件必须将Reply-to头设置为普通的开发邮件列表，而不是提交邮件列表。那是因为，当有人评审一个提交并撰写了一个回复，这个回复应当自动转向到人们的开发邮件列表，也就是通常人们讨论技术问题的地方。有这么几个原因。首先，你希望将技术讨论保持在一个邮件列表中，因为这也是人们所期望的情况，而且这种情况下只需要搜索一个归档。其次，有一些感兴趣的参与者可能没有订阅提交邮件列表。第三，提交邮件列表把自己当作一个监视提交的服务，而不是用来关注提交<emphasis>并</emphasis>偶尔进行技术讨论。订阅提交邮件列表的人除了提交邮件没有订阅其他东西；通过那个列表发送其他内容违反了隐含的契约。第四，人们经常写程序来阅读提交邮件列表并处理结果（例如为了显示一个网页）。这些程序预备好了处理一致格式的提交邮件，但与人写的邮件不匹配。</para>

  <para>请注意这里设置Reply-to的建议与<phrase output="printed">本章前面</phrase><xref linkend="reply-to"/>中说的并不矛盾。对于信息的<emphasis>发送者</emphasis>来说，设置Reply-to非常正常。在这个情况下，发送者是版本控制系统本身，它设置Reply-to是为了说明回复的合适地方是开发邮件列表，而不是提交列表。</para>

  </listitem>

</orderedlist>

<sidebar id="cia">
<title>CIA：另一种变更公示机制</title>

<para>提交邮件不是传播变更新闻的唯一方式，最近一种叫做CIA（<ulink
url="http://cia.navi.cx/"/>）的机制被开发了出来。CIA是一个实时提交统计信息的聚合器和分发器。CIA最流行的用处是发送提交提醒到IRC频道，所以登陆到频道的人都可以实时的看到发生的提交。尽管比提交邮件有较少的技术功效，因为观察者不一定会在提交提醒弹出时就在频道上，但是这项技术仍然有巨大的<emphasis>社会</emphasis>功效。人们得到了成为某个存在并活跃事务一部分的感觉，并且他们能够感到正在发生的进展。</para>

<para>工作原理是通过你的post-commit钩子调用CIA通知程序，通知器会将提交信息格式化为XML信息，并发送到中央服务器（通常是<literal>cia.navi.cx</literal>）。然后服务器将提交信息分发到其他论坛。</para>

<para>CIA也可以设置来发送<ulink
url="http://www.xml.com/pub/a/2002/12/18/dive-into-xml.html">RSS</ulink>，更多细节可以看文档的<ulink url="http://cia.navi.cx/"/>。</para>

<para>如果你想参考CIA的一个实例，将你的IRC客户端指向<literal>irc.freenode.net</literal>，频道<literal>#commits</literal>。</para>

</sidebar>

</sect3>

<sect3 id="branches">
<title>使用分支来避免瓶颈</title>

<para>非专家的版本控制用户有时候会担心分支与合并，这可能是CVS流行性的副作用：CVS对于分支和合并的接口和我们的知觉不太一致，所以很多人学着完全避免此类操作。</para>

<para>如果你周围有很多这类人，立即下决心战胜所有恐惧，并花时间学会如何分支和合并。它们不是什么困难的操作，一旦你习惯了，对于项目获取更多的开发者这日益重要。</para>

<para>分支非常有价值，因为它将一项稀缺的资源&mdash;项目代码的工作空间&mdash;变得充足。当某个人希望添加一个新的吊桥，但是不能确认其他人是否正在工作，分支使她被隔离到一个角落并做出尝试提供了可能。如果这种投入成功了，她可以要求其他开发者检验这个结果。如果所有人认可结果，他们可以告诉版本控制系统将吊桥从分支城堡移动（“合并”）到主城堡。</para>

<para>很容易看到这项能力是如何帮助协作开发的，人们需要自由尝试新问题的感觉，而无须担心干扰其他人的工作。同样重要的是，当为了完成bug修正或发布稳定化（见<phrase output="printed"><xref linkend="development-cycle"/>的</phrase><xref linkend="stabilizing-a-release"/>和<xref linkend="release-lines"/>），代码需要从日常的开发中分离出来时，所花费的时间数倍于无需担心跟踪一个移动目标的情况。</para>

<para>不受限制的使用分支，并鼓励其他人也这样做。但是要确保任何特定分支只保持必要的最短时间，任何活动分支都会让社区分神，即使不是在分支工作的人也需要对此有所了解。这种了解是应该的，当然，对于分支的提交应该能和其他提交一样发送提交邮件。但是分支不应该成为分割开发社区的机制，除了很少的例外，大多数分支最终必须合并回它们的主干并消失。</para>

</sect3>

<sect3 id="vc-singularity">
<title>信息单一</title>

<para>合并有一个推论：不要对同一个变更提交两次，也就是一个修改只进入一次版本控制系统。变更的修订（或一组修订）可以在其进入版本控制系统之后唯一标示。如果它需要应用到还没有应用过的分支，那么它应该从最初的入口点合并到其他目标&mdash;而不是直接提交相同的文本，这样虽然对代码的效果是一样的，但会导致我们无法进行精确的记录和发布管理。</para>

<para>这个建议对于不同版本控制系统的实践效果不尽相同。在一些系统，合并是特殊的事件，与提交从根本上不同，并包含他们自己的元数据。而另外一些系统，合并的结果就像其他变更一样是提交到了系统，所以区别“合并提交”和“新变更提交”的主要方法是使用日志信息。在合并的日志信息中，不会再重复原始变更的信息，而只是指明这是一个合并，并提供原始变更的修订版本，以及一段说明其效果的文字。如果有人希望看到完整的日志信息，她应该参考原来的修订。</para>

<para>避免在提交之后再重复日志信息的原因非常重要，如果变更日志在每个合并目标中重复，那有朝一日她修改了最初的信息，而那些重复还是会保持错误&mdash;混淆就会持续下去。</para>

<para>同样的原理也适用于撤销一个变更，如果一个变更从代码中撤销，那么这个撤销的日志信息也应该仅仅是指明撤销的是哪些特定的修订版本，而<emphasis>不是</emphasis>描述撤销过程中实际变更的代码，因为变更的内容可以通过阅读原来的日志信息和修订获得。当然，修订版本日志信息也应当说明恢复变更的原因，但它不应该从原始变更日志信息复制任何东西。如果可能，回到原来的变更日志信息，并指明它已经撤销了。</para>

<para>前面所说的都暗示了你应该使用一致的语法来引用这些修订版本，这不仅仅在日志信息中有益，在邮件、bug跟踪和其他地方也同样重要。如果你使用CVS，我建议“<literal>path/to/file/in/project/tree:REV</literal>”，其中的REV就是CVS的修订版本好吗，例如“1.76”。如果你使用Subversion，修订版本1729的标准语法是“r1729”（文件路径不是必需的，因为Subversion使用全局修订版本号）。在其他系统中，也都有一些表达变更集的标准语法，无论对你的系统什么是合适的语法，鼓励人们使用它们来饮用变更。对变更名一致的表达方法可以帮助项目更简单的纪录（在<xref linkend="communications"/>和<xref linkend="development-cycle"/>我们将会看到），而且因为许多纪录是由志愿者完成的，它应该尽可能的简单。</para>

<para>在<phrase
output="printed"><xref linkend="development-cycle"/>的</phrase><xref
linkend="releases-and-daily-development"/>也有介绍。</para>

</sect3>

<sect3 id="vc-authz">
<title>授权</title>

<para>大多数版本控制系统提供了控制特定人可以从版本库特定子区域提交的特性，根据这个原理，当人们手握锤子时，就开始到处找钉子，许多项目开始恣意使用这种特性，小心的为每个人只赋予他们被确认的权限，而不能在任何其他地方提交（看<phrase output="printed"><xref linkend="managing-volunteers"/>的</phrase><xref linkend="committers"/>来确认何人可以在何处提交。）</para>

<para>执行这样严格的控制可能会有一些害处，一个宽松的政策也足够好。一些项目会简单得使用一个荣誉系统：当一个人被赋予提交权限，即使只是版本库的一个子区域，他也会收到一个可以在项目所有地方可以提交的密码。他们只是被告知要在自己的区域提交，请记住这里没有真正的危险：在一个活跃的项目里，所有的提交会被审核，如果有人在不被允许的地方提交，其他人会发现这一点并说出来。如果这个变更需要被回退，很简单&mdash;因为所有地变更都在版本控制之下，只需要回退。</para>

<para>这种宽松的方法有许多好处，首先，当开发者扩展了他们的活动范围（如果他们一直在项目中，这是一个通常的情况），赋予更宽泛的权限无需额外的管理工作，一旦作出了这样的决定，这个人就可以立刻在新区域提交。</para>

<para>第二，扩展可以以一种更细致的方式实现。通常情况下，区域X的提交者如果希望扩展到区域Y，他会通过发表对Y的一个补丁并寻求评审开始，如果对区域Y有提交权限的人看到这个补丁并确认，他可以直接让提交者直接提交这个变更（当然也要在日志信息中提及评审者/确认者的名字）。这样，这个提交就会成为实际编写变更者的作品，无论从信息管理角度还是审计角度这样都更好。</para>

<para>最后，可能是最重要的，使用荣誉系统来鼓励互相尊重和信任的氛围。给一个人对某一区域的访问权限是对他们已经完成技术准备的证明&mdash;这是说：“我们已经看到了你已经具备了对某一领域做出修改的专业知识，那就继续吧。”但设置严格的授权控制则是暗示：“我们不仅仅确认你专业知识的限制，而且我们对你的<emphasis>目的</emphasis>也保持怀疑。”如果可以避免的话，你一定不愿意做出这样的评价。将一个人引入为项目的提交者是将其引入互相信任循环的机会，好的方法是给他们比期望所能发挥作用更大的权力，然后告诉他们是否保持在规定的限制内完全依赖于他们自己。</para>

<para>Subversion项目按照荣誉系统的方式已经运作超过4年了，在写作时包含了33个完全的和43个部分提交者。系统实际强制的只是提交者和非提交者的区别；更细的划分只由人为控制。但是我们从来没有遇到故意在领域外提交的问题，只是有一两次由于对个人提交权限范围的误解造成的错误，而且都能够很快和亲切的得到解决。</para>

<para>
很明显，当自律的方式不够实际时，那你就需要严格的授权控制，但这种情形非常少见。当有几百万行的代码，以及数百或上千的开发者时，对于任何给定模块的提交，也必须经过模块上工作的人们的评审，而且他们可以识别出提交者是否得当。如果<emphasis>没有</emphasis>有规律的提交评审，那么项目恐怕就会遇到比没有授权系统更大的问题了。</para>

<para>归纳起来，不要在版本控制的授权系统上花费太多时间，除非你有特别的原因，复杂的授权系统不能带来实际的好处，依赖人为控制有更多的优点。</para>

<para>当然，上面所说的并不意味着限制本身不重要，项目不应该鼓励人们在不够格的地方提交。此外，在很多项目中，完全（无限制）的提交访问有一个特别的状态：它隐含了项目范围 问题的投票权。提交访问的政治方面将会在<phrase output="printed"><xref linkend="social-infrastructure"/>的</phrase><xref
linkend="electorate"/>详细讨论。</para>

</sect3>

</sect2>

</sect1>


<!-- ========================== SECTION =========================== -->
<sect1 id="bug-tracker">
<title>Bug跟踪</title>

<para>Bug跟踪是一个宽泛的话题；贯穿本书会讨论此问题的各个方面。尽管这里我们要着重于配置和技术因素，但是首先要从一个策略问题开始：Bug跟踪系统中应该包含哪些信息？</para>

<para>术语<firstterm>Bug跟踪（bug tracker）</firstterm>很有误导性，Bug跟踪系统也通常会用来跟踪哪些初始与结束状态不同，包含可选的中间状态，并在生命周期中积累信息的问题，例如新特性请求、一次性任务以及被动性的补丁。由于这些原因，Bug跟踪也被称为<firstterm>问题跟踪（issue
trackers）</firstterm>、<firstterm>缺陷跟踪（defect 
trackers）</firstterm>、<firstterm>制品跟踪（artifact trackers）</firstterm>、<firstterm>请求跟踪（request
trackers）</firstterm>以及<firstterm>问题票跟踪（trouble ticket systems）</firstterm>。<xref linkend="bug-trackers"/>包含了一个此类软件的列表。
</para>

<para>在本书中，我会继续使用“bug跟踪（bug tracker）”这个名称，因为大多数人这样称呼，但我会使用<firstterm>问题（issue）</firstterm>来称呼Bug跟踪数据库中的单个条目。这让我们可以把用户遇到的（Bug本身）正常或不良行为与跟踪系统中Bug的发现、诊断和最终解决的<emphasis>记录</emphasis>区分开来。请牢记，尽管大多数问题与实际的Bug相关，我们也可以用其来跟踪其它类型的任务。</para>

<para>典型的问题生命周期如下：

<orderedlist>
  <listitem><para>某人发起了一个问题，他提供了摘要，初始描述（如果合适则包含重现方法；如何激励好的bug报告请看<phrase
            output="printed"><xref linkend="managing-volunteers"/>的</phrase><xref
            linkend="users-to-volunteers"/>），以及其它跟踪系统要求的信息。项目可能对发起人一无所知&mdash;Bug报告和特性请求既可能来自用户社区，也可能来自开发者。</para>

            <para>一旦发起，这个问题就进入了<firstterm>打开（open）</firstterm>状态，因为还没有作出任何行动，一些跟踪系统也将其标示为<firstterm>未验证（unverified）</firstterm>或<firstterm>未开始（unstarted）</firstterm>。它还没有分配给任何人；或者在某些系统中将起分配给一个冒牌用户来表示其还没有真正的分配。此刻，它存在于一个保留区：这个问题已经记录，但是还没有成为项目关注的一部分。</para>
  </listitem>
  <listitem><para>其他人读到这个问题，并做出回复，或许会再向发起者询问来澄清一些问题。</para>
  </listitem>
  
  
  <listitem><para>Bug得到<firstterm>重现（reproduced）</firstterm>。这可能是其生命周期中最重要的一个时刻，尽管bug还没有修正，但发起者之外的人重现这个事实可以证明这个bug的真实性，此外，可以确认原发起者通过报告真实的bug为项目做出了贡献。</para>
  </listitem>
  <listitem><para>Bug得到<firstterm>诊断（diagnosed）</firstterm>：它的原因得到确认，如果可能，会对修正这个bug所需的工作量做出评估。请确认这些内容会在问题中得到记录；如果诊断人要离开项目一会儿（对于志愿开发者这很普遍），其他人应该能够接手。</para>

            <para>在本阶段，或者前一个阶段，开发者可以“获取”问题所有权并将其<firstterm>分配（assign）</firstterm>给自己（<phrase
            output="printed"><xref linkend="managing-volunteers"/>的</phrase><xref
            linkend="delegation-assignment"/>详细描述了分配过程的细节）。问题<firstterm>优先级（priority）</firstterm>也可以在本阶段设置，例如，如果某个问题严重到足以影响下一个版本的及时发布，则需要尽早标示出来，跟踪系统必须能够使其突出显示。</para>
  </listitem>
  <listitem><para>问题纳入解决的日程（schedule），纳入日程并不是意味着规定一个解决的日期，有时候只是决定未来的那个版本（下一个版本不是必须的）必须解决这个bug，或者这个bug将会阻碍哪些特定版本。如果很容易修正，也可以取消纳入日程这一步。
  </para>
  </listitem>
  <listitem><para>Bug得到修正（任务完成、或应用了补丁、或者其他类似的事情），变更或者变更集必须记录在问题的回复中，其后是问题被标注为<firstterm>解决（resolved）</firstterm>而得到<firstterm>关闭（closed）</firstterm>。</para>
  </listitem>
</orderedlist>

</para>

<para>这个生命周期有许多变化，有时候一个问题再发起之后很快就会关闭，例如发现它不是一个bug，而只是部分用户的误解。随着项目获得了越来越多的用户，就会带来更多无效的问题，开发者会通过日益缺乏耐心的回应来关闭这些问题。要尝试预防这后一种趋势，这对谁都没有好处，每个案例中的每个单独用户对于此前的无效问题没有任何责任；统计学的趋势只是从开发者而不是用户的视点有效。（<phrase output="printed">在本章后的</phrase><xref linkend="bug-filtering"/>将会看到减少这种无效问题的技巧。）另外，如果不同的用户反复经历同样的误解，这或许意味着软件的某方面需要重新设计。如果有一个问题经理监视着bug数据库，就会很容易发现这种模式；见<phrase output="printed"><xref linkend="managing-volunteers"/>的</phrase><xref linkend="issue-manager"/>。
</para>

<para>生命周期的另一种常见变种是问题在步骤1之后直接以<firstterm>重复（duplicate）</firstterm>状态关闭，重复是某人发起了一个项目已知的问题。重复不仅限于开放的问题：它也可能来自已经修正的bug重现（这个称为<firstterm>衰退（regression）</firstterm> ），无论何种情况最佳的解决方式是重新打开最初的问题，并将新的报告复制到最初的问题中。bug跟踪系统应当能够双向保持联系，这样重复的重现信息中就可以在原问题中看到，反之亦然。</para>

<para>开发者关闭这个问题的第三种情况是他们认为已经修正了问题，只是让原报告者拒绝这个修正并重新打开它。这通常仅仅是因为开发者不能访问重现bug的环境，或者因为他们不能通过报告者的再现描述测试这个修正。</para>

<para>除了这些情况，不同的跟踪软件也有一些其它小的生命周期细节，但基本的生命周期是相同的，生命周期本身并不特定于开源软件，这暗示了开源项目如何使用他们的bug跟踪系统。</para>

<para>就像步骤1暗示的，跟踪系统和邮件列表或网页一样，是项目的门面。任何人可以发起一个问题，任何人可以浏览当前打开的问题列表。由此我们也能推断我们无法知道有多少人在等待给定问题的进展，而开发社区的规模和技巧限制了问题解决得速率，项目至少应该知道每个出现的问题。即使问题会缓慢小时，一个回复也会鼓励报告者保持参与，因为她能感觉到有人已经为其所作的事情登记（请牢记填写一份问题远比发一封邮件更麻烦）。此外，一旦开发者看到一个问题，它就进入了项目的意识中 ，也就是开发者会查看此问题的类似情况，或者会与其他开发者讨论，等等。</para>

<para>及时反应的需求意味着两件事：

<itemizedlist>
  <listitem>
    <para>跟踪系统必须能够连接到邮件列表，这样问题的每个变更，包括初始的填写，都会导致描述发生情况的邮件。这些邮件列表通常与通常的开发列表不同，因为不是所有的开发者会希望接收自动bug邮件，但是（就像提交邮件）Reply-to头应该设置为开发邮件列表。</para>
  </listitem>
  <listitem>
    <para>填写问题的表单一定能够捕捉开发者的邮件列表，这样她可以联系到更多信息。（然而，它不应当<emphasis>要求</emphasis>输入报告者的邮件地址，因为一些人喜欢匿名报告问题，匿名访问的重要性可以看<phrase output="printed">本章后面的</phrase><xref linkend="anonymity"/>。）</para>
  </listitem>
</itemizedlist>

</para>

<sect2 id="bug-tracker-mailing-list-interaction">
<title>与邮件列表交互</title>

<para>请确保bug跟踪系统不会成为讨论论坛。尽管让人参与bug跟踪很重要，但从根本上它不适合实时讨论。更应该将其当作归档，组织证据和其他讨论（通常发生在邮件列表）的引用。</para>

<para>做出这种区别有两个原因，首先，bug跟踪系统的使用比邮件列表（或者实时讨论论坛）更加笨拙，这不是因为bug跟踪系统都没有好的用户界面设计，是因为它们的界面设计用来捕捉和展示分离的状态，而不是自由流动的讨论。第二，不是每个参与到特定问题讨论的人都必须注意bug跟踪系统。优良的问题管理（见<phrase output="printed"><xref linkend="managing-volunteers"/>的</phrase><xref linkend="share-management"/>）是让每个问题被恰当的人注意到，而不是让所有的开发者监视所有的问题。在<phrase output="printed"><xref linkend="communications"/>的</phrase><xref linkend="bug-tracker-usage"/>，我们会关注确保人们不会脱离合适的论坛而陷入在bug跟踪系统内讨论的问题。</para>

<para>有一些bug跟踪系统可以监控邮件列表并自动记录关于已知问题的邮件，他们通常是通过在邮件列表中，将邮件标题出现的问题标示号码作为特殊字符串来识别问题；开发者学着在他们的邮件中包含这类字符串来触动跟踪系统的注意。bug跟踪系统可以保存整个邮件，或（更好一点）只是记录邮件在邮件列表归档中的链接，无论何种方式，这是一个非常有用的特性；如果你的跟踪系统有这个功能，要确保在开启它的同时提醒人们利用这个特性。</para>

</sect2>

<sect2 id="bug-filtering">
<title>Bug跟踪的预过滤</title>

<para>大多数问题数据库最终会遭遇相同的困境：由好心但没经验或消息不灵通用户所发起的重复和无效问题的洪流。与这种趋势斗争的第一步通常是在bug跟踪系统的前页放置一个显著的提醒，解释如何知道一个bug是否确实是bug、如何查找bug是否已经被发起、以及如果依然认为是新bug时如何有效的报告。</para>

<para>这会暂时减少噪音，但是当用户数增加后，问题还是会出现。每个单独的用户都不应该因此被谴责，即使他们的第一个bug报告没有用处，你还是要鼓励他们保持参与并在以后提出更好的问题。同时，项目需要保持问题数据库的垃圾越少越好。</para>

<para>这两件事可以最大程度的防止这些问题：请确认监视bug跟踪系统的人有足够的知识在问题无效或重复时关闭它，而且能够要求（或足够的勇气）用户在填入跟踪系统前确认他们的bug。</para>

<para>第一种技术看起来被广泛使用，即使项目有巨大的问题数据库（例如，Debian在<ulink url="http://bugs.debian.org/"/>的bug跟踪系统，目前有315,929个问题）也是这样安排的，这样<emphasis>某人</emphasis>进入时就能看到所有的问题，不同的问题类别可能是不同的人。例如，Debian项目包含了一组软件包，这样Debian就能够自动路由每个问题到合适的包维护者。当然，用户有时会把问题类别搞错，这样一开始问题就会发送到错误的人，而他可以再将其转向到其他人。然而，最重要的事情是负担被分担了&mdash;无论用户在填写的时候是对是错，问题监视的任务还是会在开发者之间分配，所以每个问题都能够得到及时的回复。</para>

<para>第二种技术应用的没有那么广泛，可能因为它很难被自动化。本质思想是每个新问题都是经过搭档处理后进入到的数据库中。当用户认为他发现了一个问题，他就会被要求在邮件列表或IRC频道中对其进行描述，然后得到某个人对其是bug确认，尽早引入第二双眼睛可以防止许多虚假的报告。有时候第二方可以识别出这个行为不是一个bug，或者已经在最近的发布中被修正。或者她可能由于类似症状bug而感到熟悉，而且可以通过给用户指明老的问题来防止重复的填写。通常仅仅是询问用户“你查找过bug跟踪系统以确定这个问题是否已经报告过了？”许多用户不会想到这个一点，如果有人<emphasis>期望</emphasis>，你可以愉快的为他们查找一下。</para>

<para>这种伙伴系统确实可以保证问题数据库的清洁，但是也有一些不利的地方。许多用户无论如何也要独立发起问题，对为发起新问题而寻找伙伴的指南看不到或者视而不见。因此，还是需要有志愿者关注问题数据库。此外，因为许多新报告者不理解维护问题数据库的难度，对他们忽略指南的行为进行过于严厉的斥责是不公平的。所以志愿者必须保持警觉，联系如何反弹未经搭档处理的问题给报告者。目标是训练每个报告者在未来使用伙伴系统，这样就有一个日益增长的能够理解问题过滤系统的用户池。当看到一个未经伙伴系统处理的问题时，理想的步骤是：</para>

<orderedlist>
  <listitem>
    <para>立刻回复问题，礼貌的感谢用户的填写，但是向他们指出伙伴系统的操作指南（当然应该在网站的显著位置）。</para>
  </listitem>
  <listitem>
    <para>如果问题是明显有效而且没有重复，想办法证明它，使之开始正常的生命周期。毕竟，报告者没有被告知伙伴系统，所有浪费工作量关闭有效的问题是没有意义的。</para>
  </listitem>
  <listitem>
    <para>否则，如果问题不是很清楚的有效，关闭它，但是要求报告者在得到伙伴的确认后重新打开它，当他们这样做时，他们应当放置一个确认邮件列表线索的引用（例如一个邮件列表归档的URL）。</para>
  </listitem>
</orderedlist>

<para>请记住尽管系统会逐渐改善问题数据库的信/噪比，但是不会阻止误填的发生。完全防止误填的唯一方法是关闭bug跟踪系统，只开放给开发者&mdash;治愈几乎永远比疾病本身更坏。应当接受无效问题的清理是项目日常维护的一部分，并努力得到更多的人们来帮忙。</para>

<para>See also
<xref linkend="issue-manager"/><phrase output="printed"> in
<xref linkend="managing-volunteers"/></phrase>.</para>

</sect2>

</sect1>

<!-- ========================== SECTION =========================== -->
<sect1 id="irc">
<title>IRC / 实时聊天系统</title>

<para>Many projects offer real-time chat rooms using <firstterm>Internet
Relay Chat</firstterm> (<firstterm>IRC</firstterm>), forums where users
and developers can ask each other questions and get instant responses.
While you <emphasis>can</emphasis> run an IRC server from your own
web site, it is generally not worth the hassle.  Instead, do what
everyone else does: run your IRC channels at Freenode
(<ulink url="http://freenode.net/"/>).  Freenode gives you the control
you need to administer your project's IRC
channels,<footnote><para>There is no requirement or expectation that
you donate to Freenode, but if you or your project can afford it,
please consider a contribution.  They are a tax-exempt charity in the
U.S., and they perform a valuable service.</para></footnote> while
sparing you the not-insignificant trouble of maintaining an IRC server
yourself.</para>

<para>The first thing to do is choose a channel name.  The most
obvious choice is the name of your project&mdash;if that's available
at Freenode, then use it.  If not, try to choose something as close to
your project's name, and as easy to remember, as possible.  Advertise
the channel's availabity from your project's web site, so a visitor
with a quick question will see it right away.  For example, this
appears in a prominently placed box at the top of Subversion's home
page:</para>

  <blockquote>
    <para><emphasis>If you're using Subversion, we recommend that you
    join the</emphasis> <literal>users@subversion.tigris.org</literal>
    <emphasis>mailing list, and read the <ulink
    url="http://svnbook.red-bean.com/">Subversion Book</ulink> and
    <ulink
    url="http://subversion.tigris.org/faq.html">FAQ</ulink>.
    You can also ask questions on IRC at</emphasis>
    <literal>irc.freenode.net</literal>
    <emphasis>channel</emphasis>&nbsp;<literal>#svn</literal>.</para>
  </blockquote>

<para>Some projects have multiple channels, one per subtopic.  For
example, one channel for installation problems, another for usage
questions, another for development chat, etc. (<xref
linkend="growth"/><phrase output="printed"> in
<xref linkend="communications"/></phrase> discusses and how to
divide into multiple channels).  When your project is young, there
should only be one channel, with everyone talking together.  Later, as
the user-to-developer ratio increases, separate channels may become
necessary.</para>

<para>How will people know all the available channels, let alone which
channel to talk in?  And when they talk, how will they know what the
local conventions are?</para>

<para>The answer is to tell them by setting the <firstterm>channel
topic</firstterm>.<footnote><para>To set a channel topic, use the
<literal>/topic</literal> command.  All commands in IRC start with
"<literal>/</literal>".  See <ulink url="http://www.irchelp.org/"/> if
you're not familiar with IRC usage and administration; in particular,
<ulink url="http://www.irchelp.org/irchelp/irctutorial.html"/> is an
excellent tutorial.</para></footnote>  The channel topic is a brief
message each user sees when they first enter the channel.  It gives
quick guidance to newcomers, and pointers to further information.  For
example:</para>

<screen>
You are now talking on #svn

Topic for #svn is Forum for Subversion user questions, see also
http://subversion.tigris.org/. || Development discussion happens in
#svn-dev. || Please don't paste long transcripts here, instead use
a pastebin site like http://pastebin.ca/. || NEWS: Subversion 1.1.0
is released, see http://svn110.notlong.com/ for details.
</screen>

<para>That's terse, but it tells newcomers what they need to know.  It
says exactly what the channel is for, gives the project home page (in
case someone wanders into the channel without having first been to the
project web site), mentions a related channel, and gives some guidance
about pasting.</para>

<sidebar id="paste-sites">
<title>Paste Sites</title>

<para>An IRC channel is a shared space: everyone can see what everyone
else is saying.  Normally, this is a good thing, as it allows people
to jump into a conversation when they think they have something to
contribute, and allows spectators to learn by watching.  But it
becomes problematic when someone has to provide a large quantity of
information at once, such as a debugging session transcript, because
pasting too many lines of output into the channel will disrupt other
conversations.</para>

<para>The solution is to use one of the
<firstterm>pastebin</firstterm> or <firstterm>pastebot</firstterm>
sites.  When requesting a large amount of data from someone, ask them
not to paste it into the channel, but instead to go to (for example)
<ulink url="http://pastebin.ca/"/>, paste their data into the form
there, and tell the resulting new URL to the IRC channel.  Anyone can
then visit the URL and view the data.</para>

<para>There are a number of free paste sites available now, too many
for a comprehensive list, but here are some of the ones I've seen used:
<ulink url="http://www.nomorepasting.com/"/>,
<ulink url="http://pastebin.ca/"/>,
<ulink url="http://nopaste.php.cd/"/>
<ulink url="http://rafb.net/paste/"/>
<ulink url="http://sourcepost.sytes.net/"/>,
<ulink url="http://extraball.sunsite.dk/notepad.php"/>,
and
<ulink url="http://www.pastebin.com/"/>.</para>

</sidebar>

<sect2 id="bots">
<title>Bots</title>

<para>Many technically-oriented IRC channels have a non-human member,
a so-called <firstterm>bot</firstterm>, that is capable of storing and
regurgitating information in response to specific commands.
Typically, the bot is addressed just like any other member of the
channel, that is, the commands are delivered by "speaking to" the bot.
For example:</para>

<screen>
&lt;kfogel&gt; ayita: learn diff-cmd = http://subversion.tigris.org/faq.html#diff-cmd
&lt;ayita&gt;  Thanks!
</screen>

<para>That told the bot (who is logged into the channel as ayita) to
remember a certain URL as the answer to the query "diff-cmd".  Now we
can address ayita, asking the bot to tell another user about
diff-cmd:</para>

<screen>
&lt;kfogel&gt; ayita: tell jrandom about diff-cmd
&lt;ayita&gt;  jrandom: http://subversion.tigris.org/faq.html#diff-cmd
</screen>

<para>The same thing can be accomplished via a convenient shorthand:</para>

<screen>
&lt;kfogel&gt; !a jrandom diff-cmd
&lt;ayita&gt;  jrandom: http://subversion.tigris.org/faq.html#diff-cmd
</screen>

<para>The exact command set and behaviors differ from bot to bot.  The
above example is with <literal>ayita</literal>
(<ulink url="http://hix.nu/svn-public/alexis/trunk/"/>), of which
there is usually an instance running in <literal>#svn</literal> at
freenode.  Other bots include Dancer
(<ulink url="http://dancer.sourceforge.net/"/>) and Supybot
(<ulink url="http://supybot.com/"/>).  Note that no special server
privileges are required to run a bot.  A bot is a client program;
anyone can set one up and direct it to listen to a particular
server/channel.</para>

<para>If your channel tends to get the same questions over and over,
I highly recommend setting up a bot.  Only a small percentage of
channel users will acquire the expertise needed to manipulate the bot,
but those users will answer a disproportionately high percentage of
questions, because the bot enables them to respond so much more
efficiently.</para>

</sect2>

<sect2 id="irc-archiving">
<title>Archiving IRC</title>

<para>Although it is possible to archive everything that happens in an
IRC channel, it's not necessarily expected.  IRC conversations may be
nominally public, but many people think of them as informal,
semi-private conversations.  Users may be careless with grammar, and
often express opinions (for example, about other software or other
programmers) that they wouldn't want preserved forever in an online
archive.</para>

<para>Of course, there will sometimes be <emphasis>excerpts</emphasis>
that should be preserved, and that's fine.  Most IRC clients can log a
conversation to a file at the user's request, or failing that, one can
always just cut and paste the conversation from IRC into a more
permanent forum (most often the bug tracker).  But indiscriminate
logging may make some users uneasy.  If you do archive everything,
make sure you state so clearly in the channel topic, and give a URL to
the archive.</para>

</sect2>

</sect1>

<!-- ========================== SECTION =========================== -->
<sect1 id="wikis">
<title>Wikis</title>

<para>A <firstterm>wiki</firstterm> is a web site that allows any
visitor to edit or extend its content; the term "wiki" (from a
Hawaiian word meaning "quick" or "super-fast") is also used to refer
to the software that enables such editing.  Wikis were invented in
1995, but their popularity has really started to take off since 2000
or 2001, boosted partly by the success of Wikipedia (<ulink
url="http://www.wikipedia.org/"/>), a wiki-based free-content
encyclopedia.  Think of a wiki as falling somewhere between IRC and
web pages: wikis don't happen in realtime, so people get a chance to
ponder and polish their contributions, but they are also very easy to
add to, involving less interface overhead than editing a regular web
page.</para>

<para>Wikis are not yet standard equipment for open source projects,
but they probably will be soon.  As they are relatively new
technology, and people are still experimenting with different ways of
using them, I will just offer a few words of caution here&mdash;at
this stage, it's easier to analyze misuses of wikis than to analyze
their successes.</para>

<para>If you decide to run a wiki, put a lot of effort into having a
clear page organization and pleasing visual layout, so that visitors
(i.e., potential editors) will instinctively know how to fit in their
contributions.  Equally important, post those standards on the wiki
itself, so people have somewhere to go for guidance.  Too often, wiki
administrators fall victim to the fantasy that because hordes of
visitors are individually adding high quality content to the site,
the sum of all these contributions must therefore also be of high
quality.  That's not how web sites work.  Each individual page or
paragraph may be good when considered by itself, but it will not be
good if embedded in a disorganized or confusing whole.  Too often,
wikis suffer from:</para>

<itemizedlist>
  <listitem>
     <para><emphasis role="bold">Lack of navigational principles.</emphasis>
     A well-organized web site makes visitors feel like they know
     where they are at any time.  For example, if the pages are
     well-designed, people can intuitively tell the difference
     between a "table of contents" region and a "content" region.
     Contributors to a wiki will respect such differences too, but
     only if the differences are present to begin with.</para>
  </listitem>
  <listitem>
     <para><emphasis role="bold">Duplication of information.</emphasis>
     Wikis frequently end up with different pages saying similar
     things, because the individual contributors did not notice the
     duplications.  This can be partly a consequence of the lack of
     navigational principles noted above, in that people may not find
     the duplicate content if it is not where they expect it to
     be.</para>
  </listitem>
  <listitem>
     <para><emphasis role="bold">Inconsistent target audience.</emphasis>
     To some degree this problem is inevitable when there are so many
     authors, but it can be lessened if there are written guidelines
     about how to create new content.  It also helps to aggressively
     edit new contributions at the beginning, as an example, so that
     the standards start to sink in.</para>
  </listitem>
</itemizedlist>

<para>The common solution to all these problems is the same: have
editorial standards, and demonstrate them not only by posting them,
but by editing pages to adhere to them.  In general, wikis will
amplify any failings in their original material, since contributors
imitate whatever patterns they see in front of them.  Don't just
set up the wiki and hope everything falls into place.  You must also
prime it with well-written content, so people have a template to
follow.</para>

<para>The shining example of a well-run wiki is Wikipedia, though this
may be partly 
because the content (encyclopedia entries) is naturally well-suited to
the wiki format.  But if you examine Wikipedia closely, you'll see
that its administrators laid a <emphasis>very</emphasis> thorough
foundation for cooperation.  There is extensive documentation on how
to write new entries, how to maintain an appropriate point of view,
what sorts of edits to make, what edits to avoid, a dispute resolution
process for contested edits (involving several stages, including
eventual arbitration), and so forth.  They also have authorization
controls, so that if a page is the target of repeated inappropriate
edits, they can lock it down until the problem is resolved.  In other
words, they didn't just throw some templates onto a web site and hope
for the best.  Wikipedia works because its founders thought carefully
about how to get thousands of strangers to tailor their writing to a
common vision.  While you may not need the same level of preparedness
to run a wiki for a free software project, the spirit is worth
emulating.</para>

<para>For more information about wikis, see
<ulink url="http://en.wikipedia.org/wiki/Wiki"/>.  Also, the first
wiki remains alive and well, and contains a lot of discussion about
running wikis: see <ulink
url="http://www.c2.com/cgi/wiki?WelcomeVisitors"/>, 
<ulink url="http://www.c2.com/cgi/wiki?WhyWikiWorks"/>, and
<ulink url="http://www.c2.com/cgi/wiki?WhyWikiWorksNot"/> for
various points of view.</para>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="web-site">
<title>Web Site</title>

<para>There is not much to say about setting up the project web site
from a technical point of view: setting up a web server and writing
web pages are fairly simple tasks, and most of the important things to
say about layout and arrangement were covered in the previous chapter.
The web site's main function is to present a clear and welcoming
overview of the project, and to bind together the other tools (the
version control system, bug tracker, etc.).  If you don't have the
expertise to set up a web server yourself, it's usually not hard to
find someone who does and is willing to help out.  Nonetheless, to
save time and effort, people often prefer to use one of the canned
hosting sites.</para>

<sect2 id="canned-hosting">
<title>Canned Hosting</title>

<para>There are two main advantages to using a canned site.  The first
is server capacity and bandwidth: their servers are beefy boxes sitting
on really fat pipes.  No matter how successful your project gets,
you're not going to run out of disk space or swamp the network
connection.  The second advantage is simplicity.  They have already
chosen a bug tracker, a version control system, a mailing list manager,
an archiver, and everything else you need to run a site.  They've
configured the tools, and are taking care of backups for all the data
stored in the tools.  You don't need to make many decisions.  All you
have to do is fill in a form, press a button, and suddenly you've got
a project web site.</para>

<para>These are pretty significant benefits.  The disadvantage, of
course, is that you must accept <emphasis>their</emphasis> choices and
configurations, even if something different would be better for your
project.  Usually canned sites are adjustable within certain narrow
parameters, but you will never get the fine-grained control you would
have if you set up the site yourself and had full administrative
access to the server.</para>

<para>A perfect example of this is the handling of generated files.
Certain project web pages may be generated files&mdash;for example,
there are systems for keeping FAQ data in an easy-to-edit master
format, from which HTML, PDF, and other presentation formats can be
generated.  As explained in
<xref linkend="version-everything"/><phrase output="printed">
earlier in this chapter</phrase>,
you wouldn't want to version the generated formats, only the master
file.  But when your web site is hosted on someone else's server, it
may be impossible to set up a custom hook to regenerate the online
HTML version of the FAQ whenever the master file is changed.  The only
workaround is to version the generated formats too, so that they show
up on the web site.</para>

<para>There can be larger consequences as well.  You may not have as
much control over presentation as you would wish.  Some of the canned
hosting sites allow you to customize your web pages, but the site's
default layout usually ends up showing through in various awkward
ways.  For example, some projects that host themselves at SourceForge
have completely customized home pages, but still point developers to
their "SourceForge page" for more information.  The SourceForge page
is what would be the project's home page, had the project not used a
custom home page.  The SourceForge page has links to the bug tracker,
the CVS repository, downloads, etc.  Unfortunately, a SourceForge page
also contains a great deal of extraneous noise.  The top is a banner
ad, often an animated image.  The left side is a vertical arrangement
of links of little relevance to someone interested in the project.
The right side is often another advertisement.  Only the center of the
page is devoted to truly project-specific material, and even that is
arranged in a confusing way that often makes visitors unsure of what
to click on next.</para>

<para>Behind every individual aspect of SourceForge's design, there is
no doubt a good reason&mdash;good from SourceForge's point of view,
such as the advertisements.  But from an individual project's point of
view, the result can be a less-than-ideal web page.  I don't mean to
pick on SourceForge; similar concerns apply to many of the canned
hosting sites.  The point is that there's a tradeoff.  You get relief
from the technical burdens of running a project site, but only at the
price of accepting someone else's way of running it.</para>

<para>Only you can decide whether canned hosting is best for your
project.  If you choose a canned site, leave open the option of
switching to your own servers later, by using a custom domain name for
the project's "home address".  You can forward the URL to the canned
site, or have a fully customized home page at the public URL and hand
users off to the canned site for sophisticated functionality.  Just
make sure to arrange things such that if you later decide to use a
different hosting solution, the project's address doesn't need to
change.</para>

<sect3 id="canned-hosting-choosing">
<title>Choosing a canned hosting site</title>

<para>The largest and most well-known hosting site is <ulink
url="http://www.sourceforge.net/">SourceForge</ulink>.  Two other
sites providing the same or similar services are <ulink
url="http://savannah.gnu.org/">savannah.gnu.org</ulink> and <ulink
url="http://www.berlios.de/">BerliOS.de</ulink>.  A few organizations,
such as the <ulink url="http://www.apache.org/">Apache Software
Foundation</ulink> and <ulink
url="http://www.tigris.org/">Tigris.org</ulink><footnote><para>Disclaimer:
I am employed by <ulink
url="http://www.collab.net/">CollabNet</ulink>, which sponsors
Tigris.org, and I use Tigris regularly.</para></footnote>, give free
hosting to open source projects that fit well with their missions and
their community of existing projects.</para>

<para>Haggen So did a thorough evaluation of various canned hosting
sites, as part of the research for his Ph.D. thesis,
<citetitle>Construction of an Evaluation Model for Free/Open Source
Project Hosting (FOSPHost) sites</citetitle>.  The results are at
<ulink url="http://www.ibiblio.org/fosphost/"/>, and see especially
the very readable comparison chart at <ulink
url="http://www.ibiblio.org/fosphost/exhost.htm"/>.</para>

</sect3>

<sect3 id="anonymity">
<title>Anonymity and involvement</title>

<para>A problem that is not strictly limited to the canned sites, but
is most often found there, is the abuse of user login functionality.
The functionality itself is simple enough: the site allows each
visitor to register herself with a username and password.  From
then on it keeps a profile for that user, and project administrators
can assign the user certain permissions, for example, the right to
commit to the repository.</para>

<para>This can be extremely useful, and in fact it's one of the prime
advantages of canned hosting.  The problem is that sometimes user
login ends up being required for tasks that ought to be permitted to
unregistered visitors, specifically the ability to file issues in the
bug tracker, and to comment on existing issues.  By requiring a
logged-in username for such actions, the project raises the
involvement bar for what should be quick, convenient tasks.  Of
course, one wants to be able to contact someone who's entered data
into the issue tracker, but having a field where she can enter her
email address (if she wants to) is sufficient.  If a new user spots a
bug and wants to report it, she'll only be annoyed at having to fill
out an account creation form before she can enter the bug into the
tracker.  She may simply decide not to file the bug at all.</para>

<para>The advantages of user management generally outweigh the
disadvantages.  But if you can choose which actions can be done
anonymously, make sure not only that <emphasis>all</emphasis>
read-only actions are permitted to non-logged-in visitors, but also
some data entry actions, especially in the bug tracker and, if you
have them, wiki pages.</para>

</sect3>

</sect2>

</sect1>


<!-- ======================== SECTION ============================== -->


</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->

