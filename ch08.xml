<chapter id="pfs-ch-8">

<title>Managing Volunteers</title>

<simplesect>

<para>Getting people to agree on what a project needs, and to work
together to achieve it, requires more than just a genial atmosphere
and a lack of obvious dysfunction.  It requires someone, or several
someones, consciously managing all the people involved.  Managing
volunteers may not be a technical craft in the same sense as computer
programming, but it is a craft in the sense that it can be improved
through study and practice.  This chapter is a grab-bag of specific
techniques for managing volunteers.  It draws, perhaps more heavily
than previous chapters, on the Subversion project as a case study,
partly because I am working on that project as I write this and have
all the primary sources close at hand, and partly because it's more
acceptable to cast critical stones into one's own glass house than
into others'.  But I have also seen in various other projects the
benefits of applying&mdash;and consequences of not applying&mdash;the
recommendations that follow; when it is politically feasible to give
examples from some of those other projects, I will do so.</para>

<para>Speaking of politics, this is as good a time as any to drag that
much-maligned word out for a closer look.  Many engineers like to
think of politics as something other people engage in.
"<emphasis>I'm</emphasis> just advocating the best course for the
project, but <emphasis>she's</emphasis> raising objections for
political reasons."  I believe this distaste of politics (or of what
is imagined to be politics) is especially strong in engineers because
engineers are bought into the idea that some solutions are objectively
superior to others.  Thus, when someone acts in a way that seems
motivated by other considerations&mdash;say, the maintenance of their
own position of influence, or the lessening of someone else's
influence, or outright horse-trading, or avoiding hurting someone's
feelings&mdash;other participants in the project may get annoyed.  Of
course, this rarely prevents those others from behaving in the same
way when their own vital interests are at stake.</para>

<para>If you consider "politics" a dirty word, and hope to keep your
project free of it, give up right now.  Politics are inevitable
whenever people have to cooperatively manage a shared resource.  It is
absolutely rational that one of the considerations going into each
person's decision-making processes is the question of how a given
action might affect their own future influence in the project.  After
all, if you trust your own judgement and skills, as most programmers
do, then the potential loss of future influence has to be considered a
technical result, in a sense.  Similar reasoning applies to other
behaviors that might seem on their face like "pure" politics.  In
fact, there is no such thing as pure politics: it is precisely because
actions have real-world consequences that people become politically
conscious in the first place.  Politics is, in the end, simply an
acknowledgement that <emphasis>all</emphasis> consequences of
decisions must be taken into account.  If a particular decision leads
to a result that most participants find technically satisfying, but
involves a change in power relationships that leaves key people
feeling isolated, then the latter is just as important a result as the
former.  To fail to consider it would not be high-minded, but
short-sighted.</para>

<para>So as you read the advice that follows, and as you work with
your own project, remember that there is <emphasis>no one</emphasis>
who is not playing politics.  Appearing to be above politics is merely
one particular political strategy, and sometimes a very useful one,
but it is never the reality.  Politics is simply what happens when
people disagree, and successful projects are those that evolve
political mechanisms for managing disagreement constructively.</para>

</simplesect>

<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-volunteers">
<title>Getting the Most Out of Volunteers</title>

<para>Why do volunteers work on free software projects?</para>

<para>When asked, many claim they do it because they want to produce
good software, or want to be personally involved in fixing the bugs
that matter to them.  But these reasons are usually not the whole
story.  After all, could you imagine a volunteer staying with a
project even if no one ever said a word in appreciation of her work,
or listened to her in discussions?  Of course not.  Clearly, people
spend time on free software for reasons beyond just an abstract desire
to produce good code.  Understanding volunteers' true motivations will
help you arrange things so as to attract and keep them.  The desire to
produce good software may be among those motivations, along with the
challenge and educational value of working on hard problems.  But
humans also have a built-in desire to work with other humans, and to
give and earn respect through cooperative activities.  Groups engaged
in cooperative activities must evolve norms of behavior such that
status is acquired and kept through actions which help the group's
goals.  Those norms won't always arise by themselves.  There are
projects&mdash;experienced open source developers can probably name
several off the tops of their heads&mdash;in which people apparently
feel that status is acquired by posting frequently and verbosely, for
example.  They don't come to this conclusion accidentally; they come
to it because they are rewarded with respect for making long,
articulate arguments, whether or not that actually helps the project.
Following are some techniques for creating an atmosphere in which
status-acquiring actions are also constructive actions.</para>

<!-- ======================== subsection ============================== -->
<sect2 id="pfs-delegation">
<title>Delegation</title>

<para>Delegation is not merely a way to spread the workload around; it
is also a political and social tool.  Consider all the effects when
you ask someone to do something.  The most obvious effect is that, if
she accepts, she does the task and you don't.  But another effect is
that she is made aware that you trusted her to handle the task.
Furthermore, if you made the request in a public forum, then she knows
that others in the group have been made aware of that trust too.  She
may also feel some pressure to accept, depending on how you asked, and
if she doesn't really want the job, this can become a source of
resentment.  The task may require coordination with others in the
project, in which case you are effectively proposing that this person
become more involved, form bonds that might not otherwise have been
formed, and perhaps become a source of authority in some subdomain of
the project.  The added involvement may be daunting, or it may lead
the person to become engaged in other ways as well, from an increased
feeling of overall commitment.</para>

<para>Because of all these effects, it often makes sense to ask
someone else to do something even when you know you could do it faster
or better yourself.  Of course, there is sometimes a strict economic
efficiency argument for this anyway: perhaps the opportunity cost of
doing it yourself would be too high&mdash;there might be something
even more important you could do with that time.  But even when the
opportunity cost argument doesn't apply, you may
<emphasis>still</emphasis> want to ask someone else to take on the
task, because in the long run you want to draw that person deeper into
the project, even if it means spending extra time watching over them
at first.  Delegation is not just about getting things done, it's also
about drawing people into a closer committment to the project.</para>

<sect3 id="pfs-delegation-assignment">
<title>Distinguish clearly between inquiry and assignment</title>

<para>Sometimes it is fair to expect that a person will accept a
particular task.  For example, if someone writes a bug, or commits
some code that fails to comply with project guidelines in some obvious
way, then it is enough to point out the problem and thereafter behave
as though you assume the person will take care of it.  But there are
other situations where it is by no means clear that you have a right
to expect action.  The person may do as you ask, or may not.  Since no
one wants to be taken for granted, you need to be be sensitive to the
difference between these two types of situations, and tailor your
requests accordingly.</para>

<para>One thing that almost always causes people instant annoyance is
being asked to do something in a way that implies that you think it is
clearly their responsibility to do it, when they feel otherwise.  For
example, assignment of incoming issues is particularly fertile ground
for this kind of annoyance.  The participants in a project usually
know who is expert in what areas, so when a bug report comes in, there
will often be one or two people whom everyone knows could probably fix
it quickly.  However, if you assign the issue over to one of those
people without their prior permission, they may feel they have been
put into an uncomfortable position.  They sense the pressure of
expectation, but also may feel that they are, in effect, being
punished for their expertise.  After all, the way one acquires
expertise is by fixing bugs, so perhaps someone else should take this
one!  (Note that issue trackers that automatically assign issues to
particular people based on information in the bug report are less
likely to offend, because everyone knows that the assignment was made
by an automated process, and is not an indication of human
expectations.)</para>

<para>While it would be nice to spread the load as evenly as possible,
there are certain times when you just want to encourage the person who
can fix a bug the fastest to do so.  Given that you can't afford a
communications turnaround for every such assignment ("Would you be
willing to look at this bug?"  "Yes."  "Okay, I'm assigning the issue
over to you then." "Okay."), you should simply make the assignment in
the form of an inquiry, conveying no pressure.  Virtually all issue
trackers allow a comment to be associated with the assignment of an
issue.  In that comment, you can say something like this:</para>

<blockquote>
   <para>Assigning this over to you, jrandom, because you're most
   familiar with this code.  Feel free to bounce this back if you
   don't have time to look at it, though.  (And let me know if you'd
   prefer not to receive such requests in the future.)</para>
</blockquote>

<para>This distinguishes clearly between the
<emphasis>request</emphasis> for assignation and the
recipient's <emphasis>acceptance</emphasis> of that assignation.  The
audience isn't only the assignee, it's everyone: both the assignee and
the group see a public confirmation of the assignee's expertise, but
the message makes it clear that it's up to the assignee whether or not
to accept the responsibility.</para>

</sect3>

<sect3 id="pfs-delegation-followup">
<title>Follow up after you delegate</title>

<para>When you ask someone to do something, remember that you have
done so, and follow up no matter what.  Most requests are made in
public forums, and are roughly of the form "Can you take care of X?
Let us know either way; no problem if you can't, just need to know."
You may or may not get a response.  If you do, and the response is
negative, then the loop is closed&mdash;you'll need to try some other
strategy for dealing with X.  If there is a positive response, then
keep an eye out for progress on the issue, and comment on the progress
you do or don't see (everyone works better when they know someone else
is appreciating their work).  If there is no response, then after a
few days, ask again, or just post saying that you got no response and
are looking for someone else to do it.  Or just do it yourself, but
still make sure to say that you got no response to the initial
inquiry.</para>

<para>The purpose of publicly noting the lack of response is
<emphasis>not</emphasis> to humiliate the person, and your remarks
should be phrased so as never to have that effect.  The purpose is
simply to show that you keep track of what you have asked for, and
that you notice the reactions you get.  This makes people more likely
to say yes next time, because they will observe (even if only
unconsciously) that you are likely to notice any work they do, given
that you noticed the much less visible event of someone failing to
respond.</para>

</sect3>

<sect3 id="pfs-delegation-interest">
<title>Notice what people are interested in</title>

<para>Another thing that makes people happy is to have their interests
noticed&mdash;in general, the more aspects of someone's personality
you notice and remember, the more comfortable they will be, and the
more they will want to work with groups of which you are a
part.</para>

<para>For example, there was a sharp distinction in the Subversion
project between people who wanted to reach a definitive 1.0 release
(which we eventually did), and people who mainly wanted to add new
features and work on interesting problems but who didn't much care
when 1.0 came out.  Neither of these positions is better or worse than
the other; they're just two different kinds of developers, and both
kinds do lots of work on the project.  But we swiftly learned that it
was important to <emphasis>not</emphasis> assume that the excitement
of the 1.0 drive was shared by everyone.  Electronic media can be very
deceptive: you may sense an atmosphere of shared purpose, when in fact
it's shared only by the people you happen to have been talking to,
while others have completely different priorities.</para>

<para>The more aware you are of what people want out of the project,
the more effectively you can make requests of them.  Even just
demonstrating an understanding of what they want, without making any
associated request, is useful, in that it confirms to each person that
they're not just another particle in an undifferentiated mass.</para>

</sect3>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="pfs-praise-and-criticism">
<title>Praise and Criticism</title>

<para>Praise and criticism are more similar than they are different.
Both are primarily forms of attention, and are most effective when
specific rather than generic.  Both should be deployed with concrete
goals in mind.  Both can be diluted by inflation: praise too much or
too often and you will devalue your praise; the same can be true for
criticism, though in practice criticism is usually reactive and
therefore somewhat more resistant to devaluation.</para>

<para>An important feature of technical culture is that detailed,
dispassionate criticism is often taken as a kind of praise (as
discussed in <xref linkend="pfs-rudeness"/>), because of the
implication that the recipient's work is worth the time required to
analyze it.  However, both of those
conditions&mdash;<emphasis>detailed</emphasis>,
<emphasis>dispassionate</emphasis>&mdash;must be met for this to be
true.  For example, if someone makes a sloppy change to the code, it
is useless (actually, harmful) to follow up saying simply "That was
sloppy."  Sloppiness is ultimately a characteristic of a
<emphasis>person</emphasis>, not of their work, and it's important to
keep your reactions focussed on the work.  It's much more effective to
describe all the things wrong with the change, tactfully and without
malice.  If this is the third or fourth careless change in a row by
the same person, it's appropriate to say that&mdash;again without
anger&mdash;at the end of your critique, to make it clear that the
pattern has been noticed.</para>

<para>If someone does not improve in response to criticism, the
solution is not more or stronger criticism.  The solution is for the
group to remove that person from the position of incompetence, in a
way that minimizes hurt feelings as much as possible; see
<xref linkend="pfs-committers"/> for example.  That is a rare
occurrence, however.  Most people respond pretty well to criticism
that is specific, detailed, and contains a clear (even if unspoken)
expectation of improvement.</para>

<para><remark>(Is that the right cross-reference above?  Perhaps
<xref linkend="pfs-redelegation"/>, or a combination of the two, would
be better.)</remark></para>

<para>Praise won't hurt anyone's feelings, of course, but that doesn't
mean it should be used any less carefully than criticism.  Praise is a
tool: before you use it, ask yourself <emphasis>why</emphasis> you
want to use it.  As a rule, it's not a good idea to praise people for
doing what they usually do, or for actions that are a normal and
expected part of participating in the group.  If you were to do that,
it would be hard to know when to stop: should you praise
<emphasis>everyone</emphasis> for doing the usual things?  After all,
if you leave some people out, they'll wonder why.  It's much better to
express praise and gratitude sparingly, in response to unusual or
unexpected efforts, with the intention of encouraging more such
efforts.  When a participant seems to have moved permanently into a
state of higher productivity, then adjust your praise threshold for
that person accordingly.  Repeated praise for normal behavior
gradually becomes meaningless anyway.  Instead, that person should
sense that their high level of productivity is now considered normal
and natural for them, and only work that goes beyond even that should
be specially noticed.</para>

<para>This is not to say that the person's contributions shouldn't be
acknowledged, of course.  But remember that if the project is set up
right, everything that person does is already visible anyway, and so
the group will know (and the person will know that the rest of the
group knows) everything she does.  There are also ways to acknowledge
someone's work by means other than direct praise.  You could mention
in passing, while discussing a related topic, that she has done a lot
of work in the given area and is the resident expert there; or you
could publicly consult her on some question about the code; or perhaps
most effectively, you could conspicuously make further use of the work
she has done, so she sees that others are now comfortable relying on
the results of her work.  But it's probably not necessary to do these
things in any calculated way.  Someone who regularly makes large
contributions in a project will know it, and will occupy a position of
influence by default.  There's usually no need to take explicit steps
to ensure this, unless you sense that, for whatever reason, it's not
happening as much as it should.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="pfs-territoriality">
<title>Prevent Territoriality</title>

<para>Watch out for participants who try to stake out exclusive
ownership of certain areas of the project, and who seem to want to do
all the work in those areas, to the extent of taking over work that
others try to do.  Such territoriality may feel healthy at first:
after all, on the surface it looks like someone taking on more
responsibility for a particular area, and often correlates with
increased activity within that area by the person staking the claim.
But in the long run, it is destructive.  When people sense a "no
trespassing" sign, they stay away.  This results in reduced review in
that area, and greater fragility, because the lone developer becomes a
single point of failure.  Worse, it fractures the cooperative,
egalitarian spirit of the project.  The theory must always be that any
developer is welcome to help out on any task at any time.  Of course,
in practice things work a bit differently: people do have areas where
they are more and less influential, and non-experts voluntarily defer
to experts in certain domains of the project.  But the key is that
this is all voluntary: informal authority is granted based on
competence and proven judgement, but it should never be actively
<emphasis>taken</emphasis>.  Even if the person desiring the authority
really is competent, it is still crucial that she hold that authority
informally, through the consensus of the group, and that the authority
never cause her to exclude others from working in that area.
(Rejecting someone's work for technical reasons is an entirely
different matter, of course.)</para>

<para>In order to combat incipient territorialism, or even the
appearance of it, many projects have taken the step of banning the
inclusion of author names or designated maintainer names in source
files.  I wholeheartedly agree with this practice: we do it in the
Subversion project, and other projects that do it include <remark>[get
list from Sander Striker]</remark>.  A software project's source code
files are the core of its identity.  They should reflect the fact that
the developer community as a whole is responsible for them, and never
be divided up into little fiefdoms.</para>

<para>People sometimes argue in favor of author or maintainer tags in
source files, on the grounds that they give visible credit to those
who have done the most work there.  There are two problems with this
argument.  First, the tags inevitably raise the awkward question of
how much work one must do to get one's own name listed there too.
Second, they conflate the issue of credit with that of authority:
having done work in the past does not imply ownership of the area
where the work was done, but it's difficult if not impossible to avoid
such an implication when individual names are listed at the tops of
source files.  In any case, credit information can already be obtained
from the version control logs and other out-of-band recording
mechanisms like mailing list archives, so no information is lost by
banning it from the source files themselves.</para>

<para>If your project decides to keep individual names out of source
files, make sure not to go overboard.  For instance, many projects
have <filename>contrib/</filename> area where small tools and helper
scripts are kept, often written by people who are otherwise not
associated with the project.  It's okay for those files to contain
author names, because they are not really maintained by the project as
a whole.  On the other hand, if a contributed tool starts getting
hacked on by other people in in the project, eventually you may want
to move it to a less separate location and, assuming the original
author approves, remove the author's name, so that the code looks like
any other community-maintained resource.  If the author is sensitive
about this, compromise solutions are fine, for example:</para>

<blockquote>
<programlisting>
# indexclean.py: Remove old data from a Scanley index.
#
# Original Author: K. Maru &lt;kobayashi\@yetanotheremailservice.com&gt;
# Now Maintained By: The Scanley Project &lt;http://www.scanley.org/&gt; and K. Maru.
# 
# ...
</programlisting>
</blockquote>

<para>The important thing is to remember that there is a continuum
between what lies outside the core project and what lies inside it.
The main source code files for the software are clearly inside, and
should be considered as maintained by the community.  On the other
hand, companion tools or pieces of documentation may be the work of
single individuals, who maintain them essentially alone, even though
the works may be associated with or even distributed with the project.
There is no need to apply a one-size-fits-all rule to every file, as
long as the principle that community-maintained resources are not to
be made into individual territories is maintained.</para>

<para><remark>(Another example: inclusion of internal issue numbers in
scarab commits.  Though not strictly about money, it is about the
relationship between internal/profit-driven, and external/volunteer
development.)</remark></para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="pfs-automation">
<title>The Automation Ratio</title>

<para><remark>Never let a human do what a machine could do.  As a rule
of thumb, I think it's worth spending 10x the amount of time needed
for one manual operation on automating that operation.  For example,
handling redundancy (ChangeLogs in CVS, 'cvs log', 'svn log', CIA
logs, etc).  Same information, different presentations.  What if some
pages have to be autogenerated?  Make it bone-simple, and make a
pre-commit hook to check that the regeneration happened.  Whatever
time you have to spend on this, it's worth it.  The badness that can
result if you don't do it is destructive not only because of the
wasted time, but because of the bad feelings and griping that ensue
when humans forget (as they inevitably will) to do what the machine
should have been doing for them anyway.  (Mention cvs2cl for CVS
here?)</remark></para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="pfs-division-of-labor">
<title>Design to Support Division of Labor</title>

<para><remark>How to make the project's architecture support division
among many workers.  (Example: According to Tim [via Andy], Linus said
that he found it easier to get volunteers because he knew how to break
down the functionality or source code into chunks that different
people could handle.)  This will tie into material in Chapter
5(a).</remark></para>

<para><remark>Note the penalty paid by programs with complex or
non-standard build procedures.  They suffer greatly reduced
contribution rates.  Mozilla Firefox is a good example (name a
specific bug annoying me right now, and how I could probably debug it
easily, except that I can't build the danged thing).  [NOTE: there may
be some sections earlier in the book that refer to the old location of
this paragraph, in "pfs-packaging" (?  svn blame -r265 ch07.html will
say for sure), regarding importance of standardized build procedures,
especially in chapter 2.  Search for those and update them to point to
here instead.]</remark></para>

<sect3 id="pfs-automated-testing">
<title>Automated Testing</title>

<para><remark>(Regression testing: choosing the right level of
formality.  Coordinating results from human volunteers.  Spend any
effort to make tests easier to write, it will pay back manyfold.
Importance of the don't-break-the-build concept.)</remark></para>

</sect3>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="pfs-users-to-volunteers">
<title>Treat Every User as a Potential Volunteer</title>

<para><remark>For example: take the time to teach people how to write
a good bug report, and do so publicly at least some of the time.
Corollary: don't get angry at people who file useless reports.  Just
tell them why the report isn't useful, how they can fix it, and then
wait for the next iteration.  Same goes for complaints about missing
features: don't say "talk to the hand", but do point out that it'll
get done faster if they submit a patch (and then make sure to actually
follow up and review patches obtained this way).  [If this gets its
own subsection, then fix up ref in ch 3 bug tracking.]</remark></para>

<para><remark>This strategy depends in part of having a lot of the
"teaching materials" already prepared, such as the all-caps files
(link to live example here), etc.  Make sure to link to them from
appropriate spots.</remark></para>

</sect2>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-share-management">
<title>Share Management Tasks As Well As Technical Tasks</title>

<para> todo </para>

<screen>
   Letting volunteers share the management burden as well as the
   technical burden:

       - patch management
       - bug management
       - release management
       - documentation and FAQ maintenance
       - distributing meta-management tasks. 
       - mailing list moderation
         Note the interface conundrum here: it's more convenient to
         get moderation mails by email, but that makes it harder to
         parallelize, since it's "mail" style not "news" style.  If
         the posts appear somewhere in a centralized list, you have
         the inconvenience of having to go visit that list, but at
         least the list is up-to-date w.r.t. whatever other
         moderation others have done.  Sigh.  (Gnus is actually the
         best candidate, since it can do both mail and news, heh :-)
         However, note that if done as news, there would have to be
         a global reject mark -- once something is evaluated as spam,
         no one should ever have to look at it again.)

</screen>

<para><remark>When discussing managerial aspects of FAQ maintenance,
refer to the Chapter 6 FAQ material at <xref
linkend="pfs-all-as-archives"/>.  Delegate, delegate, delegate: get a
FAQ manager, a human who will be able to follow and sort out a thread,
post a proposed FAQ entry, recognize approval/disapproval and
incorporate comments, and add it to the FAQ.  Comment on the disaster
that is FAQ-o-Matic, at least when it is misapplied.  See <ulink
url="http://osdir.com/Article1722.phtml"/>.  (Does it mention <ulink
url="http://www.bestpractical.com/rtfm/"/>?)</remark></para>

<para><remark>Regarding bug management: full issue sweeps become less
and less feasible over time.  You eventually must evolve a system for
categorizing and prioritizing new issues based on overall context, not
on an O(N^2) comparison with all the other issues in the database.  It
is normal for the bug database to grow slowly but without bound over
time.  This is not a sign of failure.  In general, guard against the
tendency to draw conclusions from bug statistics (or commit
statistics, for that matter).  They are qualitative events, and cannot
be measured quantitatively.</remark></para>

<para><remark>(Note how it's possible to train volunteers to adhere to
very complex development guidelines, if you do it amiably and always
being understanding of slips.  Tell the you-know-who story: remember
being amazed at how they claimed they could never get their paid
employees to adhere to the log message guidelines that we've gotten
virtually all Subversion developers (50+!) to adhere to
<emphasis>voluntarily</emphasis>.</remark></para>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-committers">
<title>Committers</title>

<para><remark>Criteria for adding/removing committers.  Note the
Hippocratic principle.  Refer to the voting system and secrecy
requirements in <xref linkend="pfs-electorate"/>.  Describe how to
boot a committer if absolutely must, but stress importance of not
getting into that situation in the first place.  How to treat dormant
committers: the high school diploma example: your diploma does not
expire, why should commit access?  Commit access is not so much about
knowledge as about judgement and overall techical compentence.  If
someone is away from the project for a long time, that doesn't mean
they lose their judgement, so if/when they come back, they'll
presumably know what they don't know, and commit more conservatively
if that's warranted.  Therefore, removing committers for inactivity is
not necessary.  The committers list should stress, however, that the
order of appearance means nothing, that there are many contributors
not listed, and that committers' levels of activity varies widely, so
checking the logs is the only way to really know what someone's
done.</remark></para>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-redelegation">
<title>The Right Person For the Right Job</title>

<para> When and how to ask someone to step aside from a role for which
they're not suited. (Example: the SVN release manager debacle and how
it was caused it by not being sensitive enough to someone's feelings
and motivations.) </para>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-credit">
<title>Credit</title>

<para><remark>(introduction)</remark></para>


<!-- ======================== subsection ============================== -->
<sect2 id="pfs-crediting">
<title>Why Accurate Crediting Is Crucial</title>
<para> todo </para>
</sect2>


<!-- ======================== subsection ============================== -->
<sect2 id="pfs-displaying-credit">
<title>Techniques for Giving Credit Unobtrusively</title>
<para> todo </para>
</sect2>


<!-- ======================== subsection ============================== -->
<sect2 id="pfs-credit-abuse">
<title>Avoiding "Credit Inflation"</title>

<para><remark>Thanking everybody for everything is boring and
information-free; save the gratitude for the unexpected or impressive
stuff.  Always avoid commit-counting, and debunk it quickly if someone
else starts doing it (story of Steinmetz and the mark here).  In
general, there is always a tension between making sure that people's
individual contributions are recognized, and making the project be a
group effort rather than a collection of individual glories (hmmm,
that thought ought perhaps go at the start of this chapter).  One
guideline is: the more ephemeral the forum, the more okay it is to
thank people by name there.  IRC is great, asides in email discussions
are also okay (make sure that the thankee sees it, though!).  On the
other hand, web pages are a horrible place to do it, and announcement
emails are not a good place either, except in unusual
circumstances.</remark></para>

</sect2>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-forks">
<title>Forks</title>

<para> How to recognize when a fork is inevitable, how to prevent it
when is isn't.  Handling forks both amicable and hostile.  </para>

<para><remark>(In explaining why there is no definitive answer to the
question of "which fork is the true fork", use the obvious
evolutionary analogy.  Point out how people will colloquially talk of
how fork F came out of project P, rather than the reverse, but this is
in effect a declaration of how that speaker feels about it.  When a
large enough percentage of observers agree, then it starts to become
objectively true.  It is fundamentally a matter of perception: that
is, it's not the case that there's an objective truth here but that we
are only imperfectly able to perceive it.  Rather, the perceptions
<emphasis>are</emphasis> the objective truth, since ultimately a
project (or a fork) is an entity that exists only in people's minds
anyway.)</remark></para>

<para><remark>Paragraph lifted from Chapter 4, may eventually have a
place here:</remark></para>

<para><remark>People tend not to use the threat of a fork as an
extremist debating technique&mdash;"Do things my way or I'll fork the
project!"&mdash;because everyone is aware that a fork which fails to
attract developers away from the original project is unlikely to
survive long.  All observers, not just developers but users and
operating system packagers too, will make their own judgement about
which side to choose.  Anyone who would contemplate initiating a fork
knows this, and would therefore want to appear extremely reluctant to
fork, so that if they finally do it, they can credibly claim it was
the only route left.  Whether they were actually reluctant or not
doesn't matter, since fake reluctance has much the same outward effect
as real reluctance.</remark></para>

<para><remark>(Similar logic underlies one's reaction to a fork: you
may be mad, may feel it was unjust, etc.  But if your goal is to
persuade developers that your side is the safest bet, then you want to
appear as non-vindictive as possible.  In war, it sometimes make
strategic sense to force people to choose sides; in free software, it
does not.)</remark></para>

<!-- ======================== subsection ============================== -->
<sect2 id="pfs-forks-case-studies">
<title>Case Studies</title>

<para>todo</para>

<screen>Should these really be their own section?
        [ Case study #1: The GDB maintainership structure debate. ]
        [ Case study #2: FSF Emacs / XEmacs fork (?maybe?) ]
</screen>

</sect2>

</sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->

