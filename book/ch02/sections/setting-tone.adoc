[[setting-tone]]
=== Setting the Tone

So far we've covered one-time tasks you do during project setup: picking
a license, arranging the initial web site, etc. But the most important
aspects of starting a new project are dynamic. Choosing a mailing list
address is easy; ensuring that the list's conversations remain on-topic
and productive is another matter entirely. For example, if the project
is being opened up after years of closed, in-house development, its
development processes will change, and you will have to prepare the
existing developers for that change.

The first steps are the hardest, because precedents and expectations for
future conduct have not yet been set. Stability in a project does not
come from formal policies, but from a shared, hard-to-pin-down
collective wisdom that develops over time. There are often written rules
as well, but they tend to be essentially a distillation of the
intangible, ever-evolving agreements that really guide the project. The
written policies do not define the project's culture so much as describe
it, and even then only approximately.

There are a few reasons why things work out this way. Growth and high
turnover are not as damaging to the accumulation of social norms as one
might think. As long as change does not happen _too_ quickly, there is
time for new arrivals to learn how things are done, and after they
learn, they will help reinforce those ways themselves. Consider how
children's songs survive for centuries. There are children today singing
roughly the same rhymes as children did hundreds of years ago, even
though there are no children alive now who were alive then. Younger
children hear the songs sung by older ones, and when they are older,
they in turn will sing them in front of other younger ones. The children
are not engaging in a conscious program of transmission, of course, but
the reason the songs survive is nonetheless that they are transmitted
regularly and repeatedly. The time scale of free software projects may
not be measured in centuries (we don't know yet), but the dynamics of
transmission are much the same. The turnover rate is faster, however,
and must be compensated for by a more active and deliberate transmission
effort.

This effort is aided by the fact that people generally show up expecting
and looking for social norms. That's just how humans are built. In any
group unified by a common endeavor, people who join instinctively search
for behaviors that will mark them as part of the group. The goal of
setting precedents early is to make those "in-group" behaviors be ones
that are useful to the project; once established, they will be largely
self-perpetuating.

Following are some examples of specific things you can do to set good
precedents. They're not meant as an exhaustive list, just as
illustrations of the idea that setting a collaborative mood early helps
a project tremendously. Physically, every developer may be working alone
in a room by themselves, but you can do a lot to make them _feel_ like
they're all working together in the same room. The more they feel this
way, the more time they'll want to spend on the project. I chose these
particular examples because they came up in the Subversion project
(http://subversion.apache.org/[subversion.apache.org]), which I
participated in and observed from its very beginning. But they're not
unique to Subversion; situations like these will come up in most open
source projects, and should be seen as opportunities to start things off
on the right foot.

[[avoid-private-discussions]]
==== Avoid Private Discussions

Even after you've taken the project public, you and the other founders
will often find yourselves wanting to settle difficult questions by
private communications among an inner circle. This is especially true in
the early days of the project, when there are so many important
decisions to make, and, usually, few volunteers qualified to make them.
All the obvious disadvantages of public list discussions will loom
palpably in front of you: the delay inherent in email conversations, the
need to leave sufficient time for consensus to form, the hassle of
dealing with naive volunteers who think they understand all the issues
but actually don't (every project has these; sometimes they're next
year's star contributors, sometimes they stay naive forever), the person
who can't understand why you only want to solve problem X when it's
obviously a subset of larger problem Y, and so on. The temptation to
make decisions behind closed doors and present them as __faits
accomplis__, or at least as the firm recommendations of a united and
influential voting block, will be great indeed.

Don't do it.

As slow and cumbersome as public discussion can be, it's almost always
preferable in the long run. Making important decisions in private is
like spraying contributor repellant on your project. No serious
contributor would stick around for long in an environment where a secret
council makes all the big decisions. Furthermore, public discussion has
beneficial side effects that will last beyond whatever ephemeral
technical question was at issue:

* The discussion will help train and educate new developers. You never
know how many eyes are watching the conversation; even if most people
don't participate, many may be lurking silently, gleaning information
about the software.
* The discussion will train _you_ in the art of explaining technical
issues to people who are not as familiar with the software as you are.
This is a skill that requires practice, and you can't get that practice
by talking to people who already know what you know.
* The discussion and its conclusions will be available in public
archives forever after, enabling future discussions to avoid retracing
the same steps. See <<using-archives>> in
<<communications>>.

Finally, there is the possibility that someone on the list may make a
real contribution to the conversation, by coming up with an idea you
never anticipated. It's hard to say how likely this is; it just depends
on the complexity of the code and degree of specialization required. But
if anecdotal evidence may be permitted, I would hazard that this is more
likely than you might intuitively expect. In the Subversion project, we
(the founders) believed we faced a deep and complex set of problems,
which we had been thinking about hard for several months, and we frankly
doubted that anyone on the newly created mailing list was likely to make
a real contribution to the discussion. So we took the lazy route and
started batting some technical ideas back and forth in private emails,
until an observer of the projectfootnote:[We haven't gotten to the
section on crediting yet, but just to practice what I'll later preach:
the observer's name was Brian Behlendorf, and he was emphatic about the
general importance of keeping all discussions public unless there was a
specific need for privacy.] caught wind of what was happening and asked
for the discussion to be moved to the public list. Rolling our eyes a
bit, we did—and were stunned by the number of insightful comments and
suggestions that quickly resulted. In many cases people offered ideas
that had never even occurred to us. It turned out there were some _very_
smart people on that list; they'd just been waiting for the right bait.
It's true that the ensuing discussions took longer than they would have
if we had kept the conversation private, but they were so much more
productive that it was well worth the extra time.

Without descending into hand-waving generalizations like "the group is
always smarter than the individual" (we've all met enough groups to know
better), it must be acknowledged that there are certain activities at
which groups excel. Massive peer review is one of them; generating large
numbers of ideas quickly is another. The quality of the ideas depends on
the quality of the thinking that went into them, of course, but you
won't know what kinds of thinkers are out there until you stimulate them
with a challenging problem.

Naturally, there are some discussions that must be had privately;
throughout this book we'll see examples of those. But the guiding
principle should always be: _If there's no reason for it to be private,
it should be public._

Making this happen requires action. It's not enough merely to ensure
that all your own posts go to the public list. You also have to nudge
other people's unnecessarily private conversations to the list too. If
someone tries to start a private discussion with you and there's no
reason for it to be private, then it is incumbent on you to open the
appropriate meta-discussion immediately. Don't even comment on the
original topic until you've either successfully steered the conversation
to a public place, or ascertained that privacy really was needed. If you
do this consistently, people will catch on pretty quickly and start to
use the public forums by default.

[[prevent-rudeness]]
==== Nip Rudeness in the Bud

From the very start of your project's public existence, you should
maintain a zero-tolerance policy toward rude or insulting behavior in
its forums. Zero-tolerance does not mean technical enforcement per se.
You don't have to remove people from the mailing list when they flame
another subscriber, or take away their commit access because they made
derogatory comments. (In theory, you might eventually have to resort to
such actions, but only after all other avenues have failed—which, by
definition, isn't the case at the start of the project.) Zero-tolerance
simply means never letting bad behavior slide by unnoticed. For example,
when someone posts a technical comment mixed together with an _ad
hominem_ attack on some other developer in the project, it is imperative
that your response address the _ad hominem_ attack as a separate issue
unto itself, separate from the technical content.

It is unfortunately very easy, and all too typical, for constructive
discussions to lapse into destructive flame wars. People will say things
in email that they would never say face-to-face. The topics of
discussion only amplify this effect: in technical issues, people often
feel there is a single right answer to most questions, and that
disagreement with that answer can only be explained by ignorance or
stupidity. It's a short distance from calling someone's technical
proposal stupid to calling the person themselves stupid. In fact, it's
often hard to tell where technical debate leaves off and character
attack begins, which is one reason why drastic responses or punishments
are not a good idea. Instead, when you think you see it happening, make
a post that stresses the importance of keeping the discussion friendly,
without accusing anyone of being deliberately poisonous. Such "Nice
Police" posts do have an unfortunate tendency to sound like a
kindergarten teacher lecturing a class on good behavior:

____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
_First, let's please cut down on the (potentially) ad hominem comments;
for example, calling J's design for the security layer "naive and
ignorant of the basic principles of computer security." That may be true
or it may not, but in either case it's no way to have the discussion. J
made his proposal in good faith. If it has deficiencies, point them out,
and we'll fix them or get a new design. I'm sure M meant no personal
insult to J, but the phrasing was unfortunate, and we try to keep things
constructive around here._

_Now, on to the proposal. I think M was right in saying that..._
____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

As stilted as such responses sound, they have a noticeable effect. If
you consistently call out bad behavior, but don't demand an apology or
acknowledgment from the offending party, then you leave people free to
cool down and show their better side by behaving more decorously next
time—and they will.

One of the secrets of doing this successfully is to never make the
meta-discussion the main topic. It should always be an aside, a brief
preface to the main portion of your response. Point out in passing that
"we don't do things that way around here," but then move on to the real
content, so that you're giving people something on-topic to respond to.
If someone protests that they didn't deserve your rebuke, simply refuse
to be drawn into an argument about it. Either don't respond (if you
think they're just letting off steam and don't require a response), or
say you're sorry if you overreacted and that it's hard to detect nuance
in email, then get back to the main topic. Never, ever insist on an
acknowledgment, whether public or private, from someone that they
behaved inappropriately. If they choose of their own volition to post an
apology, that's great, but demanding that they do so will only cause
resentment.

The overall goal is to make good etiquette be seen as one of the
"in-group" behaviors. This helps the project, because developers can be
driven away (even from projects they like and want to support) by flame
wars. You may not even know that they were driven away; someone might
lurk on the mailing list, see that it takes a thick skin to participate
in the project, and decide against getting involved at all. Keeping
forums friendly is a long-term survival strategy, and it's easier to do
when the project is still small. Once it's part of the culture, you
won't have to be the only person promoting it. It will be maintained by
everyone.

[[code-review]]
==== Practice Conspicuous Code Review

One of the best ways to foster a productive development community is to
get people looking at each others' code — ideally, to get them looking
at each others' code _changes_ as those changes arrive. Commit review
(sometimes just called code review) is the practice of reviewing commits
as they come in, looking for bugs and possible improvements.

There are a couple of reasons to focus on reviewing changes, rather than
on reviewing code that's been around for a while. First, it just works
better socially: when someone reviews your change, she is interacting
with work you did recently. That means if she comments on it right away,
you will be maximally interested in hearing what she has to say; six
months later, you might not feel as motivated to engage, and in any case
might not remember the change very well. Second, looking at what changes
in a codebase is a gateway to looking at the rest of the code
anyway — reviewing a change often causes one to look at the surrounding
code, at the affected callers and callees elsewhere, at related module
interfaces, etc.footnote:[None of this is an argument against
top-to-bottom code review, of course, for example to do a security
audit. But while that kind of review is important too, it's more of a
generic development best practice, and is not as specifically relevant
to running an open source project as change-by-change review is.]

Commit review thus serves several purposes simultaneously. It's the most
obvious example of peer review in the open source world, and directly
helps to maintain software quality. Every bug that ships in a piece of
software got there by being committed and not detected; therefore, the
more eyes watch commits, the fewer bugs will ship. But commit review
also serves an indirect purpose: it confirms to people that what they do
matters, because one obviously wouldn't take time to review a commit
unless one cared about its effect. People do their best work when they
know that others will take the time to evaluate it.

Reviews should be public. Even on occasions when I have been sitting in
the same physical room with another developer, and one of us has made a
commit, we take care not to do the review verbally in the room, but to
send it to the appropriate online review forum instead. Everyone
benefits from seeing the review happen. People follow the commentary and
sometimes find flaws in it; even when they don't, it still reminds them
that review is an expected, regular activity, like washing the dishes or
mowing the lawn.

Some technical infrastructure is required to do change-by-change review
effectively. In particular, setting up commit emails is extremely
useful. The effect of commit emails is that every time someone commits a
change to the central repository, an email goes out showing the log
message and diffs (unless the diff is too large; see
<<vc-vocabulary-diff>>, in <<vc-vocabulary>>). The review
itself might take place on a mailing list, or in a review tool such as
Gerrit or the GitHub "pull request" interface. See
<<commit-emails>> in <<technical-infrastructure>> for
details.

[[subversion-commit-review]]
===== Case study

In the Subversion project, we did not at first make a regular practice
of code review. There was no guarantee that every commit would be
reviewed, though one might sometimes look over a change if one were
particularly interested in that area of the code. Bugs slipped in that
really could and should have been caught. A developer named Greg Stein,
who knew the value of code review from past work, decided that he was
going to set an example by reviewing every line of _every single commit_
that went into the code repository. Each commit anyone made was soon
followed by an email to the developer's list from Greg, dissecting the
commit, analyzing possible problems, and occasionally praising a clever
bit of code. Right away, he was catching bugs and non-optimal coding
practices that would otherwise have slipped by without ever being
noticed. Pointedly, he never complained about being the only person
reviewing every commit, even though it took a fair amount of his time,
but he did sing the praises of code review whenever he had the chance.
Pretty soon, other people, myself included, started reviewing commits
regularly too.

What was our motivation? It wasn't that Greg had consciously shamed us
into it. But he had proven that reviewing code was a valuable way to
spend time, and that one could contribute as much to the project by
reviewing others' changes as by writing new code. Once he demonstrated
that, it became expected behavior, to the point where any commit that
didn't get some reaction would cause the committer to worry, and even
ask on the list whether anyone had had a chance to review it yet. Later,
Greg got a job that didn't leave him as much time for Subversion, and
had to stop doing regular reviews. But by then, the habit was so
ingrained for the rest of us as to seem that it had been going on since
time immemorial.

Start doing reviews from very first commit. The sorts of problems that
are easiest to catch by reviewing diffs are security vulnerabilities,
memory leaks, insufficient comments or API documentation, off-by-one
errors, caller/callee discipline mismatches, and other problems that
require a minimum of surrounding context to spot. However, even
larger-scale issues such as failure to abstract repeated patterns to a
single location become spottable after one has been doing reviews
regularly, because the memory of past diffs informs the review of
present diffs.

Don't worry that you might not find anything to comment on, or that you
don't know enough about every area of the code. There will usually be
something to say about almost every commit; even where you don't find
anything to question, you may find something to praise. The important
thing is to make it clear to every committer that what they do is seen
and understood, that attention is being paid. Of course, code review
does not absolve programmers of the responsibility to review and test
their changes before committing; no one should depend on code review to
catch things she ought to have caught on her own.

[[be-open-from-day-one]]
==== Be Open From Day One

Start your project out in the open from the very first day. The longer a
project is run in a closed source manner, the harder it is to open
source later.footnote:[This section started out as a blog post,
http://blog.civiccommons.org/2011/01/be-open-from-day-one/[blog.civiccommons.org/2011/01/be-open-from-day-one],
though it's been edited a lot for inclusion here.]

Being open source from the start doesn't mean your developers must
immediately take on the extra responsibilities of community management.
People often think that "open source" means "strangers distracting us
with questions", but that's optional — it's something you might do down
the road, if and when it makes sense for your project. It's under your
control. There are still major advantages to be had by running the
project out in open, publicly-visible forums from the beginning.
Conversely, the longer the project is run closed-source, the more
difficult it will be to open up later.

I think there's one underlying cause for this:

At each step in a project, programmers face a choice: to do that step in
a manner compatible with a hypothetical future open-sourcing, or do it
in a manner incompatible with open-sourcing. And every time they choose
the latter, the project gets just a little bit harder to open source.

The crucial thing is, they can't help choosing the latter
occasionally — all the pressures of development propel them that way.
It's very difficult to give a future event the same present-day weight
as, say, fixing the incoming bugs reported by the testers, or finishing
that feature the customer just added to the spec. Also, programmers
struggling to stay on budget will inevitably cut corners here and there
(in Ward Cunningham's phrase, they will incur
"http://en.wikipedia.org/wiki/Technical_debt[technical debt]"), with the
intention of cleaning it up later.

Thus, when it's time to open source, you'll suddenly find there are
things like:

* Customer-specific configurations and passwords checked into the code
repository;
* Sample data constructed from live (and confidential) information;
* Bug reports containing sensitive information that cannot be made
public;
* Comments in the code expressing perhaps overly-honest reactions to the
customer's latest urgent request;
* Archives of correspondence among the developer team, in which useful
technical information is interleaved with personal opinions not intended
for strangers;
* Licensing issues due to dependency libraries whose terms might have
been fine for internal deployment (or not even that), but aren't
compatible with open source distribution;
* Documentation written in the wrong format (e.g., that proprietary
internal wiki your department uses), with no easy translation tool
available to get it into formats appropriate for public distribution;
* Non-portable build dependencies that only become apparent when you try
to move the software out of your internal build environment;
* Modularity violations that everyone knows need cleaning up, but that
there just hasn't been time to take care of yet...
* (This list could go on.)

The problem isn't just the work of doing the cleanups; it's the extra
decision-making they sometimes require. For example, if sensitive
material was checked into the code repository in the past, your team now
faces a choice between cleaning it out of the historical revisions
entirely, so you can open source the entire (sanitized) history, or just
cleaning up the latest revision and open-sourcing from that (sometimes
called a "top-skim"). Neither method is wrong or right — and that's the
problem: now you've got one more discussion to have and one more
decision to make. In some projects, that decision gets made and reversed
several times before the final release. The thrashing itself is part of
the cost.

[[avoid-exposure-events]]
===== Waiting Just Creates an Exposure Event

The other problem with opening up a developed code base is that it
creates a needlessly large exposure event. Whatever issues there may be
in the code (modularity corner-cutting, security vulnerabilities, etc),
they are all exposed to public scrutiny at once — the open-sourcing
event becomes an opportunity for the technical blogosphere to pounce on
the code and see what they can find.

Contrast that with the scenario where development was done in the open
from the beginning: code changes come in one at a time, so problems are
handled as they come up (and are often caught sooner, since there are
more eyeballs on the code). Because changes reach the public at a low,
continuous rate of exposure, no one blames your development team for the
occasional corner-cutting or flawed code checkin. Everyone's been there,
after all; these tradeoffs are inevitable in real-world development. As
long as the technical debt is properly recorded in "FIXME" comments and
bug reports, and any security issues are addressed promptly, it's fine.
Yet if those same issues were to appear suddenly all at once,
unsympathetic observers may jump on the aggregate exposure in a way they
never would have if the issues had come up piecemeal in the normal
course of development.

(These concerns apply even more strongly to government software
projects; see <<starting-open-for-govs>> in
<<governments-and-open-source>>.)

The good news is that these are all unforced errors. A project incurs
little extra cost by avoiding them in the simplest way possible: by
running in the open from Day One.

"In the open" means the following things are publicly accessible, in
standard formats, from the first day of the project: the code
repository, bug tracker, design documents, user documentation, wiki, and
developer discussion forums. It also means the code and documentation
are placed under an open source license, of course. It also means your
team's day-to-day work takes place in the publicly visible area.

"In the open" does not have to mean: allowing strangers to check code
into your repository (they're free to copy it into their own repository,
if they want, and work with it there); allowing anyone to file bug
reports in your tracker (you're free to choose your own QA process, and
if allowing reports from strangers doesn't help you, you don't have to
do it); reading and responding to every bug report filed, even if you do
allow strangers to file; responding to every question people ask in the
forums (even if you moderate them through); reviewing every patch or
suggestion posted, when doing so may cost valuable development time;
etc.

One way to think of it is that you're open sourcing your code, not your
time. One of those resources is infinitely replicable, the other is not.
You'll have to determine the point at which engaging with outside users
and developers makes sense for your project. In the long run it usually
does, and most of this book is about how to do it effectively. But it's
still under your control. Developing in the open does not change this,
it just ensures that everything done in the project is, by definition,
done in a way that's compatible with being open source.

[[opening-closed-projects]]
==== When Opening a Formerly Closed Project, be Sensitive to the
Magnitude of the Change

As per <<be-open-from-day-one>>, it's best to
avoid being in the situation of opening up a closed project in the first
place; just start the project in the open if you can. But if it's too
late for that, and you find yourself opening up an existing project that
already has active developers accustomed to working in a closed-source
environment, make sure everyone understands that a big change is
coming—and make sure that you understand how it's going to feel from
their point of view.

Try to imagine how the situation looks to them: formerly, all code and
design decisions were made with a group of other programmers who knew
the software more or less equally well, who all received the same
pressures from the same management, and who all know each others'
strengths and weaknesses. Now you're asking them to expose their code to
the scrutiny of random strangers, who will form judgements based only on
the code, with no awareness of what business pressures may have forced
certain decisions. These strangers will ask lots of questions, questions
that jolt the existing developers into realizing that the documentation
they slaved so hard over is _still_ inadequate (this is inevitable). To
top it all off, the newcomers are unknown, faceless entities. If one of
your developers already feels insecure about his skills, imagine how
that will be exacerbated when newcomers point out flaws in code he
wrote, and worse, do so in front of his colleagues. Unless you have a
team of perfect coders, this is unavoidable—in fact, it will probably
happen to all of them at first. This is not because they're bad
programmers; it's just that any program above a certain size has bugs,
and peer review will spot some of those bugs (see
<<code-review>> earlier in this
chapter). At the same time, the newcomers themselves won't be subject to
much peer review at first, since they can't contribute code until
they're more familiar with the project. To your developers, it may feel
like all the criticism is incoming, never outgoing. Thus, there is the
danger of a siege mentality taking hold among the old hands.

The best way to prevent this is to warn everyone about what's coming,
explain it, tell them that the initial discomfort is perfectly normal,
and reassure them that it's going to get better. Some of these warnings
should take place privately, before the project is opened. But you may
also find it helpful to remind people on the public lists that this is a
new way of development for the project, and that it will take some time
to adjust. The very best thing you can do is lead by example. If you
don't see your developers answering enough newbie questions, then just
telling them to answer more isn't going to help. They may not have a
good sense of what warrants a response and what doesn't yet, or it could
be that they don't have a feel for how to prioritize coding work against
the new burden of external communications. The way to get them to
participate is to participate yourself. Be on the public mailing lists,
and make sure to answer some questions there. When you don't have the
expertise to field a question, then visibly hand it off to a developer
who does—and watch to make sure he follows up with an answer, or at
least a response. It will naturally be tempting for the longtime
developers to lapse into private discussions, since that's what they're
used to. Make sure you're subscribed to the internal mailing lists on
which this might happen, so you can ask that such discussions be moved
to the public lists right away.

There are other, longer-term concerns with opening up formerly closed
projects. <<money>> explores techniques for mixing paid and
unpaid developers successfully, and <<legal>> discusses the
necessity of legal diligence when opening up a private code base that
may contain software written or "owned" by other parties.
