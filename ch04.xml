<chapter id="pfs-ch-4">

<title>Social and Political Infrastructure <!-- [ 15-25 pp ] --></title>

<simplesect>

<para>The first question people usually ask about free software is
"How does it work?  What keeps a project running &mdash; who makes the
decisions?"  I'm always dissatisfied with bland responses about
meritocracy, the spirit of cooperation, code speaking for itself, etc.
The fact is, the question is not easy to answer.  Meritocracy,
cooperation, and running code are all part of it, but they do little
to explain how projects actually run on a day-to-day basis, and say
nothing about how conflicts are resolved.</para>

<para>This chapter tries to show the structural underpinnings
successful projects have in common.  I mean "successful" not just in
terms of technical quality, but also operational health and
survivability.  Operational health is the project's ongoing ability to
incorporate new code contributions and new developers, and to be
responsive to incoming bug reports.  Survivability is the project's
ability to exist independently of any specific participant &mdash;
think of it as the likelihood that the project would continue even if
all of its founding members were to move on to other things.  It is
not hard to achieve initial technical success, but without a robust
developer base and social foundation, a project may be unable to
handle the growth that initial success brings, or the departure of
charismatic individuals.</para>

<para>There are various different ways to achieve this kind of
success.  Some involve a formal governance structure, by which debates
are resolved, new developers are invited in (and sometimes out), new
features chosen, and so on.  Others involve less formal structure, but
more conscious self-restraint, to produce an atmosphere of fairness
that people can rely on as a <foreignphrase>de facto</foreignphrase>
form of governance.  Both ways lead to the same result: a sense of
institutional permanence, supported by habits and procedures that are
well-understood by everyone who participates.  These features are even
more important in self-organizing systems than in centrally-controlled
ones, because in self-organizing systems, everyone is conscious that a
few bad apples can bring the whole thing crashing down, at least for a
while.</para>

<sect2 id="pfs-forkability">
<title>Forkability</title>

<para>The force that binds developers together on a free software
project, and makes them willing to compromise on their own visions for
the software when necessary, is the code's
<firstterm>forkability</firstterm>: the ability of anyone to take a
copy of the source code and use it to start a competing project.  This
is known as <firstterm>forking</firstterm> the code, and the
paradoxical thing is that the <emphasis>possibility</emphasis> of
forks is usually a much greater force in free software projects than
actual forks, which are very rare.  Because a fork is bad for everyone
(for reasons examined in detail in <xref linkend="pfs-forks"/>), the
more serious the threat of a fork becomes, the more willing people are
to compromise to avoid it.  People also tend not to use fork threats
as an extremist debating technique ("Do things my way or I'll fork the
project!"), because everyone is aware that a fork which fails to
seduce developers away from the original project is unlikely to
survive long.  Observers (including not only developers, but also
users and operating system packagers) will make their own judgement
about which side to choose.  Anyone who contemplates initiating a fork
knows this, and will therefore want to appear extremely reluctant to
fork, so that if they finally do it, they can credibly claim it was
the only route left.  Whether or not they were actually reluctant
doesn't matter, since faked reluctance has much the same outward
effect as real reluctance.</para>

<para>Forks, or rather the potential for forks, are the reason there
are no true dictators in free software projects.  This may seem like a
surprising claim &mdash; certainly it's common enough to hear some
developer referred to as the "dictator" or "tyrant" in a given open
source project.  But this kind of tyranny is quite different from the
normal understanding of the word.  Imagine a king who rules over a
kingdom, but with the special proviso that any of his subjects could
duplicate the entire kingdom at any time, and move to the copy to rule
it as they see fit.  Would not such a king govern very differently
from one whose subjects were bound to stay under his rule no matter
what he did?</para>

<para>This is why even projects which are not formally organized as
democracies are, in practice, democracies when it comes to important
decisions.  Replicability implies forkability; forkability implies
consensus.  It may well be that everyone is willing to defer to one
leader (the most famous example being Linus Torvalds in Linux kernel
development), but this is because they <emphasis>choose</emphasis> to
do so, in an entirely non-cynical, non-sinister way.  The dictator has
no magical hold over the project; one of the key properties of any
open source license is that it does not give one party more power than
others in deciding how the code can changed or used.  If the dictator
were to suddenly start making bad decisions, there would be
restlessness, followed eventually by revolt and a fork.  Except, of
course, things rarely get that far, because the dictator compromises
first.</para>

</sect2>

<para>Just because forkability puts an upper limit on how much power
anyone can exert in a project doesn't mean there aren't important
differences in how projects can be governed.  You don't want every
decision to come down to the question of who might be considering a
fork.  That would get tiresome very quickly, and sap energy away from
development efforts.  Below we'll look at two ways to organize
projects such that most decisions go smoothly.  These two examples are
the extremes; most projects fall somewhere along the range between
them.</para>

</simplesect>

<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-benevolant-dictator">
<title>The Benevolent Dictator</title>

<para><remark>(in progress)</remark></para>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-consensus-democracy">
<title>Consensus-based Democracy</title>

<para><remark>(in progress)</remark></para>

<para><remark>Even free software projects which run on the Benevolent
Dictatorship model are not truly centrally-controlled.  Some people
say it all boils down to who has root on the server.  Show why this is
not really true.  Also, difference between formal governance and their
daily practice.  Note that the less governance structure there is, the
more careful senior developers have to be about stomping on newcomers
&mdash; not so much because the target will feel squished, as that
<emphasis>other</emphasis> people will not be willing to come to their
aid, because <emphasis>they</emphasis> will not feel protected by the
"rule of law".</remark></para>

<para><remark>Talk importance of reconsiderability of rules.  If
someone isn't happy with the process and opens a meta-question, it is
important to recognize that they have a right to do that.  If someone
makes a habit of that, then it becomes okay to ignore them (after all,
if people agree, they'll chime in &mdash; not everything requires a
response).</remark></para>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-money">
<title>Money and How to Handle It</title>

<screen>
Conflicts of Interest: In a funded project, the corporation or
consortium supplying the money may have different goals than many of
the volunteers have.  How to balance the funder's interests with the
volunteers' interests without either side becoming disgruntled.  [Case
studies: Subversion, possibly others ]
</screen>

<para><remark>Deleted material from Chapter 1, in the spot which now
just refers to this chapter: "This means that if the project has
corporate sponsorship, it should lay out clear guidelines for how the
sponsor may and may not influence project direction.  For if the
unpaid volunteers get the feeling that design decisions or feature
additions are simply available to the highest bidder, they'll most
likely head off to someplace that seems more like a meritocracy and
less like unpaid labor for someone else's benefit.  Volunteer
developers generally do not mind corporate support for the projects
they work on; in fact, they often welcome it, because it can give the
project a higher chance of surviving.  But they insist, reasonably
enough, on being treated as equal partners."</remark></para>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-written-rules">
<title> Written vs Unwritten Rules </title>

<para> When does a project need a written constitution, and what kind? </para>

<!-- Make sure to talk about the procedures by which a
     contributor gets <firstterm>commit access</firstterm>, that is,
     the ability to put changes directly into the software without
     going through some other developer.)  Refer back to the Mike
     Pilato example. --> 

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-decision-making">
<title> Consensus vs Voting vs Tyranny </title>

<para> Consensus vs voting: the importance of having a voting system,
but also, the importance of rarely using it.  Contrast official
tyranny with de facto tyranny. </para>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-money-vs-love">
<title>Money Can't Buy You Love</title>

<para><remark>(Still deciding if this section belongs here, or
somewhere in Chapter 5.  For now, here, as I think it's one of the
better examples, so might as well put it sooner rather than
later.)</remark></para>

<para>Free software projects today are funded by a wide variety of
methods.  There are</para>

<itemizedlist>
  <listitem>
  <para>Totally unfunded projects, done simply for pleasure or
        personal utility and then released for free.</para>
  </listitem>

  <listitem>
  <para>Projects which are essentially done for the love of it but
        which solicit small-scale donations.</para>
  </listitem>

  <listitem>
  <para>Projects that receive all, or a significant portion of, their
        funding from non-profit organizations (such as the Free
        Software Foundation, the Apache Software Foundation,
        Xiph.org, et al).</para>
  </listitem>

  <listitem>
  <para>Projects that are funded from royalties driven by a
        dual-licencing model (see <xref linkend="pfs-dual-licensing"/>),  
        where those using the software in proprietary products
        subsidize its development for the free world.</para>
  </listitem>

  <listitem>
  <para>Projects which are started and managed by for-profit
        corporations for strategic reasons, for example to drive
        support or hardware sales.</para>
  </listitem>
</itemizedlist>

<para>...and all sorts of outliers and edge cases.</para>

<para>Money can affect a project both positively and negatively.  By
reducing the project's vulnerability the Forces of Chaos, which sweep
away so many projects before they really get off the ground, it can
make people more willing to give the software a chance &mdash; they
feel they're investing their time into something that will be around a
year from now.  On the other hand, if not handled carefully, money can
also divide the project into in-group and out-group developers.</para>

<para>If your project is funded, even partially, then it is very
important for you to set guidelines about what the money can and
cannot buy right, from the start.  This does not mean you need to post
twice a day to the mailing lists reiterating your nobility and
incorruptibility.  It merely means that you should be on the lookout
for opportunities to defuse the tensions that
<emphasis>could</emphasis> be created by money.  You don't need to
start out assuming that the tensions are there; you just need to show
an awareness that there is a potential for them to arise.</para>

<para>A perfect example of this came up in the Subversion project.
Subversion was started in 2000 by <ulink
url="http://www.collab.net/">CollabNet</ulink>, which has been the
project's primary funder since its inception, paying the salaries of
several developers (disclaimer: I'm one of them).  Fairly early in the
project, we hired another developer, Mike Pilato, to join the effort.
By then, coding had already started, although we were still very much
in the early stages.</para>

<para>The question was, how to receive Mike into the public project?
Subversion already had a policy about how new developers get commit
access: first, they submit some patches to the development mailing
list.  After enough patches have gone by for the other committers to
see that the new contributor knows what he's doing, someone proposes
that he just commit directly (this proposal takes place on a closed
mailing list of just committers, so no feelings will be hurt if the
proposal fails).  When the committers agree, someone mails the new
developer and offers him direct commit access to the project's master
sources.</para>

<para>But what about Mike?  CollabNet had hired him specifically to
work on Subversion.  There was no doubt about his coding skills or his
readiness to work on the project.  Furthermore, the non-salaried
developers had a very good relationship with the CollabNet employees,
and most likely would not have objected if we'd just given Mike commit
access the day he was hired.  But we realized we were setting a
precedent.  If we just granted Mike commit access by fiat, we'd be
saying that CollabNet had the right to ignore project guidelines,
simply by virtue of being the primary funder.  While the damage from
this might not have been immediately apparent, it would eventually
result in the non-salaried developers feeling gradually
disenfranchised.  Other people have to earn their commit access
&mdash; CollabNet just buys it.</para>

<para>So Mike agreed to start out his employment at CollabNet like any
other volunteer developer, without commit access.  He sent patches to
the mailing list, where they could be, and were, reviewed by everyone.
Equally importantly, we said on the list that we were doing things
this way deliberately, so there could be no missing the point.  After
a while, someone (I can't remember if it was a CollabNet developer or
not) proposed Mike for commit access, and he was accepted, as everyone
knew he would be.</para>

<para>That kind of consistency gets you a credibility that money could
never buy.  And credibility is a valuable currency to have in
technical discussions: it's immunization against having ones motives
questioned later.  In the heat of argument, people will sometimes look
for non-technical ways to win the battle.  The project's primary
funder, because of its deep involvement and obvious concern over the
directions the project takes, presents a wider target than most.  By
being scrupulous to observe all project guidelines right from the
start, the funder makes themselves the same size as everyone
else.</para>

<para><remark>(Check with Mike that it's okay to use his name.  I
don't think he'll mind, but it's nice to ask.)</remark></para>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-contracting">
<title> Contracting </title>

<para> Contracting.  You may have funding, but that doesn't mean it's
easy to disburse.  Subcontracting needs to be done carefully in free
software projects, because part of the deal is that the
subcontractor's work must be accepted by the community -- and just
because someone funded the work doesn't necessarily mean the community
will accept it!  [Tell the story of CVS pserver here?]  </para>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-holy-wars">
<title>Avoid Holy Wars</title>

<para>A <firstterm>Holy War</firstterm> is a dispute, usually over a
relatively minor issue, which has no hope of being resolved on the
merits of the arguments, but where people feel passionate enough to
continue arguing anyway in the hope that their side will
prevail.</para>

<para>Once a holy war has started, it generally cannot be resolved to
everyone's satisfaction.  It does no good to point out, in the midst
of a holy war, that a holy war is going on.  Everyone knows that
already.  Unfortunately, a common feature of holy wars is disagreement
on the very question of <emphasis>whether</emphasis> the dispute is
resolveable by continued discussion.  Viewed from outside, it is clear
that neither side is changing the other's mind.  Viewed from inside,
the other side is being obtuse and not thinking clearly, but they
might come around if browbeaten enough.  Now, I am
<emphasis>not</emphasis> saying there's never a right side in a holy
war.  Sometimes there is &mdash; in the holy wars I've participated
in, it's always been my side, of course.  But it doesn't matter,
because there's no algorithm for convincingly demonstrating that one
side or the other is right.</para>

<para>A common, but unsatisfactory, way people try to resolve holy
wars is to say "We've already spent far more time and energy
discussing this than it's worth!  Can we please just drop it?"  There
are two problems with this.  First, that time and energy has already
been spent and can never be retrieved &mdash; the only question now
is, how much <emphasis>more</emphasis> effort remains?  If some people
feel that just a little more discussion will bring the issue to a
close, then it still makes sense (from their point of view) to
continue.</para>

<para>The other problem with asking for the matter to be dropped is
that this is often equivalent to allowing one side, the status quo, to
declare victory by inaction.  And in some cases, the status quo is
known to be unacceptable anyway: everyone agrees that some decision
must be made, some action taken.  Dropping the subject would be worse
for everyone than simply giving up the argument would be for anyone.
But since that dilemma applies to all equally, it's still possible to
end up arguing forever about what to do.</para>

<para>So how should you handle a holy war?</para>

<para>The first answer is, try to set things up so they don't happen.
This is not as hopeless as it sounds:</para>

<para><remark>(finish) This is done by anticipating standard holy
wars: languages, licences (<xref linkend="pfs-avoiding-license-wars"/>),
reply-to munging.  Regarding language holy wars: most important thing
is, choose a language that you and the the other initial developers
are comfortable with, and defend the language on *those* grounds,
*not* on the grounds that it's better than some other possible
language.  Never ever let the conversation degenerate into an academic
comparison of programming languages (this seems to happen especially
often when someone brings up Perl); that's one of many examples of a
death topic that should be stopped before it gets
started.</remark></para>

<para><remark>When a holy war can't be avoided, decide early how much
you care, and then be willing to publicly give up.  When you do so,
say that you're backing out because the holy war isn't worth it, but
don't be bitter and <emphasis>don't</emphasis> take the opportunity
for a last parting shot at the opposing side's arguments.  Giving up
is only effective when done gracefully.</remark></para>

<para>For more historical background on holy wars, see <ulink
url="http://catb.org/~esr/jargon/html/H/holy-wars.html"/>, and the
paper by Danny Cohen that popularized the term, <ulink
url="http://www.ietf.org/rfc/ien/ien137.txt"/>.</para>

</sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
