<chapter id="pfs-ch-4">

<title>Social and Political Infrastructure <!-- [ 15-25 pp ] --></title>

<simplesect>

<para>The first question people usually ask about free software is
"How does it work?  What keeps a project running &mdash; who makes the
decisions?"  I'm always dissatisfied with bland responses about
meritocracy, the spirit of cooperation, code speaking for itself, etc.
The fact is, the question is not easy to answer.  Meritocracy,
cooperation, and running code are all part of it, but they do little
to explain how projects actually run on a day-to-day basis, and say
nothing about how conflicts are resolved.</para>

<para>This chapter tries to show the structural underpinnings
successful projects have in common.  I mean "successful" not just in
terms of technical quality, but also operational health and
survivability.  Operational health is the project's ongoing ability to
incorporate new code contributions and new developers, and to be
responsive to incoming bug reports.  Survivability is the project's
ability to exist independently of any invididual participant &mdash;
think of it as the likelihood that the project would continue even if
all of its founding members were to move on to other things.
Technical success is not hard to achieve, but without a robust
developer base and social foundation, a project may be unable to
handle the growth that initial success brings, or the departure of
charismatic individuals.</para>

<para>There are various ways to achieve this kind of success.  Some
involve a formal governance structure, by which debates are resolved,
new developers are invited in (and sometimes out), new features
planned, and so on.  Others involve less formal structure, but more
conscious self-restraint, to produce an atmosphere of fairness that
people can rely on as a <foreignphrase>de facto</foreignphrase> form
of governance.  Both ways lead to the same result: a sense of
institutional permanence, supported by habits and procedures that are
well-understood by everyone who participates.  These features are even
more important in self-organizing systems than in centrally-controlled
ones, because in self-organizing systems, everyone is conscious that a
few bad apples can bring the whole thing crashing down, at least for a
while.</para>

<sect1 id="pfs-forkability">
<title>Forkability</title>

<para>The indispensable ingredient that binds developers together on a
free software project, and makes them willing to compromise when
necessary, is the code's <firstterm>forkability</firstterm>: the
ability of anyone to take a copy of the source code and use it to
start a competing project, known as a <firstterm>fork</firstterm>.
The paradoxical thing is that the <emphasis>possibility</emphasis> of
forks is usually a much greater force in free software projects than
actual forks, which are very rare.  Because a fork is bad for everyone
(for reasons examined in detail in <xref linkend="pfs-forks"/>), the
more serious the threat of a fork becomes, the more willing people are
to compromise to avoid it.</para>

<para>Forks, or rather the potential for forks, are the reason there
are no true dictators in free software projects.  This may seem like a
surprising claim, considering how common it is to hear someone called
the "dictator" or "tyrant" in a given open source project.  But this
kind of tyranny is special, quite different from the conventional
understanding of the word.  Imagine a king who rules over a kingdom,
but with the special proviso that any of his subjects can duplicate
the entire kingdom at any time, and move to the copy to rule it as
they see fit.  Would not such a king govern very differently from one
whose subjects were bound to stay under his rule no matter what he
did?</para>

<para>This is why even projects which are not formally organized as
democracies are, in practice, democracies when it comes to important
decisions.  Replicability implies forkability; forkability implies
consensus.  It may well be that everyone is willing to defer to one
leader (the most famous example being Linus Torvalds in Linux kernel
development), but this is because they <emphasis>choose</emphasis> to
do so, in an entirely non-cynical and non-sinister way.  The dictator
has no magical hold over the project.  A key property of all open
source licenses is that they do not give one party more power than any
other in deciding how the code can changed or used.  If the dictator
were to suddenly start making bad decisions, there would be
restlessness, followed eventually by revolt and a fork.  Except, of
course, things rarely get that far, because the dictator compromises
first.</para>

<para>But just because forkability puts an upper limit on how much
power anyone can exert in a project doesn't mean there aren't
important differences in how projects are governed.  You don't want
every decision to come down to the last-resort question of who is
considering a fork.  That would get tiresome very quickly, and sap
energy away from real work.  Below we'll look at two ways to organize
projects such that most decisions go smoothly.  These two examples are
the extremes; most projects fall somewhere along a continuum between
them.</para>

<para><remark>(Andy, was that an okay context to say "Below" instead
of "Following"?  The latter felt awkward when I tried it.  If "Below"
is just flat-out objectionable, I can rephrase.)</remark></para>

</sect1>

</simplesect>

<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-benevolant-dictator">
<title>Benevolent Dictators</title>

<para>The <firstterm>benevolent dictator</firstterm> model is exactly
what it sounds like: final decision-making authority rests with one
person, who by virtue of their personality and experience is expected
to use it wisely.</para>

<para>Although "benevolent dictator" (or <firstterm>BD</firstterm>)is
the standard term for this role, it would be better to think of it as
"community-approved arbitrator" or "judge".  Generally, benevolent
dictators do not actually make all the decisions, or even most of the
decisions.  First of all, it's unlikely that one person could have
enough expertise to make consistently good decisions across all areas
of the project.  Second, quality developers won't stay around unless
they have some influence on the project's direction.  Therefore,
benevolent dictators commonly do not dictate much.  Instead, they let
things work themselves out through discussion and experimentation
whenever possible.  They participate in those discussions themselves,
but as regular developers, often deferring to an area maintainer who
has more expertise.  Only when it is clear that no consensus can be
reached, and that most of the group <emphasis>wants</emphasis> someone
to guide the decision so that development can move on, do they put
their foot down and say "This is the way it's going to be."
Reluctance to make decisions by fiat is a trait shared by virtually
all successful benevolent dictators; it is one of the reasons they
manage to keep the role.</para>

<sect2 id="pfs-benevolant-dictator-qualifications">
<title>Who can be a good benevolent dictator?</title>

<para>Being a BD requires a combination of traits.  It needs first of
all a well-honed sensitivity to one's own influence in the project,
which in turn brings self-restraint.  In the early stages of a
discussion, one should not express opinions and conclusions with so
much certainty that others feel like it's pointless to dissent.
People must be free to air ideas, even stupid ideas.  It is inevitable
that the BD will post a stupid idea from time to time too, of course,
and therefore the role also requires an ability to recognize and
acknowledge when one has made a bad decision &mdash; though this is
simply a trait that <emphasis>any</emphasis> good developer should
have, especially if they stay with the project a long time.  But the
difference is that the BD can afford to slip from time to time without
worrying about long-term damage to her credibility.  Developers with
less seniority may not feel so secure, and this is something the BD
must constantly keep in mind when phrasing critiques or
decisions.</para>

<para>The BD does <emphasis>not</emphasis> need to have the most
profound technical skills of anyone in the project.  She must be
skilled enough to work on the code herself, and to understand and
comment on any change under consideration, but that's all.  The BD
position is neither acquired nor held by virtue of intimidating coding
skills.  What <emphasis>is</emphasis> important is experience and
overall design sense &mdash; not necessarily the ability to produce
good design, but the ability to recognize good design whatever its
source.</para>

<para>It is common for the Benevolent Dictator to be a founder of the
project, but this is more a correlation than a cause.  The sorts of
qualities that make one able to successfully start a project &mdash;
technical skills, ability to persuade other people to join, etc
&mdash; are exactly the qualities any BD would need.  And of course,
founders start out with a sort of automatic seniority, which can often
be enough to make Benevolent Dictatorship appear the path of least
resistance for all concerned.</para>

<para>Remember that the potential to fork goes both ways.  A BD can
fork a project just as easily as anyone else, and some have
occasionally done so, when they felt that the direction they wanted to
take the project was different from where the majority of other
developers wanted to go.  Because of forkability, it does not matter
whether the Benevolent Dictator has root (system administrator
privileges) on the project's main servers or not.  People sometimes
talk of server control as though it were the ultimate source of power
in a project, but in fact it is irrelevant.  The ability to add or
remove people's commit passwords on one particular server affects only
the copy of the project that resides on that server.  Prolonged abuse
of that power, whether by the BD or someone else, would simply lead to
development moving to a different server.</para>

</sect2>

<para>Whether your project should have a Benevolent Dictator, or would
run better with some less centralized system, largely depends on who
is available to be fill the role.  As a general rule, if it's simply
obvious to everyone who should be the BD, then do that.  But if no
candidate for BD is immediately obvious, then the project should
probably use a decentralized decision-making process, as described in
the next section.</para>

<para><remark>(Here or later, need to make a note about succession,
and how the mere formalization of a succession procedure forces
projects to identify what the BD role is, and therefore make explicit
the fact that it is granted by the other developers &mdash; in other
words, succession plans inevitably start moving a project toward a
more democratic approach.)</remark></para>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-consensus-democracy">
<title>Consensus-based Democracy</title>

<para>As projects get older, they usually move away from the
Benevolent Dictatorship model and toward more openly democratic
systems.  This is not necessarily out of dissatisfaction with a
particular BD.  It's simply that group-based governance is more
"evolutionarily stable", to borrow a biological metaphor.  Whenever a
Benevolent Dictator steps down, or indicates a desire to spread
decision-making responsibility more evenly, it is an opportunity for
the group to settle on a new, non-dictatorial system &mdash; establish
a constitution, as it were.  The group may not take this opportunity
the first time, or the second, but eventually they will, and such a
decision is unlikely ever to be reversed.  Common sense explains why:
when a group of N people decides to vest one person with more
influence, it means that (N&nbsp;-&nbsp;1) people are agreeing to
decrease their individual influence.  This is quite improbable, and
even if it were to happen, the resulting dictatorship would still be
conditional: the group anointed the BD, clearly the group could depose
the BD.  Therefore, once a project has moved from leadership by one or
two charismatic individuals to a more formal, group-based system, it
rarely moves back.</para>

<para>The details of how these systems work can vary quite widely, but
there are two common elements: one, the group works by consensus most
of the time; two, there is a formal voting mechanism to fall back on
when consensus cannot be reached.</para>

<para><firstterm>Consensus</firstterm> merely means an agreement that
everyone is willing to live with, and there should never be any
ambiguity about it: a group has reached consensus on a given question
when someone proposes that consensus has been reached, and no one
contradicts the assertion.  The person proposing consensus should, of
course, state specifically what the consensus is, and what actions
would be taken in consequence of it, if they're not obvious.</para>

<para>Most conversation in a project is on technical topics, such as
the right way to fix a certain bug, whether or not to add a feature,
how strictly to document interfaces, etc.  Consensus-based governance
works well because it blends seamlessly with the technical discussion
itself.  Often there is general agreement on the right course by the
end of the discussion, and so the summing-up mail that usually
concludes such conversations is simultaneously a summary of what has
been decided and an implicit proposal of consensus.  It provides a
last chance for someone to say "Whoa &mdash; wait, I didn't agree to
that, we need to hash this out some more," while not encumbering the
group with the ritual of voting when everyone agrees.</para>

<para><remark>todo: working here: Becase most decisions are reversible
most projects handle the question of waiting periods informally (the
luxury of version control allows this...)</remark></para>

<sect2 id="pfs-electorate">
<title>Who is the group?</title>

<para>The first practical question that comes up is, whose voice
counts when consensus is being measured, or votes tallied?</para>

<para>Most projects answer this the same way:</para>

</sect2>

<para><remark>(remark on how this non-BD-based organization is more
desirable when money is involved, then link to the money
chapter/section)</remark></para>

<para><remark>Even free software projects which run on the Benevolent
Dictatorship model are not truly centrally-controlled.  Some people
say it all boils down to who has root on the server.  Show why this is
not really true.  Also, difference between formal governance and their
daily practice.  Note that the less governance structure there is, the
more careful senior developers have to be about stomping on newcomers
&mdash; not so much because the target will feel squished, as that
<emphasis>other</emphasis> people will not be willing to come to their
aid, because <emphasis>they</emphasis> will not feel protected by the
"rule of law".</remark></para>

<para><remark>Talk importance of reconsiderability of rules.  If
someone isn't happy with the process and opens a meta-question, it is
important to recognize that they have a right to do that.  If someone
makes a habit of that, then it becomes okay to ignore them (after all,
if people agree, they'll chime in &mdash; not everything requires a
response).</remark></para>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-money">
<title>Money and How to Handle It</title>

<screen>
Conflicts of Interest: In a funded project, the corporation or
consortium supplying the money may have different goals than many of
the volunteers have.  How to balance the funder's interests with the
volunteers' interests without either side becoming disgruntled.  [Case
studies: Subversion, possibly others ]
</screen>

<para><remark>Deleted material from Chapter 1, in the spot which now
just refers to this chapter: "This means that if the project has
corporate sponsorship, it should lay out clear guidelines for how the
sponsor may and may not influence project direction.  For if the
unpaid volunteers get the feeling that design decisions or feature
additions are simply available to the highest bidder, they'll most
likely head off to someplace that seems more like a meritocracy and
less like unpaid labor for someone else's benefit.  Volunteer
developers generally do not mind corporate support for the projects
they work on; in fact, they often welcome it, because it can give the
project a higher chance of surviving.  But they insist, reasonably
enough, on being treated as equal partners."</remark></para>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-written-rules">
<title> Written vs Unwritten Rules </title>

<para> When does a project need a written constitution, and what kind? </para>

<!-- Make sure to talk about the procedures by which a
     contributor gets <firstterm>commit access</firstterm>, that is,
     the ability to put changes directly into the software without
     going through some other developer.)  Refer back to the Mike
     Pilato example. --> 

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-decision-making">
<title> Consensus vs Voting vs Tyranny </title>

<para> Consensus vs voting: the importance of having a voting system,
but also, the importance of rarely using it.  Contrast official
tyranny with de facto tyranny. </para>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-money-vs-love">
<title>Money Can't Buy You Love</title>

<para><remark>(Still deciding if this section belongs here, or
somewhere in Chapter 5.  For now, here, as I think it's one of the
better examples, so might as well put it sooner rather than
later.)</remark></para>

<para>Free software projects today are funded by a wide variety of
methods.  There are</para>

<itemizedlist>
  <listitem>
  <para>Totally unfunded projects, done simply for pleasure or
        personal utility and then released for free.</para>
  </listitem>

  <listitem>
  <para>Projects which are essentially done for the love of it but
        which solicit small-scale donations.</para>
  </listitem>

  <listitem>
  <para>Projects that receive all, or a significant portion of, their
        funding from non-profit organizations (such as the Free
        Software Foundation, the Apache Software Foundation,
        Xiph.org, et al).</para>
  </listitem>

  <listitem>
  <para>Projects that are funded from royalties driven by a
        dual-licencing model (see <xref linkend="pfs-dual-licensing"/>),  
        where those using the software in proprietary products
        subsidize its development for the free world.</para>
  </listitem>

  <listitem>
  <para>Projects which are started and managed by for-profit
        corporations for strategic reasons, for example to drive
        support or hardware sales.</para>
  </listitem>
</itemizedlist>

<para>...and all sorts of outliers and edge cases.</para>

<para>Money can affect a project both positively and negatively.  By
reducing the project's vulnerability the Forces of Chaos, which sweep
away so many projects before they really get off the ground, it can
make people more willing to give the software a chance &mdash; they
feel they're investing their time into something that will be around a
year from now.  On the other hand, if not handled carefully, money can
also divide the project into in-group and out-group developers.</para>

<para>If your project is funded, even partially, then it is very
important for you to set guidelines about what the money can and
cannot buy right, from the start.  This does not mean you need to post
twice a day to the mailing lists reiterating your nobility and
incorruptibility.  It merely means that you should be on the lookout
for opportunities to defuse the tensions that
<emphasis>could</emphasis> be created by money.  You don't need to
start out assuming that the tensions are there; you just need to show
an awareness that there is a potential for them to arise.</para>

<para>A perfect example of this came up in the Subversion project.
Subversion was started in 2000 by <ulink
url="http://www.collab.net/">CollabNet</ulink>, which has been the
project's primary funder since its inception, paying the salaries of
several developers (disclaimer: I'm one of them).  Fairly early in the
project, we hired another developer, Mike Pilato, to join the effort.
By then, coding had already started, although we were still very much
in the early stages.</para>

<para>The question was, how to receive Mike into the public project?
Subversion already had a policy about how new developers get commit
access: first, they submit some patches to the development mailing
list.  After enough patches have gone by for the other committers to
see that the new contributor knows what he's doing, someone proposes
that he just commit directly (this proposal takes place on a closed
mailing list of just committers, so no feelings will be hurt if the
proposal fails).  When the committers agree, someone mails the new
developer and offers him direct commit access to the project's master
sources.</para>

<para>But what about Mike?  CollabNet had hired him specifically to
work on Subversion.  There was no doubt about his coding skills or his
readiness to work on the project.  Furthermore, the non-salaried
developers had a very good relationship with the CollabNet employees,
and most likely would not have objected if we'd just given Mike commit
access the day he was hired.  But we realized we were setting a
precedent.  If we just granted Mike commit access by fiat, we'd be
saying that CollabNet had the right to ignore project guidelines,
simply by virtue of being the primary funder.  While the damage from
this might not have been immediately apparent, it would eventually
result in the non-salaried developers feeling gradually
disenfranchised.  Other people have to earn their commit access
&mdash; CollabNet just buys it.</para>

<para>So Mike agreed to start out his employment at CollabNet like any
other volunteer developer, without commit access.  He sent patches to
the mailing list, where they could be, and were, reviewed by everyone.
Equally importantly, we said on the list that we were doing things
this way deliberately, so there could be no missing the point.  After
a while, someone (I can't remember if it was a CollabNet developer or
not) proposed Mike for commit access, and he was accepted, as everyone
knew he would be.</para>

<para>That kind of consistency gets you a credibility that money could
never buy.  And credibility is a valuable currency to have in
technical discussions: it's immunization against having ones motives
questioned later.  In the heat of argument, people will sometimes look
for non-technical ways to win the battle.  The project's primary
funder, because of its deep involvement and obvious concern over the
directions the project takes, presents a wider target than most.  By
being scrupulous to observe all project guidelines right from the
start, the funder makes themselves the same size as everyone
else.</para>

<para><remark>(Check with Mike that it's okay to use his name.  I
don't think he'll mind, but it's nice to ask.)</remark></para>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-contracting">
<title> Contracting </title>

<para> Contracting.  You may have funding, but that doesn't mean it's
easy to disburse.  Subcontracting needs to be done carefully in free
software projects, because part of the deal is that the
subcontractor's work must be accepted by the community -- and just
because someone funded the work doesn't necessarily mean the community
will accept it!  [Tell the story of CVS pserver here?]  </para>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-holy-wars">
<title>Avoid Holy Wars</title>

<para>A <firstterm>Holy War</firstterm> is a dispute, usually over a
relatively minor issue, which has no hope of being resolved on the
merits of the arguments, but where people feel passionate enough to
continue arguing anyway in the hope that their side will
prevail.</para>

<para>Once a holy war has started, it generally cannot be resolved to
everyone's satisfaction.  It does no good to point out, in the midst
of a holy war, that a holy war is going on.  Everyone knows that
already.  Unfortunately, a common feature of holy wars is disagreement
on the very question of <emphasis>whether</emphasis> the dispute is
resolveable by continued discussion.  Viewed from outside, it is clear
that neither side is changing the other's mind.  Viewed from inside,
the other side is being obtuse and not thinking clearly, but they
might come around if browbeaten enough.  Now, I am
<emphasis>not</emphasis> saying there's never a right side in a holy
war.  Sometimes there is &mdash; in the holy wars I've participated
in, it's always been my side, of course.  But it doesn't matter,
because there's no algorithm for convincingly demonstrating that one
side or the other is right.</para>

<para>A common, but unsatisfactory, way people try to resolve holy
wars is to say "We've already spent far more time and energy
discussing this than it's worth!  Can we please just drop it?"  There
are two problems with this.  First, that time and energy has already
been spent and can never be retrieved &mdash; the only question now
is, how much <emphasis>more</emphasis> effort remains?  If some people
feel that just a little more discussion will bring the issue to a
close, then it still makes sense (from their point of view) to
continue.</para>

<para>The other problem with asking for the matter to be dropped is
that this is often equivalent to allowing one side, the status quo, to
declare victory by inaction.  And in some cases, the status quo is
known to be unacceptable anyway: everyone agrees that some decision
must be made, some action taken.  Dropping the subject would be worse
for everyone than simply giving up the argument would be for anyone.
But since that dilemma applies to all equally, it's still possible to
end up arguing forever about what to do.</para>

<para>So how should you handle a holy war?</para>

<para>The first answer is, try to set things up so they don't happen.
This is not as hopeless as it sounds:</para>

<para><remark>(finish) This is done by anticipating standard holy
wars: languages, licences (<xref linkend="pfs-avoiding-license-wars"/>),
reply-to munging.  Regarding language holy wars: most important thing
is, choose a language that you and the the other initial developers
are comfortable with, and defend the language on *those* grounds,
*not* on the grounds that it's better than some other possible
language.  Never ever let the conversation degenerate into an academic
comparison of programming languages (this seems to happen especially
often when someone brings up Perl); that's one of many examples of a
death topic that should be stopped before it gets
started.</remark></para>

<para><remark>When a holy war can't be avoided, decide early how much
you care, and then be willing to publicly give up.  When you do so,
say that you're backing out because the holy war isn't worth it, but
don't be bitter and <emphasis>don't</emphasis> take the opportunity
for a last parting shot at the opposing side's arguments.  Giving up
is only effective when done gracefully.</remark></para>

<para>For more historical background on holy wars, see <ulink
url="http://catb.org/~esr/jargon/html/H/holy-wars.html"/>, and the
paper by Danny Cohen that popularized the term, <ulink
url="http://www.ietf.org/rfc/ien/ien137.txt"/>.</para>

</sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
