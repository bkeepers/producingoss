<chapter id="getting-started">

<!-- Reviwed by rsantos in 2010-08-06 { -->

<title>Primeiros Passos</title>

<simplesect>

<para>O modelo tradicional de como os projetos de software livre
iniciam foram disponibilizados por Eric Raymond, em um ensaio
que agora está famoso nos processos de código aberto com o título
<citetitle>A Catedral e o Bazar</citetitle>. Ele escreveu:</para>

    <blockquote>
      <para><emphasis>Todo bom trabalho de software começa ao se colocar
      o dedo na ferida de um programador.</emphasis></para>

      <para>(retirado de <emphasis role="bold"><ulink
      url="http://www.catb.org/~esr/writings/cathedral-bazaar/"/>
      </emphasis>)</para>
    </blockquote>

<para>Note que Raymond não estava dizendo que os projetos de código
aberto acontecem somente quando um indivíduo tem uma "ferida". Melhor,
ele esta dizendo que um <emphasis>bom</emphasis> software acontece quando
o programador tem um interesse pessoal em ver o problema resolvido; a
relevância disso para o software livre era que a "ferida" pessoal 
calhou de ser a motivação mais frequênte para iniciar um projeto
de software livre.</para>

<para>Isto ainda é como a maioria dos projetos são iniciados, mas menos
agora que em 1997, quando Raymond escreveu estas palavras. Hoje, temos
o fenômeno das organizações&mdash;incluindo as empresas que visam 
lucro&mdash;iniciando do zero grandes projetos de código aberto e com 
gerenciamento centralizado. O programador solitário, desenvolvendo
algum código para resolver um problema local, percebendo, então, que
o resultado tem uma aplicabilidade mais vasta, ainda é a fonte de 
muito software livre novo, mas essa não é a única história.</para>

<para>De qualquer forma, a evidência de Raymond ainda é perspicaz.  A condição
principal é que os produtores do software tenham um interesse direto em seu
sucesso, porque eles próprios o utilizam.  Se o software não faz o que deveria
fazer, a pessoa ou organização que está produzindo-o sentirá a insatisfação em
seu trabalho diário.  Por exemplo, o projeto OpenAdapter
(<ulink url="http://www.openadapter.org/"/>), o qual foi iniciado por
investimento do banco Dresdner Kleinwort Wasserstein como um framework de
código aberto para integrar diferentes sistemas de informação financeira, pode
dificilmente ser dito como por o dedo na ferida pessoal de qualquer
programador individual.  Isso põe o dedo na ferida de uma instituição.  Mas
essa ferida surge diretamente das experiências da instituição e de seus
parceiros e, por esse motivo, se o projeto falha em aliviá-los, eles
reconhecerão.  Essa combinação produz um bom software porque o laço de feedback
flui na direção certa.  O programa não está sendo escrito para ser vendido a
outros, para tentarem resolver <emphasis>seus</emphasis> problemas.  Ele está
sendo escrito para resolver os <emphasis>próprios</emphasis> problemas de
alguém e, então, poder ser compartilhado com todos. Em suma, podemos comparar o
problema a uma doença e o software a um medicamento cuja distribuição
destina-se a erradicar completamente a epidemia.</para>

<para>Este capítulo fala sobre como introduzir um novo projeto de software livre
ao mundo, mas muitas dessas recomendações soariam familiar a uma organização de
saúde distribuindo medicamentos.  Os objetivos são bem similares: você quer
deixar bem claro o que o medicamento faz, distribuí-lo nas mãos das pessoas
certas, tendo certeza de que aqueles que o receberam sabem como utilizá-lo.
Mas com software, você também quer atrair alguns dos destinatários para
participarem da pesquisa em andamento com empenho para aperfeiçoarem o
"medicamento".</para>

<para>A distribuição de Software Livre é uma tarefa duplicada.  O software
necessita adquirir usuários, e adquirir desenvolvedores.  Essas duas
necessidades não estão necessariamente em conflito, mas elas adicionam um pouco
de complexidade a apresentação inicial do projeto.  Algumas informações são
úteis para ambas audiências, algumas são úteis somente para uma ou a
outra.  Ambos tipos de informações deveriam contribuir para o princípio de
apresentação escalada; isto é, o grau de detalhes apresentados em cada estágio
deveria corresponder diretamente a quantidade de tempo e esforço encaixados pelo
leitor.  Mais esforço deveria sempre igualar a mais contribuição.  Quando os
dois não se correlacionam firmimente, as pessoas podem rapidamente perder a fé
no projeto e pararem de investir esforços.</para>

<para>A consequência evidente disso é que <emphasis>aparência
importa</emphasis>. Programadores, em particular, frequentemente não gostam de
acreditar nisso. Seu amor pelo conteúdo sobre a forma é quase um ponto de
orgulho profissional. Não é por acaso que tantos programadores
demonstram antipatia por trabalhos de marketing e relações públicas,
nem que designers gráficos profissionais ficam frequentemente
horrorizados com o que os programadores desenham por eles mesmos.</para>


<para>Isso é uma pena, porque existem situações onde a forma
<emphasis>é</emphasis> conteúdo, e a aprensentação do projeto é uma delas.
Por exemplo, a primeira coisa que um visitante absorve sobre um
projeto é a aparência de seu web site. Esta informação é absorvida
antes que qualquer conteúdo possa ser compreendido&mdash;antes
de que qualquer texto tenha sido lido ou que links tenham sido
clicados. No entanto, isto pode ser injusto, mas as pessoas sempre vão formar
uma primeira impressão imediata. A aparência de um site mostra sinais dos
cuidados que foram tomados na apresentação de um projeto. Humanos tem "antenas"
extremamente sensíveis em detectar o cuidado investido. A maioria de nós pode
falar em um relance se um site foi feito as pressas ou se foi seriamente
pensado. Este é o primeiro contato que seu projeto expõe, e a impressão que isso
cria será levada para o resto do projeto, por associação.</para>

<para>Assim, enquanto muito deste capítulo fala sobre o conteúdo com o qual
o seu projeto deve começar, lembre-se que sua aparência e o que ele passa
também importam. Como o web site do projeto deve funcionar para dois diferentes
tipos de visitantes&mdash;usuários e desenvolvedores&mdash;uma atenção especial
deve ser tomada para dar clareza e direcionamento. Apesar de não ser o local
para tratar de web design, um princícpio é importante o suficiente para merecer
ser falado, particularmente quando um site atende a muitos públicos: as pessoas
deveriam ter uma forte ideia para onde um link vai antes de clicar nele. Por
exemplo, deveria ser óbvio, <emphasis>olhando para os links</emphasis> de
documentação do usuário, saber que eles o levarão para a documentação do
usuário, e não para, digamos, a documentação do desenvolvedor. A execução de um
projeto deve, em parte, fornecer informação, mas deve também fornecer
conforto. A mera presença de certas ofertas padrões, nos lugares esperados,
tranquiliza usuários e desenvolvedores que estão decidindo em se envolver.
Essas ofertas dizem que o projeto mantém suas ações em união, que disponibilizam
perguntas frequentes, antecipadamente, e que estas foram respondidas de forma a
requerer o mínimo de esforço de quem pergunta. Por dar esta
sensação de preparação, o projeto dá a mensagem: "O seu tempo não será perdido
se você participar", o que é exatamente o que as pessoas esperam ouvir.</para>

<!-- } Reviwed by rsantos in 2010-08-06 -->

<!-- ======================== subsection ============================== -->
<sect2 id="look-around">
<title>Mas primeiro, olhe em volta</title>

<para>Antes de iniciar um projeto de código aberto, existe uma advertência
importante:</para>

<para>Sempre olhe em volta para ver se existe um projeto que faz o que
você quer. As chances são boas para qualquer problema que você queira
resolver agora, alguma outra pessoa quis resolver antes de você. Se
eles não resolveram, e lançaram o código sob uma licença livre, então
não há razão para você reinventar a roda hoje. Claro que existem exceções:
se você quer iniciar um projeto como uma experiência educacional, um
código já existente não irá ajudar; ou talvez o projeto que você tem em
mente é tão específico que você sabe que não há chances de alguém ter
desenvolvido isso. Mas geralmente, não há motivos para não procurar,
e a lista pode ser enorme. Se os mecanismos de buscas usuais não
mostrarem nada, tente procurar em <ulink url="http://freshmeat.net/"/> 
(um site de notícias de projetos de código aberto, o qual será falado mais
tarde), em <ulink url="http://www.sourceforge.net/"/>, e na Free Software
Foundation, directório de software livre em
<ulink url="http://directory.fsf.org/"/>.</para>

<para>Mesmo se você não achar exatamente o que você está procurando,
você pode encontrar algo muito próximo que pode fazer mais sentido
se unir aquele projeto e adicionar a funcionalidade que iniciar
do zero você mesmo.</para>

</sect2>

</simplesect>

<!-- ========================== SECTION =========================== -->
<sect1 id="starting-from-what-you-have">
<title>Começando-se com o que tem</title>

<para>Você olhou em volta, e não encontrou nada que realmente
atendesse suas necessidades, e decidiu iniciar um novo projeto.</para>

<para>E agora?</para>

<para>A parte mais difícil em lançar um projeto de software livre é
transformar a visão privada em pública. Você ou a sua organização poder
saber perfeitamente bem o que querem, mas expressar este objetivo de 
maneira compreensiva ao mundo é um belo trabalho. É essencial, 
entretanto, que você reserve algum tempo para faze-lo. Voce e os
outros fundadores devem decidir sobre do que realmente se trata o 
projeto&mdash;isto é, decidir suas limitações, o que ele <emphasis>não</emphasis>
fará assim como o que ele fará&mdash;e escrever uma declaração de
missçao. Esta é a parte geralmente não é tão difícil, embora ela
possa algumas vezes revelar suposições implícitas e até desacordos
em relação a natureza do projeto, o que é bom: melhor resolve-los
agora do que mais tarde. O próximo passo é o pacote do projeto para
uso público, e isso é, basicamente, pura labuta.</para>

<para>O que faz isso tão trabalhoso é que consiste principalmente
em organizar e documentar o que todo mundo já sabe&mdash;"todo mundo",
ou seja, quem está envolvido com o projeto até o momento. Assim, 
para o pessoal que está trabalhando no projeto, não há um benefício
imediato. Eles não precisam de um arquivo <filename>LEIAME</filename>
com a visão geral do projeto, nem um documento de design ou manual
do usuário. Eles não precisam de uma árvore de código cuidadosamente 
formatada conforme os padrões informais mas largamente difundidos de
distribuição de fontes de software. De qualquer forma que o código
estiver disponível está bom para eles, porque eles já estão acostumados
com isso mesmo, e se o código executa completamente, eles sabem como
usá-lo. Nem mesmo importa a eles, se os pressupostos de arquitetura
fundamentais do projeto fiquem sem documentação; eles já estão
familiarizados com isso também.</para>

<para>Os recém-chegados, por outro lado, precisam destes documentos.
Felizmente, eles não precisam de todos de uma vez. Não é necessário
que você forneça todos os recursos necessários antes de tornar o 
projeto público. Em um mundo perfeito, talvez, todo novo projeto
de código aberto poderia começar seu ciclo de vida com um documento
completo de design, um manual completo de usuário (com marcações
especiais para funcionalidades planejadas mas não documentadas),
com um pacote de código lindo e portável, capaz de executar em
qualquer plataforma de computador, e assim por diante. Na realidade,
cuidade de todos estes pontos seria exageradamente demorado, e
de qualquer forma, é um trabalho que pode-se razoavelmente esperar
que os voluntários irão ajudar uma vez que o projeto esteja em
andamento.</para>

<para>O que <emphasis>é</emphasis> necessario, entretanto, é o
investimento colocado na apresentação que os recém-chegados possam
passar pelo obstáculo inicial da falta de familiaridade. Pense 
nisso como se fosse a primeira etapa em um processo de boot, que
traz ao projeto um forma mínima de ativação de energia. Tenho ouvido
esta definição de  <firstterm>energia de hacktivação</firstterm>:
o esforço mínimo de um recém-chegado precisa fazer antes de ter
algo em retorno. Quanto menor a energia de hacktivação, melhor.
Sua primeira tarefa é diminuir a energia de hacktivação a um nível
que encoraje as pessoas a se envolverem com o projeto.</para>

<para>Cada uma das seguintes subseções descreve um aspecto importante
para iniciar um novo projeto. Eles são apresentadas aproximadamente
na ordem em que um visitante poderia encontra-las, embora é claro
que a ordem do qual você vai realmente implementa-las pode ser
diferente. Você pode considerá-las como um checklist. Quando iniciar
um projeto, verifique a lista e certifique-se que você cobriu cada
item, ou que pelo menos que você está confortável com as potenciais
consequencias de deixar algum de fora.</para>


<!-- ======================== subsection ============================== -->
<sect2 id="choosing-a-name">
<title>Escolha um bom nome</title>

<para>Ponha-se no lugar de alguém que tenha acabado de ouvir sobre seu
projeto, talvez por ter topado com ele enquando realizava uma busca
por um software para solucionar algum problema. A primeira coisa que
eles irão encontrar será o nome do projeto.</para>

<para>Um bom nome não irá automaticamente fazer do seu projeto um sucesso,
e um nome ruim não irá destruí-lo&mdash;bom, um nome <emphasis>realmente</emphasis> 
ruim provavelmente poderia fazer isso, mas vamos assumir que ninguém está
tentando ativamente fazer com que seu projeto seja um fracasso. No 
entanto, um nome ruim pode desacelerar a adoção ao projeto, ou
por que as pessoas não o levarão a sério, ou porque eles simplesmente
terão problemas para lembrarem-se dele.</para>

<para>Um bom nome:

<itemizedlist>
  <listitem><para>Traz a ideia do que o projeto faz, ou ao menos
            está relacionado de maneira óbvia, de forma que se alguém sabe o 
            nome e sabe o que o projeto faz, daí em diante o nome virá
            rapidamente a cabeça.</para>
  </listitem>
  <listitem><para>É fácil de lembrar. Aqui, não há como contornar o
            fato de que o inglês se tornou a linguagem padrão da Internet:
            "fácil de lembrar" significa "facil para alguem que possa ler
            em inglês de lembrar." Nomes que são trocadilhos dependentes
            da pronunciação de um nativo, por exemplo, irão ser opacos para 
            muitos leitores de inglês não-nativos por aí. Se o trocadilho
            é particulamente convincente e memorável, ele ainda pode valer
            a pena; apenas tenha em mente que muitas pessoas olhando o nome 
            não irão ouvi-lo em suas cabecas da maneira que um nativo
            ouviria.</para>
  </listitem>
  <listitem><para>Não é o mesmo que outros nomes de projeto, e não
            viola nenhuma marca. Estas são apenas boas maneiras, assim
            como bom senso legal. Você não quer criar uma confusão de
            identidade. É difícil estar por dentro de tudo o que já
            está disponível Net, sem que coisas diferentes tenham o
            mesmo nome.</para>

            <para>Os recursos mencionados antes em
            <xref linkend="look-around"/> são úteis em
            descobrir se outro projeto já tem o nome ao qual 
            você está pensando. A busca de marcas livres estão
            disponível em <ulink url="http://www.nameprotect.org/"/>
            e <ulink url="http://www.uspto.gov/"/>.</para>

  </listitem>
  <listitem><para>Se possível, está disponível os nomes de domínio em
            <systemitem>.com</systemitem>,
            <systemitem>.net</systemitem>, e
            <systemitem>.org</systemitem>.  
            Você deve escolher um, provavelmente o <systemitem>.org</systemitem>,
            para manter como o web site oficial para o projeto;
            os outros dois devem redirecionar para lá e são simplesmente
            para evitar que terceiros criem alguma confusão de identidade 
            ao redor do nome do projeto. Mesmo que você pretenda hospedar
            o projeto em outro site (veja <xref linkend="starting-with-canned-hosting"/>), 
            você ainda pode registrar os domínios específicos para o 
            projeto e redirecioná-los para o site em que ele está hospedado.
            Isso ajuda muito os usuários a terem uma URL simples para 
            lembrar.</para>
    </listitem>
</itemizedlist>

</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="mission-statement">
<title>Tenha uma declaração de missão clara</title>

<para>Uma vez que eles tenha encnotrado o web site, a próxima coisa que
irão procurar é uma breve descrição, uma declaração de missão,  aí eles
poderão decidir (dentro de 30 segundos) se eles estão ou não interessados
em saber mais. Ela deve ser proeminentemente colocada na página de rosto,
preferencialmente logo após o nome do projeto.</para>

<para>A declaração de missão deve ser concreta, limitada, e acima de tudo,
curta. Aqui está um exemplo de uma boa declaração, retirada de <ulink
url="http://www.openoffice.org/"/>:</para>

  <blockquote>
  <para><emphasis>Para criar, como uma comunidade, a suíte office
  líder internacionalmente que irá rodar sobre todas as plataformas
  principais e fornecer acesso a todas as funcionalidades e dados
  através de um componente aberto baseado em APIs e formato de arquivos
  baseado em XML.</emphasis></para>
  </blockquote> 

<para>Em apenas algumas palavras, eles atingiram todos os pontos
altos, principalmente baseando-se em um conhecimento prévio do
leitor. Ao citar "<emphasis>como uma comunidade</emphasis>", eles
sinalizam que nenhuma empresa irá dominar o desenvolvimento; 
"<emphasis>internacionalmente</emphasis>" significa que o software irá
permitir que as pessoas trabalhem em diversas linguagens e locais;
"<emphasis>todas as plataformas principais</emphasis>" significa
que ele será portável para Unix, Macintosh, e Windoes. O restante
sinaliza que interfaces abertas e formatos de arquivo de fácil
compreensão são aspectos importantes do objetivo. Eles não vêm a
público dizendo que estão tentando ser uma alternative livre ao
Microsoft Office, mas a maioria das pessoas podem ler nas entrelinhas.
Embora esta declaração de missão pareça ampla a primeira vista, 
na verdade ela é bem circunscrita: as palavras  "<emphasis>suíte 
<!-- Nota para o revisor: nao achei como melhorar circumscribed: -->
office</emphasis>" significa algo muito concreto para os que
estão familiarizados com tal software. Mais uma vez, o presumido
conhecimento prévio do leitor (neste caso provavelmente oriundo
do MS Office)  é usado para manter a declaração de missão concisa.</para>

<para>A natureza da declaração de missão depende parcialmente de quem
a está escrevendo, não apenas no software que ele descreve. Por exemplo,
faz sentido para OpenOffice.org usar as palavras "<emphasis>como uma
comunidade</emphasis>", por que o projeto foi iniciado, e ainda é
amplamente patrocinado pela Oracle<footnote>Nota do tradutor: Livro 
original cita Sun Microsystems. Originalmente, o projeto era patrocinado 
pela Sun Microsystem, que foi comprada e incorporada a empresa Oracle</footnote>
Por incluir estas palavras, a Oracle indica sua sensibilidade em 
preocupações que poderiam dominar o processo de desenvolvimento,
apenas demonstrando consciência do <emphasis>potencial</emphasis>
de virar um problema e ter um longo caminho para evitar o problema
completamente. Por outro lado, projetos que não são patrocinados por
uma única empresa provavelmente não necessita de tais argumentos;
afinal de contas, desenvolvimento pela comunidade é a regra, o
que normalmente não seria razão para listá-la como parte da missão.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="state-freedom">
<title>Declare que o projeto é livre</title>

<para>Aqueles que continuarem interessados após lerem a declaração
de missão irão querer olhar mais detalher, talvez alguma documentação
de usuário ou desenvolvedorl, e eventualmente irão fazer o download de
algo. Mas antes disso, eles irão se certificar que é um projeto de
código aberto.</para>

<para><emphasis>A página inicial deve ter de forma muito clara que
o projeto é de código aberto.</emphasis>  Isso pode parecer óbvio,
mas você ficaria surpreso de quantos projetos esquecem de fazer isto.
Eu vi web sites de projetos de software livre onde na páginal inicial
não somente não dizia sob qual o tipo de licença o software era 
distribuído, mas nem mesmo declarava que o software era livre.
Algumas vezes este pequeno detalhe de informação crucial era visível
apenas na página de Download, ou na página de Desenvolvedores, ou
qualquer outro lugar onde era preciso mais um clique do mouse para
chegar até lá. Em casos extremos, a licença não era mencionada em
nenhum local do web site&mdash;a única maneira para encontrá-la era
realizar o download do software e procurar dentro dele.</para>

<para>Não cometa este erro. Tal omissão pode deixar escapar muitos
potenciais desenvolvedores e usuários. Declare de cara, logo abaixo
a declaração de missão, que o projeto é um "software livre" ou
"software de código aberto", e forneça a licença exata. Um guia rápido
para escolha da licença é dado em
<xref linkend="license-quickstart"/><phrase output="printed">
mais adiante neste capítulo</phrase>, e os problemas de licenciamento são
discutidos em detalhes no <xref linkend="legal"/>.</para>

<para>Neste ponto, nosso visitante hipotético determinou&mdash;
provavelmente em um minuto ou menos&mdash;que ele está interessado
em passar, digamos, pelo menos mais cinco minutos investigando este
projeto. As próximas seções descrevem o que ele poderá encontrar 
nestes cinco minutos.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="features-and-requirements">
<title>Lista de Funcionalidades e Requerimentos</title>

<para>Deve existir uma breve lista de funcionalidades suportadas pelo
software (se algo ainda não está completo, você ainda pode listá-lo, mas
coloque "<emphasis>planejado</emphasis>" ou "<emphasis>em&nbsp;andamento</emphasis>" 
prómimo a ele), e o tipo de ambiente computacional necessário para executar
o software. Pense na lista de funcionalidades/requerimentos como a que
você daria a alguém que perguta por um resumo do software. Isso é 
geralmente apenas uma expansão lógica da declaração de missão. Por
exemplo, a declaração de missão pode ser:</para>

  <blockquote>
  <para><emphasis>Criar um indexador completo de texto e motor de busca
  com uma API rica, para uso de programadores proveem serviços de
  busca para uma vasta coleção de arquivos de texto.</emphasis></para>
  </blockquote>


<para>A lista de funcionalidade e requerimentos daria os detalhes,
clareando o escopo da declaração de missão:</para>

  <blockquote>
    <para><emphasis>Funcionalidades:</emphasis></para>
    <itemizedlist>
      <listitem><para><emphasis>Procura por textos puros, HTML, e
                XML</emphasis></para>
      </listitem>
      <listitem><para><emphasis>Busca por palavra ou frases</emphasis></para>
      </listitem>
      <listitem><para><emphasis>(planejado) correspondências Fuzzy</emphasis></para>
      </listitem>
      <listitem><para><emphasis>(planejado) Atualização incremental de
               índices</emphasis></para>
      </listitem>
      <listitem><para><emphasis>(planejado) Indexação de web sites
                remotos</emphasis></para>
      </listitem>
    </itemizedlist>
    <para><emphasis>Requerimentos:</emphasis></para>
    <itemizedlist>
      <listitem><para><emphasis>Python 2.2 ou superior</emphasis></para>
      </listitem>
      <listitem><para><emphasis>Espaço em disco suficiente para armazenar os índices
                (aproximadamento 2x o tamanho original do dado)</emphasis></para>
      </listitem>
    </itemizedlist>
  </blockquote>

<para>Com esta informação, os leitores podem rapidamente saber se este
software tem chances de funcionar para eles, e podem consider em
participarem também como desenvolvedores.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="development-status">
<title>Status de desenvolvimento</title>

<para>As pessoas sempre querem saber como está indo um projeto. Para 
novos projetos, eles querem saber o gap entre a promessa do projeto e
a atual realidade. Para projetor mais maduros, eles querem saber quanto
que ele é ativamente mantido, a fequencia de novos lançamentos, a
resposta para reportes de bug, etc.</para>

<para>Para responder a estas questões, você deve fornecer uma página
de status de desenvolvimento, listando os objetivos a curto prazo do
projeto e necessidades (por exemplo, ele pode estar precisando de
desenvolvedores com um tipo específico de experiência). A página pode
também mostrar um histórico de versões anteriores, com a lista de
funcionalidades, para que visitantes possam ter uma ideia de como o
projeto define "progresso" e a velocidade com que esse progresso
ocorre de acordo com esta definição.</para>

<para>Não tenha medo de parecer despreparado, e não caia na tentação
de exagerar no status de desenvolvimento. Todo mundo sabe que o
software evolui por estágios; não há vergonha em dizer "Este é
um software na versão alpha com alguns bugs conhecidos". Ele roda,
e funciona ao menos por um tempo, mas use-o por sua conta e risco."
Tal linguagem não espantará os tipos de desenvolvedores que você
precisa neste estágio. Quanto aos usuários, uma das piores coisas
que um projeto pode fazer é atrir usuários antes do software estar
pronto para eles. Uma reputação de instabilidade ou excesso de bugs
é difícil de eliminar, uma vez adquirida. O conservadorismo compensa
a longo prazo; é sempre melhor para o software ser 
<emphasis>mais</emphasis> estável que o esperado para o usuário
do que menos, e surpresas agradáveis produzem o melhor tipo de
boca a boca.</para>

<sidebar id="alpha-and-beta">
  <title>Alpha e Beta</title>
  <para>O termo <firstterm>alpha</firstterm> geralmente significa a
  primeira versão, com a qual os usuários podem ver algum trabalho
  pronto de verdade e a qual tem todas as funcionalidades pretendidas,
  mas que também possuim alguns bugs conhecidos. O propósito principal
  de um software alpha é obter feedback, para que os desenvolvedores
  possam saber no que devem trabalhar. O próximo estágio,  <firstterm>beta</firstterm>,
  significa que o software teve seus bugs mais sérios corrigidos,
  mas ainda não foi testado o suficiente para tornar-se um lançamento.
  O propósito da versão de software beta é tanto para virar um
  lançamento oficial, assumindo que nenhum bug foi encontrado, ou 
  fornecer um feedback detalhado aos desenvolvedores para que então
  eles possam rapidamente chegar ao lançamento oficial. A diferença
  entre alpha e beta é muito mais uma questão de julgamento.</para>
</sidebar>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="downloads">
<title>Downloads</title>

<para>O software deve estar disponível para download em código fonte
em um formato padrão. Quando um projeto está dando os primeiros passos,
o pacote binário (executável) não é necessário, a menos que o software 
tenha requisitos de construção ou dependências tão complicadas que 
somente para exetutar daria muito trabalho para a maioria das pessoas.
(Mas se este é o caso, de qualquer forma o projeto terá uma fase difícil
para atrair desenvolvedores!)</para>

<para>O mecanismo de distribuição deve ser conveniente, padrão e
o menos dependente possível. Se você estivesse tentando erradicar uma
doença, você não iria distribuir o medicamente de uma forma que
fosse requerer uma seringa de tamanho diferenciado para administrá-lo.
Da mesma forma, o software deve estar de acordo com o padrão de
métodos de construção e instalação; quanto mais ele desviar dos padrões,
mais potenciais usuários e desenvolvedores desistirão e irão embora
confusos.</para>

<para>Isso parece óbviom mas muitos projetos não se importam em
padronizar seus procedimentos de instalação até ser tarde demais
para isso, dizendo a si mesmos que eles podem fazer isso a qualquer
momento:  <emphasis>"Vamos resolver todas essas coisas quando o código
estiver mais perto de estar pronto."</emphasis> O que eles não percebem
é que deixando de lado o trabalho chato de terminar os procedimentos
de construção e instalação, eles na verdade estão fazendo com que o
código demore mais para ficar pronto&mdash;por que eles desencorajam
os desenvolvedores que poderiam ter contribuído para o código. Mais
insidiosamente, eles não <emphasis>sabem</emphasis> que estão perdendo
todos esses desenvolvedores, porque o processo é um acúmulo não 
eventuais: alguém visita o we site, faz o download do software, tenta
contruí-lo, falha, desiste e vai embora. Quem saberá que isso aconteceu,
exceto a própria pessoa? Ninguém trabalhando no projeto irá imaginar
que o interesse e boa vontade de alguém tenha sido desperdiçado.</para>

<para>Trabalho chato com um alto retorno deve ser feito sempre antes,
e diminuir significantemente as barreiras de se entrar em um projeto
atravém de um bom empacotamente traz um alto retorno.</para>

<para>Quando você lança um pacote para download, é vital que você dê um
número único de versão a ele, para que as pessoas possam comparar dois
lançamentos e saber qual substitui o outro. Uma discussão detalhada de
numeração de versão pode ser encontrada em <xref
linkend="release-numbering"/>, e os detalhes de padronizar os procedimentos
de construção e instalação são discutidos em 
<xref linkend="packaging"/><phrase output="printed">, e também 
no <xref linkend="development-cycle"/></phrase>.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="vc-and-bug-tracker-access">
<title>Acesso ao Controle de Versão e ao Bug Tracker</title>

<para>Efetuar o download de pacotes de fontes é ótimo para aqueles que
querem apenas instalar e usar o software, mas não é suficiente para
aqueles que querem depurar ou adicionar novas funcionalidades. Os
snapshots de fontes gerados toda noite podem ajudar, mas eles ainda
não são o suficientemente filtrados para uma comunidade florescente
de desenvolvimento. A presenta de um controle de versão acessado de
forma anônima é um sinal&mdash;para usuários e desenvolvedores&mdash;que
este projeto está se esforçando para dar as pessoas o que elas precisam
para participar. Se você não pode ofecerer prontamente um controle de
versão, então coloque aviso dizendo que você pretende configurar uma
em breve. Insfraestrutura de controle de versão é discutida em detalhes
em  <xref linkend="vc"/><phrase output="printed"> no
<xref linkend="technical-infrastructure"/></phrase>.</para>

<para>O mesmo vale para o bug tracker do projeto. A importância de um
sistema de bug tracking não se aplica apenas na utilidade para
desenvolvedores, mas o que ele significa para quem oberva o projeto.
Para muitas pessoas, uma banco de dados de bug acessível é um dos
sinais mais fortes de que um projeto deva ser levado a sério. Além
disso, quanto maior o número de bugs no banco de dados, melhor para
a visibilidade do projeto. Isso pode parecem sem sentido, mas lembre-se
que o número de bugs registrados realmente dependem de três coisas:
o número absoluto de bugs presentes no software, o número de usuários
do software, e a conveniência de qual esses usuários conseguem 
registrar novos bugs. Destes três fatores, os últimos dois são
mais significantes que o primeiro.
<!-- Translated by rsantos in 2010-08-13 { -->Qualquer software de
tamanho e complexidade suficientes tem, essencialmente, um número arbitrário de
bugs esperando para serem descobertos. A verdadeira questão é, de que melhor
maneira o projeto vai guardar e prioritizar esses bugs? Um projeto com um largo
e bem mantido banco de dados de bugs (
<!-- Translation of pending part by rsantos in 2010-08-14 { --> significando que
os bugs são respondidos imediatamente<!-- } Translation of pending part
by rsantos in 2010-08-14 -->, bugs duplicados são unificados, etc.) gera,
portanto, uma melhor impressão do que um projeto com nenhum banco de dados de
bugs, ou com um banco de dados quase vazio.</para>

<para>Claro que, se o seu projeto está apenas começando, então o banco de dados
de bugs conterá muito poucos bugs, e não se tem muito o que você possa fazer
sobre isso. Mas se a página de status enfatiza que o projeto se encontra em fase
inicial, e se as pessoas perceberem que a maioria dos bugs que preenchem o
banco de dados foram enviados recentemente, elas podem concluir disso que o
projeto ainda tem uma <emphasis>taxa</emphasis> saudável de bugs conhecidos, e
não serão injustamente alarmados pelo número absolutamente baixo de bugs
gravados</para>

<para>Note que os bug trackers são frequentemente usados não somente para
rastrearem bugs, mas solicitações de melhorias, mudanças de documentação,
tarefas pendentes e mais.  Os detalhes sobre o uso de um bug tracker estão
cobertos em <xref linkend="bug-tracker"/><phrase output="printed"> no
<xref linkend="technical-infrastructure"/></phrase>, então não irei comentá-los
aqui.  A importância, do ponto de vista da apresentação, é justamente o de
<emphasis>ter</emphasis> um bug tracker, e ter certeza de que este esteja
visível na página inicial do projeto.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="communications-channels">
<title>Canais de Comunicações</title>

<para>Os visitantes normalmente querem saber como alcançarem os seres humanos
envolvidos no projeto.  Providencie os endereços das listas de discussões, das
salas de bate-papo, dos canais de IRC, e de qualquer outros fórums onde os
otros envolvidos com o software possam ser alcançados. Deixe claro que você e
os outros autores do projeto estão subscritos a essas listas de discussões,
assim, as pessoas veem que se tem alguma forma de enviarem seus feedbacks aos
desenvolvedores.  A sua presença nas listas não implica um comprometimento em
responder a todas as perguntas ou em implementar todos os pedidos de
novos recursos.  A longo prazo, a maioria dos usuários provavelmente nunca se
juntará aos fórums de qualquer maneira, mas eles estarão confortáveis em
saber que <emphasis>poderiam</emphasis> se alguma vez necessitassem.</para>

<para>Nos primeiros "passos" de um projeto, não há necessidade de se ter
fórums de usuários e desenvolvedores separados.  É muito melhor ter todos os
envolvidos com o software conversando juntos, em uma única "sala".  Entre
os primeiros seguidores, a distinção entre desenvolvedores e usuários é
frequentemente nula; para a dimensão que a distinção pode ser feita, a taxa de
desenvolvedores por usuários é normalmente muito alta nos primeiros dias do
projeto do que mais tarde.  Enquanto você não pode presumir que cada um dos
primeiros seguidores do projeto é um programador que queira reprogramar o
software, você pode presumir que eles estão, pelo menos, interessados em
seguirem as discussões de desenvolvimento e em adquirirem um senso da
direção do projeto.</para>

<para>Como este capítulo é somente sobre como iniciar um projeto, é
apenas o suficiente dizer que esses fórums de comunicações necessitam
existir. Mais tarde, em <xref linkend="growth"/><phrase output="printed"> no
<xref linkend="communications"/></phrase>, nós iremos examinar onde e como
configurar tais fórums, quando chegar a hora, sem criar um abismo
intransponível.</para>

</sect2>
<!-- } Translated by rsantos in 2010-08-13 -->

<!-- ======================== subsection ============================== -->
<sect2 id="developer-guidelines">
<title>Developer Guidelines</title>

<para>If someone is considering contributing to the project, she'll
look for developer guidelines.  Developer guidelines are not so much
technical as social: they explain how the developers interact with
each other and with the users, and ultimately how things get
done.</para>

<para>This topic is covered in detail in
<xref linkend="written-rules"/><phrase output="printed"> in
<xref linkend="social-infrastructure"/></phrase>, but the basic
elements of developer guidelines are:

<itemizedlist>
  <listitem><para>pointers to forums for interaction with other
            developers</para> 
  </listitem>
  <listitem><para>instructions on how to report bugs and submit
            patches</para>
  </listitem>
  <listitem><para>some indication of <emphasis>how</emphasis>
            development is usually done&mdash;is the project a
            benevolent dictatorship, a democracy, or something
            else</para>
  </listitem>
</itemizedlist>

No pejorative sense is intended by "dictatorship", by the way.  It's
perfectly okay to run a tyranny where one particular developer has
veto power over all changes.  Many successful projects work this way.
The important thing is that the project come right out and say so.  A
tyranny pretending to be a democracy will turn people off; a tyranny
that says it's a tyranny will do fine as long as the tyrant is
competent and trusted.</para>
  
<para>See <ulink url="http://subversion.apache.org/docs/community-guide/"/>
for an example of particularly thorough developer guidelines, or
<ulink url="http://www.openoffice.org/dev_docs/guidelines.html"/> for
broader guidelines that focus more on governance and the spirit of
participation and less on technical matters.</para>

<para>The separate issue of providing a programmer's introduction to
the software is discussed in <xref
linkend="developer-documentation"/><phrase output="printed">
later in this chapter</phrase>.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="documentation">
<title>Documentation</title>

<para>Documentation is essential.  There needs to be
<emphasis>something</emphasis> for people to read, even if it's
rudimentary and incomplete.  This falls squarely into the "drudgery"
category referred to earlier, and is often the first area where a new
open source projects falls down.  Coming up with a mission statement
and feature list, choosing a license, summarizing development
status&mdash;these are all relatively small tasks, which can be
definitively completed and usually need not be returned to once done.
Documentation, on the other hand, is never really finished, which may
be one reason people sometimes delay starting it at all.</para>

<para>The most insidious thing is that documentation's utility to
those writing it is the reverse of its utility to those who will read
it.  The most important documentation for initial users is the basics:
how to quickly set up the software, an overview of how it works,
perhaps some guides to doing common tasks.  Yet these are exactly the
things the <emphasis>writers</emphasis> of the documentation know all
too well&mdash;so well that it can be difficult for them to see
things from the reader's point of view, and to laboriously spell out
the steps that (to the writers) seem so obvious as to be unworthy of
mention.</para>

<para>There's no magic solution to this problem.  Someone just needs
to sit down and write the stuff, and then run it by typical new users
to test its quality.  Use a simple, easy-to-edit format such as HTML,
plain text, Texinfo, or some variant of XML&mdash;something that's
convenient for lightweight, quick improvements on the spur of the
moment.  This is not only to remove any overhead that might impede the
original writers from making incremental improvements, but also for
those who join the project later and want to work on the
documentation.</para>

<para>One way to ensure basic initial documentation gets done is to
limit its scope in advance.  That way, writing it at least won't feel
like an open-ended task.  A good rule of thumb is that it should meet
the following minimal criteria:</para>

<itemizedlist>
  <listitem><para>Tell the reader clearly how much technical
            expertise they're expected to have.</para>
  </listitem>
  <listitem><para>Describe clearly and thoroughly how to set up
            the software, and somewhere near the beginning of the
            documentation, tell the user how to run some sort of
            diagnostic test or simple command to confirm that
            they've set things up correctly.  Startup
            documentation is in some ways more important than
            actual usage documentation.  The more effort someone has
            invested in installing and getting started with the
            software, the more persistent she'll be in figuring out
            advanced functionality that's not well-documented.
            When people abandon, they abandon early; therefore,
            it's the earliest stages, like installation, that need
            the most support.</para>
  </listitem>
  <listitem><para>Give one tutorial-style example of how to do a
            common task.  Obviously, many examples for many tasks
            would be even better, but if time is limited, pick one
            task and walk through it thoroughly.  Once someone
            sees that the software <emphasis>can</emphasis> be
            used for one thing, they'll start to explore what else
            it can do on their own&mdash;and, if you're lucky,
            start filling in the documentation themselves.  Which
            brings us to the next point...</para>
  </listitem>
  <listitem><para>Label the areas where the documentation is known
            to be incomplete.  By showing the readers that you are
            aware of its deficiencies, you align yourself with
            their point of view.  Your empathy reassures them that
            they don't face a struggle to convince the project of
            what's important.  These labels needn't represent
            promises to fill in the gaps by any particular date
           &mdash;it's equally legitimate to treat them as open
            requests for volunteer help.</para>
  </listitem>
</itemizedlist>

<para>The last point is of wider importance, actually, and can be
applied to the entire project, not just the documentation.  An
accurate accounting of known deficiencies is the norm in the open
source world.  You don't have to exaggerate the project's
shortcomings, just identify them scrupulously and dispassionately when
the context calls for it (whether in the documentation, in the bug
tracking database, or on a mailing list discussion).  No one will
treat this as defeatism on the part of the project, nor as a
commitment to solve the problems by a certain date, unless the project
makes such a commitment explicitly.  Since anyone who uses the
software will discover the deficiencies for themselves, it's much
better for them to be psychologically prepared&mdash;then the
project will look like it has a solid knowledge of how it's
doing.</para>

<sidebar id="starting-a-faq">
  <title>Maintaining a FAQ</title>

  <para>A <firstterm>FAQ</firstterm> ("Frequently Asked Questions"
  document) can be one of the best investments a project makes in
  terms of educational payoff.  FAQs are highly tuned to the questions
  users and developers actually ask&mdash;as opposed to the questions
  you might have <emphasis>expected</emphasis> them to ask&mdash;and
  therefore, a well-maintained FAQ tends to give those who consult it
  exactly what they're looking for.  The FAQ is often the first place
  users look when they encounter a problem, often even in preference
  to the official manual, and it's probably the document in your
  project most likely to be linked to from other sites.</para>

  <para>Unfortunately, you cannot make the FAQ at the start of the
  project.  Good FAQs are not written, they are grown.  They are by
  definition reactive documents, evolving over time in response to
  people's day-to-day usage of the software.  Since it's impossible to
  correctly anticipate the questions people will ask, it is impossible
  to sit down and write a useful FAQ from scratch.</para>

  <para>Therefore, don't waste your time trying to.  You may, however,
  find it useful to set up a mostly blank FAQ template, so there will
  be an obvious place for people to contribute questions and answers
  after the project is under way.  At this stage, the most important
  property is not completeness, but convenience: if the FAQ is easy to
  add to, people will add to it.  (Proper FAQ maintenance is a
  non-trivial and intriguing problem, and is discussed more in <xref
  linkend="faq-manager"/><phrase output="printed"> in
  <xref linkend="managing-volunteers"/></phrase>.)</para>
</sidebar>

<sect3 id="documentation-availability">
<title>Availability of documentation</title>

<para>Documentation should be available from two places: online
(directly from the web site), <emphasis>and</emphasis> in the
downloadable distribution of the software (see
<xref linkend="packaging"/><phrase output="printed"> in
<xref linkend="development-cycle"/></phrase>).  It needs to be
online, in browsable form, because people often read documentation
<emphasis>before</emphasis> downloading software for the first time,
as a way of helping them decide whether to download at all.  But it
should also accompany the software, on the principle that downloading
should supply (i.e., make locally accessible) everything one needs to
use the package.</para>

<para>For online documentation, make sure that there is a link that
brings up the <emphasis>entire</emphasis> documentation in one HTML
page (put a note like "monolithic" or "all-in-one" or "single large
page" next to the link, so people know that it might take a while to
load).  This is useful because people often want to search for a
specific word or phrase across the entire documentation.  Generally,
they already know what they're looking for; they just can't remember
what section it's in.  For such people, nothing is more frustrating
than encountering one HTML page for the table of contents, then a
different page for the introduction, then a different page for
installation instructions, etc.  When the pages are broken up like
that, their browser's search function is useless.  The separate-page
style is useful for those who already know what section they need, or
who want to read the entire documentation from front to back in
sequence.  But this is <emphasis>not</emphasis> the most common way
documentation is accessed.  Far more often, someone who is basically
familiar with the software is coming back to search for a specific
word or phrase.  To fail to provide them with a single, searchable
document would only make their lives harder.</para>

</sect3>

<sect3 id="developer-documentation">
<title>Developer documentation</title>

<para>Developer documentation is written to help programmers
understand the code, so they can repair and extend it.  This is
somewhat different from the <emphasis>developer guidelines</emphasis>
discussed earlier, which are more social than technical.  Developer
guidelines tell programmers how to get along with each other;
developer documentation tells them how to get along with the code
itself.  The two are often packaged together in one document for
convenience (as with the <ulink
url="http://subversion.apache.org/docs/community-guide/"/> example given
earlier), but they don't have to be.</para>

<para>Although developer documentation can be very helpful, there's no
reason to delay a release to do it.  As long as the original authors
are available (and willing) to answer questions about the code, that's
enough to start with.  In fact, having to answer the same questions
over and over is a common motivation for writing documentation.  But
even before it's written, determined contributors will still manage to
find their way around the code.  The force that drives people to spend
time learning a code base is that the code does something useful for
them.  If people have faith in that, they will take the time to figure
things out; if they don't have that faith, no amount of developer
documentation will get or keep them.</para>

<para>So if you have time to write documentation for only one
audience, write it for users.  All user documentation is, in effect,
developer documentation as well; any programmer who's going to work on
a piece of software will need to be familiar with how to use it.
Later, when you see programmers asking the same questions over and
over, take the time to write up some separate documents just for
them.</para>

<para>Some projects use wikis for their initial documentation, or even
as their primary documentation.  In my experience, this really only
works if the wiki is actively edited by a few people who agree on how
the documentation is to be organized and what sort of "voice" it
should have.  See
<xref linkend="wikis"/><phrase output="printed"> in
<xref linkend="technical-infrastructure"/></phrase> for
more.</para>

</sect3>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="example-output">
<title>Example Output and Screenshots</title>

<para>If the project involves a graphical user interface, or if it
produces graphical or otherwise distinctive output, put some samples
up on the project web site.  In the case of interface, this means
screenshots; for output, it might be screenshots or just files.  Both
cater to people's need for instant gratification: a single screenshot
can be more convincing than paragraphs of descriptive text and mailing
list chatter, because a screenshot is inarguable proof that the
software <emphasis>works</emphasis>.  It may be buggy, it may be hard
to install, it may be incompletely documented, but that screenshot is
still proof that if one puts in enough effort, one can get it to
run.</para>

<sidebar id="screenshots">
  <title>Screenshots</title>
  <para>Since screenshots can be daunting until you've actually made a
  few, here are basic instructions for making them.  Using the Gimp
  (<ulink url="http://www.gimp.org/"/>), open
  <guimenu>File</guimenu>-&gt;<guimenu>Acquire</guimenu>-&gt;<guimenu>Screenshot</guimenu>,
  choose <guimenuitem>Single&nbsp;Window</guimenuitem> or
  <guimenuitem>Whole&nbsp;Screen</guimenuitem>, then click
  <guimenuitem>OK</guimenuitem>.  Now your next mouse click will
  capture the window or screen clicked on as an image in the Gimp.
  Crop and resize the image as necessary, using the instructions at 
  <ulink url="http://www.gimp.org/tutorials/Lite_Quickies/#crop"/>.</para> 
</sidebar>
  
</sect2>

<para>There are many other things you could put on the project web
site, if you have the time, or if for one reason or another they are
especially appropriate: a news page, a project history page, a related
links page, a site-search feature, a donations link, etc.  None of
these are necessities at startup time, but keep them in mind for the
future.</para>

<sect2 id="starting-with-canned-hosting">
<title>Canned Hosting</title>

<para>There are a few sites that provide free hosting and
infrastructure for open source projects: a web area, version control,
a bug tracker, a download area, chat forums, regular backups, etc.
The details vary from site to site, but the same basic services are
offered at all of them.  By using one of these sites, you get a lot
for free; what you give up, obviously, is fine-grained control over
the user experience.  The hosting service decides what software the
site runs, and may control or at least influence the look and feel of
the project's web pages.</para>

<para>See
<xref linkend="canned-hosting"/><phrase output="printed"> in
<xref linkend="technical-infrastructure"/></phrase> for a more
detailed discussion of the advantages and disadvantages of canned
hosting, and a list of sites that offer it.</para>

</sect2>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="license-quickstart">
<title>Choosing a License and Applying It</title>

<para>This section is intended to be a very quick, very rough guide to
choosing a license.  Read <xref linkend="legal"/> to understand
the detailed legal implications of the different licenses, and how the
license you choose can affect people's ability to mix your software
with other free software.</para>

<para>There are a great many free software licenses to choose from.
Most of them we needn't consider here, as they were written to satisfy
the particular legal needs of some corporation or person, and wouldn't
be appropriate for your project.  We will restrict ourselves to just
the most commonly used licenses; in most cases, you will want to
choose one of them.</para>

<!-- ======================== subsection ============================== -->
<sect2 id="license-quickstart-non-gpl">
<title>The "Do Anything" Licenses</title>

<para>If you're comfortable with your project's code potentially being
used in proprietary programs, then use
an <firstterm>MIT/X-style</firstterm> license.  It is the simplest of
several minimal licenses that do little more than assert nominal
copyright (without actually restricting copying) and specify that the
code comes with no warranty.  See
<xref linkend="license-choosing-mit-x"/> for details.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="license-quickstart-gpl">
<title>The GPL</title>

<para>If you don't want your code to be used in proprietary programs,
use the GNU General Public License
(<ulink url="http://www.gnu.org/licenses/gpl.html"/>).  The GPL is
probably the most widely recognized free software license in the world
today.  This is in itself a big advantage, since many potential users
and contributors will already be familiar with it, and therefore won't
have to spend extra time to read and understand your license.  See
<xref linkend="license-choosing-gpl"/><phrase output="printed">
in <xref linkend="legal"/></phrase> for details.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="license-quickstart-applying">
<title>How to Apply a License to Your Software</title>

<para>Once you've chosen a license, you should state it on the
project's front page.  You don't need to include the actual text of
the license there; just give the name of the license, and make it link
to the full license text on another page.</para>

<para>This tells the public what license you
<emphasis>intend</emphasis> the software to be released under, but
it's not sufficient for legal purposes.  For that, the software itself
must contain the license.  The standard way to do this is to put the
full license text in a file called <filename>COPYING</filename> (or
<filename>LICENSE</filename>), and then put a short notice at the top
of each source file, naming the copyright date, holder, and license,
and saying where to find the full text of the license.</para>

<para>There are many variations on this pattern, so we'll look at just
one example here.  The GNU GPL says to put a notice like this at the
top of each source file:</para>

<screen>
Copyright (C) &lt;year&gt;  &lt;name of author&gt;

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
</screen>

<para>It does not say specifically that the copy of the license you
received along with the program is in the file
<filename>COPYING</filename>, but that's where it's usually put.  (You
could change the above notice to state that directly.)  This template
also gives a geographical address from which to request a copy of the
license.  Another common method is to give a link to a web page
containing the license.  Just use your judgement and point to wherever
you feel the most permanent copy of the license is maintained, which
might simply be somewhere on your project's web site.  In general, the
notice you put in each source file does not have to look exactly like
the one above, as long as it starts with the same notice of copyright
holder and date, states the name of the license, and makes it clear
where to view the full license.</para>

</sect2>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="setting-tone">
<title>Setting the Tone</title>

<para>So far we've covered one-time tasks you do during project setup:
picking a license, arranging the initial web site, etc.  But the most
important aspects of starting a new project are dynamic.  Choosing a
mailing list address is easy; ensuring that the list's conversations
remain on-topic and productive is another matter entirely.  If the
project is being opened up after years of closed, in-house
development, its development processes will change, and you will have
to prepare the existing developers for that change.</para>

<para>The first steps are the hardest, because precedents and
expectations for future conduct have not yet been set.  Stability in a
project does not come from formal policies, but from a shared,
hard-to-pin-down collective wisdom that develops over time.  There are
often written rules as well, but they tend to be essentially a
distillation of the intangible, ever-evolving agreements that really
guide the project.  The written policies do not define the project's
culture so much as describe it, and even then only
approximately.</para>

<para>There are a few reasons why things work out this way.  Growth
and high turnover are not as damaging to the accumulation of social
norms as one might think.  As long as change does not happen
<emphasis>too</emphasis> quickly, there is time for new arrivals to
learn how things are done, and after they learn, they will help
reinforce those ways themselves.  Consider how children's songs
survive the centuries.  There are children today singing roughly the
same rhymes as children did hundreds of years ago, even though there
are no children alive now who were alive then.  Younger children hear
the songs sung by older ones, and when they are older, they in turn
will sing them in front of other younger ones.  The children are not
engaging in a conscious program of transmission, of course, but the
reason the songs survive is nonetheless that they are transmitted
regularly and repeatedly.  The time scale of free software projects
may not be measured in centuries (we don't know yet), but the dynamics
of transmission are much the same.  The turnover rate is faster,
however, and must be compensated for by a more active and deliberate
transmission effort.</para>

<para>This effort is aided by the fact that people generally show up
expecting and looking for social norms.  That's just how humans are
built.  In any group unified by a common endeavor, people who join
instinctively search for behaviors that will mark them as part of the
group.  The goal of setting precedents early is to make those
"in-group" behaviors be ones that are useful to the project; for once
established, they will be largely self-perpetuating.</para>

<!-- todo: maybe say this:

     Point out how the sponsor's noble fair-mindedness and balanced
     judgement are not properties that can usefully be written down
     formally, because they wouldn't be believed.  They'd just look
     like propaganda anyway, so there's no point.  This is one of
     those areas where conduct and informal precedent is the *only*
     way to solidify a social norm.  And refer to the relevant parts
     of Chapter 5.
-->

<para>Following are some examples of specific things you can do to set
good precedents.  They're not meant as an exhaustive list, just as
illustrations of the idea that setting a collaborative mood early
helps a project tremendously.  Physically, every developer may be
working alone in a room by themselves, but you can do a lot to make
them <emphasis>feel</emphasis> like they're all working together in
the same room.  The more they feel this way, the more time they'll
want to spend on the project.  I chose these particular examples
because they came up in the Subversion project (<ulink
url="http://subversion.tigris.org/"/>),
which I participated in and observed from its very beginning.  But
they're not unique to Subversion; situations like these will come up
in most open source projects, and should be seen as opportunities to
start things off on the right foot.</para>

<!-- ======================== subsection ============================== -->
<sect2 id="avoid-private-discussions">
<title>Avoid Private Discussions</title>

<para>Even after you've taken the project public, you and the other
founders will often find yourselves wanting to settle difficult
questions by private communications among an inner circle.  This is
especially true in the early days of the project, when there are so
many important decisions to make, and, usually, few volunteers
qualified to make them.  All the obvious disadvantages of public list
discussions will loom palpably in front of you: the delay inherent in
email conversations, the need to leave sufficient time for consensus
to form, the hassle of dealing with naive volunteers who think they
understand all the issues but actually don't (every project has these;
sometimes they're next year's star contributors, sometimes they stay
naive forever), the person who can't understand why you only want to
solve problem X when it's obviously a subset of larger problem Y, and
so on.  The temptation to make decisions behind closed doors and
present them as <foreignphrase>faits accomplis</foreignphrase>, or at
least as the firm recommendations of a united and influential voting
block, will be great indeed.</para>

<para>Don't do it.</para>

<para>As slow and cumbersome as public discussions can be, they're
almost always preferable in the long run.  Making important decisions
in private is like spraying contributor repellant on your project.  No
serious volunteer would stick around for long in an environment where
a secret council makes all the big decisions.  Furthermore, public
discussion has beneficial side effects that will last beyond whatever
ephemeral technical question was at issue:

<itemizedlist>
  <listitem>
  <para>The discussion will help train and educate new developers.
        You never know how many eyes are watching the conversation;
        even if most people don't participate, many may be tracking
        silently, gleaning information about the software.</para>
  </listitem>
  <listitem>
  <para>The discussion will train <emphasis>you</emphasis> in the art
        of explaining technical issues to people who are not as
        familiar with the software as you are.  This is a skill that
        requires practice, and you can't get that practice by talking
        to people who already know what you know.</para>
  </listitem>
  <listitem>
  <para>The discussion and its conclusions will be available in public
        archives forever after, enabling future discussions to avoid
        retracing the same steps.  See
        <xref linkend="using-archives"/><phrase output="printed">
        in <xref linkend="communications"/></phrase>.</para>
  </listitem>
</itemizedlist>

</para>

<para>Finally, there is the possibility that someone on the list may
make a real contribution to the conversation, by coming up with an
idea you never anticipated.  It's hard to say how likely this is; it
just depends on the complexity of the code and degree of
specialization required.  But if anecdotal evidence may be permitted,
I would hazard that this is more likely than one would intuitively
expect.  In the Subversion project, we (the founders) believed we
faced a deep and complex set of problems, which we had been thinking
about hard for several months, and we frankly doubted that anyone on
the newly created mailing list was likely to make a real contribution
to the discussion.  So we took the lazy route and started batting some
technical ideas back and forth in private emails, until an observer of
the project<footnote><para>We haven't gotten to the section on
crediting yet, but just to practice what I'll later preach: the
observer's name was Brian Behlendorf, and it was he who pointed out
the general importance of keeping all discussions public unless there
was a specific need for privacy.</para></footnote> caught wind of what
was happening and asked for the discussion to be moved to the public
list.  Rolling our eyes a bit, we did&mdash;and were stunned by the
number of insightful comments and suggestions that quickly resulted.
In many cases people offered ideas that had never even occurred to us.
It turned out there were some <emphasis>very</emphasis> smart people
on that list; they'd just been waiting for the right bait.  It's true
that the ensuing discussions took longer than they would have if we
had kept the conversation private, but they were so much more
productive that it was well worth the extra time.</para>

<para>Without descending into hand-waving generalizations like "the
group is always smarter than the individual" (we've all met enough
groups to know better), it must be acknowledged that there are certain
activities at which groups excel.  Massive peer review is one of them;
generating large numbers of ideas quickly is another.  The quality of
the ideas depends on the quality of the thinking that went into them,
of course, but you won't know what kinds of thinkers are out there
until you stimulate them with a challenging problem.</para>

<para>Naturally, there are some discussions that must be had
privately; throughout this book we'll see examples of those.  But the
guiding principle should always be: <emphasis>If there's no reason for
it to be private, it should be public.</emphasis></para>

<para>Making this happen requires action.  It's not enough merely to
ensure that all your own posts go to the public list.  You also have
to nudge other people's unnecessarily private conversations to the
list too.  If someone tries to start a private discussion, and there's
no reason for it to be private, then it is incumbent on you to open
the appropriate meta-discussion immediately.  Don't even comment on
the original topic until you've either successfully steered the
conversation to a public place, or ascertained that privacy really was
needed.  If you do this consistently, people will catch on pretty
quickly and start to use the public forums by default.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="prevent-rudeness">
<title>Nip Rudeness in the Bud</title>

<para>From the very start of your project's public existence, you
should maintain a zero-tolerance policy toward rude or insulting
behavior in its forums.  Zero-tolerance does not mean technical
enforcement per se.  You don't have to remove people from the mailing
list when they flame another subscriber, or take away their commit
access because they made derogatory comments.  (In theory, you might
eventually have to resort to such actions, but only after all other
avenues have failed&mdash;which, by definition, isn't the case at the
start of the project.)  Zero-tolerance simply means never letting bad
behavior slide by unnoticed.  For example, when someone posts a
technical comment mixed together with an <foreignphrase>ad
hominem</foreignphrase> attack on some other developer in the project,
it is imperative that your response address the <foreignphrase>ad
hominem</foreignphrase> attack <emphasis>first</emphasis>, as a
separate issue unto itself, and only afterward move on to the
technical content.</para>

<para>It is unfortunately very easy, and all too typical, for
constructive discussions to lapse into destructive flame wars.
People will say things in email that they would never say
face-to-face.  The topics of discussion only amplify this effect: in
technical issues, people often feel there is a single right answer to
most questions, and that disagreement with that answer can only be
explained by ignorance or stupidity.  It's a short distance from
calling someone's technical proposal stupid to calling the person
themselves stupid.  In fact, it's often hard to tell where technical
debate leaves off and character attack begins, which is one reason why
drastic responses or punishments are not a good idea.  Instead, when
you think you see it happening, make a post that stresses the
importance of keeping the discussion friendly, without accusing anyone
of being deliberately poisonous.  Such "Nice Police" posts do have an
unfortunate tendency to sound like a kindergarten teacher lecturing a
class on good behavior:</para>

    <blockquote>
      <para><emphasis>First, let's please cut down on the
      (potentially) ad hominem comments; for example, calling J's
      design for the security layer "naive and ignorant of the basic
      principles of computer security."  That may be true or it may
      not, but in either case it's no way to have the discussion.  J
      made his proposal in good faith.  If it has deficiencies, point
      them out, and we'll fix them or get a new design.  I'm sure M
      meant no personal insult to J, but the phrasing was unfortunate,
      and we try to keep things constructive around here.
      </emphasis></para>

      <para><emphasis>Now, on to the proposal.  I think M was right
      in saying that...</emphasis></para>
    </blockquote>

<para>As stilted as such responses sound, they have a noticeable
effect.  If you consistently call out bad behavior, but don't demand
an apology or acknowledgment from the offending party, then you leave
people free to cool down and show their better side by behaving more
decorously next time&mdash;and they will.  One of the secrets of
doing this successfully is to never make the meta-discussion the main
topic.  It should always be an aside, a brief preface to the main
portion of your response.  Point out in passing that "we don't do
things that way around here," but then move on to the real content, so
that you're giving people something on-topic to respond to.  If
someone protests that they didn't deserve your rebuke, simply refuse
to be drawn into an argument about it.  Either don't respond (if you
think they're just letting off steam and don't require a response), or
say you're sorry if you overreacted and that it's hard to detect
nuance in email, then get back to the main topic.  Never, ever insist
on an acknowledgment, whether public or private, from someone that
they behaved inappropriately.  If they choose of their own volition to
post an apology, that's great, but demanding that they do so will only
cause resentment.</para>

<para>The overall goal is to make good etiquette be seen as one of the
"in-group" behaviors.  This helps the project, because developers can
be driven away (even from projects they like and want to support) by
flame wars.  You may not even know that they were driven away; someone
might lurk on the mailing list, see that it takes a thick skin to
participate in the project, and decide against getting involved at
all.  Keeping forums friendly is a long-term survival strategy, and
it's easier to do when the project is still small.  Once it's part of
the culture, you won't have to be the only person promoting it.  It
will be maintained by everyone.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="code-review">
<title>Practice Conspicuous Code Review</title>

<para>One of the best ways to foster a productive development
community is to get people looking at each others' code.  Some
technical infrastructure is required to do this effectively&mdash;in
particular, commit emails must be turned on; see
<xref linkend="commit-emails"/> for more details.  The effect of
commit emails is that every time someone commits a change to the
source code, an email goes out showing the log message and diffs for
the change (see <xref linkend="vc-vocabulary-diff"/>, in
<xref linkend="vc-vocabulary"/>).  <firstterm>Code review</firstterm>
is the practice of reviewing commit emails as they come in, looking
for bugs and possible improvements.<footnote><para>This is how code
review is usually done in open source projects, at any rate.  In more
centralized projects, "code review" can also mean multiple people
sitting down together and going over printouts of source code, looking
for specific problems and patterns.</para></footnote></para>

<para>Code review serves several purposes simultaneously.  It's the
most obvious example of peer review in the open source world, and
directly helps to maintain software quality.  Every bug that ships in
a piece of software got there by being committed and not detected;
therefore, the more eyes watch commits, the fewer bugs will ship.  But
code review also serves an indirect purpose: it confirms to people
that what they do matters, because one obviously wouldn't take time to
review a commit unless one cared about its effect.  People do their
best work when they know that others will take the time to evaluate
it.</para>

<para>Reviews should be public.  Even on occasions when I have been
sitting in the same physical room with developers, and one of us has
made a commit, we take care not to do the review verbally in the room,
but to send it to the development mailing list instead.  Everyone
benefits from seeing the review happen.  People follow the commentary
and sometimes find flaws in it, and even when they don't, it still
reminds them that review is an expected, regular activity, like
washing the dishes or mowing the lawn.</para>

<para>In the Subversion project, we did not at first make a regular
practice of code review.  There was no guarantee that every commit
would be reviewed, though one might sometimes look over a change if
one was particularly interested in that area of the code.  Bugs
slipped in that really could and should have been caught.  A developer
named Greg Stein, who knew the value of code review from past work,
decided that he was going to set an example by reviewing every line of
<emphasis>every single commit</emphasis> that went into the code
repository.  Each commit anyone made was soon followed by an email to
the developer's list from Greg, dissecting the commit, analyzing
possible problems, and occasionally praising a clever bit of code.  Right
away, he was catching bugs and non-optimal coding practices that would
otherwise have slipped by without ever being noticed.  Pointedly, he
never complained about being the only person reviewing every commit,
even though it took a fair amount of his time, but he did sing the
praises of code review whenever he had the chance.  Pretty soon, other
people, myself included, started reviewing commits regularly too.
What was our motivation?  It wasn't that Greg had consciously shamed
us into it.  But he had proven that reviewing code was a valuable way
to spend time, and that one could contribute as much to the project by
reviewing others' changes as by writing new code.  Once he
demonstrated that, it became expected behavior, to the point where any
commit that didn't get some reaction would cause the committer to
worry, and even ask on the list whether anyone had had a chance to
review it yet.  Later, Greg got a job that didn't leave him as much
time for Subversion, and had to stop doing regular reviews.  But by
then, the habit was so ingrained for the rest of us as to seem that it
had been going on since time immemorial.</para>

<para>Start doing reviews from very first commit.  The sorts of
problems that are easiest to catch by reviewing diffs are security
vulnerabilities, memory leaks, insufficient comments or API
documentation, off-by-one errors, caller/callee discipline mismatches,
and other problems that require a minimum of surrounding context to
spot.  However, even larger-scale issues such as failure to abstract
repeated patterns to a single location become spottable after one has
been doing reviews regularly, because the memory of past diffs informs
the review of present diffs.</para>

<!-- todo: Andrew Stellman suggested putting a checklist of what to
     look for in code review here.  That might be a good idea. -->

<para>Don't worry that you might not find anything to comment on, or
that you don't know enough about every area of the code.  There will
usually be something to say about almost every commit; even where you
don't find anything to question, you may find something to praise.
The important thing is to make it clear to every committer that what
they do is seen and understood.  Of course, code review does not
absolve programmers of the responsibility to review and test their
changes before committing; no one should depend on code review to
catch things he ought to have caught on his own.</para>

</sect2>

<!-- ======================== SECTION ============================== -->
<sect2 id="opening-closed-projects">
<title>When Opening a Formerly Closed Project, be Sensitive to the
Magnitude of the Change</title>

<para>If you're opening up an existing project, one that already has
active developers accustomed to working in a closed-source
environment, make sure everyone understands that a big change is
coming&mdash;and make sure that you understand how it's going to
feel from their point of view.</para>

<para>Try to imagine how the situation looks to them: formerly, all
code and design decisions were made with a group of other programmers
who knew the software more or less equally well, who all received the
same pressures from the same management, and who all know each others'
strengths and weaknesses.  Now you're asking them to expose their code
to the scrutiny of random strangers, who will form judgements based
only on the code, with no awareness of what business pressures may
have forced certain decisions.  These strangers will ask lots of
questions, questions that jolt the existing developers into realizing
that the documentation they slaved so hard over is
<emphasis>still</emphasis> inadequate (this is inevitable).  To top it
all off, the newcomers are unknown, faceless entities.  If one of your
developers already feels insecure about his skills, imagine how that
will be exacerbated when newcomers point out flaws in code he wrote,
and worse, do so in front of his colleagues.  Unless you have a team
of perfect coders, this is unavoidable&mdash;in fact, it will probably
happen to all of them at first.  This is not because they're bad
programmers; it's just that any program above a certain size has bugs,
and peer review will spot some of those bugs (see
<xref linkend="code-review"/><phrase output="printed"> earlier
in this chapter</phrase>).  At the same time, the newcomers
themselves won't be subject to much peer review at first, since they
can't contribute code until they're more familiar with the project.
To your developers, it may feel like all the criticism is incoming,
never outgoing.  Thus, there is the danger of a siege mentality taking
hold among the old hands.</para>

<para>The best way to prevent this is to warn everyone about what's
coming, explain it, tell them that the initial discomfort is perfectly
normal, and reassure them that it's going to get better.  Some of
these warnings should take place privately, before the project is
opened.  But you may also find it helpful to remind people on the
public lists that this is a new way of development for the project,
and that it will take some time to adjust.  The very best thing you
can do is lead by example.  If you don't see your developers answering
enough newbie questions, then just telling them to answer more isn't
going to help.  They may not have a good sense of what warrants a
response and what doesn't yet, or it could be that they don't have a
feel for how to prioritize coding work against the new burden of
external communications.  The way to get them to participate is to
participate yourself.  Be on the public mailing lists, and make sure
to answer some questions there.  When you don't have the
expertise to field a question, then visibly hand it off to a developer
who does&mdash;and watch to make sure he follows up with an answer,
or at least a response.  It will naturally be tempting for the
longtime developers to lapse into private discussions, since that's
what they're used to.  Make sure you're subscribed to the internal
mailing lists on which this might happen, so you can ask that such
discussions be moved to the public lists right away.</para>

<para>There are other, longer-term concerns with opening up formerly
closed projects.  <xref linkend="social-infrastructure"/> explores
techniques for mixing paid and unpaid developers successfully, and
<xref linkend="legal"/> discusses the necessity of legal diligence
when opening up a private code base that may contain software written
or "owned" by other parties.</para>

</sect2>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="announcing">
<title>Announcing</title>

<para>Once the project is presentable&mdash;not perfect, just
presentable&mdash;you're ready to announce it to the world.  This is
actually a very simple process: go to <ulink
url="http://freshmeat.net/"/>, click on
<guimenuitem>Submit</guimenuitem> in the top navigation bar, and fill
out a form announcing your new project.  Freshmeat is the place
everyone watches for new project announcements.  You only have to
catch a few eyes there for news of your project to spread by word of
mouth.</para>

<para>If you know of mailing lists or newsgroups where an announcement
of your project would be on-topic and of interest, then post there,
but be careful to make exactly <emphasis>one</emphasis> post per
forum, and to direct people to your project's own forums for follow-up
discussion (by setting the <systemitem>Reply-to</systemitem> header).
The posts should be short and get right to the point:</para>

<screen>
To: discuss@lists.example.org
Subject: [ANN] Scanley full-text indexer project
Reply-to: dev@scanley.org

This is a one-time post to announce the creation of the Scanley
project, an open source full-text indexer and search engine with a
rich API, for use by programmers in providing search services for
large collections of text files.  Scanley is now running code, is
under active development, and is looking for both developers and
testers.

Home page: http://www.scanley.org/

Features:
   - Searches plain text, HTML, and XML
   - Word or phrase searching
   - (planned) Fuzzy matching
   - (planned) Incremental updating of indexes
   - (planned) Indexing of remote web sites

Requirements:
   - Python 2.2 or higher
   - Enough disk space to hold the indexes (approximately 2x
     original data size)

For more information, please come to scanley.org.

Thank you,
-J. Random
</screen>

<para>(See <xref linkend="publicity"/><phrase output="printed">
in <xref linkend="communications"/></phrase> for advice on announcing
further releases and other project events.)</para>

<para>There is an ongoing debate in the free software world about
whether it is necessary to begin with running code, or whether a
project can benefit from being opened even during the
design/discussion stage.  I used to think starting with running code
was the most important factor, that it was what separated successful
projects from toys, and that serious developers would only be
attracted to software that did something concrete already.</para>

<para>This turned out not to be the case.  In the Subversion project,
we started with a design document, a core of interested and
well-connected developers, a lot of fanfare, and
<emphasis>no</emphasis> running code at all.  To my complete surprise,
the project acquired active participants right from the beginning, and
by the time we did have something running, there were quite a few
volunteer developers already deeply involved.  Subversion is not the
only example; the Mozilla project was also launched without running
code, and is now a successful and popular web browser.</para>

<para>In the face of such evidence, I have to back away from the
assertion that running code is absolutely necessary for launching a
project.  Running code is still the best foundation for success, and a
good rule of thumb would be to wait until you have it before
announcing your project.  However, there may be circumstances where
announcing earlier makes sense.  I do think that at least a
well-developed design document, or else some sort of code framework,
is necessary&mdash;of course it may be revised based on public
feedback, but there has to be something concrete, something more
tangible than just good intentions, for people to sink their teeth
into.</para>

<para>Whenever you announce, don't expect a horde of volunteers to
join the project immediately afterward.  Usually, the result of
announcing is that you get a few casual inquiries, a few more people
join your mailing lists, and aside from that, everything continues
pretty much as before.  But over time, you will notice a gradual
increase in participation from both new code contributors and users.
Announcement is merely the planting of a seed.  It can take a long
time for the news to spread.  If the project consistently rewards
those who get involved, the news <emphasis>will</emphasis> spread,
though, because people want to share when they've found something
good.  If all goes well, the dynamics of exponential communications
networks will slowly transform the project into a complex community,
where you don't necessarily know everyone's name and can no longer
follow every single conversation.  The next chapters are about working
in that environment.</para>

</sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->

