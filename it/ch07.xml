<chapter id="development-cycle">

<title>Confezione, Rilascio, e Sviluppo Quotidiano</title>

<simplesect>

<para>Questo capitolo parla di come i progetti di software libero confezionano e rilasciano i loro software e di come si organizzano le procedure generali di sviluppo su questi obiettivi. </para>

<para>Una differenza principale fra i progetti open source e quelli proprietari è il difetto di un controllo centralizzato sul team di sviluppo. Quando sta venendo preparata una nuova release, questa differenza è specialmente forte: una compagnia può richiedere al suo team di sviluppo di focalizzarsi sula prossima release, mettendo da parte lo sviluppo di nuove funzionalità e la correzione di bugs non critici fino a che il rilascio non è avvenuto. I gruppi di volontari no sono così monolitici. La gente lavora al progetto per tutti i tipi di motivazioni, e quelli non interessati  a favorire una data release vogliono continuare il lavoro di sviluppo mentre la release sta andando avanti. Poiché lo sviluppo non si ferma, i processi di rilascio tendono a impiegare più tempo, ma sono meno distruttivi, dei processi di rilascio commerciali. Questo è in po' come ritrovare la strada maestra.
Ci sono due modi di riparare una strada: potete chiuderla completamente, così che il gruppo che sta riparando la strada maestra può sciamare su di essa alla piena capacità finché il problema è risolto, o potete lavorare su una coppia di corsie alla volta, lasciando le altre aperte al traffico. Il primo modo è molto efficace <emphasis>per il gruppo di riparazione</emphasis>, but not for anyone else&mdash;ma non per gli altri la strada è chiusa completamente fino a che il lavoro non è completato. Il secondo modo richiede molto più tempo comporta più problemi per il gruppo di riparazione (ora essi devono lavorare con meno gente e meno equipaggiamento, in condizioni più ristrette, con bandiere per rallentare e dirigere il traffico, ecc..), ma almeno la strada rimane utilizzabile, sebbene non con la sua piena capacità.</para>

<para>I progetti open source tendono a funzionare nel secondo modo. Infatti per un pezzo di software maturo con diverse linee di rilascio mantenute simultaneamente, il progetto è un genere di stato di permanente riparazione di una strada. C'è sempre una coppia di corsie chiuse ma un basso livello di inconveniente di fondo vien sempre tollerato dal gruppo di sviluppo nel complesso, cosicché le release vengono effettuate con una programmazione regolare. </para>

<para>Il modello che rende ciò  possibile si estende a più che una sola release. E' il principio di mettere in parallelo  operazioni che non sono mutualmente interdipendenti un principio che non è in nessun modo unico dello sviluppo open source, certamente, ma è un principio che i progetti open source implementano fra propri in particolar modo. Essi non possono permettersi di infastidire molto sia il gruppo di lavoro sulla strada sia il regolare traffico, ma non possono permettersi anche di avere gente dedita a fare affidamento sui coni arancione e a fare segnalazioni lungo il traffico. Così essi sono attratti da processi che hanno piatti, costanti livelli di spese generali amministrative, piuttosto che picchi e valli. I volontari vogliono generalmente lavorare con piccoli ma consistenti quantità di incomodo. La prevedibilità permette loro di venire e andare senza senza preoccuparsi se il loro programma contrasterà con ciò che sta avvenendo nel progetto. Ma se il progetto fosse soggetto a un importante programma in cui alcune attività escludessero altre attività, il risultato sarebbe un sacco di sviluppatori seduti a oziare per un sacco di tempo la qualcosa sarebbe non solo inefficiente ma tediosa, e quindi dannosa, in quanto uno sviluppatore annoiato è equivalente presto a un ex sviluppatore. </para>

<para>Il lavoro di release è usualmente la più notevole operazione che avviene in parallelo con lo sviluppo, così i metodi descritti nella prossima sezione sono per lo più attrezzati a rendere possibili le releases. Comunque notate che essi si applicano anche ad altre operazione eseguibili in parallelo, come la traduzione e l'internazionalizzazione, grandi cambiamenti alle API fatti generalmente lungo tutto il codice base, ecc..</para>

</simplesect>

<!-- ========================== SECTION =========================== -->

<sect1 id="release-numbering">
<title>Numerazione delle Releases</title>

<para>Prima di parlare di come fare una release, vediamo come chiamare una release, che vuol dire sapere veramente cosa significa per un utilizzatore. Una release significa che:</para>

<itemizedlist>

  <listitem><para>I vecchi bugs sono stati corretti. Questa è probabilmente l'unica cosa sulla cui verità gli utilizzatori possono contare.</para>
  </listitem>

  <listitem><para>Nuovi bugs si sono aggiunti. Questa è anche una cosa su cui si può contare, tranne a volte nel caso di releases di sicurezza o di altre cose che avvengono una sola volta (vedere
            <xref linkend="security-releases"/><phrase
            output="printed"> più avanti in questo capitolo</phrase>).</para>
  </listitem>

  <listitem><para>Nuove funzionalità possono essere state aggiunte.</para>
  </listitem>

  <listitem><para>Nuove opzioni di configurazione possono essere state aggiunte, o il fine delle vecchie opzioni può essere stato cambiato di poco. Le procedure di installazione anche possono essere cambiate sin dalla ultima release, sebbene uno speri di no.</para>
  </listitem>

  <listitem><para>Possono essere stati introdotti cambiamenti incompatibili, sicché alcuni formati di dati usati dalle versioni più vecchie non sono più utilizzabile senza sopportare qualche sorta di (possibilmente manuale) passo a senso unico. </para>
  </listitem>

</itemizedlist>

<para>Come potete vedere non tutte queste cose sono buone. Questo è il motivo per cui utilizzatori di esperienza si avvicinano alle nuove releases con qualche apprensione, specialmente quando il software è maturo e stavano già per la maggior parte facendo quello che volevano (o pensavano quello che volevano). Anche l'arrivo di nuove funzionalità è una benedizione di diversa specie, in quanto può significare che il software si comporterà ora in maniera imprevista.</para>

<para>Lo scopo della numerazione delle versioni, quindi, è duplice: ovviamente dovrebbero comunicare senza ambiguità l'orine delle releases (cioè, guardando a una di due releases, uno può sapere quella che viene dopo), ma anche dovrebbe indicare in modo quanto più compatto possibile il grado e la natura dei cambiamenti nella release. </para>

<para>Tutto questo in un numero? Si, più o meno, si. La strategia della numerazione delle releases è una delle più vecchie superflue discussioni qua e là
(vedere <xref linkend="bikeshed"/><phrase output="printed"> in
<xref linkend="communications"/></phrase>), ed è improbabile che il mondo pattuisca un unico completo standard molto presto. Comunque poche buone strategie sono emerse, insieme a un principio su cui si è universalmente d'accordo: <emphasis> essere in armonia</emphasis>.
Scegliete uno schema di numerazione, documentatelo, e seguitelo. I vostri utilizzatori vi ringrazieranno.</para>

<!-- ========================== subsection =========================== -->
<sect2 id="release-number-components">
<title>I Componenti del Numero di Rilascio</title>

<para>Questa sezione descrive le convenzioni formali della numerazione delle releases, e presuppone, una piccola precedente conoscenza. Se già avete familiarità con queste convenzioni, potete saltare questa sezione.</para>

<para>I numeri delle releases son gruppi di cifre separate da punti:</para>

<informalexample>
<literallayout>Scanley 2.3
Singer 5.11.4</literallayout>
</informalexample>

<para>...e così via.  I punti <emphasis>non</emphasis> ono punti decimali, essi sono solamente separatori; "5.3.9" sarebbe seguito da
"5.3.10".  Pochi progetti hanno fatto intendere diversamente, il più famoso il kernel Linux con la sua sequenza "0.95", "0.96"... "0.99" 
leading up to Linux 1.0, ma la convenzione che i punti non sono decimali è fermamente stabilita e deve essere considerato uno standard. Non c'è un limite al numero dei componenti (parti di cifre non contenenti il punto), ma la maggior parte dei progetti non va oltre tre o quattro. La ragione diventerà chiara avanti.</para>

<para>In aggiunta a componenti numerici i progetti a volte aggiungono un'etichetta descrittiva tipo “Alpha” o “Beta” (vedere
<xref linkend="alpha-and-beta"/>), per esempio:</para>

<informalexample>
<literallayout>Scanley 2.3.0 (Alpha)
Singer 5.11.4 (Beta)</literallayout>
</informalexample>

<para>Un qualificatore Alpha o Beta significa che quella release  <emphasis>precede</emphasis>una futura release che avrà lo stesso numero senza il qualificatore  Così, "2.3.0&nbsp;(Alpha)"
porta alla fine a "2.3.0".  Per far entrare queste release candidate in una riga, gli stessi qualificatori posso avere dei meta-qualificatori. Per esempio qui c'è una serie di releases che sarebbero rese disponibili al pubblico:</para>

<informalexample>
<literallayout>Scanley 2.3.0 (Alpha 1)
Scanley 2.3.0 (Alpha 2)
Scanley 2.3.0 (Beta 1)
Scanley 2.3.0 (Beta 2)
Scanley 2.3.0 (Beta 3)
Scanley 2.3.0</literallayout>
</informalexample>

<para>Notate che quando essa ha il qualificatore  “Alpha” Scanley "2.3" si scrive "2.3.0". I due numeri sono equivalenti&mdash;tutti i componenti 0 seguenti possono sempre essere eliminati per brevità ma quando un qualificatore è presente, la brevità smette di esistere comunque, come pure uno potrebbe scegliere la completezza invece. </para>

<para>Altri qualificatori semi regolari usano includere “Stabile”, “Instabile”, “Sviluppo” e “RC” (per “Release Candidate”). Le più largamente usate sono comunque "Alpha" e "Beta", con “RC” che concorre da vicino per il terzo posto, ma notate che “RC” include sempre un meta-qualificatore numerico. Cioè non rilasciate
"Scanley&nbsp;2.3.0&nbsp;(RC)", voi rilasciate
"Scanley&nbsp;2.3.0&nbsp;(RC&nbsp;1)", seguita dalla RC2, etc.</para>

<para>Queste tre etichette “Alpha”, “Beta” e “RC” sono piuttosto largamente conosciute ora, e raccomando di non usare le altre, anche se a prima vista sembrano scelte migliori perché sono parole normali, non gergo. Ma la gente che installa software da release ha già familiarità con quelle tre, è non c'è motivo per fare cose gratuitamente in modo differente dal modo in cui chiunque altro le fa.</para>

<para>Sebbene i punti nei numeri delle realases non siano punti decimali, indicano un significato del valore della posizione. Tutte le realeases "0.X.Y" precedono la "1.0" (che è equivalente alla “1.0.0”, certo). La"3.14.158" precede immediatamente la "3.14.159" e non immediatamente precede la "3.14.160" come la "3.15.qualcosa", e così via. </para>

<para>Una politica di numerazione delle releases rende capace l'utilizzatore di di guardare ai numeri di rilascio per lo stesso pezzo di software e dire, proprio dai numeri, le importanti differenze fra queste due relaeases. In un tripico sistema a tre componenti il primo componente è il<firstterm>numero&nbsp;maggiore</firstterm>, il secondo è il  <firstterm>il secondo è il numero&nbsp;minore</firstterm>, il terzo è il
<firstterm>micro&nbsp;numero</firstterm>.  FPer esempio, la release "2.10.17" è la diciassettesima micro-relaese nella decima linea di release minore entro la seconda serie di release maggiore. Le parole “linea” e “serie” sono usate informalmente qui, 
ma significano ciò che uno si aspetterebbe. Una serie maggiore sono semplicemente tutte le releases che hanno in comune lo stesso numero maggiore, e una serie minore (o linea minore) sono semplicemente tutte le releases che hanno in comune lo stesso numero maggiore <emphasis>e</emphasis> lo stesso numero minore.  Cioè la "2.4.0" e la "3.4.1" non si trovano nella stessa serie minore anche se ambedue hanno “4” come numero minore; d'altra parte la "2.4.0" e la "2.4.2" si trovano nella stessa linea minore, sebbene non siano adiacenti se la “2.4.1” è stata rilasciata fra di esse.</para>

<para>Il significato di questi numeri è esattamente ciò che vi aspettereste: un aumento del numero maggiore indica che il cambiamento maggiore è avvenuto; un cambiamento del numero minore indica che sono avvenuti cambiamenti minori, e un cambiamento del micro numero indica cambiamenti trascurabili. Alcuni progetti aggiungono un quarto componente, usualmente chiamato 
<firstterm>numero di&nbsp;patch</firstterm>, specialmente per un un controllo più fine sulle differenze fra le loro releases (in maniera disorientante, altri progetti usano “patch” come sinonimo di “micro” in un sistema. Ci sono anche progetti che usano un sistema a tre componenti).  Ci sono anche progetti che usano l'ultimo componente come<firstterm>numero&nbsp;di fabbricazione</firstterm>, incrementato ogni volta che il software è costruito, e non rappresenta nessun cambiamento al di fuori della costruzione. Ciò aiuta il progetto a mettere in relazione ogni rapporto di bugs con una specifica costruzione, ed è forse molto utile quando i pacchetti binari sono il metodo di distribuzione di default.</para>

<para>Sebbene ci siano molte differenti convenzioni su quanti componenti usare, e cosa significhino i componenti, le differenze tendono a diventare piccole, voi tenete una piccola tolleranza, ma non troppo. Le prossime sue sezioni parlano delle due convenzioni più largamente usate.</para>

</sect2>

<!-- ========================== subsection =========================== -->
<sect2 id="release-number-simple-strategy">
<title>La Strategia Semplice</title>

<para>La maggior parte dei progetti ha delle regole su che tipo di cambiamenti sono permessi nella release se uno sta incrementando solo il micro numero, differenti regole per il numero minore e ancora differenti regole per il numero maggiore.  Non c'è uno standard stabilito per queste regole ancora, ma qui io descriverò una politica che è stata usata con successo da più di un progetto. Voi potete giusto adottare questa politica nei vostri porgetti, ma anche se non lo volete, questo è tuttavia un buon esempio del tipo di informazione che i numeri di release dovrebbero portare con sé. Questa politica è adattata dal sistema di numerazione usato dal progetto APR, vedere
<ulink url="http://apr.apache.org/versioning.html"/>.</para>

<orderedlist>

  <listitem><para>I cambiamenti dei micro numeri (cioè i cambiamenti alla stessa linea minore) devono essere sia in avanti compatibili che indietro compatibili. Cioè, i cambiamenti dovrebbero essere solo le correzioni di bugs o accrescimenti molto piccoli delle funzionalità esistenti. Nuove funzionalità non dovrebbero essere introdotte in una micro release. </para>
  </listitem>

  <listitem><para>Cambiamenti del numero minore (cioè entro la linea maggiore) devono essere compatibili all'indietro, ma non necessariamente in avanti. E' normale aggiungere nuove funzionalità ad una release minore, ma non troppe in un sola volta.</para>
  </listitem>

  <listitem><para>I cambiamenti al numero maggiore segnano i limiti della compatibilità. Una nuova release maggiore può essere incompatibile sia in avanti che all'indietro. Ci si aspetta che una release maggiore abbia nuove funzionalità e può avere interi nuovi d set di funzionalità.</para>
  </listitem>

</orderedlist>

<para>Che  significhi<firstterm>compatibile in avanti</firstterm>
e<firstterm>compatibile all'indietro</firstterm> , esattamente, dipende da ciò che il vostro software fa, ma nel contesto, non sono aperte a tante interpretazioni. Per esempio, se il vostro software è una applicazione client/server, allora “compatibile all'indietro” significa che l'aggiornamento del server alla 2.6.0 non dovrebbe causare per i clients la perdita di funzionalità o comportamenti differenti da quelli di prima (eccetto per i bugs che sono stati corretti, certo).  D'altra parte, l'aggiornamento di uno di quei clients alla 2.6.0 , insieme al server, potrebbe rendere disponibili <emphasis>nuove</emphasis> funzionalità per quel client, funzionalità di cui i client 2.5.4 non sanno come avvantaggiarsi. Se ciò avviene, l'aggiornamento <emphasis>non</emphasis>
è “compatibile in avanti”: chiaramente non potete ora tornare indietro con quel client alla 2.5.4 e mantenere tutte le funzionalità che aveva nella 2.6.0, perché alcune di quelle funzionalità erano nuove nella 2.6.0.</para>

<para>Questo è il motivo per cui le micro releases sono essenzialmente per le correzioni dei bugs. Esse devono rimanere compatibili in entrambe le direzioni: se voi aggiornate dalla 2.5.3 alla 2.5.4, poi cambiate idea e tornate indietro alla 2.5.3, nessuna funzionalità dovrebbe andar perduta. Certo i bugs corretti riapparirebbero dopo il ritorno alla precedente versione, ma voi non perdereste nessuna funzionalità, eccetto per il fatto che i bugs reintrodotti impediscono l'uso di alcune funzionalità esistenti.</para>

<para>I protocolli client/server sono giusto uno dei campi dalle molte possibili compatibilità. Un' altra è la formattazione dei dati: il software scrive i dati in uno spazio permanente? Se così, i formati che legge devono seguire le leggi di compatibilità promesse dalla politica dei numeri di rilascio. La versione 2.6.0 deve poter leggere files scritti nella 2.5.4, ma può in silenzio aggiornare il formato a qualcosa che la 2.5.4 non può leggere, perché la possibilità di ritornare indietro non è un requisito della 2.6.0 per via delle delimitazioni riguardanti un numero minore.  Se il vostro progetto distribuisce librerie di codice per l'impiego in altri programmi, allora le API sono anche un dominio di compatibilità: dovete essere sicuri che le regole di compatibilità per il sorgente e il binario siano dette in maniera  tale che l'utilizzatore informato non debba mai chiedersi se è sicuro e opportuno aggiornare o no. Egli deve essere capace di guardare i numeri è e saperlo istantaneamente.</para>

<para> In questo sistema voi non avete una chance per una fresca partenza finché non incrementate il numero maggiore. Questo può essere spesso un reale inconveniente: ci possono essere funzionalità che voi volete aggiungere, o protocolli che volete ridisegnare, cose che non possono essere semplicemente fatte mentre mantenete la compatibilità. Non c'è una soluzione magica a questo, eccetto che cercare di disegnare le cose in modo estensibile in primo luogo (una argomento che facilmente merita il proprio libro, ma certamente fuori tema in questo). Ma pubblicare una politica di compatibilità delle releases, e aderirvi, è una parte delle distribuzione del software a cui non si può sfuggire. Una sgradevole sorpresa può allontanare un sacco di utilizzatori. La politica appunto descritta è buona in parte perché è già abbastanza diffusa, ma anche perché è facile da spiegare e da ricordare, anche per coloro che non hanno ancora familiarità con essa.</para>

<para>E' generalmente convenuto che queste regole non si applicano alle release pre-1.0 (sebbene la vostra politica di release lo stabilisca esplicitamente, giusto per essere chiari). Un progetto che sia ancora allo sviluppo iniziale può rilasciare la 0.1, 0.2, 0.3 e così via in sequenza, finché non sia pronto per la 1.0, e le differenze fra queste releases possono essere arbitrariamente grandi. I micro numeri nelle releases pre-1.0 sono opzionali. A seconda della natura del vostro progetto e delle differenze fra le releases potreste trovare utile avere la 0.1.0, la 0.1.1. ecc.., oppure no. Le convenzioni per le releases pre-1.0 sono piuttosto permissive, principalmente perché la gente capisce che forti costrizioni di compatibilità intralcerebbero molto il primo sviluppo, e anche perché i primi che le adottano tendono ad essere indulgenti comunque.</para>

<para>Ricordate che tutte queste ingiunzioni si applicano a questo sistema a tre componenti. Il vostro progetto potrebbe venir su con un differente sistema a tre componenti, oppure potrebbe decidere di non avere bisogno di un così fine granulosità e usare invece un sistema a due componenti. La cosa importante è deciderlo per tempo, rendere pubblico ciò che i componenti significano, e aderire ad essi.</para>

</sect2>

<!-- ========================== subsection =========================== -->
<sect2 id="release-number-even-odd-strategy">
<title>La Strategia pari/dispari </title>

<para>Alcuni progetti usano la parità del componente numero minore per indicare la stabilità del software. Pari significa stabile, dispari significa instabile. Ciò si applica solo al numero minore, non al numero maggiore a al micro numero. Incrementi nel micro numero ancora significano correzioni di bug (non nuove funzionalità), e incrementi nel numero maggiore ancora indicano grossi cambiamenti, nuovi set di funzionalità, ecc.. </para>

<para>Il vantaggio del sistema pari/dispari, che è stato usato dal progetto kernel di Linux fra gli altri, è che offre una via per rilasciare nuove funzionalità per la fase di prova, senza costringere gli utilizzatori della produzione a un codice potenzialmente instabile. Le persone possono vedere dai numeri che la "2.4.21" va bene per l'installazione sul loro attivo web server, ma che la "2.5.1" dovrebbe essere usata solamente per esperimenti sulle work station. Il team di sviluppo gestisce i report di bugs che arrivano dalla serie minore (numerata dispari), e quando le cose incominciano a sistemarsi dopo un certo numero di micro releases in quella serie, incrementano il numero minore (così facendolo diventare pari), riportano il micro numero a “0”, e rilasciano il pacchetto presumibilmente stabile. </para>

<para>Questo sistema conserva, o almeno non va in conflitto con le linee guida date prima. Esso semplicemente carica ulteriormente il numero minore di qualche extra informazione. Questo costringe d'altronde il numero minore ad essere incrementato di circa due volte tanto spesso quanto sarebbe necessario, ma non c'è un gran male in ciò. Il sistema pari dispari è probabilmente il migliore per i progetti che hanno cicli di release molto lunghi, e che per loro natura hanno una grande fetta di utilizzatori conservatori che valutano la stabilità al di sopra delle nuove funzionalità. Questo comunque non è il solo modo di fare il test di nuove funzionalità allo stato selvaggio, comunque.
<xref linkend="stabilizing-a-release"/><phrase output="printed">
Più avanti in questo capitolo</phrase> si descrive un altro, forse più comune, metodo di rilasciare al pubblico codice potenzialmente instabile, contrassegnato in modo che le persona abbiano un'idea del compromesso rischio/beneficio vedendo il nome della release.</para>

</sect2>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="release-branches">
<title>Rami Di Release</title>

<para>Dal punto di vista dello sviluppatore un progetto di software libero è in continuo stato di release sviluppatori eseguono sempre l'ultimo codice disponibile, perché vogliono scoprire i bugs, e perché seguono il progetto abbastanza da vicino da essere capaci di tirarsi indietro da aree instabili per quanto riguarda le funzionalità. Essi spesso aggiornano la loro copia del software ogni giorno, a volte più di una volta al giorno, e quando registrano un cambiamento, essi possono ragionevolmente aspettarsi che ogni altro sviluppatore lo riceverà entro ventiquattro ore.</para>

<para>Come, allora un progetto dovrebbe creare una release formale? Dovrebbe ricevere una istantanea dell'albero in un momento in tempo, farne il pacchetto, e passarlo al mondo come, diciamo, la versione "3.5.0"?. Il senso comune dice di no. Primo, ci può non essere un momento nel tempo in cui l'intero albero di sviluppo è pulito e pronto per il rilascio. Le funzionalità già cominciate potrebbero trovarsi in vari stadi di completamento. Qualcuno potrebbe aver cercato in un cambiamento più importante dei bug, ma il cambiamento potrebbe essere controverso e sotto dibattito al momento in cui la foto è stata  fatta. Se così, non funzionerebbe ritardare la fotografia fino a quando il dibattito non termini, perché un altro dibattito non collegato potrebbe iniziare nel frattempo, e allora voi dovreste attendere che anche<emphasis>quello</emphasis> termini.
Non è garantito che questo processo termini.</para>

<para>In ogni caso, usare fotografie dell'intero albero per le releases  interferirebbe con il lavoro di sviluppo in corso, anche se l'albero potrebbe essere messo in uno stato di rilascio. Per esempio questa fotografia potrebbe andare per la "3.5.0"; presumibilmente la successiva fotografia sarebbe la "3.5.1" e conterrebbe per lo più correzioni dei bugs trovati nella 3.5.0. Ma se ambedue sono fotografie dello stesso albero, cosa si suppone che gli sviluppatori facciano nel tempo fra le due releases? Essi non possono aggiungere nuove funzionalità; le linee guida di compatibilità non lo permettono.
Ma non tutti saranno entusiasti di correggere i bugs nel codice 3.5.0. Alcuni possono avere alcune funzionalità che stanno cercando di completare, e si arrabbieranno se saranno obbligati a scegliere fra il sedere oziosi e lavorare a cose alle quali non sono interessati, giusto perché i processi di rilascio del progetto chiedono che l'albero di sviluppo rimanga fermo in maniera non naturale.</para>

<para>La soluzione a questi problemi è usare sempre una <firstterm>release ramo</firstterm>.  Una release ramo è appunto un ramo nel sistema di controllo della versione  (vedere
<xref linkend="vc-vocabulary-branch"/>), sul quale il codice destinato a questa release può essere isolato dalla  linea principale dello sviluppo. Il concetto di rami di release non è certamente originale del software libero; molti sviluppi commerciali lo usano anche. Comunque, in ambienti commerciali, i rami di release sono a volte considerati un lusso una specie di formale “miglior pratica” di cui nell'entusiasmo di una scadenza maggiore, se ne può fare a meno mentre ognuno nel team si affanna a stabilizzare l'albero principale.</para>

<para>I rami di release sono quasi richiesti nel software open source, comunque. Io ho visto progetti fare una release senza di essi, ma il risultato è stato sempre che alcuni sviluppatori stessero oziosi
mentre altri&mdash;usualmente una minoranza&mdash;lavoravano a fare uscire la release fuori della porta. Il risultato è usualmente cattivo per molti versi. Primo, la velocità dello sviluppo principale è diminuita. Secondo. La qualità erea peggiore di quanto sarebbe stato necessario, perché c'erano solo poche persone a lavorare ad essa, ed essi si affrettavano a finire in modo che ogni altro potesse tornare a lavorare. Terzo, esso divide il team di sviluppo psicologicamente, dando luogo a una situazione in cui differenti tipi di lavoro interferiscono con ogni altro tipo senza necessità. Gli sviluppatori che restano oziosi sarebbero probabilmente felici di collaborare con una certa attenzione al ramo di release, nella misura in cui quella sarebbe una scelta che potrebbero fare in accordo con i loro programmi e interessi. Ma senza il ramo, la loro scelta diventa “Devo partecipare al progetto o no?” invece di “Devo partecipare alla release oggi, o lavorare a quella funzionalità che stavo sviluppando nella linea principale del codice?”</para>

<!-- ======================== subsection ============================== -->
<sect2 id="release-branch-mechanics">
<title>Il Meccanismo Dei Rami di Release</title>

<para>L'esatto meccanismo della creazione di un ramo di release dipende dal vostro sistema di controllo della versione, certo, ma i concetti generali sono gli stessi nella maggior parte dei sistemi. Un ramo usualmente vien fuori da un altro ramo o dal tronco. Tradizionalmente, il tronco è dove si ha la linea principale dello sviluppo, libera dai vincoli della release. Il primo ramo della release, quello che porta alla release “1.0”, vien fuori dal tronco. Nel CVS il comando di ramo sarebbe qualcosa come</para>

<screen>
$ cd trunk-working-copy
$ cvs tag -b RELEASE_1_0_X
</screen>

<para>o in Subversion, come questo:</para>

<screen>
$ svn copy http://.../repos/trunk http://.../repos/branches/1.0.x
</screen>

<para>(Tutti questi esempi accettano il sistema di numerazione a tre componenti. Mentre non posso mostrare i comandi per ogni sistema di controllo della versione, farò degli esempi in CVS e Subversion e spero che i corrispondenti comandi in altri sistemi possano essere dedotti da questi due.)</para>

<para>Notare che noi creammo il ramo "1.0.x" (con una lettera  "x") invece di "1.0.0". Questo perché la stessa linea minore cioè lo stesso ramo&mdash;sarebbe stato usato per le micro releases in quella linea. Il reale processo di stabilizzazione dei rami è trattato 
<xref linkend="stabilizing-a-release"/><phrase output="printed">
 più avanti in questo capitolo</phrase>.  Qui noi ci occupiamo appunto dell'interazione fra il sistema di controllo della versione con il processo di release. Quando il ramo di release è stabilizzato e pronto, è il momento di tracciare una fotografia del ramo:</para>

<screen>
$ cd RELEASE_1_0_X-working-copy
$ cvs tag RELEASE_1_0_0
</screen>

<para>or</para>

<screen>
$ svn copy http://.../repos/branches/1.0.x http://.../repos/tags/1.0.0
</screen>

<para>Questa traccia ora rappresenta lo stato esatto dell'albero origine nella release 1.0.0 (ciò è utile nel caso che qualcuno abbia bisogno di prelevare una vecchia versione dopo che distribuzioni confezionate e i binari siano stati dismessi). La successiva micro release nella stessa linea è preparata nello steso modo nel ramo 1.0.x, e quando è pronta, una traccia è fatta per la 1.0.1. Più avanti, risciacquatura, si ripete con la 1.0.2, e così via. Quando è il tempo di partire pensando alla release 1.1.x, create un nuovo ramo dal tronco:</para>

<screen>
$ cd trunk-working-copy
$ cvs tag -b RELEASE_1_1_X
</screen>

<para>or</para>

<screen>
$ svn copy http://.../repos/trunk http://.../repos/branches/1.1.x
</screen>

<para>Il mantenimento può continuare in parallelo lungo la 1.0.x e la 1.1.x e un rilascio può essere fatto indipendentemente da ambedue le differenti linee. La vecchia serie è raccomandata per gli amministratori di sito più conservatori che possono non voler fare il grosso salto alla (diciamo)  1.1 senza una attenta preparazione. Intanto, persone più avventurose prendono la più recente release sulla linea più alta, per essere sicuri di fare proprie le più recenti funzionalità, anche a rischio di una piuttosto grande instabilità. </para>

</sect2>

<para>Questa non è l'unica strategia delle releases ramo, certo. In alcune circostanze, può neanche essere la migliore, sebbene abbia funzionato bene per i progetti in cui è stata impiegata. Usate una strategia che sembra funzionare, ma ricordate i punti principali: il proposito di una release ramo è quello di isolare il lavoro di rilascio dalle fluttuazioni dello sviluppo giornaliero, e dare al progetto una entità fisica intorno alla quale organizzare il processo di rilascio. Il processo è descritto in dettaglio nelle successiva sezione.</para>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="stabilizing-a-release">
<title>Stabilizzare una Release</title>

<para>La <firstterm>stabilizzazione</firstterm> è il processo di procurarsi una ramo di release per uno stato in cui si può rilasciare; cioè ilo processo di decidere quali cambiamenti ci saranno nelle release, quali no, e dar forma al contenuto  del ramo di conseguenza. </para>

<para>Ci sono un sacco di di potenziali pene in quella parola, “decidere”. La corsa alla funzionalità dell'ultimo minuto è un fenomeno familiare nei progetti di software in collaborazione: appena gli sviluppatori vedono che la release sta per avvenire, si agitano a finire il loro correnti cambiamenti, per non perdere il battello. Questo, certamente, è l'esatto opposto di ciò che volete al momento del rilascio. Sarebbe molto meglio per la gente lavorare alle funzionalità in una confortevole ritmo, e non preoccuparsi e non preoccuparsi tanto se i loro cambiamenti riusciranno a farcela per questa release o per la prossima. Più uno cerca di imbottire i cambiamenti nella release all'ultimo minuto, più il codice è destabilizzato, e (usualmente) più bugs si creano.</para>

<para>La maggior parte degli ingegneri di software convengono in teoria su abbozzi di criteri circa quali cambiamenti debbano essere consentiti in una linea di rilascio durante il suo periodo di stabilizzazione. Ovviamente correzioni per importanti bugs dovrebbero entrarci, specialmente per bugs senza correzioni che non risolvono il problema. Gli aggiornamenti della documentazione vanno bene, così come le correzioni ai messaggi di errore (eccetto quando sono considerati parte dell'interfaccia e devono rimanere stabili). Molti progetti anche consentono certi cambiamenti non rischiosi e non di base di entrare durante la stabilizzazione, e si possono avere formali linee guida per la misurazione del rischio. Ma nessun ammontare di formalizzazione può ovviare al bisogno del giudizio umano. Ci saranno casi in cui il progetto deve semplicemente prendere una decisione se un dato cambiamento deve entrare in una release. Il pericolo è che siccome ognuno vuol vedere il suo cambiamento preferito ammesso nella release, ci sarà una gran quantità di gente motivata a consentire cambiamenti, e gente non abbastanza motivata a impedirli.</para>

<para>Così, il processo di stabilizzazione di una release consiste per lo più nel creare un meccanismo per dire “no”. Il trucco per un progetto open source, in particolare, è venir fuori con modi di dire “no” che non abbiano molto l risultato di dare la sensazione di una ferita o creare il disappunto degli sviluppatori, e che anche non impediscano che cambiamenti validi entrino nella release. Ci sono molti modi per fare ciò. E' piuttosto facile inventare sistemi che soddisfino questi criteri, una volta che il team si è focalizzato su di essi come criteri importanti. Qui descriverò due dei più popolari sistemi, agli estremi dello spettro, ma non permetto che questo scoraggi il vostro progetto dall'essere creativo. Una abbondanza di altri espedienti è possibile; questi sono giusto due che ho visto funzionare in pratica. </para>

<!-- ======================== subsection ============================== -->
<sect2 id="release-owner">
<title>Dittatura Da Parte del Proprietario Della Release</title>

<para> Il gruppo conviene di permettere a una persona di essere <firstterm>proprietario della release</firstterm>. Questo proprietario ha la parola finale sui cambiamenti che devono entrare nella release. Certo, ci si aspetterebbe ed è normale che ci siano discussioni e argomentazioni, ma alla fine il gruppo deve assegnare al proprietario  la sufficiente autorità per prendere le decisioni finali. Affinché questo sistema funzioni, è necessario scegliere una persona con la competenza  tecnica per comprendere tutti i cambiamenti e la posizione sociale e le capacità di navigare fra le discussioni puntando alla release senza causare tanti sensi di risentimento. </para>

<para>Un comportamento comune del proprietario è dire “non penso che ci sia qualcosa di sbagliato in questo cambiamento, ma non abbiamo avuto abbastanza tempo per provarlo, per cui non deve entrare nelle release”. Ciò aiuta molto se il proprietario della release ha larghe conoscenze tecniche del progetto, e ha la capacità di rendere conto del perché il cambiamento potrebbe esser potenzialmente destabilizzante (per esempio la sua interazione con altre parti del software, o questioni di portabilità). La gente potrà a volte chiedere che tali decisioni siano giustificate o sostenere che il cambiamento non è un rischio come sembra. Queste conversazioni non devono essere provocatorie, nella misura in cui il proprietario della release è capace di prendere in considerazione tutte le argomentazioni obbiettivamente e non come un colpo alle sue gambe</para>

<para>Notate che non è necessario che il proprietario della release sia la stessa persona del leader del progetto (nei casi in cui c'è un leader del progetto; vedere
<xref linkend="benevolent-dictator"/><phrase output="printed">
in <xref linkend="social-infrastructure"/></phrase>).  Infatti a volte è bene assicurarsi che non siano la stessa persona. Le capacità che fanno un buon leader di sviluppo non sono necessariamente le stesse che fanno un buon proprietario di release. In una cosa così importante come il processo di release, può essere saggio avere qualcuno che controbilanci il giudizio del leader di progetto. </para>

<para>Contrastate il ruolo del proprietario di release con un un ruolo meno dittatoriale descritto in
<xref linkend="release-manager"/><phrase output="printed"> più avanti in questo capitolo</phrase>.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="release-voting">
<title>Votare Il Cambiamento</title>

<para>All'estremo opposto della dittatura da parte del proprietario di release, gli sviluppatori possono semplicemente votare su quali cambiamenti includere nella release. Comunque, poichè la funzione più importante per la stabilizzazione delle release è <emphasis>escludere</emphasis> cambiamenti, è importante creare un sistema di voto in modo tale che fare cambiamenti alla release comporti una azione positiva da parte di più di uno sviluppatore. Per inserire un cambiamento ci dovrebbe essere bisogno più di una semplice maggioranza (vedere <xref
linkend="electorate"/><phrase output="printed"> in
<xref linkend="social-infrastructure"/></phrase>).  Diversamente un voto a favore e uno contro un dato cambiamento sarebbe sufficiente per inserirlo nella release e si creerebbe una sciagurata dinamica per cui ciascuno sviluppatore voterebbe per i propri cambiamenti, mentre sarebbe riluttante a votare contro i cambiamenti degli altri, per paura di possibili ritorsioni. Per evitare ciò, il sistema dovrebbe essere congegnato in modo che sottogruppi di sviluppatori debbano agire in cooperazione per inserire cambiamenti nella release. Ciò significa non solo che più persone revisionano ogni cambiamento, ma rende  uno sviluppatore individuale meno indeciso nel votare contro un cambiamento, perché egli sa che nessuno in particolare fra quelli che votarono per esso può prendere il suo voto contro come un affronto personale. Più grande è il numero di persone coinvolte, più numerose diventano le discussioni sui cambiamenti e meno numerose quelle sugli individui.</para>

<para>Il sistema che noi usiamo nel progetto Subversion sembra aver centrato un buon bilanciamento, per cui io lo raccomando qui. Affinché un cambiamento sia apportato a un ramo di release, almeno tre sviluppatori devono votare a favore di esso, e nessuno contro. Un singolo voto “no” è sufficiente a impedire che il cambiamento sia incluso; cioè un voto “no” in un contesto di release è equivalente a un veto (vedere <xref linkend="veto"/>).
Naturalmente ogni voto di questo tipo deve essere accompagnato da una giustificazione, e in teoria si potrebbe non tener conto del veto, se abbastanza gente ritenesse che esso è non ragionevole e obbliga a  un voto speciale su di esso. In pratica, ciò non è mai successo, e prevedo che non succederà mai. Le persone sono conservatrici nei confronti delle release in ogni modo, e quando qualcuno si sente abbastanza fortemente a favore del veto nei confronti dell'inclusione di una cambiamento, c'è usualmente una buona ragione per ciò.</para>

<para>Poiché la procedura di rilascio è deliberatamente orientata verso il conservatorismo, le giustificazioni portate per il veto sono talvolta procedurali piuttosto che tecniche. Per esempio, una persona può ritenere che un cambiamento sia ben scritto e che sia improbabile che causi nuovi bugs, ma vota contro la sua inclusione nella micro release semplicemente perché è troppo grossa magari apporta nuove funzionalità, o in qualche modo sottile non riesce a seguire completamente le linee guida di compatibilità. Io occasionalmente ho visto anche sviluppatori porre il veto a qualcosa semplicemente perché avevano una sensazione viscerale che il cambiamento avesse bisogno di  ulteriori prove, anche se essi non potevano individuare bugs in esse con un esame interno. Le persone si lagnavano un poco, ma il veto resisteva e il cambiamento non veniva incluso nella release (non ricordo se qualche bug veniva trovato o no in una ulteriore prova, comunque). </para>

<sect3 id="release-stabilization-collaboration">
<title>Portare avanti una stabilizzazione di release in collaborazione</title>

<para>Se il vostro progetto opta per un sistema di voto per il cambiamento, è imperativo che i meccanismi di organizzazione delle schede di voto e di votare sia il più adatto possibile. Anche se c'è una pletora di software open source disponibile, in pratica la cosa più facile da fare è giusto preparare nel ramo di release un file di testo, chiamato<filename>STATO</filename> or <filename>VOTI</filename> o qualcosa di simile. Questo file elenca ogni cambiamento proposto per l'inclusione insieme a tutti i voti a favore e contro, più eventuali note o commenti (Proporre un cambiamento non significa necessariamente votarlo, strada facendo, sebbene le due cose vadano insieme). Una voce in un tale file appare così:</para>

<screen>
* r2401 (issue #49)
  Prevent client/server handshake from happening twice.
  Justification:
    Avoids extra network turnaround; small change and easy to review.
  Notes:
    This was discussed in http://.../mailing-lists/message-7777.html
    and other messages in that thread.
  Votes:
    +1: jsmith, kimf
    -1: tmartin (breaks compatibility with some pre-1.0 servers;
                 admittedly, those servers are buggy, but why be
                 incompatible if we don't have to?)
</screen>

<para>In this case, the change acquired two positive votes, but was
vetoed by tmartin, who gave the reason for the veto in a parenthetical
note.  The exact format of the entry doesn't matter; whatever your
project settles on is fine&mdash;perhaps tmartin's explanation for the
veto should go up in the "Notes:" section, or perhaps the change
description should get a "Description:" header to match the other
sections.  The important thing is that all the information needed to
evaluate the change be reachable, and that the mechanism for casting
votes be as lightweight as possible.  The proposed change is referred
to by its revision number in the repository (in this case a single
revision, r2401, although a proposed change could just as easily
consist of multiple revisions).  The revision is assumed to refer to a
change made on the trunk; if the change were already on the release
branch, there would be no need to vote on it.  If your version control
system doesn't have an obvious syntax for referring to individual
changes, then the project should make one up.  For voting to be
practical, each change under consideration must be unambiguously
identifiable.</para>

<para>Those proposing or voting for a change are responsible for
making sure it applies cleanly to the release branch, that is, applies
without conflicts (see <xref linkend="vc-vocabulary-conflict"/>).
If there are conflicts, then the entry should either point to an
adjusted patch that does apply cleanly, or to a temporary branch that
holds an adjusted version of the change, for example:</para>

<screen>
* r13222, r13223, r13232
  Rewrite libsvn_fs_fs's auto-merge algorithm
  Justification:
    unacceptable performance (>50 minutes for a small commit) in
    a repository with 300,000 revisions
  Branch:
    1.1.x-r13222@13517
  Votes:
    +1: epg, ghudson
</screen>

<para>That example is taken from real life; it comes from the
<filename>STATUS</filename> file for the Subversion 1.1.4 release
process.  Notice how it uses the original revisions as canonical
handles on the change, even though there is also a branch with a
conflict-adjusted version of the change (the branch also combines the
three trunk revisions into one, r13517, to make it easier to merge the
change into the release, should it get approval).  The original
revisions are provided because they're still the easiest entity to
review, since they have the original log messages.  The temporary
branch wouldn't have those log messages; in order to avoid duplication
of information (see
<xref linkend="vc-singularity"/><phrase output="printed"> in
<xref linkend="technical-infrastructure"/></phrase>), the
branch's log message for r13517 should simply say "Adjust r13222,
r13223, and r13232 for backport to 1.1.x branch."  All other
information about the changes can be chased down at their original
revisions.</para>

</sect3>

<sect3 id="release-manager">
<title>Release manager</title>

<para>The actual process of merging (see
<xref linkend="vc-vocabulary-merge"/>) approved changes into the
release branch can be performed by any developer.  There does not need
to be one person whose job it is to merge changes; if there are a lot
of changes, it can be better to spread the burden around.</para>

<para>However, although both voting and merging happen in a
decentralized fashion, in practice there are usually one or two people
driving the release process.  This role is sometimes formally blessed
as <firstterm>release manager</firstterm>, but it is quite different
from a release owner (see
<xref linkend="release-owner"/><phrase output="printed"> earlier
in this chapter</phrase>) who has
final say over the changes.  Release managers keep track of how many
changes are currently under consideration, how many have been
approved, how many seem likely to be approved, etc.  If they sense
that important changes are not getting enough attention, and might be
left out of the release for lack of votes, they will gently nag other
developers to review and vote.  When a batch of changes are approved,
these people will often take it upon themselves to merge them into the
release branch; it's fine if others leave that task to them, as
long as everyone understands that they are not obligated to do all the
work unless they have explicitly committed to it.  When the time comes
to put the release out the door (see
<xref linkend="testing-and-releasing"/><phrase output="printed">
later in this chapter</phrase>), the release managers
also take care of the logistics of creating the final release
packages, collecting digital signatures, uploading the packages, and
making the public announcement.</para>

</sect3>

</sect2>

</sect1>

<!-- ========================== SECTION =========================== -->
<sect1 id="packaging">
<title>Packaging</title>

<para>The canonical form for distribution of free software is as
source code.  This is true regardless of whether the software normally
runs in source form (i.e., can be interpreted, like Perl, Python, PHP,
etc.) or needs to be compiled first (like C, C++, Java, etc.).  With
compiled software, most users will probably not compile the sources
themselves, but will instead install from pre-built binary packages
(see <xref linkend="binary-packages"/><phrase output="printed">
later in this chapter</phrase>).  However, those binary
packages are still derived from a master source distribution.  The
point of the source package is to unambiguously define the release.
When the project distributes "Scanley&nbsp;2.5.0", what it means,
specifically, is "The tree of source code files that, when compiled
(if necessary) and installed, produces Scanley 2.5.0."</para>

<para>There is a fairly strict standard for how source releases
should look.  One will occasionally see deviations from this standard,
but they are the exception, not the rule.  Unless there is a compelling
reason to do otherwise, your project should follow this standard
too.</para>

<!-- ========================== subsection =========================== -->
<sect2 id="packaging-format">
<title>Format</title>

<para>The source code should be shipped in the standard formats for
transporting directory trees.  For Unix and Unix-like operating
systems, the convention is to use TAR format, compressed
by <command>compress</command>, <command>gzip</command>,
<command>bzip</command> or <command>bzip2</command>.  For MS Windows,
the standard method for distributing directory trees
is <firstterm>zip</firstterm> format, which happens to do compression
as well, so there is no need to compress the archive after creating
it.</para>

   <sidebar id="packaging-tar">
   <title>TAR Files</title>

   <para><firstterm>TAR</firstterm> stands for "Tape&nbsp;ARchive",
   because tar format represents a directory tree as a linear data
   stream, which makes it ideal for saving directory trees to tape.
   The same property also makes it the standard for distributing
   directory trees as a single file.  Producing compressed tar files
   (or <firstterm>tarballs</firstterm>) is pretty easy.  On some
   systems, the <command>tar</command> command can produce a
   compressed archive itself; on others, a separate compression
   program is used.</para>

   </sidebar>

</sect2>

<!-- ========================== subsection =========================== -->
<sect2 id="packaging-name-and-layout">
<title>Name and Layout</title>

<para>The name of the package should consist of the software's name
plus the release number, plus the format suffixes appropriate for the
archive type.  For example, Scanley 2.5.0, packaged for Unix using GNU
Zip (gzip) compression, would look like this:</para>

<informalexample>
<literallayout>scanley-2.5.0.tar.gz</literallayout>
</informalexample>

<para>or for Windows using zip compression:</para>

<informalexample>
<literallayout>scanley-2.5.0.zip</literallayout>
</informalexample>

<para>Either of these archives, when unpacked, should create a single
new directory tree named <filename>scanley-2.5.0</filename> in the
current directory.  Underneath the new directory, the source code
should be arranged in a layout ready for compilation (if compilation
is needed) and installation.  In the top level of new directory tree,
there should be a plain text <filename>README</filename> file
explaining what the software does and what release this is, and giving
pointers to other resources, such as the project's web site, other
files of interest, etc.  Among those other files should be an
<filename>INSTALL</filename> file, sibling to
the <filename>README</filename> file, giving instructions on how to build
and install the software for all the operating systems it supports.
As mentioned in
<xref linkend="license-quickstart-applying"/><phrase output="printed">
in <xref linkend="getting-started"/></phrase>, there should also
be a <filename>COPYING</filename> or <filename>LICENSE</filename>
file, giving the software's terms of distribution.</para>

<para>There should also be a <filename>CHANGES</filename> file
(sometimes called <filename>NEWS</filename>), explaining what's new in
this release.  The <filename>CHANGES</filename> file accumulates
changelists for all releases, in reverse chronological order, so that
the list for this release appears at the top of the file.  Completing
that list is usually the last thing done on a stabilizing release
branch; some projects write the list piecemeal as they're developing,
others prefer to save it all up for the end and have one person write
it, getting information by combing the version control logs.  The list
looks something like this:</para>

<screen>
Version 2.5.0
(20 December 2004, from /branches/2.5.x)
http://svn.scanley.org/repos/svn/tags/2.5.0/

 New features, enhancements:
    * Added regular expression queries (issue #53)
    * Added support for UTF-8 and UTF-16 documents
    * Documentation translated into Polish, Russian, Malagasy
    * ...

 Bugfixes:
    * fixed reindexing bug (issue #945)
    * fixed some query bugs (issues #815, #1007, #1008)
    * ...
</screen>

<para>The list can be as long as necessary, but don't bother to
include every little bugfix and feature enhancement.  Its purpose is
simply to give users an overview of what they would gain by upgrading
to the new release.  In fact, the changelist is customarily included
in the announcement email (see
<xref linkend="testing-and-releasing"/><phrase output="printed">
later in this chapter</phrase>), so write it with that
audience in mind.</para>

   <sidebar id="changelog">
   <title>CHANGES Versus ChangeLog</title>
   <para>Traditionally, a file named <firstterm>ChangeLog</firstterm>
   lists every change ever made to a project&mdash;that is, every
   revision committed to the version control system.  There are
   various formats for ChangeLog files; the details of the formats
   aren't important here, as they all contain the same information:
   the date of the change, its author, and a brief summary (or just
   the log message for that change).</para>

   <para>A <filename>CHANGES</filename> file is different.  It too is
   a list of changes, but only the ones thought important for a
   certain audience to see, and often with metadata like the exact
   date and author stripped off.  To avoid confusion, don't use the
   terms interchangeably.  Some projects use "NEWS" instead of
   "CHANGES"; although this avoids the potential for confusion with
   "ChangeLog", it is a bit of a misnomer, since the CHANGES file
   retains change information for all releases, and thus has a lot of
   old news in addition to the new news at the top.</para>

   <para>ChangeLog files may be slowly disappearing anyway.  They were
   helpful in the days when CVS was the only choice of version control
   system, because change data was not easy to extract from CVS.
   However, with more recent version control systems, the data that
   used to be kept in the ChangeLog can be requested from the version
   control repository at any time, making it pointless for the project
   to keep a static file containing that data&mdash;in fact, worse
   than pointless, since the ChangeLog would merely duplicate the log
   messages already stored in the repository.</para>
   </sidebar>

<para>The actual layout of the source code inside the tree should be
the same as, or as similar as possible to, the source code layout one
would get by checking out the project directly from its version
control repository.  Usually there are a few differences, for example
because the package contains some generated files needed for
configuration and compilation (see
<xref linkend="packaging-build-install"/><phrase output="printed">
later in this chapter</phrase>), or because it includes
third-party software that is not maintained by the project, but that
is required and that users are not likely to already have.  But even
if the distributed tree corresponds exactly to some development tree
in the version control repository, the distribution itself should not
be a working copy (see <xref linkend="vc-vocabulary-working-copy"/>).
The release is supposed to represent a static reference point&mdash;a
particular, unchangeable configuration of source files.  If it were a
working copy, the danger would be that the user might update it, and
afterward think that he still has the release when in fact he has
something different.</para>

<para>Remember that the package is the same regardless of the
packaging.  The release&mdash;that is, the precise entity referred to
when someone says "Scanley&nbsp;2.5.0"&mdash;is the tree created by
unpacking a zip file or tarball.  So the project might offer all of
these for download:</para>

<informalexample>
<literallayout>scanley-2.5.0.tar.bz2
scanley-2.5.0.tar.gz
scanley-2.5.0.zip</literallayout>
</informalexample>

<para>...but the source tree created by unpacking them must be the
same.  That source tree is the distribution; the form in which it is
downloaded is merely a matter of convenience.  Certain trivial
differences between source packages are allowable: for example, in the
Windows package, text files should have lines ending with CRLF
(Carriage Return and Line Feed), while Unix packages should use just
LF.  The trees may be arranged slightly differently between source
packages destined for different operating systems, too, if those
operating systems require different sorts of layouts for compilation.
However, these are all basically trivial transformations.  The basic
source files should be the same across all the packagings of a given
release.</para>

<sect3 id="release-capitalization">
<title>To capitalize or not to capitalize</title>

<para>When referring to a project by name, people generally capitalize
it as a proper noun, and capitalize acronyms if there are any:
"MySQL&nbsp;5.0", "Scanley&nbsp;2.5.0", etc.  Whether this
capitalization is reproduced in the package name is up to the project.
Either <filename>Scanley-2.5.0.tar.gz</filename> or
<filename>scanley-2.5.0.tar.gz</filename> would be fine, for example
(I personally prefer the latter, because I don't like to make people
hit the shift key, but plenty of projects ship capitalized packages).
The important thing is that the directory created by unpacking the
tarball use the same capitalization.  There should be no surprises:
the user must be able to predict with perfect accuracy the name of the
directory that will be created when she unpacks a distribution.</para>

</sect3>
<sect3 id="release-prereleases">
<title>Pre-releases</title>

<para>When shipping a pre-release or candidate release, the qualifier
is truly a part of the release number, so include it in the name of
the package's name.  For example, the ordered sequence of alpha and
beta releases given earlier in
<xref linkend="release-number-components"/> would result in
package names like this:</para>

<informalexample>
<literallayout>scanley-2.3.0-alpha1.tar.gz
scanley-2.3.0-alpha2.tar.gz
scanley-2.3.0-beta1.tar.gz
scanley-2.3.0-beta2.tar.gz
scanley-2.3.0-beta3.tar.gz
scanley-2.3.0.tar.gz</literallayout>
</informalexample>

<para>The first would unpack into a directory
named <filename>scanley-2.3.0-alpha1</filename>, the second into
<filename>scanley-2.3.0-alpha2</filename>, and so on.</para>

</sect3>

</sect2>

<!-- ========================== subsection =========================== -->
<sect2 id="packaging-build-install">
<title>Compilation and Installation</title>

<para>For software requiring compilation or installation from source,
there are usually standard procedures that experienced users expect to
be able to follow.  For example, for programs written in C, C++, or
certain other compiled languages, the standard under Unix-like systems
is for the user to type:</para>

<screen>
   $ ./configure
   $ make
   # make install
</screen>

<para>The first command autodetects as much about the environment as
it can and prepares for the build process, the second command builds
the software in place (but does not install it), and the last command
installs it on the system.  The first two commands are done as a
regular user, the third as root.  For more details about setting up
this system, see the excellent <citetitle>GNU Autoconf, Automake, and
Libtool</citetitle> book by Vaughan, Elliston, Tromey, and Taylor.  It
is published as treeware by New Riders, and its content is also freely
available online at
<ulink url="http://sources.redhat.com/autobook/"/>.</para>

<para>This is not the only standard, though it is one of the most
widespread.  The Ant (<ulink url="http://ant.apache.org/"/>) build
system is gaining popularity, especially with projects written in
Java, and it has its own standard procedures for building and
installing.  Also, certain programming languages, such as Perl and
Python, recommend that the same method be used for most programs
written in that language (for example, Perl modules use the
command <command>perl&nbsp;Makefile.pl</command>).  If it's not
obvious to you what the applicable standards are for your project, ask
an experienced developer; you can safely assume
that <emphasis>some</emphasis> standard applies, even if you don't
know what it is at first.</para>

<para>Whatever the appropriate standards for you project are, don't
deviate from them unless you absolutely must.  Standard installation
procedures are practically spinal reflexes for a lot of system
administrators now.  If they see familiar invocations documented in
your project's <filename>INSTALL</filename> file, that instantly
raises their faith that your project is generally aware of
conventions, and that it is likely to have gotten other things right
as well.  Also, as discussed in
<xref linkend="downloads"/><phrase output="printed"> in
<xref linkend="getting-started"/></phrase>, having a standard
build procedure pleases potential developers.</para>

<para>On Windows, the standards for building and installing are a bit
less settled.  For projects requiring compilation, the general
convention seems to be to ship a tree that can fit into the
workspace/project model of the standard Microsoft development
environments (Developer Studio, Visual Studio, VS.NET, MSVC++, etc.).
Depending on the nature of your software, it may be possible to offer
a Unix-like build option on Windows via the Cygwin
(<ulink url="http://www.cygwin.com/"/>) environment.  And of course,
if you're using a language or programming framework that comes with
its own build and install conventions&mdash;e.g., Perl or
Python&mdash;you should simply use whatever the standard method is for
that framework, whether on Windows, Unix, Mac OS X, or any other
operating system.</para>

<para>Be willing to put in a lot of extra effort in order to make your
project conform to the relevant build or installation standards.
Building and installing is an entry point: it's okay for things to get
harder after that, if they absolutely must, but it would be a shame
for the user's or developer's very first interaction with the software
to require unexpected steps.</para>

</sect2>

<!-- ========================== subsection =========================== -->
<sect2 id="binary-packages">
<title>Binary Packages</title>

<para>Although the formal release is a source code package, most users
will install from binary packages, either provided by their operating
system's software distribution mechanism, or obtained manually from
the project web site or from some third party.  Here "binary" doesn't
necessarily mean "compiled"; it just means any pre-configured form of
the package that allows a user to install it on his computer without
going through the usual source-based build and install procedures.  On
RedHat GNU/Linux, it is the RPM system; on Debian GNU/Linux, it is the
APT (<filename>.deb</filename>) system; on MS Windows, it's usually
<literal>.MSI</literal> files or self-installing
<literal>.exe</literal> files.</para>

<para>Whether these binary packages are assembled by people closely
associated with the project, or by distant third parties, users are
going to <emphasis>treat</emphasis> them as equivalent to the
project's official releases, and will file issues in the project's bug
tracker based on the behavior of the binary packages.  Therefore, it
is in the project's interest to provide packagers with clear
guidelines, and work closely with them to see to it that what they
produce represents the software fairly and accurately.</para>

<para>The main thing packagers need to know is that they should always
base their binary packages on an official source release.  Sometimes
packagers are tempted to pull a later incarnation of the code from the
repository, or include selected changes that were committed after the
release was made, in order to provide users with certain bug fixes or
other improvements.  The packager thinks he is doing his users a favor
by giving them the more recent code, but actually this practice can
cause a great deal of confusion.  Projects are prepared to receive
reports of bugs found in released versions, and bugs found in recent
trunk and major branch code (that is, found by people who deliberately
run bleeding edge code).  When a bug report comes in from these
sources, the responder will often be able to confirm that the bug is
known to be present in that snapshot, and perhaps that it has since
been fixed and that the user should upgrade or wait for the
next release.  If it is a previously unknown bug, having the precise
release makes it easier to reproduce and easier to categorize in the
tracker.</para>

<para>Projects are not prepared, however, to receive bug reports based
on unspecified intermediate or hybrid versions.  Such bugs can be hard
to reproduce; also, they may be due to unexpected interactions in
isolated changes pulled in from later development, and thereby cause
misbehaviors that the project's developers should not have to take the
blame for.  I have even seen dismayingly large amounts of time wasted
because a bug was <emphasis>absent</emphasis> when it should have been
present: someone was running a slightly patched up version, based on
(but not identical to) an official release, and when the predicted bug
did not happen, everyone had to dig around a lot to figure out
why.</para>

<para>Still, there will sometimes be circumstances when a packager
insists that modifications to the source release are necessary.
Packagers should be encouraged to bring this up with the project's
developers and describe their plans.  They may get approval, but
failing that, they will at least have notified the project of their
intentions, so the project can watch out for unusual bug reports.  The
developers may respond by putting a disclaimer on the project's web
site, and may ask that the packager do the same thing in the
appropriate place, so that users of that binary package know what they
are getting is not exactly the same as what the project officially
released.  There need be no animosity in such a situation, though
unfortunately there often is.  It's just that packagers have a
slightly different set of goals from developers.  The packagers mainly
want the best out-of-the-box experience for their users.  The
developers want that too, of course, but they also need to ensure that
they know what versions of the software are out there, so they can
receive coherent bug reports and make compatibility guarantees.
Sometimes these goals conflict.  When they do, it's good to keep in
mind that the project has no control over the packagers, and that the
bonds of obligation run both ways.  It's true that the project is
doing the packagers a favor simply by producing the software.  But the
packagers are also doing the project a favor, by taking on a mostly
unglamorous job in order to make the software more widely available,
often by orders of magnitude.  It's fine to disagree with packagers,
but don't flame them; just try to work things out as best you
can.</para>

</sect2>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="testing-and-releasing">
<title>Testing and Releasing</title>

<para>Once the source tarball is produced from the stabilized release
branch, the public part of the release process begins.  But before the
tarball is made available to the world at large, it should be tested
and approved by some minimum number of developers, usually three or
more.  Approval is not simply a matter of inspecting the release for
obvious flaws; ideally, the developers download the tarball, build and
install it onto a clean system, run the regression test suite (see
<xref linkend="automated-testing"/>)<phrase output="printed"> in
<xref linkend="managing-volunteers"/></phrase>, and do some
manual testing.  Assuming it passes these checks, as well as any other
release checklist criteria the project may have, the developers then
digitally sign the tarball using GnuPG
(<ulink url="http://www.gnupg.org/"/>), PGP
(<ulink url="http://www.pgpi.org/"/>), or some other program capable
of producing PGP-compatible signatures.</para>

<para>In most projects, the developers just use their personal digital
signatures, instead of a shared project key, and as many developers as
want to may sign (i.e., there is a minimum number, but not a maximum).
The more developers sign, the more testing the release undergoes, and
also the greater the likelihood that a security-conscious user can
find a digital trust path from herself to the tarball.</para>

<para>Once approved, the release (that is, all tarballs, zip files,
and whatever other formats are being distributed) should be placed
into the project's download area, accompanied by the digital
signatures, and by MD5/SHA1 checksums (see <ulink
url="http://en.wikipedia.org/wiki/Cryptographic_hash_function"/>).
There are various standards for doing this.  One way is to accompany
each released package with a file giving the corresponding digital
signatures, and another file giving the checksum.  For example, if one
of the released packages is <filename>scanley-2.5.0.tar.gz</filename>,
place in the same directory a file
<filename>scanley-2.5.0.tar.gz.asc</filename> containing the digital
signature for that tarball, another file
<filename>scanley-2.5.0.tar.gz.md5</filename> containing its MD5
checksum, and optionally another,
<filename>scanley-2.5.0.tar.gz.sha1</filename>, containing the SHA1
checksum.  A different way to provide checking is to collect all the
signatures for all the released packages into a single file,
<filename>scanley-2.5.0.sigs</filename>; the same may be done with the
checksums.</para>

<para>It doesn't really matter which way you do it.  Just keep to a
simple scheme, describe it clearly, and be consistent from release to
release.  The purpose of all this signing and checksumming is to give
users a way to verify that the copy they receive has not been
maliciously tampered with.  Users are about to run this code on their
computers&mdash;if the code has been tampered with, an attacker could
suddenly have a back door to all their data.  See
<xref linkend="security-releases"/><phrase output="printed">
later in this chapter</phrase> for more about paranoia.</para>

<sect2 id="candidate-releases">
<title>Candidate Releases</title>

<para>For important releases containing many changes, many projects
prefer to put out <firstterm>release candidates</firstterm> first,
e.g., <filename>scanley-2.5.0-beta1</filename> before
<filename>scanley-2.5.0</filename>.  The purpose of a candidate is to
subject the code to wide testing before blessing it as an official
release.  If problems are found, they are fixed on the release branch
and a new candidate release is rolled out
(<filename>scanley-2.5.0-beta2</filename>).  The cycle continues until
no unacceptable bugs are left, at which point the last candidate
release becomes the official release&mdash;that is, the only
difference between the last candidate release and the real release
is the removal of the qualifier from the version number.</para>

<para>In most other respects, a candidate release should be treated
the same as a real release.  The <emphasis>alpha</emphasis>,
<emphasis>beta</emphasis>, or <emphasis>rc</emphasis> qualifier is
enough to warn conservative users to wait until the real release, and
of course the announcement emails for the candidate releases should
point out that their purpose is to solicit feedback.  Other than
that, give candidate releases the same amount of care as regular
releases.  After all, you want people to use the candidates, because
exposure is the best way to uncover bugs, and also because you never
know which candidate release will end up becoming the official
release.</para>

</sect2>

<sect2 id="release-announcement">
<title>Announcing Releases</title>

<para>Announcing a release is like announcing any other event, and
should use the procedures described in
<xref linkend="publicity"/><phrase output="printed"> in
<xref linkend="communications"/></phrase>.  There are a few
specific things to do for releases, though.</para>

<para>Whenever you give the URL to the downloadable release tarball,
make sure to also give the MD5/SHA1 checksums and pointers to the
digital signatures file.  Since the announcement happens in multiple
forums (mailing list, news page, etc.), this means users can get the
checksums from multiple sources, which gives the most
security-conscious among them extra assurance that the checksums
themselves have not been tampered with.  Giving the link to the
digital signature files multiple times doesn't make those signatures
more secure, but it does reassure people (especially those who don't
follow the project closely) that the project takes security
seriously.</para>

<para>In the announcement email, and on news pages that contain more
than just a blurb about the release, make sure to include the relevant
portion of the CHANGES file, so people can see why it might be in
their interests to upgrade.  This is as important with candidate
releases as with final releases; the presence of bugfixes and new
features is important in tempting people to try out a candidate
release.</para>

<para>Finally, don't forget to thank the development team, the
testers, and all the people who took the time to file good bug
reports.  Don't single out anyone by name, though, unless there's
someone who is individually responsible for a huge piece of work,
the value of which is widely recognized by everyone in the
project.  Just be wary of sliding down the slippery slope of credit
inflation (see <xref linkend="credit"/><phrase output="printed">
in <xref linkend="managing-volunteers"/></phrase>).</para>

</sect2>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="release-lines">
<title>Maintaining Multiple Release Lines</title>

<para>Most mature projects maintain multiple release lines in
parallel.  For example, after 1.0.0 comes out, that line should
continue with micro (bugfix) releases 1.0.1, 1.0.2, etc., until the
project explicitly decides to end the line.  Note that merely
releasing 1.1.0 is not sufficient reason to end the 1.0.x line.  For
example, some users make it a policy never to upgrade to the first
release in a new minor or major series&mdash;they let others shake the
bugs out of, say 1.1.0, and wait until 1.1.1.  This isn't necessarily
selfish (remember, they're forgoing the bugfixes and new features
too); it's just that, for whatever reason, they've decided to be very
careful with upgrades.  Accordingly, if the project learns of a major
bug in 1.0.3 right before it's about to release 1.1.0, it would be a
bit severe to just put the bugfix in 1.1.0 and tell all the old 1.0.x
users they should upgrade.  Why not release both 1.1.0 and 1.0.4, so
everyone can be happy?</para>

<para>After the 1.1.x line is well under way, you can declare 1.0.x to
be at <firstterm>end of life</firstterm>.  This should be announced
officially.  The announcement could stand alone, or it could be
mentioned as part of a 1.1.x release announcement; however you do
it, users need to know that the old line is being phased out, so they
can make upgrade decisions accordingly.</para>

<para>Some projects set a window of time during which they pledge to
support the previous release line.  In an open source context,
"support" means accepting bug reports against that line, and making
maintenance releases when significant bugs are found.  Other projects
don't give a definite amount of time, but watch incoming bug reports
to gauge how many people are still using the older line.  When the
percentage drops below a certain point, they declare end of life for
the line and stop supporting it.</para>

<para>For each release, make sure to have a <firstterm>target
version</firstterm> or <firstterm>target milestone</firstterm>
available in the bug tracker, so people filing bugs will be able to do
so against the proper release.  Don't forget to also have a target
called "development" or "latest" for the most recent development
sources, since some people&mdash;not only active developers&mdash;will
often stay ahead of the official releases.</para>

<!-- ======================== subsection ============================== -->
<sect2 id="security-releases">
<title>Security Releases</title>

<para>Most of the details of handling security bugs were covered in
<xref linkend="security"/><phrase output="printed"> in
<xref linkend="communications"/></phrase>, but there are some
special details to discuss for doing security releases.</para>

<para>A <firstterm>security release</firstterm> is a release made
solely to close a security vulnerability.  The code that fixes the bug
cannot be made public until the release is available, which means not
only that the fixes cannot be committed to the repository until the
day of the release, but also that the release cannot be publicly
tested before it goes out the door.  Obviously, the developers can
examine the fix among themselves, and test the release privately, but
widespread real-world testing is not possible.</para>

<para>Because of this lack of testing, a security release should
always consist of some existing release plus the fixes for the
security bug, with <emphasis>no other changes</emphasis>.  This is
because the more changes you ship without testing, the more likely
that one of them will cause a new bug, perhaps even a new security
bug!  This conservatism is also friendly to administrators who may
need to deploy the security fix, but whose upgrade policy prefers that
they not deploy any other changes at the same time.</para>

<para>Making a security release sometimes involves some minor
deception.  For example, the project may have been working on a 1.1.3
release, with certain bug fixes to 1.1.2 already publicly declared,
when a security report comes in.  Naturally, the developers cannot
talk about the security problem until they make the fix available;
until then, they must continue to talk publicly as though 1.1.3 will
be what it's always been planned to be.  But when 1.1.3 actually
comes out, it will differ from 1.1.2 only in the security fixes, and
all those other fixes will have been deferred to 1.1.4 (which, of
course, will now <emphasis>also</emphasis> contain the security
fix, as will all other future releases).</para>

<para>You could add an extra component to an existing release to
indicate that it contains security changes only.  For example, people
would be able to tell just from the numbers that 1.1.2.1 is a security
release against 1.1.2, and they would know that any release "higher"
than that (e.g., 1.1.3, 1.2.0, etc.) contains the same security fixes.
For those in the know, this system conveys a lot of information.  On
the other hand, for those not following the project closely, it can be
a bit confusing to see a three-component release number most of the
time with an occasional four-component one thrown in seemingly at
random.  Most projects I've looked at choose consistency and simply
use the next regularly scheduled number for security releases, even
when it means shifting other planned releases by one.</para>

</sect2>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="releases-and-daily-development">
<title>Releases and Daily Development</title>

<para>Maintaining parallel releases simultaneously has implications
for how daily development is done.  In particular, it makes
practically mandatory a discipline that would be recommended anyway:
have each commit be a single logical change, and never mix unrelated
changes in the same commit.  If a change is too big or too disruptive
to do in one commit, break it across N commits, where each commit is a
well-partitioned subset of the overall change, and includes nothing
unrelated to the overall change.</para>

<para>Here's an example of an ill-thought-out commit:</para>

<screen>
------------------------------------------------------------------------
r6228 | jrandom | 2004-06-30 22:13:07 -0500 (Wed, 30 Jun 2004) | 8 lines

Fix Issue #1729: Make indexing gracefully warn the user when a file
is changing as it is being indexed.

* ui/repl.py
  (ChangingFile): New exception class.
  (DoIndex): Handle new exception.

* indexer/index.py
  (FollowStream): Raise new exception if file changes during indexing.
  (BuildDir): Unrelatedly, remove some obsolete comments, reformat
  some code, and fix the error check when creating a directory.

Other unrelated cleanups:

* www/index.html: Fix some typos, set next release date.
------------------------------------------------------------------------
</screen>

<para>The problem with it becomes apparent as soon as someone needs to
port the <function>BuildDir</function> error check fix over to a
branch for an upcoming maintenance release.  The porter doesn't want
any of the other changes&mdash;for example, perhaps the fix to issue
#1729 wasn't approved for the maintenance branch at all, and the
<filename>index.html</filename> tweaks would simply be irrelevant
there.  But she cannot easily grab just the
<function>BuildDir</function> change via the version control tool's
merge functionality, because the version control system was told that
that change is logically grouped with all these other unrelated
things.  In fact, the problem would become apparent even before the
merge.  Merely listing the change for voting would become problematic:
instead of just giving the revision number, the proposer would have to
make a special patch or change branch just to isolate the portion of
the commit being proposed.  That would be a lot of work for others to
suffer through, and all because the original committer couldn't be
bothered to break things into logical groups.</para>

<para>In fact, that commit really should have been
<emphasis>four</emphasis> separate commits: one to fix issue
#1729, another to remove obsolete comments and reformat code in
<function>BuildDir</function>, another to fix the error check in
<function>BuildDir</function>, and finally, one to tweak
<filename>index.html</filename>.  The third of those commits would be
the one proposed for the maintenance release branch.</para>

<para>Of course, release stabilization is not the only reason why
having each commit be one logical change is desirable.
Psychologically, a semantically unified commit is easier to review,
and easier to revert if necessary (in some version control systems,
reversion is really a special kind of merge anyway).  A little
up-front discipline on everyone's part can save the project a lot of
headache later.</para>

<!-- ======================== subsection ============================== -->
<sect2 id="planning">
<title>Planning Releases</title>

<para>One area where open source projects have historically differed
from proprietary projects is in release planning.  Proprietary
projects usually have firmer deadlines.  Sometimes it's because
customers were promised that an upgrade would be available by a
certain date, because the new release needs to be coordinated with
some other effort for marketing purposes, or because the venture
capitalists who invested in the whole thing need to see some results
before they put in any more funding.  Free software projects, on the
other hand, were until recently mostly motivated by amateurism in the
most literal sense: they were written for the love of it.  No one felt
the need to ship before all the features were ready, and why should
they?  It wasn't as if anyone's job was on the line.</para>

<para>Nowadays, many open source projects are funded by corporations,
and are correspondingly more and more influenced by deadline-conscious
corporate culture.  This is in many ways a good thing, but it can
cause conflicts between the priorities of those developers who are
being paid and those who are volunteering their time.  These conflicts
often happen around the issue of when and how to schedule releases.
The salaried developers who are under pressure will naturally want to
just pick a date when the releases will occur, and have everyone's
activities fall into line.  But the volunteers may have other
agendas&mdash;perhaps features they want to complete, or some testing
they want to have done&mdash;that they feel the release should wait
on.</para>

<para>There is no general solution to this problem except discussion
and compromise, of course.  But you can minimize the frequency and
degree of friction caused, by decoupling the proposed
<emphasis>existence</emphasis> of a given release from the date when
it would go out the door.  That is, try to steer discussion toward the
subject of which releases the project will be making in the near- to
medium-term future, and what features will be in them, without at
first mentioning anything about dates, except for rough guesses with
wide margins of error<footnote><para>For an alternative approach, you
may wish to read Martin Michlmayr's Ph.D. thesis <citetitle>Quality
Improvement in Volunteer Free and Open Source Software Projects:
Exploring the Impact of Release Management</citetitle>
(<ulink url="http://www.cyrius.com/publications/michlmayr-phd.html"/>).
It is about using time-based release processes, as opposed to
feature-based, in large free software projects.  Michlmayr also gave a
talk at Google on the subject, available on Google Video at
<ulink url="http://video.google.com/videoplay?docid=-5503858974016723264"
/>.</para></footnote>.  By nailing down feature sets early, you reduce
the complexity of the discussion centered on any individual release,
and therefore improve predictability.  This also creates a kind of
inertial bias against anyone who proposes to expand the definition of
a release by adding new features or other complications.  If the
release's contents are fairly well defined, the onus is on the
proposer to justify the expansion, even though the date of the release
may not have been set yet.</para>

<para>In his multi-volume biography of Thomas Jefferson,
<citetitle>Jefferson and His Time</citetitle>, Dumas Malone tells the
story of how Jefferson handled the first meeting held to decide the
organization of the future University of Virginia.  The University had
been Jefferson's idea in the first place, but (as is the case
everywhere, not just in open source projects) many other parties had
climbed on board quickly, each with their own interests and agendas.
When they gathered at that first meeting to hash things out, Jefferson
made sure to show up with meticulously prepared architectural
drawings, detailed budgets for construction and operation, a proposed
curriculum, and the names of specific faculty he wanted to import from
Europe.  No one else in the room was even remotely as prepared; the
group essentially had to capitulate to Jefferson's vision, and the
University was eventually founded more or less in accordance with his
plans.  The facts that construction went far over budget, and that
many of his ideas did not, for various reasons, work out in the end,
were all things Jefferson probably knew perfectly well would happen.
His purpose was strategic: to show up at the meeting with something so
substantive that everyone else would have to fall into the role of
simply proposing modifications to it, so that the overall shape, and
therefore schedule, of the project would be roughly as he
wanted.</para>

<para>In the case of a free software project, there is no single
"meeting", but instead a series of small proposals made mostly by
means of the issue tracker.  But if you have some credibility in the
project to start with, and you start assigning various features,
enhancements, and bugs to target releases in the issue tracker,
according to some announced overall plan, people will mostly go along
with you.  Once you've got things laid out more or less as you want
them, the conversations about actual release
<emphasis>dates</emphasis> will go much more smoothly.</para>

<para>It is crucial, of course, to never present any individual
decision as written in stone.  In the comments associated with each
assignment of an issue to a specific future release, invite
discussion, dissent, and be genuinely willing to be persuaded whenever
possible.  Never exercise control merely for the sake of exercising
control: the more deeply others participate in the release planning
process (see
<xref linkend="share-management"/><phrase output="printed"> in
<xref linkend="managing-volunteers"/></phrase>), the easier it
will be to persuade them to share your priorities on the issues that
really count for you.</para>

<para>The other way the project can lower tensions around release
planning is to make releases fairly often.  When there's a long time
between releases, the importance of any individual release is
magnified in everyone's minds; people are that much more crushed when
their code doesn't make it in, because they know how long it might be
until the next chance.  Depending on the complexity of the release
process and the nature of your project, somewhere between every three
and six months is usually about the right gap between releases, though
maintenance lines may put out micro releases a bit faster, if there is
demand for them.</para>

</sect2>

</sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->

