<chapter id="pfs-ch-2">

<title>Getting Started <!-- [ 15-25 pp ] --></title>

<simplesect>

<para>This chapter is about how to introduce a new free software
project to the world.  We will approach the subject backwards.  In
real life, your first decision might be whether or not to start an
open source project, and all else would flow from that.  But the
question of <emphasis>whether</emphasis> isn't so easy to separate
from the question of <emphasis>how</emphasis>.  Therefore, we will
start by assuming you've already decided to do it, and examine how.
By the end, you should have a pretty good feel for what would be
involved, and be better equipped to make a decision.</para>

<para>There is one caveat, however, and it's important enough to
potentially short-circuit the entire process: if you're thinking of
starting an open source project, you should first look to see if
there's already an existing project that does what you want.  The
chances are pretty good that whatever problem you want solved now,
someone else wanted solved before you.  If they did solve it, and
released their code under a free license, then there's no reason for
you to reinvent the wheel today.  There are exceptions, of course: if
you want to start a project as an educational experience, than
pre-existing code won't help; or maybe the project you have in mind is
so specialized that you know there is zero chance anyone else has done
it.  But generally, there's no point not looking.  It doesn't take
long, and the payoff can be huge.  If the usual Internet search
engines don't turn up anything, try searching on <ulink
url="http://www.freshmeat.net/"/> (an open source project news site,
about which more later), and if that doesn't work, try <ulink
url="http://www.sourceforge.net/"/>.  Even if you don't find exactly
what you were looking for, you mind find something close enough that
it makes more sense to join that project and add functionality, rather
than starting from scratch.</para>

</simplesect>


<!-- ========================== subsection =========================== -->
<sect1 id="pfs-ch-2-sect-1">
<title>The Principles of Scaled Presentation</title>

<para>The classic model of how free software projects get started was
supplied by Eric Raymond, in a now-famous paper on open source
processes entitled <citetitle>The Cathedral and the
Bazaar</citetitle>.  He wrote:</para>

    <blockquote>
      <para><emphasis>Every good work of software starts by scratching
      a developer's personal itch.</emphasis></para>

      <para>(from <emphasis role="bold"><ulink
      url="http://www.catb.org/~esr/writings/cathedral-bazaar/"/>
      </emphasis>)</para>
    </blockquote>

<para>Note that Raymond wasn't saying that open source projects only
happen when some individual gets an itch.  Rather, he was saying that
<emphasis>good</emphasis> software results when the programmer has a
personal interest in seeing the problem solved; and the relevance of
this to free software was that a personal itch happened to be the most
frequent motivation for starting a free software project.  It's still
how most free projects are started, but less so now than in 1997, when
Raymond wrote those words.  Today, we have the phenomenon of
organizations &mdash; including for-profit corporations &mdash;
starting large scale, centrally managed open source projects from
scratch.  The lone programmer, banging out some code to solve a local
problem and then realizing the result has wider applicability, is
still the source of much new free software, but is no longer the only
story.</para>

<para>His point is still insightful, however.  The essential thing is
that the producers of the software have a direct interest in its
success, because they want to use it themselves.  If the software
doesn't do what it's supposed to do, the person or organization
producing it will feel the dissatisfaction in their daily work.  For
example, the OpenAdapter project (<ulink
url="http://www.openadapter.org/"/>), which was started by investment
bank Dresdner Kleinwort Wasserstein as an open source framework for
integrating disparate financial information systems, can hardly be
said to scratch any individual programmer's personal itch.  It
scratches an institutional itch.  But that itch arises directly from
the experiences of the institution and its partners, and therefore if
the project fails to relieve them, they will know.  This arrangement
can produce good software because the feedback loop flows in the right
direction.  The program isn't being written to be sold to someone else
so they can solve <emphasis>their</emphasis> problem.  It's being
written to solve one's <emphasis>own</emphasis> problem, and then
shared with everyone, much as though the problem were a disease, and
the software were medicine whose distribution is meant to completely
eradicate the epidemic.</para>

<para>Indeed, many of the recommendations in this chapter would be
familiar to a health organization distributing medicine.  The goals
are very similar: you want to make it clear what the medicine does,
get it into the hands of the right people, and make sure that those
who receive it know how to use it.  But with software, you also want
to entice some of the recipients into joining the ongoing research
effort to improve the medicine.  Free software distribution is a
twofold task.  The software needs to acquire users, and it needs to
acquire developers.  The two needs are not necessarily in conflict,
but they do add some complexity to a project's initial presentation.
Some information is useful for both audiences, some is useful only for
one or the other.  Both kinds of information should subscribe to the
principle of scaled presentation, that is, the degree of detail
presented should correspond directly to the amount of time and effort
put in by the reader.  More effort should always equal more reward.
When the two do not correlate tightly, people may quickly lose faith
and stop investing effort.</para>

<para>The corollary to all this is that <emphasis>appearances
matter</emphasis>.  Programmers in particular often don't like to
believe this.  The peril of working at the boundary between humans and
machines is that one gradually comes to see the world from the point
of view of the machines.  One thinks of systems primarily in terms of
their underlying implementations, and prefers user interfaces that
place as little barrier as possible between the user and the
implementation.  This love of substance over form is almost a point of
professional pride, and it's probably no accident that so many
programmers exhibit an antipathy for marketing and public relations
work.</para>

<para>This is a pity, because there are situations where form
<emphasis>is</emphasis> substance, and project presentation is one of
them.  A project is, essentially, a collection of information with a
name.  Deciding which parts of that information to emphasize is an
ongoing task that spans the whole life of the project, but it is
especially important at the beginning.  However unjust it may be,
people cannot help themselves from forming an immediate first
impression, and they will form it based not on the project itself, nor
even on the quality of information offered about the project, but
rather on the very first bit of meta-information available: the sense
that care was, or was not, taken in organizing the project's
presentation.  Humans have sensitive antennae for detecting care
invested by other humans.  Most of us can tell in one glance whether a
web site was slapped together quickly or was given serious thought.
<emphasis>This</emphasis> is the first piece of information your
project puts out, and there is no way to avoid it, because it is the
stream in which further information must flow.  If the stream itself
is cloudy, then people will assume a similar lack of care applies to
the code and everything else.</para>

<para>So, take some time to set up a good (meaning good-looking, as
well as contentful) project web site:</para>

<itemizedlist>

  <listitem>
  <para>The very first thing a person sees when they go to the site
  should be a clear, concise description &mdash; a mission statement
  &mdash; of what the project is and and is not about.  This should be
  the topmost bit of text on the page, right after to the project's
  name.  If someone has to dig around to figure out what the project
  is all about, there's a good chance they'll just leave.</para>
  </listitem>

  <listitem>
  <para>The description must make it unambiguously clear that the
  project is open source.  This may seem obvious, but you would be
  surprised how many projects forget to do it.  I have seen free
  software project web sites where the front page not only did not
  say which particular free license the software was distributed
  under, but did not even state outright that the software was free
  at all.  Sometimes the crucial bit of information was relegated to
  the Downloads page, or the Developers page, or some other place
  that required one more mouse click to get to.  In extreme cases, the
  license was not given anywhere on the web site at all &mdash; the
  only way to find it out was to download the software and look
  inside.</para>

  <para>Needless to say, such an omission can lose many potential
  developers and users.  Don't make this mistake.  State up front that
  the project is "free software" or "open source software", and give
  the exact license.  The details of choosing a license are discussed
  in <xref linkend="pfs-ch-3"/>.</para>
  </listitem>

  <listitem>
  <para>Once someone has determined that they're interested in
  learning more about a project, it should be clear where to go for
  more.  For example, if they want to use the software, there should
  be links to user documentation, and it should be obvious
  <emphasis>from looking at the links</emphasis> that they lead to
  user documentation, not developer documentation.  It is a general
  principle of clear web site design that one should have a rough idea
  where a link goes before one clicks on it.  In this case it's even
  more important, because the web site has to target two different,
  though often overlapping, types of visitors: potential users and
  potential developers.  Always consider the site's presentation from
  the point of view of each audience.</para>
  </listitem>

  <listitem>
  <para>State the development status of the project, and what its
  near-term goals and needs are (for example, it might be looking for
  developers with a particular kind of expertise).  The mission
  statement itself will usually not contain this information, because
  it looks to the future.  This mission statement is about what the
  project will be; the development status says what it is right now.
  Don't be afraid of looking bad, and don't give in to the temptation
  to hype the development status.  Everyone knows that software
  evolves by stages; there's no shame in saying "This is alpha
  software with known bugs.  It runs, and works at least some of the
  time, but use at your own risk."  Such language won't scare away the
  kinds of developers you need at that stage.  As for users, the very
  worst thing a project can do is attract users before the software is
  ready for them.  A reputation for instability or bugginess is very
  hard to shake, once acquired.  Conservativism pays off in the long
  run; it's always better for the software to be
  <emphasis>more</emphasis> stable than the user expected than less,
  and pleasant surprises produce the best kind of
  word-of-mouth.</para>

  <para>(By the way, <firstterm>alpha</firstterm> means a running
  prototype that may not have all the intended functionality, but has
  enough core functionality to be used.  The main purpose of alpha
  software is to generate feedback, so the developers know what to
  work on.  The next stage, <firstterm>beta</firstterm>, means the
  software has most or all of its intended functionality, but still
  has known bugs.  The purpose of beta is likewise to give developers
  feedback, but it's also expected that users can get real work done
  with the software.)</para>
  </listitem>

  <listitem>
  <para>The distribution mechanism should be as convenient, standard,
  and low-overhead as possible.  If you're trying to eradicate a
  disease, you don't distribute the medicine in such a way that it
  requires a non-standard syringe size to administer.  Likewise,
  software should conform to standard build and installation methods;
  the more it deviates from the standards, the more potential users
  will be lost.</para>

  <para>This sounds obvious, but again, many projects don't bother to
  standardize their installation procedures until very late in the
  game, telling themselves they can do it any time: "We'll sort all
  that stuff out when the code is closer to being ready."  What they
  don't realize is that by putting off the boring work of
  standardizing the build and installation procedures, they are
  actually making the code take longer to get ready &mdash; because
  they lose developers who might otherwise have contributed to the
  code.  Boring work with a high payoff should always be done early,
  and significantly lowering the project's barrier to entry is a high
  payoff.</para>

  <para>The details of standardizing build and installation procedures
  are covered later in this chapter.  (###todo: link to where)</para>

  <!--
  ###todo: in the section on this, point out that users may try
  something as simple as hovering the mouse pointer over the
  "Download" link and seeing what kind of filename or page name it
  links to, without actually clicking on it.  Even the link names are
  part of the presentation.
  -->

  </listitem>

  <listitem>
  <para>Make it clear how to get involved as a developer.  If someone
  wants to contribute, the first thing they'll look for is contributor
  guidelines.  These will be covered in more detail below (###todo:
  link to where), but the basic elements are code documentation (such
  as a design doc), pointers to forums for interaction with other
  developers, and some indication of <emphasis>how</emphasis>
  development is usually done &mdash; for example, guidelines for
  submitting patches, and the procedures by which a contributor gets
  <firstterm>commit access</firstterm>, that is, the ability to put
  changes directly into the software without going through some other
  developer.</para>

  <para>As with everything else, the importance of this is as much
  about appearance as substance.  The developer guidelines are there
  partly to supply information, but it's also to supply comfort.
  Their mere presence reassures any developer who is deciding whether
  or not to get involved.  They say that this project has its act
  together, has anticipated the questions people will ask, and has
  made an effort to answer them.  By giving off an aura of
  preparedness, the project is sending out a message: "Your time will
  not be wasted if you get involved.".</para>
  </listitem>

  <listitem>
  <para>Be clear about the demographics of the intended audience.  If
  you expect the software to be run only by people with database
  administration experience, then it's okay to use database jargon in
  the presentation.</para>
  </listitem>

  <!--
        The same "make it easy" philosophy applied to the software's
        installation and build procedures should apply to its usage
        and administration as well.  This mandate extends well beyond
        the "Getting Started" stage discussed in this chapter, of
        course, but it is still relevant &mdash; even especially
        relevant &mdash; at the beginning of a project.

        The methods of administering the medicine should be
        appropriate to the resources and expertise of the intended
        recipients.  If it requires special devices and patient
        supervision anyway, then it's okay that only a trained doctor
        can administer it.  But if it's relatively straightforward,
        like mosquito repellant, then it should be administerable by
        anyone who can read simple directions.
   -->

  <listitem>
  <remark>(working here)</remark>
  <para>developer documentation; hacking file; project norms</para>
  </listitem>


</itemizedlist>



</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-ch-2-sect-2">
<title>Setting Goals, Choosing a License </title>

<para> Setting goals, choosing a license (but refer to Chapter 3 for
the really detailed discussion of licenses.  It's important to *not*
dive into that swamp too early, since the licensing discussion will
probably be the part of the book most often skipped over in a first
reading) </para>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-ch-2-sect-3">
<title> Starting from Scratch </title>

<para> todo </para>

<screen>
     b) Starting from scratch:
         1) How open should the initial design work be?
         2) Choosing a language; avoiding language holy wars.
</screen>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-ch-2-sect-4">
<title> Open-Sourcing an Existing Project </title>

<para> todo </para>

<screen> 
c) Open-sourcing an already-established project (e.g., Vesta).
Understanding that development will happen differently after the
project goes open.
</screen>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-ch-2-sect-5">
<title>Predicting Conflicts of Interest</title>

<para> todo </para>

<screen> 

        [Subsection: Money and its Effects:]
        Preliminary discussion, essay-style, of funding in the open
        source world.  Cover the totally unfunded, the
        PayPal-for-Pizza world, full non-profits (ASF, Xiph.org,
        OpenOffice [sort of]), for-profit-but-free (find some
        examples), dual-licensing models (MySQL, Sendmail,
        BerkeleyDB), and all sorts of edge cases.  Describe how
        funding can affect a project both negatively and positively:
        solid funding can make people more willing to give it a chance
        (they feel they're investing their time into something that
        will be around a year from now), and reduces the project's
        vulnerability to the Forces Of Darkness; on the other hand, if
        not handled carefully, money can divide the project into
        in-group and out-group developers.  Refer to the relevant
        parts of Chapter 5.

d) Conflicts of Interest.  In a funded project, the
           corporation or consortium supplying the money may have
           different goals than many of the volunteers have.  How to
           balance the funder's interests with the volunteers'
           interests without either side becoming disgruntled.  [ Case
           studies: Subversion, possibly others ]

These conflicts should be identified and answered early.
Preemptivity is the key.
</screen>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-ch-2-sect-6">
<title>Announcing </title>

<para> todo </para>

<screen> 
   e) Announcing the project's inception.
</screen>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-ch-2-sect-7">
<title> Making it Both Developer-Friendly and User-Friendly </title>

<para> todo </para>

<screen> 
   f) How to make a project appear developer-friendly from the start.

   note: state, in order to debunk, the fallacy of "it's more
   important to have code than good presentation."  Programmers are
   trained to believe that substance beats form every time; it's
   almost a moral position.  Unfortunately, it trips them up in
   situations when form *is* substance.

</screen>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-ch-2-sect-8">
<title> Designing to Support Division of Labor </title>

<para> todo </para>

<screen> 
        g) How to make the project's architecture support division
           among many workers.  (Example: According to Tim [via Andy],
           Linus said that he found it easier to get volunteers
           because he knew how to break down the functionality or
           source code into chunks that different people could
           handle.)  This will tie into material in Chapter 5(a).
</screen>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-ch-2-sect-9">
<title> Understanding Developers' Motivations </title>

<para> todo </para>

<screen> 
        h) Understanding potential volunteers' motivations will help
           you set things up to attract them.  You can't build the
           lamp until you know what frequencies of light the moths
           are attracted to.  Oh, wait, maybe that's not such a good
           metaphor...
</screen>

</sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->

