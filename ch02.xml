<chapter id="pfs-ch-2">

<title>Getting Started</title>

<simplesect>

<para>The classic model of how free software projects get started was
supplied by Eric Raymond, in a now-famous paper on open source
processes entitled <citetitle>The Cathedral and the
Bazaar</citetitle>.  He wrote:</para>

    <blockquote>
      <para><emphasis>Every good work of software starts by scratching
      a developer's personal itch.</emphasis></para>

      <para>(from <emphasis role="bold"><ulink
      url="http://www.catb.org/~esr/writings/cathedral-bazaar/"/>
      </emphasis>)</para>
    </blockquote>

<para>Note that Raymond wasn't saying that open source projects only
happen when some individual gets an itch.  Rather, he was saying that
<emphasis>good</emphasis> software results when the programmer has a
personal interest in seeing the problem solved; the relevance of this
to free software was that a personal itch happened to be the most
frequent motivation for starting a free software project.</para>

<para>This is still how most free projects are started, but less so
now than in 1997, when Raymond wrote those words.  Today, we have the
phenomenon of organizations &mdash; including for-profit corporations
&mdash; starting large, centrally-managed open source projects from
scratch.  The lone programmer, banging out some code to solve a local
problem and then realizing the result has wider applicability, is
still the source of much new free software, but is not the only
story.</para>

<para>Raymond's point is still insightful, however.  The essential
condition is that the producers of the software have a direct interest
in its success, because they use it themselves.  If the software
doesn't do what it's supposed to do, the person or organization
producing it will feel the dissatisfaction in their daily work.  For
example, the OpenAdapter project (<ulink
url="http://www.openadapter.org/"/>), which was started by investment
bank Dresdner Kleinwort Wasserstein as an open source framework for
integrating disparate financial information systems, can hardly be
said to scratch any individual programmer's personal itch.  It
scratches an institutional itch.  But that itch arises directly from
the experiences of the institution and its partners, and therefore if
the project fails to relieve them, they will know.  This arrangement
produces good software because the feedback loop flows in the right
direction.  The program isn't being written to be sold to someone else
so they can solve <emphasis>their</emphasis> problem.  It's being
written to solve one's <emphasis>own</emphasis> problem, and then
shared with everyone, much as though the problem were a disease, and
the software were medicine whose distribution is meant to completely
eradicate the epidemic.</para>

<para>This chapter is about how to introduce a new free software
project to the world, but many of its recommendations would sound
familiar to a health organization distributing medicine.  The goals
are very similar: you want to make it clear what the medicine does,
get it into the hands of the right people, and make sure that those
who receive it know how to use it.  But with software, you also want
to entice some of the recipients into joining the ongoing research
effort to improve the medicine.  Free software distribution is a
twofold task.  The software needs to acquire users, and to acquire
developers.  These two needs are not necessarily in conflict, but they
do add some complexity to a project's initial presentation.  Some
information is useful for both audiences, some is useful only for one
or the other.  Both kinds of information should subscribe to the
principle of scaled presentation, that is, the degree of detail
presented at each stage should correspond directly to the amount of
time and effort put in by the reader.  More effort should always equal
more reward.  When the two do not correlate tightly, people may
quickly lose faith and stop investing effort.</para>

<para>The corollary to this is that <emphasis>appearances
matter</emphasis>.  Programmers in particular often don't like to
believe this.  Their love of substance over form is almost a point of
professional pride.  It's no accident that so many programmers exhibit
an antipathy for marketing and public relations work, nor that
professional graphic designers are often horrified at what programmers
come up with on their own.</para>

<para>This is a pity, because there are situations where form
<emphasis>is</emphasis> substance, and project presentation is one of
them.  For example, the very first thing a visitor learns about a
project is what its web site looks like.  This information is absorbed
before any of the actual content on the site is comprehended &mdash;
before any of the text has been read or links clicked on.  However
unjust it may be, people cannot stop themselves from forming an
immediate first impression.  The site's appearance signals whether
care was or was not taken in organizing the project's presentation.
Humans have extremely sensitive antennae for detecting the investment
of care.  Most of us can tell in one glance whether a web site was
slapped together quickly or was given serious thought.  This is the
first piece of information your project puts out, and there is no way
to avoid it, because it is the channel through which all further
information must flow.  If the channel itself is not well-built,
people will assume a similar lack of care applies to the code and
everything else associated with the project.  Such an impression can
be overcome by further exposure to the project &mdash; but only, of
course, if the visitor stays long enough for there to be further
exposure.</para>

<para>Thus, while much of this chapter talks about the content your
project should start out with, remember that its look and feel matters
too.  Because the project web site has to work for two different types
of visitors &mdash; users and developers &mdash; special attention
must be paid to clarity and directedness.  Although this is not the
place for a general treatise on web design, one principle is important
enough to deserve mention, particularly when the site serves multiple
(if overlapping) audiences: people should have a rough idea where a
link goes before clicking on it.  For example, it should be obvious
<emphasis>from looking at the links</emphasis> to user documentation
that they lead to user documentation, and not to, say, developer
documentation.  Running a project is partly about supplying
information, but it's also about supplying comfort.  The mere presence
of certain standard offerings, grouped and arrayed in expected places,
reassures users and developers who are deciding whether they want to
get involved.  It says that this project has its act together, has
anticipated the questions people will ask, and has made an effort to
answer them in a way that requires minimal exertion on the part of the
asker.  By giving off this aura of preparedness, the project sends out
a message: "Your time will not be wasted if you get involved.", which
is exactly what people need to hear.</para>


<!-- ======================== subsection ============================== -->
<sect2 id="pfs-ch-2-sect-0.1">
<title>But First, Look Around</title>

<para>Before starting an open source project, there is one important
caveat:</para>

<para>Always look around to see if there's an existing project that
does what you want.  The chances are pretty good that whatever problem
you want solved now, someone else wanted solved before you.  If they
did solve it, and released their code under a free license, then
there's no reason for you to reinvent the wheel today.  There are
exceptions, of course: if you want to start a project as an
educational experience, than pre-existing code won't help; or maybe
the project you have in mind is so specialized that you know there is
zero chance anyone else has done it.  But generally, there's no point
not looking, and the payoff can be huge.  If the usual Internet search
engines don't turn up anything, try searching on <ulink
url="http://www.freshmeat.net/"/> (an open source project news site,
about which more later), and if that doesn't work, try <ulink
url="http://www.sourceforge.net/"/>.</para>

<para>Even if you don't find exactly what you were looking for, you
mind find something so close that it makes more sense to join that
project and add functionality, rather than starting from scratch
yourself.</para>

</sect2>

</simplesect>


<!-- ========================== SECTION =========================== -->
<sect1 id="pfs-ch-2-sect-1">
<title>Starting From What You Have</title>

<para>You've looked around, found that nothing out there really fits
your needs, and decided to start a new project.</para>

<para>What now?</para>

<para>The hardest part about launching a free software project is
transforming a private vision into a public one.  You or your
organization may know perfectly well what you want, but expressing
that goal comprehensibly to the world is a fair amount of work.  It is
essential, however, that you take the time to do it.  You and the
other founders must decide what the project is really about &mdash;
that is, decide its limitations, what it <emphasis>won't</emphasis> do
as well as what it will &mdash; and write up a mission statement.
This part is usually not too hard, though it can sometimes reveal
unspoken assumptions and even disagreements about the nature of the
project, which is fine: better to resolve those now than later.  The
next step is to package up the project for public consumption, and
this is, basically, pure drudgery.</para>

<para>What makes it so laborious is that it consists mainly of
organizing and documenting things everyone already knows &mdash;
"everyone", that is, who's been involved in the project so far.  Thus,
for the people doing the work, there is no immediate benefit.  They do
not need a <filename>README</filename> file giving an overview of the
project, nor a design document, nor user manual.  They do not need a
carefully arranged code tree conforming to the informal but widespread
standards of software source distributions.  Whatever way the source
code is arranged is fine for them, because they're already accustomed
to it anyway, and if the code runs at all, they know how to use it.
It doesn't even matter, for them, if the fundamental architectural
assumptions of the project remain undocumented; they're already
familiar with that too.</para>

<para>Newcomers, on the other hand, need these things.  Fortunately,
they don't need them all at once.  It's not necessary for you to
provide every possible resource before taking a project public.  In a
perfect world, perhaps, every new open source project would start out
life with a thorough design document, a complete user manual (with
special markings for features planned but not yet implemented),
beautifully and portably packaged code, capable of running on any
computing platform, and so on.  In reality, taking care of all these
loose ends would be prohibitively time-consuming, and anyway, it's
work that one can reasonably hope volunteers will help with once the
project is under way.</para>

<para>What <emphasis>is</emphasis> necessary, however, is that enough
investment be put into initial presentation that newcomers can get
past the initial obstacle of unfamiliarity.  Think of it as the first
step in a bootstrapping process, to bring the project to a kind of
minimum activation energy.  I've heard this threshold called the
<firstterm>hacktivation energy</firstterm>: the amount of energy a
newcomer must put in before they start getting something back.  The
lower a project's hacktivation energy, the better.  Your first task is
to determine the project's current hacktivation energy, and take steps
to bring it down to something acceptable.</para>

<!-- ======================== subsection ============================== -->
<sect2 id="pfs-ch-2-sect-1.1">
<title>Lowering the Hacktivation Energy</title>

<para>Let's put ourselves in the shoes of someone who's just heard
about your project, or maybe stumbled across it during their own
search for a solution.  The first thing they'll encounter is the
project's name.</para>

<itemizedlist>
  <listitem>

  <para><emphasis role="bold">Choosing a Name.</emphasis> A good name
  will not automatically make your project successful, and a bad name
  will not doom it &mdash; well, a <emphasis>really</emphasis> bad
  name probably could do that, but we start from the assumption that
  no one here is actively trying to make their project fail.  However,
  a bad name can slow down adoption of the project, either because
  people don't take it seriously, or because they simply have trouble
  remembering it.  A good name:</para>

  <itemizedlist>
    <listitem><para>Gives some idea what the project does, or at least
              is related in an obvious way, such that if one knows the
              name and knows what the project does, the name will come
              quickly to mind thereafter.</para>
    </listitem>
    <listitem><para>Is easy to remember.  Here, there is no getting
              around the fact that English has become the default
              language of the Internet: "easy to remember" means "easy
              for someone who can read English to remember".  Names
              that are puns dependent on native-speaker
              pronounciation, for example, will be opaque to the many
              non-native English readers out there.  If the pun is
              particularly compelling and memorable, it may still be
              worth it, just keep in mind that many people seeing the
              name will not hear it in their head the way a native
              speaker would.</para>
    </listitem>
    <listitem><para>Is not be the same as some other project's name,
              and does not infringe on any trademarks.  This is just
              good manners, as well as good legal sense.  You don't
              want to create identity confusion.  It's hard enough to
              keep track of everything that's available on the Net
              already, without different things have the same
              name.</para>
    </listitem>
    <listitem><para>If possible, is available as a domain name in the
              <systemitem>.com</systemitem>,
              <systemitem>.net</systemitem>, and
              <systemitem>.org</systemitem> top-level domains.  Even
              if you don't intend to host the project under those
              names, you can still register them and forward them to
              wherever you do host it.  It helps users a lot to have a
              simple URL to remember.</para>
    </listitem>
  </itemizedlist>
  </listitem>
</itemizedlist>

<para>Having found the project, the next thing people will look for is
a quick description, a mission statement, so they can decide (within
30 seconds) whether or not they're interested in learning more.  This
should be prominently placed on the project's home page, preferably
near the name.</para>

<itemizedlist>
  <listitem>

  <para><emphasis role="bold">Mission Statement.</emphasis>
  The mission statement should be concrete, limiting, and above all,
  short.  Here's an example of a good one, from <ulink
  url="http://www.openoffice.org/"/>: 

  <blockquote>
  <para><emphasis>To create, as a community, the leading international
  office suite that will run on all major platforms and provide access
  to all functionality and data through open-component based APIs and
  an XML-based file format.</emphasis></para>
  </blockquote>

  In just a few words, they've hit all the high points, largely by
  drawing on the reader's prior knowledge.  By saying "<emphasis>as a
  community</emphasis>", they signal that no one corporation will
  dominate development; "<emphasis>international</emphasis>" means
  that the software will allow people to work in multiple languages
  and locales; "<emphasis>all major platforms</emphasis>" means it
  will be portable to Unix, Macintosh, and Windows.  The rest signals
  that open interfaces and easily understandable file formats are an
  important part of the goal.  They don't come right out and say that
  they're trying to be a free alternative to Microsoft Office, but
  most people can probably read between the lines.  Although this
  mission statement looks broad at first glance, in fact it is quite
  circumscribed: the words "<emphasis>office suite</emphasis>" mean
  something very concrete to those familiar with such software.
  Again, the reader's presumed prior knowledge (in this case probably
  from MS Office) is used to keep the mission statement
  concise.</para>

  <para>The nature of a mission statement depends partly on who is
  writing it, not just on the software it describes.  For example, it
  makes sense for OpenOffice.org to use the words "<emphasis>as a
  community</emphasis>", because the project was started, and is still
  largely sponsored, by Sun Microsystems.  By including those words,
  Sun indicates its sensitivity to worries that it might try to
  dominate the development process.  With this sort of thing, merely
  demonstrating awareness of the <emphasis>potential</emphasis> for a
  problem goes a long way toward avoiding the problem entirely.  On
  the other hand, projects that aren't sponsored by a single
  corporation probably don't need such language; after all,
  development by community is the norm, so there would ordinarily be
  no reason to list it as part of the mission.</para>

  </listitem>
</itemizedlist>

<para>The mission statement sets up the first level of participant
filtering.  That's why it's okay to presume specific prior knowledge
on the part of the reader &mdash; if someone doesn't know what the
words mean, then they probably can tell this isn't the project for
them.  Anyone who sees your mission and stays interested will want to
move on to a more detailed description of the project, perhaps read
some user or developer documentation, and then download something.
But before any of that, they'll need to know for sure that it's open
source.</para>

<itemizedlist>
  <listitem>
  <para><emphasis role="bold">State That It's Free.</emphasis> The
  front page must make it unambiguously clear that the project is open
  source.  This may seem obvious, but you would be surprised how many
  projects forget to do it.  I have seen free software project web
  sites where the front page not only did not say which particular
  free license the software was distributed under, but did not even
  state outright that the software was free at all.  Sometimes the
  crucial bit of information was relegated to the Downloads page, or
  the Developers page, or some other place that required one more
  mouse click to get to.  In extreme cases, the license was not given
  anywhere on the web site at all &mdash; the only way to find it out
  was to download the software and look inside.</para>

  <para>Needless to say, such an omission can lose many potential
  developers and users.  Don't make this mistake.  State up front that
  the project is "free software" or "open source software", and give
  the exact license.  A quick guide to choosing a license is given in
  <xref linkend="pfs-ch-2-sect-2"/>, and licensing issues are
  discussed in detail in <xref linkend="pfs-ch-10"/>.</para>
  </listitem>
</itemizedlist>

<para>Now our hypothetical visitor can determine, probably in a minute
or less, that they're interested in spending, say, at least five more
minutes investigating this project.  What will they look for in that
five minutes?</para>

<itemizedlist>

  <listitem>
  <para><emphasis role="bold">Features and Requirements List.</emphasis>
  Give a brief list of the specific features the software supports
  (if something isn't completed yet, you can still list it, just put
  "<emphasis>planned</emphasis>" or
  "<emphasis>in&nbsp;progress</emphasis>" next to it), and the kind
  of computing environment required to run the software.  Think of
  the features/requirements list as the technical summary you would
  give someone who has one minute to decide if they'll be able to
  use the software.  It expands on the mission statement.  For
  example, the mission statement might say:

  <blockquote>
  <para><emphasis>To create a full-text indexer and search engine
  with a rich API, for use by programmers in providing search
  services for large collections of text files.</emphasis></para>
  </blockquote>

  The features and requirements list would give the details:

  <blockquote>
    <para><emphasis>Features:</emphasis></para>
    <itemizedlist>
      <listitem><emphasis>Searches plain text, HTML, and XML.</emphasis>
      </listitem>
      <listitem><emphasis>Word or phrase searching.</emphasis>
      </listitem>
      <listitem><emphasis>(planned) Fuzzy matching.</emphasis>
      </listitem>
      <listitem><emphasis>(planned) Incremental updating of indexes.</emphasis>
      </listitem>
      <listitem><emphasis>(planned) Indexing of remote web sites.</emphasis>
      </listitem>
    </itemizedlist>
    <para><emphasis>Requirements:</emphasis></para>
    <itemizedlist>
      <listitem><emphasis>Python 2.2 or higher.</emphasis>
      </listitem>
      <listitem><emphasis>Enough disk space to hold the indexes (approximately
                2x original data size).</emphasis>
      </listitem>
    </itemizedlist>
  </blockquote>

  With this information, readers can quickly get a feel for whether
  this software has any hope of working for them &mdash; and they can
  consider getting involved as a developer.</para>
  </listitem>

  <listitem>
  <para><emphasis role="bold">Development Status.</emphasis> State the
  development status of the project, and what its near-term goals and
  needs are (for example, it might be looking for developers with a
  particular kind of expertise).  Don't be afraid of looking unready,
  and don't give in to the temptation to hype the development status.
  Everyone knows that software evolves by stages; there's no shame in
  saying "This is alpha software with known bugs.  It runs, and works
  at least some of the time, but use at your own risk."  Such language
  won't scare away the kinds of developers you need at that stage.  As
  for users, the very worst thing a project can do is attract users
  before the software is ready for them.  A reputation for instability
  or bugginess is very hard to shake, once acquired.  Conservativism
  pays off in the long run; it's always better for the software to be
  <emphasis>more</emphasis> stable than the user expected than less,
  and pleasant surprises produce the best kind of
  word-of-mouth.</para>

  <para>(By the way, <firstterm>alpha</firstterm> means a running
  prototype that may not have all the intended functionality, but has
  enough core functionality to be used.  The main purpose of alpha
  software is to generate feedback, so the developers know what to
  work on.  The next stage, <firstterm>beta</firstterm>, means the
  software has most or all of its intended functionality, but still
  has known bugs.  The purpose of beta is both to give developers
  feedback and to allow users to get real work done.)</para>
  </listitem>

  <listitem>
  <para><emphasis role="bold">Downloads.</emphasis> The software
  should be downloadable as source code in standard formats.  When a
  project is first getting started, binary (executable) packages are
  not necessary, unless the software has such difficult or unusual
  build requirements that merely getting it to run would be a lot of
  work for most people.  (But if this is the case, the project is
  going to have a hard time attracting developers anyway!).</para>

  <para>The distribution mechanism should be as convenient, standard,
  and low-overhead as possible.  If you were trying to eradicate a
  disease, you wouldn't distribute the medicine in such a way that it
  requires a non-standard syringe size to administer.  Likewise,
  software should conform to standard build and installation methods;
  the more it deviates from the standards, the more potential users
  and developers will give up and go away lost.</para>

  <para>That sounds obvious, but many projects don't bother to
  standardize their installation procedures until very late in the
  game, telling themselves they can do it any time: <emphasis>"We'll
  sort all that stuff out when the code is closer to being
  ready."</emphasis> What they don't realize is that by putting off
  the boring work of finishing the build and installation procedures,
  they are actually making the code take longer to get ready &mdash;
  because they discourage developers who might otherwise have
  contributed to the code.  Most insidiously, they don't
  <emphasis>know</emphasis> they're losing all those developers,
  because the process is an accumulation of non-events: someone visits
  a website, downloads the software, tries to build it, fails, gives
  up and goes away.  Who will ever know it happened, except the person
  themselves?  No one working on the project will realize that
  someone's interest and good will has been silently
  squandered.</para>

  <para>Boring work with a high payoff should always be done early,
  and significantly lowering the project's barrier to entry by
  packaging is a very high payoff.</para>

  <para>When you release a downloadable package, it is vital that you
  give a unique version number to the release, so that people can
  compare any two releases and know which supersedes the other.  A
  detailed discussion of version numbering can be found in
  <xref linkend="pfs-ch-6-sect-1.1"/>.</para>

  <para>The details of standardizing build and installation procedures
  are covered in <xref linkend="pfs-ch-6-sect-1.2"/>.</para>
  </listitem>

  <listitem>
  <para><emphasis role="bold">Version Control.</emphasis> Downloading
  source packages is fine for those who just want to install and use
  the software, but it's not enough for those who want to debug or add
  new features.  Nightly source snapshots can help, but they're still
  not fine-grained enough for a thriving development community.
  People need real-time access to the latest sources, and the way to
  give them that is to use a version control system.  Version control
  options are discussed in detail in <xref
  linkend="pfs-ch-3-sect-3"/>; for now, the important thing is to
  think of the presence of anonymously-accessible version controlled
  sources as yet another sign &mdash; to both users and developers
  &mdash; that this project is making an effort to give people what
  they need to participate.  If you can't do version control right
  away, then put up a sign saying you intend to soon.</para>
  </listitem>

  <listitem>
  <para><emphasis role="bold">Communications Channels.</emphasis>
  Provide the addresses of mailing lists, chat rooms and IRC channels,
  and any other forums where others involved with the software can be
  reached.  Make it clear that you and the other authors of the
  project are subscribed to these mailing lists, so people see there's
  a way to give feedback that will reach the developers.  Again, your
  presence on the lists does not imply a committment to answer all
  questions or implement all feature requests.  In the long run, most
  users will probably never join the forums anyway, but they will be
  comforted to know that they <emphasis>could</emphasis> if they ever
  needed to.</para>

  <para>In the early stages of a project, there's no need to have
  separate user and developer forums.  It's much better to have
  everyone involved with the software talking together, in one "room".
  Among early adopters, the distinction between developer and user is
  often fuzzy; to the extent that the distinction can be made, the
  ratio of developers to users is usually much higher in the early
  days of the project than later on.  While you can't assume that
  every early adopter is a programmer who wants to hack on the
  software, you can assume that they are at least interested in
  following development discussions and in getting a sense of the
  project's direction.</para>
   
  <para>As this chapter is only about getting a project started, it's
  enough merely to say that these communications forums need to exist.
  Later, in <xref linkend="pfs-ch-5"/>, we'll examine where and how to
  set up such forums, the ways in which they might need moderation
  or other management, and how to separate user forums from developer
  forums, when the time comes, without creating an unbridgeable
  gulf.</para>
  </listitem>

  <listitem>
  <para><emphasis role="bold">Developer Guidelines.</emphasis> Make it
  clear how to get involved as a developer.  If someone wants to
  contribute, the first thing they'll look for is contributor
  guidelines.  These will be covered in more detail in <xref
  linkend="pfs-ch-4"/>, but the basic elements are: pointers to forums
  for interaction with other developers, instructions on how to report
  bugs and submit patches, and some indication of
  <emphasis>how</emphasis> development is usually done &mdash; is the
  project a benevolent dictatorship, or a democracy, or something
  else.  No pejorative sense is intended by any of these terms, by the
  way.  It's perfectly okay to run a tyranny where one particular
  developer has veto power over all changes.  Many successful projects
  work this way.  The important thing is that the project come right
  out and say so.  A tyranny pretending to be a democracy will turn
  people off; a tyranny that says it's a tyranny will do fine as long
  as the tyrant is competent and trusted.</para>
  
  <para>See <ulink
  url="http://svn.collab.net/repos/svn/trunk/HACKING"/> for an example
  of particularly thorough developer guidelines, or <ulink
  url="http://www.openoffice.org/dev_docs/guidelines.html"/> for 
  broader guidelines that focus on governance and the spirit of
  participation and less on technical matters.</para>
  </listitem>

  <listitem>
  <para><emphasis role="bold">Documentation.</emphasis> Documentation
  is essential; there needs to be <emphasis>something</emphasis> for
  people to read, even if it's rudimentary and incomplete.  This falls
  squarely into the "drudgery" category referred to earlier, and is
  often the first area where a new open source projects falls down.
  Coming up with a mission statement and feature list, choosing a
  license, summarizing development status &mdash; these are all
  relatively small tasks, which can be definitively completed and
  usually need not be returned to once done.  Documentation, on the
  other hand, is never really finished, which may be one reason
  people sometimes delay starting it at all.</para>

  <para>The worst part is that documentation's utility to those
  writing it is the reverse of its utility to those who will read it.
  The most important documentation for initial users is the basics:
  how to quickly set up the software, an overview of how it works,
  perhaps some guides to doing common tasks.  Yet these are exactly
  the things the <emphasis>writers</emphasis> of the documentation
  know all too well &mdash; so well that it can be difficult for them
  to see things from the reader's point of view, and to laboriously
  spell out the steps that (to the writers) seem so obvious as to be
  unworthy of mention.</para>

  <para>There's no magic solution to this problem.  Someone just needs
  to sit down and write the stuff.  Use a simple, easy-to-edit format
  such as HTML, plain text, Texinfo, or some variant of XML &mdash;
  something that's convenient for lightweight, quick improvements on
  the spur of the moment.  This is not only to remove any overhead
  that might impede the original writers from making incremental
  improvements, but also for those who join the project later and want
  to work on the documentation.</para>

  <para>A good way to ensure basic initial documentation gets done is
  to limit its scope in advance.  That way writing it at least won't
  feel like an open-ended task.  A good rule of thumb is that it
  should meet the following minimal criteria:

    <itemizedlist>
      <listitem><para>Tell the reader clearly how much technical
                expertise they're expected to have.</para>
      </listitem>
      <listitem><para>Don't skimp on describing how to set up the
                software, and somewhere near the beginning of the
                documentation, say how the user can run some sort of
                sort of diagnostic test or simple command to confirm
                that they've set things up correctly.  Startup
                documentation is in some ways more important than
                actual usage documentation.  Once someone has gone to
                the trouble of installing the software, they'll
                probably be persistent in figuring out how to use it.
                When people abandon, they abandon early; therefore,
                it's the earliest stages, like installation, that need
                the most support.</para>
      </listitem>
      <listitem><para>Give one tutorial-style example of how to do a
                common task.  Obviously, many examples for many tasks
                would be even better, but if time is limited, then
                pick one task and walk through it thoroughly, even if
                that means leaving other areas of functionality
                entirely undescribed.  Once someone sees that the
                software <emphasis>can</emphasis> be used for one
                thing, they'll start to explore what else it can do on
                their own &mdash; and, if you're lucky, start filling
                in the documentation themselves.  Which brings us to
                the next point...</para>
      </listitem>
      <listitem><para><emphasis>Label the areas where the
                documentation is known to be incomplete.</emphasis> By
                showing the reader that you are aware of its
                deficiencies, you align yourself with their point of
                view.  Your empathy reassures them that they don't
                face a struggle to convince the project of what's
                important.  There's no need to fear that these labels
                are tantamount to promises to fill in the gaps by any
                particular date &mdash; it's equally legitimate to
                treat them as open requests for volunteer help.</para>
      </listitem>
    </itemizedlist>
  </para>

  <para>The last point is of wider importance, actually, and can be
  applied to the entire project, not just the documentation.  An
  accurate accounting of known deficiencies is the norm in the open
  source world.  You don't have to exaggerate the project's
  shortcomings, just identify them scrupulously and dispassionately
  when the context calls for it (whether in the documentation, in the
  bug tracking database, or on a mailing list discussion).  No one
  will treat this as self-beratement on the part of the project, nor
  as a commitment to solve the problems by a certain date, unless the
  project makes such a commitment explicitly.  Since anyone who uses
  the software will discover the deficiencies for themselves, it's
  much better for them to be psychologically prepared &mdash; then the
  project will look like it has a solid knowledge of how it's
  doing.</para>

  <sect3 id="pfs-ch-2-sect-1.1.1">
  <title>Maintaining a FAQ</title>

  <para>A <firstterm>FAQ</firstterm> ("Frequently Asked Questions"
  document) can be a beautiful thing.  Faqs are highly tuned to the
  questions users and developers actually ask &mdash; as opposed to
  the questions you might have <emphasis>expected</emphasis> them to
  ask &mdash; and therefore a well-maintained FAQ will tend to give
  those who consult it exactly what they're looking for.  The FAQ is
  often the first place users look when they encounter a problem,
  often even in preference to the official manual, and it's probably
  the document in your project most likely to be linked to from other
  sites.</para>

  <para>Unfortunately, you cannot make the FAQ at the time the project
  starts.  Good FAQs are not written, they are grown.  They are by
  definition reactive documents, evolving over time in response to
  people's day-to-day usage of the software.  Since it's impossible to
  correctly anticipate the questions people will ask, it is impossible
  to sit down and write a useful FAQ from scratch.</para>

  <para>Therefore, don't waste your time trying to.  You may, however,
  find it useful to set up a mostly blank FAQ template, so there will
  be an obvious place for people to contribute questions and answers
  after the project is under way.  At this stage, the most important
  property is not completeness, but convenience: if the FAQ is easy to
  update, then people will update it.  (Proper FAQ maintenance is a
  non-trivial and intriguing problem, and is discussed more in
  <xref linkend="pfs-ch-7-sect-2"/>.)</para>

  </sect3>

  <sect3 id="pfs-ch-2-sect-1.1.2">
  <title>Availability of Documentation</title>

  <para>Documentation should be available from two places: online
  (directly from the web site), <emphasis>and</emphasis> in the
  downloadable distribution of the software (see <xref
  linkend="pfs-ch-6-sect-1.2"/>).  It needs to be online, in browseable
  form, because people often read documentation
  <emphasis>before</emphasis> downloading software for the first time,
  as a way of helping them decide whether or not to download at all.
  But it should also accompany the software, on the principle that
  downloading should supply (i.e., make locally accessible) everything
  one needs to use the package.</para>

  <para>For online documentation, make sure that there is a link that
  brings up the <emphasis>entire</emphasis> documentation in one HTML
  page (put a note like "monolithic" or "all-in-one" or "single large
  page" next to the link, so people know that it might take a while to
  load).  This is useful because people often want to search for a
  specific word or phrase throughout the entire documentation.  Often
  they already know more or less what they're looking for, they just
  can't remember what section it's in.  For such people, nothing is
  more frustrating than encountering one HTML page for the table of
  contents, linking to a different page for the introduction, then a
  different page for installation instructions, etc.  The separated
  style may be useful for those who already know what section they
  need, or who want to read the entire documentation from front to
  back in sequence.  But this is <emphasis>not</emphasis> the most
  common way documentation is accessed.  Far more often, someone who
  is basically familiar with the software is coming back looking for a
  specific mention of some word or phrase.  To fail to provide them
  with a single, searchable document would be self-defeating.</para>

  </sect3>

  <sect3 id="pfs-ch-2-sect-1.1.3">
  <title>Developer Documentation</title>

  <para>Developer documentation is documentation whose purpose is to
  help programmers understand the code, so they can repair and extend
  it.  This is somewhat different from the <emphasis>developer
  guidelines</emphasis> discussed earlier, which are more social than
  technical.  Developer guidelines tell programmers how to get along
  with each other; developer documentation tells them how to get along
  with the code itself.  The two are often packaged together in one
  document for convenience (as with the <ulink
  url="http://svn.collab.net/repos/svn/trunk/HACKING"/> example given
  earlier), but they don't have to be.</para>

  <para>Although technical developer documentation can be very
  helpful, there's no reason to delay a release over it.  As long as
  the original authors are available (and willing) to answer questions
  about the code, that's enough to start with.  In fact, having to
  answer the same questions over and over is a common motivation for
  writing documentation.  But even before it's written, contributors
  will still manage find their way around the code.  The force that
  drives people to spend time learning a code base is that the code
  does something useful for them.  If people have faith in that, they
  will take the time to figure things out; if they don't have that
  faith, no amount of developer documentation will get or keep
  them.</para>

  <para>So if you only have time to write documentation for one
  audience, write it for users.  All user documentation is, in effect,
  developer documentation as well; any programmer who's going to work
  on a piece of software will need familiarity with how to use it.
  Later, when you see programmers asking the same questions over and
  over, then take the time to write up some separate documents just
  for them.</para>

  </sect3>
  </listitem>

  <listitem>
  <para><emphasis role="bold">Example Output, Screenshots, Etc.</emphasis>
  If the project involves a graphical user interface of some sort, or
  if it produces graphical or otherwise distinctive output, then put
  some samples up on the project web site.  In the case of interface,
  this means screenshots; for output, it might be screenshots or just
  files.  Both cater to people's need for instant gratification: a
  single screenshot can be more convincing than paragraphs of
  descriptive text and mailing list chatter, because a screenshot is
  inarguable proof that the software <emphasis>works</emphasis>.  It
  may be buggy, it may be hard to install, it may be incompletely
  documented, but that screenshot is still proof that if one puts in
  enough effort, one can get it to run<footnote><para>I was daunted by
  screenshots until I actually made a few.  It turned out to be so
  simple that I'll give instructions for it right here.  Using the
  Gimp (<ulink url="http://www.gimp.org/"/>), open
  <guimenu>File</guimenu>-&gt;<guimenu>Acquire</guimenu>-&gt;<guimenu>Screenshot</guimenu>,
  choose <guimenuitem>Single&nbsp;Window</guimenuitem> or
  <guimenuitem>Whole&nbsp;Screen</guimenuitem>, then click
  <guimenuitem>OK</guimenuitem>.  Now your next mouse click will
  capture the window or screen clicked on as an image in the Gimp.
  Crop and resize the image as necessary, using the instructions at 
  <ulink url="http://www.gimp.org/tutorials/Lite_Quickies/"/>.  What
  could be easier?</para>
  </footnote>.</para>
  </listitem>

</itemizedlist>

<para>There are many other things you could put on the project web
site, if you had the time, or if for one reason or another they were
especially appropriate: a news page, a project history page, a related
links page, a site-search feature, a donations link, etc.  None of
these are necessities at startup time, but keep them in mind for the
future.</para>

<sect3 id="pfs-ch-2-sect-1.1.4">
<title>Canned Hosting</title>

<para>There are a few sites that provide free hosting and
infrastructure for open-source projects: web area, version control,
bug tracker, download area, chat forums, regular backups, etc.  The
details vary from site to site, but the same basic services are
offered at all of them.  By using one of these sites, you get a lot
for free; what you give up, obviously, is fine-grained control over
the developer and user experience.  The hosting service decides what
software the site runs on, and may control or at least influence the
look and feel of the project's web pages.</para>

<para>The largest and most well-known hosting site is <ulink
url="http://www.sourceforge.net/">SourceForge</ulink>.  When the
question is free open source project hosting, SourceForge is the
default answer these days.  However, there are other sites providing
the same or similar services, for example <ulink
url="http://savannah.gnu.org/">savannah.gnu.org</ulink> and <ulink
url="http://www.berlios.de/">BerliOS.de</ulink>.  There are also
organizations, such as the <ulink url="http://www.apache.org/">Apache
Software Foundation</ulink> and <ulink
url="http://www.tigris.org/">Tigris.org</ulink><footnote><para>Disclaimer:
I am employed by <ulink
url="http://www.collab.net/">CollabNet</ulink>, which sponsors
Tigris.org, and I use Tigris regularly.</para></footnote>, that give
free hosting to open source projects that fit well with their missions
and their community of existing projects.</para>

<para>See <xref linkend="pfs-ch-3-sect-7"/> for a more detailed
discussion of the advantages and disadvantages of canned hosting
sites.</para>

</sect3>

</sect2>

<para><remark>(Maybe it would be good to put an image of a good
example project web site here, and an image of a bad one, for
side-by-side comparison?  The bad one would fail to include a latest
version, nor a license, wouldn't say exactly what the program is, and
it would be harder to navigate.  These flaws would be pointed out in
the caption.)</remark></para>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-ch-2-sect-2">
<title>Choosing a License and Applying It</title>

<para>This section is intended to be a "quick start" guide to choosing
a license.  It provides an overview of the best-known licenses, and
why you might choose one over another.  You should read <xref
linkend="pfs-ch-10"/> to understand the detailed legal implications of
the different licenses, so you can understand how the license you
choose affects your ability to incorporate other free software into
yours.</para>

<para>There are a great many free software licenses to choose from.
Most of them we needn't consider, as they were written to satisfy the
particular legal needs of some corporation or person, and probably
wouldn't be appropriate for a new software project.  In this overview,
we will restrict ourselves to just the most commonly-used licenses.
In most cases, you will just want to choose one of these.</para>

<!-- ======================== subsection ============================== -->
<sect2 id="pfs-ch-2-sect-2.1">
<title>The "Do Anything" Licenses</title>

<para>If your primary goal is widespread adoption of the software by
both users and developers, and you don't mind the possibility of it
being used in proprietary products, then choose one of the following:
<firstterm>MIT-style</firstterm>, <firstterm>BSD-style</firstterm>, or
<firstterm>Apache-style</firstterm>.</para>

<variablelist>

  <varlistentry><term>MIT-style:</term>

    <listitem>
      <para>License template at: <ulink
      url="http://www.opensource.org/licenses/mit-license.php"/></para>

      <para>The MIT license is short, simple, and easy to understand.
      In fact, it's short enough to include whole right here: </para>

      <screen>Copyright (c) &lt;year&gt; &lt;copyright holders&gt;

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</screen>

    <para>As you can see, it places almost no restrictions on what
    people can do with the software, so long as they reproduce the
    copyright notice, and it carefully disclaims any liability on the
    part of the copyright holder.  It is called "MIT-style" because
    the Massachusetts Institute of Technology released free software
    under this license.  However, you do not need to be affiliated
    with MIT to use the same license for your programs.</para>
    </listitem>
  </varlistentry> 

  <varlistentry><term>BSD-style:</term>
    <listitem>
      <para>License template at: <ulink
      url="http://www.opensource.org/licenses/bsd-license.php"/></para>

      <para>The BSD license is basically like the MIT, although it
      uses slightly different words to achieve the same effect.  It's
      a bit longer, so I won't reproduce it here; you can find it at
      the above link.  The main difference is that BSD-style licenses
      include a clause explicitly disavowing the right to use the
      licensor's name to endorse the software:</para>

      <screen>Neither the name of the &lt;ORGANIZATION&gt; nor the
names of its contributors may be used to endorse or promote products
derived from this software without specific prior written
permission.</screen>

      <para>It's not clear that without such a clause, a recipient of
      the software would have had the right to use the licensor's name
      anyway, but the clause removes any possible doubt.  For
      corporations releasing software, therefore, the BSD-style may
      be slightly preferable to MIT-style (however, for reasons
      detailed below, the Apache-style may be preferable to both of
      them).  In general, however, a liberal copyright license does
      not imply that recipients have any right to use or dilute your
      trademarks &mdash; copyright law and trademark law are two
      different beasts.</para>

      <para>The name "BSD" derives from "Berkeley Software
      Distribution", a much-revered version of the Unix operating
      system produced by the University of California at Berkeley and
      released under what became known as the "BSD license".</para>
    </listitem>
  </varlistentry> 

  <varlistentry><term>Apache-style:</term>
    <listitem>
      <para>License template at: <ulink
      url="http://www.apache.org/licenses/"/></para>

      <para>The Apache license (version 2.0 as of this writing) is
      longer than either the BSD or MIT, but still quite readable, and
      the extra time needed to comprehend it is worth spending.  The
      Apache Software Foundation (<ulink
      url="http://www.apache.org/"/>) has taken great care to make
      sure the license encourages their goal of "open, collaborative
      development among individuals, industry, and nonprofit
      organizations".  The license includes provisions for protecting
      the trademarks and reputation of the distributing organization,
      preventing patent entanglements, accepting code contributions,
      and various other eventualities.  The terms of use and
      distribution that it allows are pretty much the same as with the
      BSD or MIT licenses.  It may be thought of as a more legalistic
      and thorough version of those two.</para>
    </listitem>
  </varlistentry>

</variablelist>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="pfs-ch-2-sect-2.2">
<title>The GPL</title>

<para>If you don't want your code to be used in proprietary programs,
then use the GNU General Public License (<ulink
url="http://www.gnu.org/licenses/gpl.html"/>).  The GPL is probably
the most widely recognized free software license in the world today.
This is in itself a big advantage, since potential users and
contributors will most likely already be familiar with it, and
therefore won't have to spend extra time to read and understand the
license.</para>

<para>The disadvantage of the GPL is that some programmers do not like
its contagiousness.  When GPL'd code is copied or linked into another
program, that program must, as a whole, be distributed under the GPL
as well.  Thus, the GPL is contagious, and software that incorporates
GPL'd code may end up narrowing the range of possible redistribution
terms.  Whether this is a good or a bad thing depends on who you ask
(I do not feel the GPL's terms are onerous, but I am also sympathetic
to the Free Software Foundation's goals).  In any case, it's fairly
rare for someone who would otherwise work on a project to refuse to do
so because it is under the GPL.  For that matter, it may be that there
are programmers who want reassurance that their contributions will not
be used in non-free products, and who are therefore
<emphasis>more</emphasis> comfortable with the GPL than with other
free licenses.</para>

<remark>This section needs to be expanded to describe how the
narrowing is symmetrical: by _not_ choosing the GPL, one can likewise
restrict.  See <ulink
url="http://www.dwheeler.com/essays/gpl-compatible.html"/>.  Possibly
rewrite default recommendation below to favor one of the BSD-style
licenses, instead of Apache.</remark>

<para>Note that the GPL's viral nature is more significant when your
software is a library instead of a standalone program.  The GPL is not
contagious across high-level invocation boundaries: if a non-GPL'd
program merely invokes a standalone GPL'd program, the former is not
automatically placed under the restrictions of the GPL.  However, if
otherwise non-GPL'd code requires linking against a GPL'd library,
then the distribution of the program as a whole must be under the GPL.
In other words, one cannot write a program which depends on a GPL'd
library and distribute the program as, say, an executable under some
other license, even if one distributes the source code to the GPL'd
library portion.  The entire work, source code and all, must be
distributed under the terms of the GPL.</para>

<para>These restrictions may be acceptable, if your first priority is
ensuring that all derivative works of your work are also free.  Again,
see <xref linkend="pfs-ch-10"/> for a more in-depth discussion of
these issues.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="pfs-ch-2-sect-2.3">
<title>The Artistic License</title>

<para>Finally, there are licenses designed to allow free distribution
while strongly protecting the reputation of the author and the
"artistic integrity" of the work.  The best-known example of this kind
of license the <firstterm>Artistic
License</firstterm><footnote><para>I refuse to comment on the
pun.</para></footnote>, which is the license the
<firstterm>Perl</firstterm> scripting language is distributed under.
A template for the Artistic License is available from <ulink
url="http://opensource.org/licenses/artistic-license.php"/>.  It
allows free redistribution, modification, and all the usual stuff.
But it has some extra clauses requiring anyone who modifies the
software significantly to take steps to clarify that their version is
different from the standard version, by putting notices of
modification in files, and using different names for executables.  It
also has trademark and endorsement protection clauses similar to those
of the Apache license.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="pfs-ch-2-sect-2.4">
<title>Help, I Still Can't Decide Which License to Use...</title>

<para><remark>(todo: have had some discussions lately that lead me to
think BSD might be a better default recommendation below.  Will
update after considering it.)</remark></para>

<para>If you're still not sure what to use, then go with Apache-style
or GNU GPL.  They're both fine licenses, you really can't go wrong,
and the intimidating legal language will give everyone the impression
you thought long and hard about it.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="pfs-ch-2-sect-2.5">
<title>How to Apply a License to Your Software.</title>

<para>Once you've chosen a license, you should state it on the
project's front page.  You don't need to include the actual text of
the license there; just give the name of the license, and make it link
to the full license text on another page.</para>

<para>This tells the public what license you
<emphasis>intend</emphasis> the software to be released under, but
it's not sufficient for legal purposes.  For that, the software itself
must contain the license.  The standard way to do this is to put the
full license text in a file called <filename>COPYING</filename> (or
<filename>LICENSE</filename>), and then put a short notice at the top
of each source file, naming the copyright date, holder, and license,
and saying where to find the full text of the license.</para>

<para>There are many variations on this pattern, so we'll look at just
one example here.  The GNU GPL says to put a notice like this at the
top of each source file:</para>

<screen>
    Copyright (C) &lt;year&gt;  &lt;name of author&gt;

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
</screen>

<para>It does not say specifically that the copy of the license you
received along with the program is in the file
<filename>COPYING</filename>, but that's where it's usually put.  (You
could change the above notice to state that directly.)  This template
also gives a geographical address from which to request a copy of the
license.  Another common method is to give a link to a web page
containing the license.  Just use your judgement and point to wherever
you feel the most permanent copy of the license is maintained, which
might simply be somewhere on your project's web site.  In general, the
notice you put in each source file does not have to look exactly like
the one above, as long as it starts with the same notice of copyright
holder and date, states the name of the license, and makes it clear
where to view the full license.</para>

<para>If you use an Apache-style license, there are special provisions
regarding propagating the contents of a <filename>NOTICE</filename>
file in your distribution.  You could use this file to list
trademarks, attributions, patent notices, and any other information
that needs to be preserved in works derived from your work.  See the
<ulink url="http://www.apache.org/licenses/LICENSE-2.0">Apache
license</ulink> for details about this.</para>

</sect2>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-ch-2-sect-3">
<title>Setting The Tone</title>

<para>So far we've covered one-time project setup issues: picking a
license, arranging the initial website, etc.  But the most important
aspects of starting a new project are dynamic.  Choosing a mailing
list address is easy; ensuring that the list's conversations remain
on-topic and productive is another matter entirely &mdash; it's much
easier to keep a list productive than to make it so.  Or if the
project is being opened up after years of closed, in-house
development, what are the ways in which development processes will
change, and how will you prepare the existing developers for that
change?</para>

<para>The first steps are the hardest, because precedents and
expectations for future conduct have not yet been set.  It might seem
surprising that precedent should matter at all, given that in free
software, developers come and go at random and turnover cannot be
predicted nor controlled.  One might expect precedents to constantly
dissolve under the influx of new developers and new situations that
comes with project growth.  It's tempting to think that, in such
circumstances, the local "culture" would consist mainly of whatever
formal guidelines are posted on the project website, equally
accessible to newcomers and old hands alike &mdash; that stability
would come not from some sort of fuzzy, indefinable collective memory,
but from an unambiguous, canonical text that lays down clear rules for
how the project is run.  Yet in practice, it is the intangible
collective wisdom that dominates.  The written rules usually end up
being a sort of summarization or distillation of a much larger set of
shifting, ever-evolving agreements that really guide the project.  The
written rules do not define the project's culture so much as describe
it, and even then only approximately.</para>

<para>There are a few reasons why things work out this way.  Growth
and high turnover are not as damaging to the accumulation of social
norms as one might think.  As long as change does not happen
<emphasis>too</emphasis> quickly, there is time for new arrivals to
learn how things are done, and after they learn, they will help
reinforce those ways themselves.  Consider how children's songs
survive the centuries.  There are children today singing roughly the
same rhymes as children did hundreds of years ago, even though there
are no children alive now who were alive then.  Younger children hear
the songs sung by older ones, and when they are older, they in turn
will sing them in front of other younger ones.  The children are not
engaging in a conscious program of transmission, of course, but the
reason the songs survive is nonetheless that they are transmitted
regularly and repeatedly.  The time scale of free software projects
may not be measured in centuries (we don't know yet), but the dynamics
of transmission are much the same.  The turnover rate is faster,
however, and must be compensated for by a more active and deliberate
transmission effort.</para>

<para>This effort is aided by the fact that people generally show up
expecting and looking for social norms.  That's just how humans are
built.  In any group unified by a common endeavor, people who join
will instinctively search for behaviors that mark them as part of the
group.  The goal of setting precedents early is to make those
"in-group" behaviors be ones that are useful to the project, for once
established, they will be largely self-perpetuating.</para>

<!-- todo: maybe say this:

     Point out how the sponsor's noble fair-mindedness and balanced
     judgement are not properties that can usefully be written down
     formally, because they wouldn't be believed.  They'd just look
     like propaganda anyway, so there's no point.  This is one of
     those areas where conduct and informal precedent is the *only*
     way to solidify a social norm.  And refer to the relevant parts
     of Chapter 5.
-->

<para>Below are some examples of specific things you can do to set
good precedents.  They're not meant as an exhaustive list, just as
illustrations of the general notion that setting a collaborative mood
early helps a project tremendously.  Physically, every developer may
be working alone in a room by themselves, but you can do a lot to make
them <emphasis>feel</emphasis> like they're all working together in
the same room.  The more they feel this way, the more time they'll
want to spend on the project.  I chose these particular examples
because they came up in the Subversion project (<ulink
url="http://subversion.tigris.org/">http://subversion.tigris.org/</ulink>),
which I participated in and observed from its very beginning.  But
they're not unique to Subversion; situations like these will come up
in most open source projects, and should be seen as opportunities to
start things off on the right foot.</para>

<!-- ======================== subsection ============================== -->
<sect2 id="pfs-ch-2-sect-3.1">
<title>Avoid Private Discussions</title>

<para>Even after you've taken the project public, you and the other
founders will often find yourselves wanting to settle difficult
questions by private communications among an inner circle.  This is
especially true in the early days of the project, when there are so
many important decisions to make, and, usually, few volunteers
qualified to make them.  All the obvious disadvantages of public list
discussions will loom palpably in front of you: the delay inherent in
email conversations, the need to leave sufficient time for consensus
to form, the hassle of dealing with naive volunteers who think they
understand all the issues but actually don't (every project has these;
sometimes they're next year's star contributors, sometimes they stay
naive forever), the person who can't understand why you only want to
solve problem X when it's obviously a subset of larger problem Y, and
so on.  The temptation to make decisions behind closed doors and
present them as <foreignphrase>faits accomplis</foreignphrase>, or at
least as the firm recommendations of a united and influential voting
block, will be great indeed.</para>

<para>Don't do it.</para>

<para>As slow and cumbersome as public discussions can be, they're
always preferable in the long run.  Making important decisions in
private is like spraying contributor repellant on your project.  No
serious volunteer would stick around for long in an environment where
a secret council makes all the big decisions.  Furthemore, public
discussion has beneficial side effects that will last beyond whatever
ephemeral technical question was at issue:

<itemizedlist>
  <listitem>
  <para>The discussion will help train and educate new developers.
        You never know how many eyes are watching the conversation;
        even if most people don't participate, many may be tracking
        silently, gleaning information about the software.</para>
  </listitem>
  <listitem>
  <para>The discussion will train <emphasis>you</emphasis> in the art
        of explaining technical issues to people who are not as
        familiar with the software as you are.  This is a skill that
        requires practice, and you can't get that practice by talking
        to people who already know what you know.</para>
  </listitem>
  <listitem>
  <para>The discussion and its conclusions will be available in public
        archives forever after, enabling future discussions to avoid
        retracing the same steps.  See
        <xref linkend="pfs-ch-5-sect-3"/>.</para>
  </listitem>
</itemizedlist>

</para>

<para>Finally, there is the possibility that someone on the list may
make a real contribution to the conversation, by coming up with an
idea you never anticipated.  It's hard to say how likely this is; it
just depends on the complexity of the code and degree of
specialization required.  But if anecdotal evidence may be permitted,
I would hazard that this is more likely than one would intuitively
expect.  In the Subversion project, we (the founders) believed we
faced a deep and complex set of problems, which we had been thinking
about hard for several months, and we frankly doubted that anyone on
the newly-created mailing list was likely to make a real contribution
to the discussion.  So we took the lazy route and started batting some
technical ideas back and forth in private emails, until an observer of
the project<footnote><para>We haven't gotten to the section on
crediting yet, but just to practice what I'll later preach: the
observer's name was Brian Behlendorf, and it was he who pointed out
the general importance of keeping all discussions public unless there
was a specific need for privacy.</para></footnote> caught wind of what
was happening and asked for the discussion to be moved to the public
list.  Rolling our eyes a bit, we did &mdash; and were stunned by the
number of insightful comments and suggestions that quickly resulted.
In many cases people offered ideas that had never even occurred to us.
It turned out there were some <emphasis>very</emphasis> smart people
on that list; they'd just been waiting for the right bait.  It's true
that the ensuing discussions took longer than they would have if we
had kept the conversation private, but they were so much more
productive that it was well worth the extra time.</para>

<para>Without descending into hand-waving generalizations like "the
group is always smarter than the individual" (we've all met enough
groups to know better), it must be acknowledged that there are certain
activities at which groups excel.  Massive peer review is one of them;
generating large numbers of ideas quickly is another.  The quality of
the ideas will depend on the quality of the thinking that went into
them, of course, but you won't know what kinds of thinkers are out
there until you stimulate them with a challenging problem.</para>

<para>Naturally, there are some discussions that must be had
privately; throughout this book we'll see examples of those.  But the
guiding principle should always be: <emphasis>If there's no reason for
it to be private, then it should be public.</emphasis></para>

<para>Making this happen requires action.  It's not enough merely to
ensure that all your own posts go to the public list.  You also have
to nudge other people's unnecessarily private conversations to the
list too.  If someone tries to start a private discussion, and there's
no reason for it to be private, then it is incumbent on you to open
the appropriate meta-discussion immediately.  Don't even comment on
the original topic until you've either successfully steered the
conversation to a public place, or ascertained that privacy really was
needed.  If you do this consistently, people will catch on pretty
quickly and start to use the public forums by default.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="pfs-ch-2-sect-3.2">
<title>Nip Rudeness in the Bud</title>

<para>From the very start of your project's public existence, you
should maintain a zero-tolerance policy toward rude or insulting
behavior in its forums.  Zero-tolerance does not mean technical
enforcement per se.  You don't have to remove people from the mailing
list when they flame another subscriber, or take away their commit
access because they made derogatory comments.  (In theory, you might
eventually have to resort to such actions, but only after all other
avenues have failed &mdash; which by definition isn't the case at the
start of the project).  Zero-tolerance simply means never letting bad
behavior slide by unnoticed.  For example, when someone posts a
technical comment mixed together with an ad hominem attack on some
other developer in the project, it is imperative that your response
address the ad hominem attack <emphasis>first</emphasis>, as a
separate issue unto itself, and only afterwards move on to the
technical content.</para>

<para>It is unfortunately very easy, and all too typical, for
constructive discussions to lapse into into destructive flame wars.
People will say things in email that they would never say
face-to-face.  The topics of discussion only amplify this effect: in
technical issues, people often feel there is a single right answer to
most questions, and that disagreement with that answer can only be
explained by ignorance or stupidity.  It's a short distance from
calling someone's technical proposal stupid to calling the person
themselves stupid.  In fact, it's often hard to tell where technical
debate leaves off and character attack begins, which is one reason why
drastic responses or punishments are not a good idea.  Instead, when
you think you see it happening, make a post that stresses the
importance of keeping the discussion friendly, without accusing anyone
of being deliberately poisonous.  Such "Nice Police" posts do have an
unfortunate tendency to sound like a kindergarten teacher lecturing a
class on good behavior:</para>

    <blockquote>
      <para><emphasis>First, let's please cut down on the
      (potentially) ad hominem comments, for example, calling J's
      design for the security layer "naive and ignorant of the basic
      principles of computer security".  That may be true or it may
      not, but in either case it's no way to have the discussion.  J
      made his proposal in good faith.  If it has deficiencies, point
      them out, and we'll fix them or get a new design.  I'm sure M
      meant no personal insult to J, but the phrasing was unfortunate,
      and we try to keep things constructive around here.
      </emphasis></para>

      <para><emphasis>Now, on to the proposal.  I think M was right
      in saying that...</emphasis></para>
    </blockquote>

<para>As stilted as such responses sound, they have a noticeable
effect.  If you consistently call out bad behavior, but don't demand
an apology or acknowledgement from the offending party, then you leave
people free to cool down and show their better side by behaving more
decorously next time &mdash; and they will.  One of the secrets of
doing this successfully is to never make the meta-discussion the main
topic.  It should always be an aside, a brief preface to the main
portion of your response.  Point out in passing that "we don't do
things that way around here", but then move on to the real content, so
that you're giving people something on-topic to respond to.  If
someone protests that they didn't deserve your rebuke, simply refuse
to be drawn into an argument about it.  Either don't respond (if you
think they're just letting off steam and don't require a response), or
say you're sorry if you overreacted and that it's hard to detect tonal
nuance in email, then get back to the main topic.  Never, ever insist
on an acknowledgement, whether public or private, from someone that
they behaved inappropriately.  If they choose of their own volition to
post an apology, that's great, but demanding that they do so will only
cause resentment.</para>

<para>The overall goal is to make good etiquette be seen as one of the
"in-group" behaviors.  This helps the project, because developers can
be driven away (even from projects they like and want to support) by
flame wars.  You may not even know that they were driven away; someone
might lurk on the mailing list, see that it takes a thick skin to
participate in the project, and decide against getting involved at
all.  Keeping forums friendly is a long-term survival strategy, and
it's easier to do when the project is still small.  Once it's part of
the culture, you won't find yourself having to promote it
consciously.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="pfs-ch-2-sect-3.3">
<title>Practice Conspicuous Code Review</title>

<para>One of the best ways to foster a productive development
community is to get people looking at each others' code.  Some
infrastructure is required to do this effectively; in particular,
commit emails must be turned on, see <xref linkend="pfs-ch-3-sect-3"/>
for more details.  The effect of commit emails is that every time
someone commits a change to the source code, an email goes out showing
the log message and diffs for the change.  <firstterm>Code
review</firstterm> is the practice of reviewing commit emails as they
come in, looking for bugs and possible improvements.</para>

<para>Code review serves several purposes simultaneously.  It's the
most obvious example of peer-review in the open source world, and
directly helps to maintain software quality.  Every bug that ships in
a piece of software got there by being committed and not detected;
therefore, the more eyes watch commits, the fewer bugs will ship.  But
code review also serves an indirect purpose: it confirms to people
that what they do matters, because one obviously wouldn't take time to
review a commit unless one cared about its effect.  People do their
best work when they know that others will take the time to evaluate
it.</para>

<para>In the Subversion project, we did not at first make a regular
practice of code review.  There was no guarantee that every commit
would be reviewed, though one might sometimes look over a change if
one was particularly interested in that area of the code.  Bugs
slipped in that really could and should have been caught.  A developer
named Greg Stein, who knew the value of code review from past work,
decided that he was going to set an example by reviewing every line of
<emphasis>every single commit</emphasis> that went into the code
repository.  Each commit anyone made was soon followed by a mail to
the developer's list from Greg, dissecting the commit, analyzing
possible problems, occasionally praising a clever bit of code.  Right
away, he was catching bugs and non-optimal coding practices that would
otherwise have slipped by without ever being noticed.  Pointedly, he
never complained about being the only person reviewing every commit,
even though it took a fair amount of his time, but he did sing the
praises of code review whenever he had the chance.  Pretty soon, other
people, myself included, started reviewing commits regularly too.
What was our motivation?  It wasn't that Greg had guilted us into it,
at least not openly.  But he had proven that reviewing code was a
valuable way to spend time, that one could contribute as much to the
project by reviewing others' changes as by writing new code.  Once he
demonstrated that, it became expected behavior, to the point where any
commit that didn't get any reaction would cause the committer to
worry, and even ask on the list whether anyone had had a chance to
review it yet.  Later, Greg got a job that didn't leave him as much
time for Subversion, and had to stop doing regular reviews.  But by
then, it was so ingrained for the rest of us as to seem that it had
been going on since time immemorial.</para>

<para>Start doing reviews from very first commit.  Don't worry that
you won't find any bugs, or that you don't know enough about every
area of the code.  There will be something to say about almost every
commit; even where you don't find anything to question, you may find
something to praise.  The important thing is to make it clear to every
committer that what they do is seen and understood.</para>

</sect2>

<!-- ======================== SECTION ============================== -->
<sect2 id="pfs-ch-2-sect-3.4">
<title>When Opening a Formerly Closed Project, be Sensitive to the
Magnitude of the Change</title>

<para>If you're opening up an existing project, one that already has
active developers accustomed to working in a closed-source
environment, make sure everyone understands that a big change is
coming &mdash; and make sure that you understand how it's going to
feel from their point of view.</para>

<para>Try to imagine how the situation looks to them: formerly, all
code and design decisions were made with a group of other programmers
who knew the software more or less equally well, who all received the
same pressures from the same management, and who all know each others'
strengths and weaknesses.  Now you're asking them to expose their code
to the scrutiny of random strangers, who will form judgements based
only on the code, with no awareness of what business pressures may
have forced certain decisions.  These strangers will ask lots of
questions, questions that jolt the existing developers into realizing
that the documentation they slaved so hard over is
<emphasis>still</emphasis> inadequate (this is inevitable).  To top it
all off, the newcomers are unknown, faceless entities.  If one of your
developers already feels insecure about their skills, imagine how that
will be exacerbated when newcomers point out flaws in code the
developer wrote, and worse, do so in front of the developer's
colleagues.  Unless you have a team of perfect coders, this is
unavoidable &mdash; in fact, it will probably happen to all of them at
first.  This is not because they're bad programmers; it's just that
any program above a certain size has bugs, and peer review will spot
some of those bugs (see <xref linkend="pfs-ch-2-sect-3.3"/>).  At the
same time, the newcomers themselves won't be subject to much peer
review at first, since they can't contribute code until they're more
familiar with the project.  To your developers, it may feel like all
the criticism is incoming, never outgoing.  Thus there is the danger
of a siege mentality taking hold among the old hands.</para>

<para>The best way to prevent this is to warn everyone about what's
coming, explain it, tell them that the initial discomfort is perfectly
normal, and reassure them that it's going to get better.  Some of
these warnings should take place privately, before the project is
opened.  But you may also find it helpful to remind people on the
public lists that this is a new way of development for the project,
and that it will take some time to adjust.  The very best thing you
can do is lead by example.  If you don't see your developers answering
enough newbie questions, then just telling them to answer more isn't
going to help.  They may not have a good sense of what warrants a
response and what doesn't yet, or it could be that they don't have a
feel for how to prioritize coding work against the new burden of
external communications.  The way to get them to participate is to
participate yourself.  Be on the public mailing lists, and make sure
to answer some questions there yourself.  When you don't have the
expertise to field a question, then visibly hand it off to a developer
who does &mdash; and watch to make sure they follow up with an answer,
or at least a response.  It will naturally be tempting for the
longtime developers to lapse into private discussions, since that's
what they're used to.  Make sure you're subscribed to the internal
mailing lists on which this might happen, so you can ask that such
discussions be moved to the public lists right away.</para>

<para>There are other, longer-term concerns with opening up formerly
closed projects.  <xref linkend="pfs-ch-4"/> explores techniques for
mixing paid and unpaid developers successfully, and <xref
linkend="pfs-ch-10"/> discusses the necessity of legal diligence when
opening up a private codebase that may contain software written or
"owned" by other parties.</para>

</sect2>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-ch-2-sect-4">
<title>Announcing</title>

<para>Once the project is presentable &mdash; not perfect, just
presentable &mdash; you're ready to announce it to the world.  This is
actually a very simple process: go to <ulink
url="http://freshmeat.net/"/>, click on
<guimenuitem>Submit</guimenuitem> in the top navigation bar, and fill
out a form announcing your new project.  Freshmeat is the place
everyone watches for new project announcements.  You only have to
catch a few eyes there for news of your project to spread by word of
mouth.</para>

<para>If you know of mailing lists or newsgroups where an announcement
of your project would be on-topic and of interest, then post there,
but be careful to make exactly <emphasis>one</emphasis> post per
forum, and to direct people to the project's own forums for follow-up
discussion (by setting the <systemitem>Reply-to</systemitem> header).
The posts should be short and get right to the point:</para>

<blockquote>
<screen>
To: discuss@lists.example.org
Subject: [ANN] Scanley full-text indexer project
Reply-to: dev@scanley.org

This is a one-time post to announce the creation of the Scanley
project, an open source full-text indexer and search engine with a
rich API, for use by programmers in providing search services for
large collections of text files.  Scanley is now running code, is
under active development, and is looking for both developers and
testers.

Home page: http://www.scanley.org/
   
Features:
   - Searches plain text, HTML, and XML.
   - Word or phrase searching
   - (planned) fuzzy matching
   - (planned) Incremental updating of indexes
   - (planned) Indexing of remote web sites

Requirements:
   - Python 2.2 or higher.
   - Enough disk space to hold the indexes (approximately 2x
     original data size). 

For more information, please come to scanley.org.

Thank you,
-J. Random

</screen>
</blockquote>

<para>There is an ongoing debate in the free software world about
whether it is necessary to begin with running code, or whether a
project can benefit from being opened even during the
design/discussion stage.  I used to think starting with running code
was the most important factor, that it was what separated successful
projects from toys, and that serious developers would only be
attracted to software that did something concrete already.</para>

<para>This turned out not to be the case.  In the Subversion project,
we started with a design document, a core of interested and
well-connected developers, a lot of fanfare, and
<emphasis>no</emphasis> running code at all.  To my complete surprise,
the project acquired active participants right from the beginning, and
by the time we did have something running, there were quite a few
volunteer developers already deeply involved.  Subversion is not the
only example; the Mozilla project was also launched without running
code, and is now a successful and popular web browser.</para>

<para>In the face of such evidence, I have to back away from the
assertion that running code is absolutely necessary for launching a
project.  Running code is still the best foundation for success, and a
good rule of thumb would be to wait until you have it before
announcing your project.  However, there may be circumstances where
announcing earlier makes sense.  I do think that at least a
well-developed design document, or else some sort of code framework,
is necessary &mdash; of course it may be revised based on public
feedback, but there has to be something concrete, something more
tangible than just good intentions, for people to sink their teeth
into.</para>

<para>Whenever you announce, don't expect a horde of volunteers to
join the project immediately afterwards.  Usually, the result of
announcing is that you get a few casual inquiries, a few more people
join your mailing lists, and aside from that everything continues
pretty much as before.  But over time, you will notice a gradual
increase in participation from both new code contributors and users.
Announcement is merely the planting of a seed.  It can take a long
time for the news to spread.  If the project consistently rewards
those who get involved, the news <emphasis>will</emphasis> spread,
though, because people want to share when they've found something
good.  If all goes well, the dynamics of exponential communications
networks will slowly transform the project into a complex community,
where you don't necessarily know everyone's name and can no longer
follow every single conversation.  The next chapters are about working
in that environment.</para>

</sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->

