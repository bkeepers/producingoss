<chapter id="pfs-ch-5">

<title>Money</title>

<simplesect>

<para>Corporate funding of free software development is not a new
phenemenon.  In fact, a lot of development has always been informally
subsidized.  When a system administrator writes a network analysis
tool to help her do her job, then posts it online and gets bug fixes
and feature contributions from other system administrators, what's
happened is that an unofficial consortium has been formed.  The
consortium's funding comes from the sysadmins' salaries, and its
office space and network bandwidth are donated, albeit unknowingly, by
the organizations they work for.  Those organizations benefit from the
investment, of course, although they may not be institutionally aware
of it at first.</para>

<para>The difference today is that many of these efforts are being
formalized.  Corporations have become conscious of the benefits of
open source software, and started involving themselves more directly
in its development.  The arrival of corporate resources implies the
arrival of corporate expectations.  This is not simply a matter of
measuring return on investment.  It is also about management
processes: how can the essentially hierarchical command structures of
corporations and the semi-decentralized volunteer communities of free
software projects work productively with each other?  Will they even
agree on what "productively" means?</para>

<para>Before we go any further, let's be clear what this chapter is
<emphasis>not</emphasis> about: it is not about projects that are
licensed as open source, but run closed-source.  Sometimes a company
will start a free software project, announce it with great fanfare on
<ulink url="http://www.freshmeat.net/">Freshmeat.net</ulink> and all
the right mailing lists, but never really get developer buy-in from
the outside world.  When you check back a year later, all the
committers are still from that same company, and there are no
significant outside voices on the mailing lists.  The project may be
officially open, its code available to the public at large and
forkable by anyone, but in practice it remains an in-house operation.
There is nothing wrong with this, and I would certainly never argue
against having more free code in the world.  But from a management
perspective, it is not much different from a proprietary project.  The
developers are organized hierarchically, working toward a single
vision defined by the company, and not pressured to negotiate with or
react to outside influences (other than market pressures, of course).
The project may <emphasis>be</emphasis> open source, but it is not
<emphasis>doing</emphasis> open source.  This book is about doing open
source, and this chapter is about using money effectively in the
presence of an outside development community.  For the most part, the
recommendations that follow apply equally to for-profit and non-profit
institutions; there are a few issues of particular concern to
for-profits, which will be pointed out as we go.</para>

<para>Financial backing is, in general, welcomed by open source
development communities.  It can reduce the project's vulnerability
the Forces of Chaos, which sweep away so many projects before they
really get off the ground, and therefore can make people more willing
to give the software a chance &mdash; they feel they're investing
their time into something that will still be around six months from
now.  Credibility is contagious, to a point.  When, say, IBM backs
an open source project, people pretty much assume the project won't be
allowed to fail, and their resultant willingness to devote effort to
it can make that a self-fulfilling prophecy.</para>

<para>However, if not handled carefully, money can divide a project
into in-group and out-group developers.  If the unpaid volunteers get
the feeling that design decisions or feature additions are simply
available to the highest bidder, they'll head off to a project that
seems more like a meritocracy and less like unpaid labor for someone
else's benefit.  They may never complain overtly on the mailing lists.
Instead, there will simply be less and less noise from external
sources, as the volunteers gradually stop trying to be taken
seriously.  The buzz of small-scale activity will continue, in the
form of bug reports and occasional small fixes.  But there won't be
any large code contributions or outside participation in design
discussions.  People sense what's expected of them, and live up (or
down) to those expectations.</para>

<para>Although money needs to be used carefully, that doesn't mean it
can't buy influence.  It most certainly can.  The trick is that it
can't buy influence directly.  In a straightforward commercial
transaction, you trade money for what you want.  If you need a feature
added, you sign a contract, pay for it, and it gets done.  In an open
source project, it's not so simple.  You may sign a contract with some
developers, but they'd be fooling themselves &mdash; and you &mdash;
if they guaranteed that the work you paid for would be accepted by the
development community simply because you paid for it.  The work can
only be accepted on its own merits and on how it fits into the
community's vision for the software.  You may have some say in that
vision, but you won't be the only voice.</para>

<para>So you can't purchase influence, but you can purchase things
that <emphasis>lead to</emphasis> influence.  The most obvious example
is programmers.  If you hire good programmers, and they stick around
long enough to get experience with the software and credibility in the
community, then they can influence the project by the same means as
any other member.  They will have a vote, or if there are many of
them, they will have a voting bloc.  If they are respected in the
project, they will have influence beyond just their votes.  There is
no need for paid developers to disguise their motives, either.  After
all, everyone who wants a change made to the software wants it for a
reason.  Your company's reasons are no less legitimate than anyone
else's.  It's just that the weight given to your goals will be
determined by your representatives' status in the project, not by your
company's size, budget, or business plan.</para>

<para>Acquiring influence in a project isn't the only reason to
support it financially (even Machiavelli wasn't always Machiavellian),
and paying programmers isn't the only way to acquire influence.  In
the sections that follow, we'll look at various kinds of corporate
involvement.  But usually the longest-term and stablest investment a
corporation makes is in hiring developers to work on the project, so
we'll examine that first.</para>

<para></para>

</simplesect>

<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-paid-participation">
<title>Paid Participation</title>

<para>The question of how to subsidize developer involvement depends
partly on how free software fits into your company's business model.
There are a number of different reasons to be involved with free
software.  The examples that follow are not mutually exclusive.  In
many cases a company's support of free software will come from
several, or even all, of these motivations:</para>

<variablelist>

   <varlistentry><term>Sharing the burden</term>
     <listitem>
     <para>Separate organizations with related software needs often
     find themselves duplicating effort, redundantly writing similar
     code in-house, or by purchasing similar products from proprietary
     vendors.  When they realize what's going on, the organizations
     can pool their resources and create (or join) an open source
     project tailored to their needs.  The advantages are obvious: the
     costs of development are divided, but the benefits are not.
     Although this scenario seems most intuitive for non-profits, it
     can make strategic sense even for for-profit competitors.</para>
     <para>Examples: <ulink url="http://www.openadapter.org/"/>,
     <ulink url="http://www.koha.org/"/></para>
     </listitem>
   </varlistentry>

   <varlistentry><term>Augmenting services</term>
     <listitem>
     <para>When a company sells services which depend on, or are made
     more attractive by, particular open source programs, it is
     naturally in that company's interests to ensure those programs
     are actively maintained.</para>
     <para>Example: <ulink
     url="http://www.collab.net/">CollabNet's</ulink> support of
     <ulink url="http://subversion.tigris.org/"/> (disclaimer: that's
     my day job, but it's also a perfect example of this model).</para>
     </listitem>
   </varlistentry>

   <varlistentry><term>Supporting hardware sales</term>
     <listitem>
     <para>The value of computers and computer components is directly
     related to the amount of software available for them.  Hardware
     vendors &mdash; not just whole-machine vendors, but also makers
     of peripheral devices and microchips &mdash; have found that
     having high-quality free software to run on their hardware is
     important to customers.</para>
     <para>Examples: <remark>(Have some, but am not sure whether
     they're confidential.  Will ask.)</remark></para>
     </listitem>
   </varlistentry>

   <varlistentry><term>Undermining a competitor</term>
     <listitem>
     <para>Sometimes companies support a particular open source
     project as a means of undermining a competitor's product (which
     may be open source itself, or which may be proprietary).  Eating
     away at a competitor's market share is usually not the sole
     reason for getting involved with an open source project, but it
     can be a factor.</para>
     <para>Example: <ulink url="http://www.openoffice.org/"/> (No,
     this isn't the only reason OpenOffice exists, but it is at least
     partly a response to Microsoft Office.) <remark>(One more example
     would be nice.  Also, I'd like to get second opinions on whether
     OpenOffice really is an example of this phenomenon.  It seems
     clear to me that it is, but of course I've never been told that
     directly by anyone at Sun.)</remark></para> 
     </listitem>
   </varlistentry>

   <varlistentry><term>Marketing</term>
     <listitem>
     <para>Having your company associated with a popular open source
     application can be simply good brand management.</para>
     </listitem>
   </varlistentry>

   <varlistentry><term>Dual-licensing</term>
     <listitem>
     <para><firstterm>Dual-licensing</firstterm> is the practice of
           offering software under a traditional proprietary license
           for customers who want to resell it as part of a
           proprietary application of their own, and simultaneously
           under a free license for those willing to use it under open
           source terms.  (See <xref linkend="pfs-dual-licensing"/>.)
           If the open source developer community is active, the
           software gets the benefits of wide-area debugging and
           development, yet the company still gets a royalty stream to
           support some full-time programmers.</para> 
     <para>The two most well-known examples are <ulink
           url="http://www.mysql.com/">MySQL</ulink>, makers of the
           database software of the same name, and <ulink
           url="http://www.sleepycat.com/">Sleepycat</ulink>, which
           offers distributions and support for the Berkeley Database.
           It's no coincidence that they're both database companies.
           Database software tends to be integrated into applications
           rather than marketed directly to users, so it's very
           well-suited to the dual-licensing model.</para> 
     </listitem>
   </varlistentry>

</variablelist>

<para>Your business model is not the only factor in how you relate to
the open source community, it is not the only one.  There's also your
organization's historical relationship to the project: did you start
it, or are you joining an existing development effort?  In both cases,
you will have to earn credibility, but, not surprisingly, there's a
bit more earning to be done in the latter case.  Your goals will also
influence your involvement.  Are you trying to keep a position of
leadership in the project?  Or are you merely trying to maintain an
influential voice in the community, to guide but not necessarily
govern the project's direction?  Or do you just want to have a couple
of committers around, able to fix bugs for your customers and get the
changes into the public distribution without any fuss?</para>

<para>Keep these questions in mind as you read the guidelines that
follow.  They are meant to apply to any sort of organizational
involvement in a free software project, but every project is a human
environment, and therefore no two are exactly alike.  To some degree,
you will always have to play by ear, but following these principles
will increase the likelihood of things turning out the way you
want.</para>

<!-- ======================== subsection ============================== -->
<sect2 id="pfs-long-term-developers">
<title>Hire for the Long Term</title>

<para>Try to keep programmers on the same project long enough that
they acquire both technical and political expertise there&mdash;a
couple of years, at a minimum.  Of course, no project, whether open or
closed-source, benefits from swapping programmers in and out too
often.  The need for a newcomer to learn the ropes each time would be
a deterrent in any environment.  But the penalty is even stronger in
open source projects, because outgoing developers take with them not
only their knowledge of the code, but also their status in the
community and the human relationships they have made there.</para>

<para>The credibility a developer has garnered cannot be transferred.
To pick the most obvious example, an incoming developer can't inherit
commit access from an outgoing one (see <xref
linkend="pfs-money-vs-love"/> later in this chapter), so if the new
developer doesn't already have commit access, she will have to submit
patches until she does.  Commit access is only the most measurable
manifestation of lost influence.  A long-time developer also knows all
the old arguments that have been hashed and rehashed on the discussion
lists&mdash;a new developer, having no memory of those conversations,
may try to raise the topics again, leading to a loss of credibility
for with your organization ("Can't they remember anything?").  A new
developer will have no political feel for the project's personalities,
and will not be able to influence development directions as quickly or
as smoothly as one who's been around a long time.</para>

<para>When you do bring in new people, use a program of supervised
engagement.  The new developer should be in direct contact with the
public development community from the very first day, starting off
with bugfixes and cleanup tasks, so she can learn the codebase and
acquire a reputation in the community, yet not spark any long and
involved design discussions.  All the while, one or more experienced
developers should be available for questioning, and should be reading
every post the newcomer makes to the development lists, even if
they're in threads that the experienced developers normally wouldn't
pay attention to.  This will help the group spot potential rocks
before the newcomer runs aground.</para>

<para>For example, when CollabNet hires a new developer to work on
Subversion, we sit down together and pick some open bugs for the new
person to cut their teeth on.  We'll discuss the technical outlines of
the solutions, and then assign at least one experienced developer to
(publically) review the patch that the new developer will (also
publically) post.  We typically don't even look at the patch before
the main development list sees it, although we could if there were
some reason to.  The important thing is that the new developer go
through the process of public review, learning the codebase while
simultaneously becoming accumstomed to receiving critiques from
complete strangers.  But we try to coordinate the timing so that our
own review comes immediately after the posting of the patch.  That way
the first review the list sees is ours, which can help set the tone
for the others' reviews.  It also contributes to the idea that this
new person is to be taken seriously: if others see that we're putting
in the time to give detailed reviews, with thorough explanations and
references into the archives where appropriate, they'll appreciate
that a form of training is going on, and that it probably signifies a
long-term investment.  This can make them more positively disposed
toward that developer, at least to the degree of spending a little
extra time answering questions and reviewing patches.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="pfs-appear-as-many">
<title>Appear as Many, Not as One</title>

<para>Your developers should strive to appear in the project's public
forums as individual participants, rather than as a monolithic
corporate presence.  This is not because there is some negative
connotation inherent in monolithic corporate presences (well, perhaps
there is, but that's not what this book is about).  Rather, it's
because individuals are the only sort of entity open source projects
are structurally equipped to deal with.  An individual contributor can
have discussions, submit patches, acquire credibility, vote, and so
forth.  A company cannot.</para>

<para>Furthermore, by behaving in a decentralized manner, you avoid
stimulating centralization of opposition.  Let your developers
disagree with each other on the mailing lists.  Encourage them to
review each other's code as often, and as publically, as they would
anyone else's.  Discourage them from always voting as a bloc, because
if they do, others may start to feel that, just on general principles,
there should be an organized effort to keep them in check.</para>

<para>There's a difference between actually being decentralized and
simply striving to appear that way.  Under certain circumstances,
having your developers behave in concert can be quite useful, and they
should be prepared to coordinate behind the scenes when necessary.
For example, when making a proposal that is likely to be mildly
controversial (but not truly divisive), having several people chime in
with agreement early on can usually help it along, by giving the
impression of a growing consensus.  Others will feel that the proposal
has momentum, and that if they were to object they'd be stopping that
momentum.  This won't prevent someone who is truly uncomfortable from
objecting (and, needless to say, any objections should be listened
to).  But it is enough to inhibit the sort of people who like to
object just to stay in shape; see <xref
linkend="pfs-bikesheds"/> for more about them.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="pfs-open-motives">
<title>Be Open About Your Motivations</title>

<para>Be as open about your organization's goals as you can be without
compromising business secrets.  If you want the project to acquire a
certain feature because, say, your customers have been clamoring for
it, just say so outright on the mailing lists.  If the customers wish
to remain anonymous, as is sometimes the case, then at least ask them
if they can be used as unnamed examples.  The more the public
development community knows about <emphasis>why</emphasis> you want
what you want, the more comfortable they'll be with whatever you're
proposing.</para>

<para>This runs counter to the instinct &mdash; so easy to acquire, so
hard to shake off &mdash; that knowledge is power, and that the more
others know about your goals, the more control they have over you.
But that instinct would be wrong here.  By publically advocating the
feature (or bugfix, or whatever it is), you have
<emphasis>already</emphasis> laid your cards on the table.  The only
question now is whether you will succeed in guiding the community to
share your goal.  If you merely state that you want it, but can't
provide concrete examples of why, your argument is weak.  But if you
give just a few real-world scenarios showing why the proposed feature
is important, that can have a dramatic effect on the debate.</para>

<para>To see why this is so, consider the alternative.  Too
frequently, debates about new features or new directions are long and
tiresome.  The arguments people advance often reduce to "I personally
want X," or the ever-popular "In my years of experience as a software
designer, X is extremely important to users / a useless frill that
will please no one."  Predictably, the absence of real-world usage
data neither shortens nor tempers such debates, but instead allows
them to drift farther and farther from any mooring in actual user
experience.  Without some countervailing force, the end result is as
likely as not to be determined by whoever was the most articulate, or
the most persistent, or the most senior.</para>

<para>As an organization with plentiful customer data available, you
have the opportunity to provide just such a countervailing force.  You
can be a conduit for information that might otherwise have no means of
reaching the development community.  The fact that that information
supports your desires is nothing to be embarrassed about.  Most
developers don't individually have very broad experience with how the
software they write is used.  Each developer uses the software in
their own idiosyncratic way; as far as other usage patterns go,
they're relying on intuition and guesswork, and deep down, they know
this.  By providing credible data about a significant number of users,
you are giving the public development community something akin to
oxygen.  As long as you present it right, they will welcome it
enthusiastically, and it will propel things in the direction you want
to go.</para>

<para>The key, of course, is presenting it right.  It will never do to
insist that simply because you deal with a large number of users, and
because they need (or think they need) a given feature, that therefore
your solution ought to be implemented.  Instead, you should focus your
initial posts on the problem, rather than on one particular solution.
Describe in great detail the experiences your customers are
encountering, offer as much analysis as you have available, and as
many reasonable solutions as you can think of.  When people start
speculating about the effectiveness of various solutions, you can
continue to draw on your data to support or refute what they say.  You
may have one particular solution in mind all along, but don't single
it out for special consideration at first.  This is not deception, it
is simply standard "honest broker" behavior.  After all, your true
goal is to solve the problem; a solution is merely a means to that
end.  If the solution you prefer really is superior, other developers
will recognize that on their own eventually &mdash; and then they will
get behind it of their own free will, which is much better than you
browbeating them into implementing it.  (There is also the possibility
that they will think of a better solution.)</para>

<para>This is not to say that you can't ever come out in favor of a
specific solution.  But you must have the patience to see the analysis
you've already done internally repeated on the public development
lists.  Don't post saying "Yes, we've been over all that here, but it
doesn't work for reasons A, B, and C.  When you get right down to it,
the only way to solve this is...".  The problem is not so much that it
sounds arrogant as that it gives the impression that you have
<emphasis>already</emphasis> devoted some unknown (but, people will
presume, large) amount of analytical resources to the problem, behind
closed doors.  It makes it seem as though efforts have been going on,
and perhaps decisions made, that the public is not privy to, and is
therefore a recipe for resentment.</para>

<para>Naturally, <emphasis>you</emphasis> know how much effort you've
devoted to the problem internally, and that knowledge is, in a way, a
disadvantage.  It puts your developers in a slightly different mental
space than everyone else on the mailing lists, reducing their ability
to see things from the point of view of those who haven't yet thought
about the problem as much.  The earlier you can get everyone else
thinking about things in the same terms as you do, the smaller this
distancing effect will be.  This logic applies not only to individual
technical situations, but to the broader mandate of making your goals
as clear as you can.  The unknown is always more destabilizing than
the known.  If people understand why you want what you want, they'll
feel comfortable talking to you even when they disagree.  If they
can't figure out what makes you tick, they'll assume the worst, at
least some of the time.</para>

<para>You won't be able to publicize everything, of course, and people
won't expect you to.  All organizations have secrets; perhaps
for-profits have more of them, but non-profits have them too.  If you
must advocate a certain course, but can't reveal anything about why,
then simply offer the best arguments you can under that handicap, and
accept the fact that you may not have as much influence as you want in
the discussion.  This is one of the compromises you make in order to
have a development community not on your payroll.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="pfs-goldfish-bowl">
<title>Remember That You Are Being Watched</title>

<para>Audit all claims carefully before making them, and give the
public the means to check your claims on their own.  Independent
fact-checking is a major part of open source, and it applies to more
than just the code.</para>

<para>Naturally no one would advise companies to make unverifiable
claims.  But with open source activities, there are unusually many
people with the expertise to verify claims &mdash; people who are also
likely to have high-bandwidth internet access and the right social
contacts to publicize their findings in a damaging way, should they
choose to.  When Global Megacorp Chemical Industries pollutes a
stream, that's verifiable, but only by trained scientists, who can
then be refuted by Global Megacorp's scientists, leaving the public
scratching their heads and wondering what to think.  On the other
hand, your behavior in the open source world is not only visible and
recorded, it is easy for many people to check it independently, and
easy for them to spread their conclusions by word of mouth.  These
communications networks are already in place; they are the essence of
how open source operates, and they can be used to transmit any sort of
information.  Refutation is usually difficult if not impossible,
especially when what people are saying is true.</para>

<para>For example, it's okay to refer to your organization as having
"founded project X" if you really did.  But don't refer to yourself as
the "makers of X" if most of the code was written by outsiders.
Conversely, don't claim to have a deeply involved volunteer developer
community if anyone can look at your repository and see that there are
few or no code changes coming from outside your organization.</para>

<para>Not too long ago, I saw an announcement by a very well-known
computer company, stating that they were releasing an important
software package under an open source license.  When the initial
announcement came out, I took a look at their now-public version
control repository and saw that it contained only 3 revisions.  In
other words, they had done an initial import of the source code, but
hardly anything had happened since then.  That in itself was not
worrying &mdash; they'd just made the announcement, after all, there
was no reason to expect a lot of development activity right
away.</para>

<para>Some time later, they made another announcement.  Here is what
it said, with the name and release number replaced by pseudonyms:</para>

  <blockquote>
    <para><emphasis>We are pleased to announce that following
    rigorous testing by the Singer Community, Singer&nbsp;5 for Linux
    and Windows are now ready for production use.</emphasis></para>
  </blockquote>

<para>Curious to know what the community had uncovered in "rigorous
testing", I went back to the repository to look at its recent change
history.  The project was still on revision 3.  Apparently, they
hadn't found a <emphasis>single</emphasis> bug worth fixing before the
release!  Thinking that the results of the community testing must have
been recorded elsewhere, I next examined the bug tracker.  There were
exactly 6 open issues, 4 of which had been open for several months
already.</para>

<para>This beggars belief, of course.  When a community pounds on a
large and complex piece of software for any length of time, they will
find bugs.  Even if the fixes for those bugs don't make it into the
upcoming release, one would still expect some version control activity
as a result of the testing process, or at least some new issues.  Yet
to all appearances, nothing had happened between the announcement of
the open source license and the first open source release.</para>

<para>The point is not that the company was lying about the community
testing.  I have no idea if they were or not.  But they were oblivious
to how much it <emphasis>looked</emphasis> like they were lying.
Since neither the version control repository nor the issue tracker
gave any indication that the alleged rigorous testing had occurred,
the company should either not have made the claim in the first place,
or provided a clear link to some tangible result of that testing ("we
found 278 bugs, click here for details").  The latter would have
allowed anyone to get a handle on the level of community activity very
quickly.  As it was, it only took me a few minutes to determine that
whatever this community testing was, it had not left traces in any of
the usual places.  That's not a lot of effort, and I'm sure I'm not
the only one took the trouble.</para>

<para>Transparency and verifiability are also an important part of
accurate crediting, and of the sorts of marketing strategies that
succeed in getting attention from both users and developers.  See
<xref linkend="pfs-ch-9"/> and <xref linkend="pfs-marketing"/> for
more on these topics.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="pfs-money-vs-love">
<title>Money Can't Buy You Love</title>

<para>If you're paying some of the developers on a project, then set
guidelines early on about what the money can and cannot buy.  This
does not mean you need to post twice a day to the mailing lists
reiterating your noble and incorruptible nature.  It merely means that
you should be on the lookout for opportunities to defuse the tensions
that <emphasis>could</emphasis> be created by money.  You don't need
to start out assuming that the tensions are there; you do need to
demonstrate an awareness that they have the potential to arise.</para>

<para>A perfect example of this came up in the Subversion project.
Subversion was started in 2000 by <ulink
url="http://www.collab.net/">CollabNet</ulink>, which has been the
project's primary funder since its inception, paying the salaries of
several developers (disclaimer: I'm one of them).  Soon after the
project began, we hired another developer, Mike Pilato, to join the
effort.  By then, coding had already started.  Although Subversion was
still very much in the early stages, it already had a development
community, with set of basic ground rules.</para>

<para>Mike's arrival raised an interesting question.  Subversion
already had a policy about how a new developer gets commit access.
First, he submits some patches to the development mailing list.  After
enough patches have gone by for the other committers to see that the
new contributor knows what he's doing, someone proposes that he just
commit directly (the proposal is private, as described in <xref
linkend="pfs-committers"/>).  Assuming the committers agree, one of
them mails the new developer and offers him direct commit access to
the project's repository.</para>

<para>CollabNet had hired Mike specifically to work on Subversion.
Among those who already knew him, there was no doubt about his coding
skills or his readiness to work on the project.  Furthermore, the
volunteer developers had a very good relationship with the CollabNet
employees, and most likely would not have objected if we'd just given
Mike commit access the day he was hired.  But we knew we'd be setting
a precedent.  If we granted Mike commit access by fiat, we'd be saying
that CollabNet had the right to ignore project guidelines, simply
because it was the primary funder.  While the damage from this would
not necessarily be immediately apparent, it would gradually result in
the non-salaried developers feeling disenfranchised.  Other people
have to earn their commit access &mdash; CollabNet just buys
it.</para>

<para>So Mike agreed to start out his employment at CollabNet like any
other volunteer developer, without commit access.  He sent patches to
the public mailing list, where they could be, and were, reviewed by
everyone.  We also said on the list that we were doing things this way
deliberately, so there could be no missing the point.  After a while,
someone (I can't remember if it was a CollabNet developer or not)
proposed Mike for commit access, and he was accepted, as everyone knew
he would be.</para>

<para>That kind of consistency gets you a credibility that money could
never buy.  And credibility is a valuable currency to have in
technical discussions: it's immunization against having ones motives
questioned later.  In the heat of argument, people will sometimes look
for non-technical ways to win the battle.  The project's primary
funder, because of its deep involvement and obvious concern over the
directions the project takes, presents a wider target than most.  By
being scrupulous to observe all project guidelines right from the
start, the funder makes itself the same size as everyone else.</para>

<para>A similar story about commit access appears in Danese Cooper's
blog at <ulink
url="http://blogs.sun.com/roller/page/DaneseCooper/20040916"/>.
Cooper is Sun Microsystem's "Open Source Diva"&mdash;I think that's
her official title&mdash;and in the blog entry, she describes how the
Tomcat development community got Sun to hold its own engineers to the
same commit-access standards as everyone else.</para>

<para>The necessity for the funders to play by the same rules as
everyone else means that the Benevolent Dictatorship governance model
(see <xref linkend="pfs-benevolant-dictator"/>) is slightly harder to
pull off in the presence of funding, particular if the dictator works
for the primary funder.  Since a dictatorship has few rules, it is
hard for the funder to prove that it's abiding by community standards,
even when it is.  It's certainly not impossible, it just requires a
project leader who is able to see things from the point of view of the
outside developers as well as of his employers, and act accordingly.
Even then, it's probably a good idea to have a proposal for
non-dictatorial governance sitting in your back pocket, ready to be
brought out the moment there are any indications of widespread
dissatisfaction in the community.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="pfs-contracting">
<title>Contracting</title>

<para>Contracted work needs to be handled carefully in free software
projects.  Ideally, you want a contractor's work to be accepted by the
community and folded into the main public distribution.  In theory, it
wouldn't matter who the contractor is, as long as his work is good and
meets the project's guidelines.  Theory and practice can sometimes
match, too: a complete stranger who shows up with a good patch
<emphasis>will</emphasis> generally be able to get it into the
software.  The trouble is, it's very hard to produce a good patch, at
least for a non-trivial enhancement or new feature, without first
discussing it with the rest of the project, and the duration of that
discussion cannot be precisely predicted.  Thus, if the contractor is
paid by the hour, you may end up paying more than you wanted; if he is
paid a flat sum, he may end up doing more work than he can
afford.</para>

<para>There are two ways around this: the good way, and the
not-so-good way.  The good way is to make the best guess you can about
the length of the discussion process, based on past experience, add in
some padding for error, and base the contract on that.  It also helps
to divide the problem into as many small, independent chunks as
possible, to increase the predictability of each chunk.  The
not-so-good way is to contract solely for delivery of a patch, and
treat the patch's acceptance into the public project as a separate
matter.  Then it becomes much easier to write the contract, but you're
stuck with the burden of maintaining a private patch for as long as
you depend on the software, or at least for as long as it takes you to
get that patch or equivalent functionality into the mainline.  Of
course, even with the good way, the contract itself cannot require
that the patch be committed into the repository, because that would
involve selling something that's not for sale.  (What if the rest of
the project unexpectedly decides not to support the feature?)
However, the contract can require a <foreignphrase>bona
fide</foreignphrase> effort to get the change accepted by the
community, and that it be committed to the repository if the community
agrees with it.  For example, if the project has written standards
regardig code changes, the contract can reference those standards and
specify that the work must meet them.  In practice, this usually works
out the way everyone hopes.</para>

<para>The best tactic for successful contracting is to hire one of the
project's developers&mdash;preferably a committer&mdash;as the
contractor.  This may seem like a form of purchasing influence, and,
well, it is.  It's not as corrupt as it might seem, though.  A
developer's influence in the project is due mainly to the quality of
his code and to his interactions with other developers.  The fact that
he has a contract to get certain things done doesn't raise his status
in any way, and doesn't lower it either, though it may make people
scrutinize him more carefully.  No developer would risk his long-term
position in the project by backing an inappropriate or widely-disliked
new feature.  In fact, part of what you get, or should get, when you
hire such a contractor is advice about what sorts of changes are
likely to be accepted by the community.  You also get a slight shift
in the project's priorities.  Because prioritization is just a matter
of who has time to work on what, by paying for someone's time, you
cause their work to move up in the priority queue.  This is a
well-understood fact of life in open source projects, so at least some
of the other developers will often be willing to devote attention to
the contractor's work&mdash;if not by helping to write the code
themselves, then at least by discussing the design and reviewing the
code, both of which can be very helpful.  For all these reasons, the
contractor is best drawn from the ranks of those already involved with
the project.</para>

<para>This immediately raises two questions: Should contracts ever be
private?  And when they're not, should you worry about creating
tensions in the community by the fact that you've contracted with some
developers and not others?</para>

<para>It's best to be open about contracts, when you can.  Otherwise,
the contractor's behavior may seem strange to others in the
community&mdash;perhaps he's suddenly giving inexplicably high
priority to features he's never shown interest in in the past.  When
people ask him why he wants them now, how can he answer convincingly,
if he can't talk about the fact that he's been contracted to write
them?</para>

<para>At the same time, neither you nor the contractor should make a
big deal of your arrangement.  Don't issue a press release or make a
prominent announcement of the contract on the mailing lists.  Such
actions would signal to the rest of the project that you regard the
fact of the contract&mdash;as opposed to the code
<emphasis>resulting</emphasis> from the contract&mdash;to be the
important thing.  At all times, the focus of attention should be kept
on the code and on technical issues, not on the details of who is
paying whom.  For example, one of the developers in the Subversion
community handles contracting in a particularly graceful way.  While
discussing his code changes in IRC, he'll mention as an aside (often
in a private remark, an IRC <firstterm>privmsg</firstterm>, to one of
the other committers) that he's being paid for his work on this
particular bug or feature.  But he also consistently gives the
impression that he'd want to be working on that change anyway, and
that he's happy the money is making it possible for him to do that.
He may or may not reveal his customer's identity, but in any case he
doesn't dwell on the contract.  His remarks are just an ornament to an
otherise technical discussion about how to get something done.</para>

<para>That example shows another reason why it's good to be open about
contracts.  There may be multiple organizations sponsoring contracts
on a given open source project, and if each knows what the others are
trying to do, they may be able to pool their resources.  In the above
case, the project's largest funder (CollabNet) is not involved in any
way with these piecework contracts, but knowing that someone else is
sponsoring certain bug fixes allows CollabNet to redirect its
resources to other bugs, resulting in greater efficiency for the
project as a whole.</para>

<para>In general, those who are not hired will not resent those who
are, particularly when the latter are established, well-respected
members of the community anyway.  No one expects contract work to be
distributed equally among all the committers.  People understand the
importance of long-term relationships.  The uncertainties involved in
contracting are such that once you find someone you can work reliably
with, you would be reluctant to switch to a different person just for
the sake of evenhandedness.  Thus, the first time you hire, there will
be no complaints, because clearly you had to pick
<emphasis>someone</emphasis>&mdash;it's not your fault it's a zero-sum
game.  Later, when you hire the same person a second time, it's just
common sense: you already know them, the last time was successful, so
why take unnecessary risks?  Thus, it's perfectly natural to have one
or two go-to people in the community, instead of spreading the work
around evenly.</para>

<sect3 id="pfs-community-review-acceptance">
<title>Review and Acceptance of Changes</title>

<para>The community is still important to the success of contract
work, however.  Their involvement in the design and review process for
sizeable changes cannot be an afterthought.  It must be considered
part of the work, and fully embraced by the contractor.  Don't think
of community scrutiny as an obstacle to be overcome, think of it as a
free design board and QA department.  It is a benefit to be
aggressively pursued, not merely endured.</para>

<sect4 id="pfs-cvs-pserver">
<title>Case study: the CVS password-authentication protocol</title>

<para>In 1995, I was one half of a partnership that provided support
and enhancements for CVS (the Concurrent Versions System, see <ulink
url="http://www.cvshome.org/"/>).  My partner Jim and I were,
informally, the maintainers of CVS by that point.  But we'd never
thought carefully about how we ought to relate to the existing, mostly
volunteer CVS development community.  We just assumed that they'd send
in patches, and we'd apply them, and that was pretty much how it
worked.</para>

<para>Back then, client/server CVS could only be done over a remote
login program such as <literal>rsh</literal>.  Using the same password
for CVS access as for login access was an obvious security risk, and
many organizations were put off by it.  A major investment bank hired
us to add a new authentication mechanism, so they could safely use
client/server CVS with their remote offices.</para>

<para>Jim and I took the contract and sat down to design the new
authentication system.  What we came up with was pretty simple (the
United States had export controls on cryptographic code at the time,
so the customer understood that we couldn't implement the
authentication we wanted), but as we were not experienced in designing
such protocols, we still made a few gaffes that would have been
obvious to an expert.  These mistakes would easily have been caught
had we taken the time to write up a proposal and run it by the other
developers for review.  But we never did so, because it didn't occur
to us to think of the development list as a resource to be used.  We
knew that people were probably going to accept whatever we committed,
and&mdash;because we didn't know what we didn't know&mdash;we didn't
bother to do the work in a visible way, e.g., posting patches
frequently, making small, easily-digestible commits to a special
branch, etc.  The resulting authentication protocol was not very good,
and of course once it became established, it was difficult to improve,
because of compatibility concerns.</para>

<para>The root of the problem was not our lack of experience; we could
easily have learned what we needed to know.  The problem was our
attitude toward the volunteer development community.  We regarded
acceptance of the changes mainly as a requirement to be met, rather
than as a process by which the quality of the changes could be
improved.  Since we were confident that they would be accepted (as
they were), we made little effort to get others involved.</para>

</sect4>

<para>Obviously, when you're choosing a contractor, you want someone
with the right technical skills and experience for the job.  But it's
also important to choose someone with a track record of constructive
interaction with the other developers in the community.  That way
you're getting more than just a single person; you're getting an agent
who will be able to draw on a network of expertise to make sure the
work is done in a robust and maintainable way.</para>

</sect3>

<!-- 
<para><remark>Contractors as the route to expansion of services and
support.  Businesses who are deeply involved in the development of an
open source program, and who also sell support and customization
services, are in a resource bind.  The more their business grows, the
more strain they are under, trying to stay involved in the open
source side while using those same developers for in-house work.
Contracting with volunteer developers is one way out of this bind,
but it has to managed carefully (and openly, as far as
possible).</remark></para>
-->

</sect2>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-funding-non-dev">
<title>Funding Non-Development Activities</title>

<para>There are certain aspects of software development that open
source volunteers tend not to get around to.  The volunteers who get
involved with projects are usually programmers, and their primary
interests are writing code and debugging.  If your goal is just to
help a project succeed, one of the best ways is to fund activities
that are typically be neglected the volunteer community.</para>

The general idea is to use funding to make things happen that
otherwise <emphasis>wouldn't</emphasis> happen in open source
development.  Useability testing, QA, thorough documentation, etc.

<para><remark>todo: working here</remark></para>

<screen>
   - Presentation
   - QA / PSR testing
   - Useability studies
   - Documentation
   - Marketing / Publicity
   - Legal advice, protection
   - What else?
</screen>

Open source programs are widely alleged to have poor user
interfaces (although I think this is often a canard &mdash; what they
have are <emphasis>different</emphasis> user interfaces

<para><remark>The key with all of these is to integrate them into the
development community, by using a little preparation.  Use your
salaried developers as a liason.  Don't just have the marketing
department send out papers, get them fact-checked and also
*politics*-checked first.  Make sure the QA people know how to use the
project's public bug tracker, and make sure the community sees that
these resources are being devoted to the project.)</remark></para>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-ownership">
<title>Ownership</title>

<para><remark>Briefly discuss the thorny issue of copyright
assignment.  It may be important, if the code ever needs to be
defended legally against a copyright infringement or other suit.
Copyright assignment can actually protect the contributors, by making
them not be targets.</remark></para>

<para><remark>(Talk about seniority and its relationship to having
started a project vs not having started it.  CVS/Cyclic is a good
example here.)</remark></para>

<para><remark>(Re dual-licensing: Dual-licensing situations get
started for a number of reasons.  The code may have started out free,
and a permanent proprietary fork may simply not be in the cards (too
much negative publicity, too much momentum in the existing dev
community, whatever).  But also, let's not forget the "Where do you
want to spend your time?" factor.  Sometimes, people start these
companies because they just plain like doing open source development,
and don't want to give it up.  Discuss how all this affects ownership
both legal and psychological.)</remark></para>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-marketing">
<title>Marketing</title>

<para><remark>In a word: if you've got it, spend it.  For the sake of
keeping the volunteer developer community on your side, it is
<emphasis>very</emphasis> important not to say anything that isn't
demonstrably true.  Also, don't bash competing products (especially if
those products are open source, because it might turn out that some of
your developers work on them, or know people who do).  But do devote
resources to press releases, professional web site design,
advertisements in industry trade magazines.  The oft-remarked-on rift
between marketers and programmers is overstated.</remark></para>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-donations">
<title>Donations</title>

<para><remark>Is there anything to say about this?  Well, maybe one
thing: make some plans for how the money will be used
<emphasis>before</emphasis> it comes in.  Otherwise, perfectly
avoidable arguments can happen.</remark></para>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-patents">
<title>Patents</title>

<para><remark>Patents are a lightning rod issue.  If you collect them,
make it clear that it's for defensive purposes, and never enforce them
on open source projects.  (This is not only the right thing to do, but
it's also good open source public relations.)  Don't go off the deep
end ranting about the coming patent war (or put it in a footnote or an
appendix if you do), but point out that opposition to software patents
is almost universal among open source developers.  Talk about the
boomerang licenses.</remark></para>

<para><remark>(Don't forget to cross-reference to <xref
linkend="pfs-patents-legal"/>.)</remark></para>

</sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
