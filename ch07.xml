<chapter id="pfs-ch-7">

<title>Packaging, Releasing, and Daily Development <!-- [ 15-25 pp] --> </title>

<simplesect>

<para>This chapter is about how free software projects package and
release their software, and how overall development patterns organize
around those goals.</para>

<para>A major difference between open source projects and proprietary
ones is the lack of centralized control over the development team.
When a new release is being prepared, this difference is especially
stark: a corporation can ask its entire development team to focus on
an upcoming release, putting aside new feature development and
non-critical bug-fixing until the release is done.  Volunteer groups
are less monolithic.  People work on the project for all sorts of
reasons, and those not interested in helping with a given release
still need to be able to do regular development work while the release
is going on.  Because of this decoupling, open source release
processes tend to take longer, but be less disruptive, than commercial
release processes.  It's a bit like highway repair.  There are two
ways to fix a road: you can shut it down completely, so that a repair
crew can swarm all over it at full capacity until the problem is
solved, or you work on a couple of lanes at a time, while leaving the
others open to traffic.  The first way is very efficient <emphasis>for
the repair crew</emphasis>, but not for anyone else&mdash;the road is
entirely shut down until the job is done.  The second way involves
much more time and trouble for the repair crew (now they have to work
with fewer people and less equipment, in cramped conditions, with
flaggers to slow and direct traffic, etc), but at least the road
remains useable, even if not at full capacity.</para>

<para>Open source projects tend to work the second way.  In fact, for
a mature piece of software with several different release lines being
maintained simultaneously, the project is sort of in a permanent state
of minor road repair.  There are always a couple of lanes closed; a
consistent but low level of background inconvenience is always being
tolerated by the development group as a whole, so that releases get
made on a regular schedule.</para>

<para>The model that makes this possible generalizes to more than just
releases, actually.  It's the principle of parallelizing tasks that
are not mutually interdependent&mdash;a principle that is by no means
unique to open source development, of course, but one which open
source projects implement in their own particular way.  They cannot
afford to annoy either the roadwork crew or the regular traffic too
much, but they also cannot afford to have people dedicated to standing
by the orange cones and flagging traffic along.  Thus they gravitate
toward processes that have flat, constant levels of administrative
overhead, rather than peaks and valleys of inconvenience.  Volunteers
are willing to work with consistent, low-level overhead; that
predictability allows them to come and go without worrying about
whether their schedule will clash with what's happening in the
project.  But if the project were to have a master schedule in which
some activities excluded other activities, the result would be a lot
of developers sitting idle a lot of the time&mdash;which would be not
only inefficient, but boring, and therefore dangerous, in that a bored
developer is likely to soon be a ex-developer.</para>

<para>Release work is usually the most noticeable, and important, task
that happens in parallel with development, so the methods described in
the following sections are geared mostly toward enabling releases.
However, note that they also apply to other parallelizable tasks, such
as translations and internationalization
(<firstterm>i18n</firstterm>), broad API changes made gradually across
the entire code base, etc.</para>

</simplesect>

<!-- ========================== SECTION =========================== -->

<sect1 id="pfs-release-numbering">
<title>Release Numbering</title>

<para>Before we talk about how to make a release, let's look at how to
name releases, which means examining what releases actually mean to
users.  A release means that:</para>

<itemizedlist>

  <listitem><para>Old bugs have been fixed.  This is probably the one
            thing users can count on being true of every release.</para>
  </listitem>

  <listitem><para>New bugs have been added.  This too can usually
            be counted on, except sometimes in the case of security
            releases or other one-offs (see
            <xref linkend="pfs-security-releases"/>).</para>
  </listitem>

  <listitem><para>New features may have been added.</para>
  </listitem>

  <listitem><para>New configuration options may have been addded, or
            the meanings of old options may have changed subtly.  The
            installation procedures may have changed slightly since
            the last release too, though one always hopes not.</para>
  </listitem>

  <listitem><para>Incompatible changes may have been introduced, such
            that the data formats used by older versions of the
            software are no longer useable without undergoing some
            sort of (possibly manual) one-way conversion step.</para>
  </listitem>

</itemizedlist>

<para>As you can see, not all of these are good things.  This is why
experienced users approach new releases with some trepidation,
especially when the software is mature and was already mostly doing
what they wanted (or thought they wanted).  Even the arrival of new
features is not an unmixed blessing: it may mean the software will now
behave in unexpected ways.</para>

<para>The purpose of release numbering, therefore, is twofold:
obviously the numbers should unambiguously communicate the ordering of
releases (i.e., by looking at any two releases' numbers, one can know
which came later), but also they should indicate as compactly as
possible the degree and <emphasis>kind</emphasis> of changes in the
release.</para>

<para>All that in a number?  Well, more or less, yes.  Release
numbering strategies are one of the oldest bikeshed discussions around
(see <xref linkend="pfs-bikeshed"/>), and the world is unlikely to
settle on a single, complete standard anytime soon.  However, a few
good strategies have emerged, along with one universally agreed-on
principle: <emphasis>be consistent</emphasis>.  Pick a numbering
scheme, document it, and stick with it.  Your users will thank
you.</para>

<!-- ========================== subsection =========================== -->
<sect2 id="pfs-release-number-components">
<title>Release Number Components</title>

<para>Release numbers are digits separated by dots:</para>

<informalexample>
<literallayout>Scanley 2.3
Singer 5.11.4</literallayout>
</informalexample>

<para>...and so on.  The dots are <emphasis>not</emphasis> decimal
points, they are merely separators; "5.3.9" would be followed by
"5.3.10".  A few projects have occasionally hinted otherwise, most
famously the Linux kernel with its "0.95", "0.96"... "0.99" sequence
leading up to Linux 1.0, but the convention that the dots are not
decimals is now firmly established and should be considered a
standard.  There is no limit to the number of components (digit
portions containing no dots), but most projects do not go beyond three
or four components.  The reasons why will become clear later.</para>

<para>In addition to the numeric components, projects sometimes tack
on a descriptive label such as "Alpha" or "Beta" (see
<xref linkend="pfs-alpha-and-beta"/>), for example:</para>

<informalexample>
<literallayout>Scanley 2.3.0 (Alpha)
Singer 5.11.4 (Beta)</literallayout>
</informalexample>

<para>It is generally understood that an Alpha or Beta qualifier means
that this release <emphasis>precedes</emphasis> a future release that
will have the qualified number.  Thus, "2.3.0&nbsp;(Alpha)" leads
eventually to "2.3.0".  In order to allow several such candidate
releases in a row, the qualifiers themselves can have qualifiers.  For
example, here is a series of release in the order that they would be
made available to the public:</para>

<informalexample>
<literallayout>Scanley 2.3.0 (Alpha 1)
Scanley 2.3.0 (Alpha 2)
Scanley 2.3.0 (Beta 1)
Scanley 2.3.0 (Beta 2)
Scanley 2.3.0 (Beta 3)
Scanley 2.3.0</literallayout>
</informalexample>
</sect2>

<para>Notice how when it has the "Alpha" qualifier, Scanley "2.3" is
written as "2.3.0".  Those two numbers are equivalent&mdash;trailing
all-zero components can always be dropped for brevity&mdash;but when a
qualifier is attached, brevity is a lost cause anyway, so one might as
well go for completeness instead.</para>

<para>Other qualifiers in semi-regular use include "Stable",
"Unstable", "Development", and "RC" (for "Release Candidate").  The
most widely used ones are still "Alpha" and "Beta", with "RC" running
a close third place, but note that "RC" always includes a numeric
meta-qualifier.  That is, you don't release
"Scanley&nbsp;2.3.0&nbsp;(RC)", you release
"Scanley&nbsp;2.3.0&nbsp;(RC&nbsp;1)", followed by RC2, etc.  Those
three labels, "Alpha", "Beta", and "RC" are pretty widely known now,
and I don't recommend using any of the others, even though the others
might at first glance seem like better choices because they are normal
words, not jargon.  But people who install software from releases are
mostly familiar with the big three, and there's no reason to do things
gratuitously differently from the way everyone else is doing
them.</para>

<para>Although the dots in release numbers are not decimal points,
they do indicate place-value significance.  All "0.X.Y" releases
precede "1.0" (which is equivalent to "1.0.0", of course).  "3.14.158"
immediately precedes "3.14.159", and non-immediately precedes
"3.14.160" as well as "3.15.anything", and so.  What these components
actually <emphasis>mean</emphasis> is the subject of the next two
sections.</para>

<!-- ========================== subsection =========================== -->
<sect2 id="pfs-release-number-simple-strategy">
<title>The Simple Strategy</title>

<para><remark>[... working here ...]</remark></para>

</sect2>

<!-- ========================== subsection =========================== -->
<sect2 id="pfs-release-number-even-odd-strategy">
<title>The Even/Odd Strategy</title>

<para><remark>[... working here ...]</remark></para>

</sect2>

<para><remark>(Maybe refer here from the "Announcing" in Chapter
2.)</remark></para>

<para><remark>(Talk about the dismayingly-prevalent code-name
practice, i.e., "Dancing Bonobo", "Ululating Brachiator", etc, and how
it makes life difficult and generally sucks.)</remark></para>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-cycles-and-branches">
<title>Cycles and Branches</title>

<para>The software development lifecycle does not terminate naturally.
A program may die because the architecture or environment it is
written for becomes obsolete, or because its maintainers lose
interest, or because its users abandon it for something better.  But
barring some external event, there is no reason the normal cycles of
development can't go on forever.  Bug reports come in, are narrowed
down to reproduction cases, fixed, tested, and committed.  Features
are proposed, discussed, designed, implemented, tested and committed.
A release is merely a means of delivering these changes to users in a
convenient, packaged form.</para>

<para>But a release is also a cycle itself.  The process of pulling a
stable entity out from the fluctuations of daily development, testing
it, and distributing it to the world requires a fair amount of
organization and group cooperation.  For this cooperation to run
smoothly, there needs to be a structure around to organize it, and a
way for participants to tell <emphasis>where</emphasis> in the cycle
things stand at any given moment.  As is often the case when you're
trying to isolate the code from daily fluctuations, the appropriate
structure is a branch (see
<xref linkend="pfs-vc-vocabulary-branch"/>).

</para>

<para>Most free software projects start out in a state of continuous
release, because developers fooo</para>


<!-- ========================== subsection =========================== -->
<sect2 id="pfs-packaging">
<title>Packaging for Distribution</title>

<para><remark>Talk about the importance of adhering to the standards.
Describe and reference them.  Use cvs2svn as an example of how *not*
to do it.  Importance of tight link between release numbering and
tarball unpackment result name.  Importance of certain standard
all-caps files in the top-level of the project, which will also serve
as canonical reference targets from web pages.  Therefore it's
important that either the version control system have a browse mode,
or that the live web site be a checked out tree.  Note this in section
3 on version control.</remark></para>

<para><remark>Note the penalty paid by programs with complex or
non-standard build procedures.  They suffer greatly reduced
contribution rates.  Mozilla Firefox is a good example (name a
specific bug annoying me right now, and how I could probably debug it
easily, except that I can't build the danged thing).</remark></para>

<para><remark>Note also that packaging comprises the project's tree
layout.  Describe the subversion/subversion/ odd result; how this is a
perfect example of a bikeshed discussion, so you need to make sure it
doesn't continue forever, but also not shut it down too
early.</remark></para>

</sect2>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-tool-integration">
<title>Integrating Process With Tools</title>

<para><remark>How to tie in with the revision control system and the
bug tracker, so that they become integral parts of distributed
development.</remark></para>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-testing">
<title>Testing, Automated and Otherwise</title>

<para><remark>Regression testing: choosing the right level of
formality.  Coordinating results from human volunteers.</remark></para>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-releasing">
<title>Stabilizing and Releasing</title>

<para><remark>Stabilization and release preparation (i.e., avoiding the last
minute feature rush); making sure the process terminates in a finite
amount of time.  Point out how that releases may actually be harder in
open source projects than in proprietary ones.</remark></para>

<para><remark>Describe the change-inclusion voting system, but point
out how it is very different from the kinds of voting talked about in
Chapter 4.</remark></para>

<para><remark>(Note: link to <xref linkend="pfs-publicity"/> from
somewhere in here.  That should probably be in reference to the
CHANGES file, which should be described here but linked to from
there.)</remark></para>

<para><remark>(GPG-signaturs, checksums.  No, MD5 and SHA-1 are not
"broken" for these purposes.)</remark></para>

<para><remark>This might also be the right place to talk about change
annotation, as referred to from the "merge" entry in the Version
Control Vocabulary in chapter 3.</remark></para>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-release-lines">
<title>Maintaining Multiple Release Lines</title>

<para><remark>Whether and how to maintain multiple release lines.  Make sure
this gets tied in bidirectionally with revision control discussion
(branches, arch vs cvs-style, for example).  Also, stress importance
of training people to use the issue tracker well.  Be patient, be
verbose, repeat yourself -- it will feel stupid, but it <emphasis>will
pay off</emphasis>.</remark></para>

<!-- ======================== subsection ============================== -->
<sect2 id="pfs-security-releases">
<title>Security Releases</title>

<para><remark>(Special kind of release, contains exactly one change or
changeset, is never announced until ready, and does not continue the
line afterwards, since the fix is presumed to be folded into all later
release on all other lines.  Refer back to appropriate place in
Ch. 6, of course.)</remark></para>

</sect2>

</sect1>


</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->

