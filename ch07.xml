<chapter id="pfs-ch-7">

<title>Packaging, Releasing, and Daily Development <!-- [ 15-25 pp] --> </title>

<simplesect>

<para>This chapter is about how free software projects package and
release their software, and how overall development patterns organize
around those goals.</para>

<para>A major difference between open source projects and proprietary
ones is the lack of centralized control over the development team.
When a new release is being prepared, this difference is especially
stark: a corporation can ask its entire development team to focus on
an upcoming release, putting aside new feature development and
non-critical bug-fixing until the release is done.  Volunteer groups
are less monolithic.  People work on the project for all sorts of
reasons, and those not interested in helping with a given release
still need to be able to do regular development work while the release
is going on.  Because of this decoupling, open source release
processes tend to take longer, but be less disruptive, than commercial
release processes.  It's a bit like highway repair.  There are two
ways to fix a road: you can shut it down completely, so that a repair
crew can swarm all over it at full capacity until the problem is
solved, or you work on a couple of lanes at a time, while leaving the
others open to traffic.  The first way is very efficient <emphasis>for
the repair crew</emphasis>, but not for anyone else&mdash;the road is
entirely shut down until the job is done.  The second way involves
much more time and trouble for the repair crew (now they have to work
with fewer people and less equipment, in cramped conditions, with
flaggers to slow and direct traffic, etc), but at least the road
remains useable, even if not at full capacity.</para>

<para>Open source projects tend to work the second way.  In fact, for
a mature piece of software with several different release lines being
maintained simultaneously, the project is sort of in a permanent state
of minor road repair.  There are always a couple of lanes closed; a
consistent but low level of background inconvenience is always being
tolerated by the development group as a whole, so that releases get
made on a regular schedule.</para>

<para>The model that makes this possible generalizes to more than just
releases, actually.  It's the principle of parallelizing tasks that
are not mutually interdependent&mdash;a principle that is by no means
unique to open source development, of course, but one which open
source projects implement in their own particular way.  They cannot
afford to annoy either the roadwork crew or the regular traffic too
much, but they also cannot afford to have people dedicated to standing
by the orange cones and flagging traffic along.  Thus they gravitate
toward processes that have fairly flat, constant levels of
administrative overhead, rather than peaks and valleys of
inconvenience.  Volunteers are generally willing to work with
consistent, low-level overhead; that predictability allows them to
come and go without worrying about whether their schedule will clash
with what's happening in the project.  But if the project were to have
a master schedule in which some activities excluded other activities,
the result would simply be a lot of developers sitting idle a lot of
the time&mdash;which would be not only inefficient, but boring, and
therefore dangerous, in that a bored developer is likely to soon be a
ex-developer.</para>

<para><remark>[... working here ...]</remark></para>

<para><remark>Some things that should be in this chapter: common uses
of lightweight branches; separation of core development from satellite
development (such as translations, doc fixes, web site maintenance,
etc); the necessity of not interfering with ongoing development work
when some stabilizing activity (such as a release or a high-priority
fix across all the code) is going on.  The big difference with
commercial software development here is that you can't ask your dev
team to all join together and work toward the new release.  Some of
them will be interested in that, but others will not.  Those others
still want to keep busy on the project, so things need to be arranged
such that that is possible.</remark></para>

</simplesect>


<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-cycles">
<title>Cycles</title>

<para><remark>Common development cycle patterns in free
software.</remark></para>


<!-- ========================== subsection =========================== -->

<sect2 id="pfs-version-numbering">
<title>Version Numbering</title>

<para><remark>talk about how to do release numbers right, refer here from the
      "Announcing" in Chapter 2</remark></para>

</sect2>

<!-- ========================== subsection =========================== -->
<sect2 id="pfs-packaging">
<title>Packaging for Distribution</title>

<para><remark>Talk about the importance of adhering to the standards.
Describe and reference them.  Use cvs2svn as an example of how *not*
to do it.  Importance of tight link between release numbering and
tarball unpackment result name.  Importance of certain standard
all-caps files in the top-level of the project, which will also serve
as canonical reference targets from web pages.  Therefore it's
important that either the version control system have a browse mode,
or that the live web site be a checked out tree.  Note this in section
3 on version control.</remark></para>

<para><remark>Note the penalty paid by programs with complex or
non-standard build procedures.  They suffer greatly reduced
contribution rates.  Mozilla Firefox is a good example (name a
specific bug annoying me right now, and how I could probably debug it
easily, except that I can't build the danged thing).</remark></para>

<para><remark>Note also that packaging comprises the project's tree
layout.  Describe the subversion/subversion/ odd result; how this is a
perfect example of a bikeshed discussion, so you need to make sure it
doesn't continue forever, but also not shut it down too
early.</remark></para>

</sect2>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-tool-integration">
<title>Integrating Process With Tools</title>

<para><remark>How to tie in with the revision control system and the
bug tracker, so that they become integral parts of distributed
development.</remark></para>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-testing">
<title>Testing, Automated and Otherwise</title>

<para><remark>Regression testing: choosing the right level of
formality.  Coordinating results from human volunteers.</remark></para>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-releasing">
<title>Stabilizing and Releasing</title>

<para><remark>Stabilization and release preparation (i.e., avoiding the last
minute feature rush); making sure the process terminates in a finite
amount of time.  Point out how that releases may actually be harder in
open source projects than in proprietary ones.</remark></para>

<para><remark>Describe the change-inclusion voting system, but point
out how it is very different from the kinds of voting talked about in
Chapter 4.</remark></para>

<para><remark>(Note: link to <xref linkend="pfs-publicity"/> from
somewhere in here.  That should probably be in reference to the
CHANGES file, which should be described here but linked to from
there.)</remark></para>

<para><remark>(GPG-signaturs, checksums.  No, MD5 and SHA-1 are not
"broken" for these purposes.)</remark></para>

<para><remark>This might also be the right place to talk about change
annotation, as referred to from the "merge" entry in the Version
Control Vocabulary in chapter 3.</remark></para>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="pfs-release-lines">
<title>Maintaining Multiple Release Lines</title>

<para><remark>Whether and how to maintain multiple release lines.  Make sure
this gets tied in bidirectionally with revision control discussion
(branches, arch vs cvs-style, for example).  Also, stress importance
of training people to use the issue tracker well.  Be patient, be
verbose, repeat yourself -- it will feel stupid, but it <emphasis>will
pay off</emphasis>.</remark></para>

</sect1>


</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->

