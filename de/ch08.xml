<chapter id="managing-volunteers">

<title>Leitung von Freiwilligen</title>

<simplesect>

<para>Leute dazu zubringen, sich zu einigen, was das Projekt benötigt,
und zusammen zu warbeiten, um es zu erreichen, erfordert mehr als nur
eine angenehme Atmosphäte und ein Mangel an offensichtlicher
Dysfunktion. Es erfordert jemand oder mehrere jemande, wissentlich
alle beteiligten Personen zu leiten. Die Leitung von Freiwilligen mag
kein technisches Handwerk sein im selben Sinne wie das Programmieren,
es ist aber ein Handwerk im Sinne, dass es durch sein Studium und
Übung verbessert werden kann.</para>

<para>Dieses Kapitel ist ein lose Sammlung spezifischer Techniken für
die Leitung von Freiwilligen. Es greift vielleicht mehr als vorherige
Kapitel auf das Subversion Projekt als fallstudie zurück, zum Teil da
ich an dem Projekt gearbeitet habe, als ich das hier schrieb und alle
primären Quellen griffbereit hatte, und zum Teil weil es eher tragbar
ist, wenn man kritik behaftete Steine in das eigene Glashaus wirft, als
in dem von anderen. Ich habe aber auch, in verschiedenen anderen
Projekten die Vorteile der Anwendung&mdash;und die Konseqenzen der
nicht Anwendung&mdash; der Emfehlungen die folgen; wenn es politisch
möglich ist Beispiele aus einigen dieser Projekte zu geben, werde ich
das tun.</para>

<para>Wo wir schon von Politik reden, können wir genau so gut dieses
äuserts unheilvolle Wort für eine genauere Untersuchung herauszuzerren.
Viele Ingenieure denken gerne über Politik, als wäre es etwas womit
andere sich beschäftigen. "<emphasis>Uch</emphasis> spreche nur für den
besten Kurs für das Projekt, aber <emphasis>sie</emphasis> erhebt
Einsprüche aus politischen Gründen." Ich denke dieser Ekel vor Politik
(oder was als Politik verstanden wird) ist in Ingenieuren besonders
Stark, da sie sich die Idee angeeignet haben, dass manche Lösungen
objektiv besser sind als andere. Wenn es also scheint, dass jemand sich
auf eine Art benimmt, als wäre sie durch äußere Überlegungen motiviert
&mdash;sagen wir der Erhaltung ihrer einflussreichen Position, die
Verminderung des Einflusses von jemand anderem, gar offener Kuhhandel
oder die Meidung die Gefühle von jemand zu verletzen&mdash;können 
andere Mitwirkende im Projekt genervt werden. Das hindert sie natürlich
nicht daran, sich auf die gleiche Art zu benehmen, wenn ihre 
lebenswichtigen Interessen auf dem Spiel stehen.</para>

<para>Wenn "politik" als ein schmutziges erachten, und hoffen Ihr
Projekt davon frei zu halten, geben Sie es gleich auf. Politik ist
immer dann unvermeidlich, wenn Menschen zusammen eine geteilte
Resource verwalten müssen. Es ist völlig vernünftig, dass eines der
Überlegungen die in der Entscheidungsfindung von jemandem einfließt,
die Frage ist, wie ein Vorgang sich auf den eigenen zukünftigen 
Einfluss im Projekt, auswirken wird. Wenn Sie schließlich Ihr eigenes
Urteilsvermögen und Ihre Fähigkeiten vertrauen, wie es bei den meisten
Programmierern der Fall ist, dann muss der mögliche Verlust von
zukünftigem Einfluss, im gewissen Sinne als techniches Ergebnis in
betracht gezogen werden. Ähnliche Schlussfolgerungen gelten für anderes
Verhalten, welche vielleicht oberflächlich betrachtet, nach "reiner"
Politik aussehen. Tatsächlich gibe es nicht so etwas wie reine Politik:
Es ist genau aus dem Grund, dass Vorgänge mehrere Konsequenzen in der
echten Welt habe, dass Menschen überhaupt ein politisches Bewusstsein
bekommen. Politik ist, letztendlich, einfach eine Anerkennung, dass
<emphasis>alle</emphasis> Konzequenzen von Entscheidungen, in betracht
gezogen werden müssen. Wenn eine bestimmte Entscheidung zu einem
Ergebinis führt, welches die meisten Mitwirkenden technich 
zufriedenstellend finden, welches aber mit einer Änderung in den macht
Beziehungen zusammenhängt, dass entscheidende Personen ein Gefühl der
Isolation gibt, ist letzteres ein genau so wichtiges Ergebnis wie
ersteres. Es zu ignorieren, wäre nicht hoch geistig, sondern kurz 
sichtig.</para>

<para>Wärend Sie also die nachfolgenden Ratschläge lesen, und wärend
Sie an Ihrem eigenen Projekt arbeiten, denken Sie daran, dass es
<emphasis>keinen</emphasis> gibt, der über die Politik steht. Zu
erscheinen, als wäre man über die Politik, ist lediglich eine bestimmte
politische Strategie, und manchmal ein sehr nützliches, es entspricht
aber niemals der Wirklichkeit. Politik ist einfach was passiert, wenn
Menschen Meinungsverschiedenheiten haben, und erfolgreiche Projekte
sind solche die politische Mechanismen entwickeln um diese 
Streitigkeiten konstruktiv zu verwalten.</para>

</simplesect>

<!-- ======================== SECTION ============================== -->
<sect1 id="volunteers">
<title>Das Meiste Aus Freiwilligen Herausholen</title>

<para>Warum arbeiten Freiwillige an freien Software Projekten?
<footnote><para>Diese Frage wurde im Detail untersucht, mit 
interesanten Ergebnissen, in einer Veröffentlichung von Karim Lakhani
und Robert G. Wolf, mit dem Titel<citetitle>Why Hackers Do What They
Do: Understanding Motivation and Effort in Free/Open Source Software
Projects</citetitle> (de. Warum Hacker Tun Was Sie Tun: Verständniss
der Motivation und Bestrebungen in Freien/Open Source Software 
Projekten). Siehe
<ulink url="http://freesoftware.mit.edu/papers/lakhaniwolf.pdf"
/>.</para></footnote></para>

<para>Wenn man sie fragt, behaupten biele, dass sie es machen, weil
sie gute Software produzieren wollen, oder persönlich daran beteiligt
sein wollen, die Fehler zu beheben, die ihnen wichtig sind. Aber diese
Gründe sind gewöhnlich nicht die ganze Geschichte. Könnten Sie sich
schließlich einen freiwilligen vorstellen, der bei einem Projekt 
bleibt, selbst wenn keiner je ein Wort Anerkennung über seine Arbeit
sagen würde, oder keiner ihm in Diskussionen zuhören würde? Natürlich
nicht. Menschen verbringen ganz klar Zeit an freien Software Projekten,
aus Gründen die über das Bedürfniss guten Code zu produzieren, hinaus
gehen. Die wirklichen Motivationen von Freiwilligen zu verstehen wird
Ihnen helfen, Sachen so einzurichten, dass sie angelockt werden und
dabei bleiben. Der Wunsch gute Software zu produzieren mag eines dieser
Motivationen sein, zusammen mit der Herausforderung und dem 
Bildungswert an schwierign Problemen zu arbeiten. Menschen haben aber
auch ein eingbautes Bedürfniss, mit anderen zusammen zu arbeiten, und
Respekt durch Zusammenarbeit zu geben und verdienen. Gruppen die sich
mit gemeinschaftlichen Aktivitäten beschäftigen, müssen Verhaltensnormen
derart entwickeln, dass Ansehen durch Leistungen die den Zielen der
Gruppe dienen, angeeignet und behalten werden können.</para>

<para>Diese Normen werden nicht immer von alleine auftauchen. Bei
manchen Projekten&mdash;erfahrene Open Source Entwickler können
wahrscheinlich spontan mehere nennen&mdash;haben Leute zum Beispiel
anscheinend das Gefühl, dass Ansehen durch häufige und ausführliche
Nachrichten angeeignet wird. Sie kommen nicht aus versehen zu diesem
Schluss; sie kommen darauf, weil sie für lange, komplexe Argument,
mit Respekt belohnt werden, ob das dem Projekt hilft oder nicht.
Nachfolgend sind einige Techniken um eine Atmosphäre zu erzeugen, in
dem Aktivitäten die Ansehen verschaffen auch konstruktive Aktivitäten
sind.</para>

<!-- ======================== subsection ============================== -->
<sect2 id="delegation">
<title>Delegierung</title>

<para>Deligierung ist nicht nur eine möglichkeit um die Arbeit zu
verteilen; es ist auch ein politisches und soziales Werkzeug. 
Betrachten Sie alle Auswirkungen, wenn Sie jemand darum bitten, etwas
zu machen. Die offensichtlichste Folge ist, falls er annimmt, dass er
die Aufgabe erledigt, und Sie nicht. Eine weitere Folge ist aber, dass
ihm bewusst gemacht wird, dass Sie ihm zugetraut haben die Aufgabe zu
erledigen. Desweiteren, wenn Sie die Anfrage in einem öffentlichen
Forum gemacht haben, weiß er auch, dass ander in der Gruppe auch über
dieses Vertrauen unterrichtet wurden. Er mag auch etwas Druck
verspüren anzunehmen, was bedeutet, dass Sie derart Fragen müssen,
dass es ihm erlaubt taktvoll abzulehnen, falls er die Aufgabe nicht
wirklich haben will. Wenn die aufgabe Koordination mit anderen im
Projekt erfordert, schlagen Sie effektiv vor, dass er sich mehr
beteiligt, Verbindungen aufbaut die vielleicht sonst nicht entstanden
wären, und möglicherweise zu einer Authorität auf in einem Teilgebiet
des Projekts wird. Die zusätzliche Beteiligung mag einschüchternd
sein, oder ihn dazu führen, sich auch auf andere Arten zu engagieren,
durch ein erweitertes Gefühl seiner gesamten Verpflichtung.</para>

<para>Aufgrund all dieser Auswirkungen, macht es oft Sinn, jemand 
anderes darum zu bitten, etwas zu machen, selbst wenn Sie wissen, dass
Sie es selber schneller oder besser machen könnten. Es gibt natürlich 
hierfür manchmal sowieso ein gänzlich wirtschaftliches Argument: Die
Kosten der Möglichkeit es selber zu machen können zu hoch sein&mdash;es
mag etwas noch wichtigeres geben, was Sie mit der Zeit machen könnten.
Aber selbst wenn das Argumen über die Kosten der Möglichkeit nicht
gilt, kann es <emphasis>trotzdem</emphasis> in Ihrem Interesse sein
jemand anderes darum zu bitten die Aufgabe an sich zu nehmen, denn auf
lange Sicht, wollen Sie diese Person tiefer in das Projekt einbeziehen,
selbst wenn es etwas mehr Zeit bedeutet, zunächst ein auf sie 
aufzupassen. Die umgekehrte technig gilt auch: Wenn Sie sich 
gelegentlich für Arbeit melden, welches jemand anderes nicht machen
will oder wofür er nicht die nötig Zeit hat, werden Sie sein Wohlwollen
und Respekt ernten. Deligierung und Ersetzung drehen sich nicht nur
darum einzelne Aufgaben erledigt zu bekommen; es geht auch darum Leute
in eine engere Verpflichung an das Projekt zu bringen.</para>

<sect3 id="delegation-assignment">
<title>Unterscheiden Sie Eindeutig Zwischen Anfrage und Anweisung</title>

<para>Manchmal kann man erwarten, dass eine Person eine bestimmte
Aufgabe annehmen wird. Wenn jemand zum Beispiel eine Bug im Code
schreibt, oder Code committed, welche auf irgend eine offensichtliche
Art, nicht den Richtlinien des Projekts entspricht, dann reicht es aus
auf das Problem hinzuweisen, und sich danach zu verhalten, als würden
Sie annehmen, dass sich die Person darum kümmern wird. Es gibt aber
andere Situationen bei denen es keineswegs klar ist, dass Sie ein
Recht darauf haben, eine Reaktion zu erwarten. Die Person kann machen
worum Sie ihn bitten, oder auch nicht. Da keiner es mag, als 
selbstverständlich erachtet zu werden, müssen Sie für den Unterschied
zwischen diesen beiden Arten von Situationen, einfühlsam sein, und Ihre
Anfragen entsprechend anpassen.</para>

<para>Eine Sache bei dem Leuten fast immer sofort verärgert werden,
ist wenn sie auf eine Art gefragt werden etwas zu machen, welches 
impliziert, dass Sie der Meinung sind, dass es ganz klar ihre
Verantwortung ist, wenn Sie anderer Meinung sind. Zum Beispiel ist die
Zuweisung eintreffender Meldungen eine besonders reichhaltiger Boden
für diese Art von Verärgerung. Die Beteiligten in einem Projekt wissen
für gewöhnlich, wer Exerte in welchen Bereichen ist, wenn also eine
Bug Meldung eintrifft, wird es oft ein oder zwei Personen geben, von
denen jeder weiß, dass sie das Problem schnell beheben könnten. Wenn
Sie jedoch die Meldung einer dieser Personen zuweisen, ohne vorherige
Zustimmung, kann er das Gefühl bekommen, in eine unbequeme Lage 
gebracht zu werden. Er spürt den Druck der erwartung, aber auch, dass
er effektiv für seine Kentnisse bestraft wird. Schließlich erlangt man
diese Kenntnisse, indem Man Bugs behebt, also sollte vielleicht jemand
anderes diesen übernehmen! (Beachten Sie, dass Ticket Systeme die 
Tickets automatisch bestimmten Personen zuweisen, aufgrund von 
Informationen in dem Ticket, wahrscheinlich nicht so sehr beleidigend
sind, da jeder weiß, dass die Zuweisung automatisch durchgeführt wurde,
und keine Andeutung von menschlichen Erwartungen ist.)</para>

<para>Obwohl es nett wäre die Last so gleichmäßig wie möglich zu
verteilen, gibt es bestimmte Zeiten, wenn Sie einfach die Person die
einen Fehler am schnellsten beheben kann, dazu ermutigen wollen.
Angesichts dessen, dass Sie es sich den Kommunikationsaufwand bei jeder
solchen Zuweisung nicht leisten können ("Wärst du bereit dir diesen Bug
anzuschauen? "Ja." "Alles klar, dann weise ich dir den Ticket zu." 
"Ok."), sollten Sie die Zuweisung einfach in der Form einer Anfrage 
machen, welche keinen Druck vermittelt. Praktisch alle Ticket Systeme
erlauben, dass ein Kommentar an eine Zuweisung angehängt wird. In
diesem Kommentar, können Sie soetwas sagen:</para>

<blockquote>
   <para>Ich weise dir das mal zu, hmustermann, weil du dich am
   besten in diesem Code auskennst. Wenn du keine Zeit hast es dir
   anzuschauen, kannst du es ruhig zurückgeben. (Und sag mir bescheid,
   wenn du in Zukunft solch Anfragen lieber nicht bekommen würdest.)
   </para>
</blockquote>

<para>Das unterscheidet eindeutig zwischen der <emphasis>Anfrage
</emphasis> für eine Aufgabe und <emphasis>Annahme</emphasis> dieser
Aufgabe seitens des Empfängers. Das Publikum hier ist nicht nur der
Zugewiesene, es sind alle: Die ganze Gruppe sieht eine öffentliche
bestätigung der Fähigkeiten des Zugewiesenen, die Nachricht macht
aber auch klar, dass es ihm frei steht, die Verantwortung dafür
anzunehmen oder abzulehnen.</para>

</sect3>

<sect3 id="delegation-followup">
<title>Schließen Sie Nach Der Deligierung An</title>

<para>Wenn Sie jemand darum bitten, etwas zu machen, behalten Sie es
im Hinterkopf, und schließen Sie mit ihm danach an, egal was passiert.
Die meisten Anfragen werden in öffentlichen Foren gemacht, und sind
ungefähr von der Art "Kannst du dich um X kümmern? Sag uns bescheid,
egal wie du dich entscheidest; kein Problem wenn du keine Zeit hast,
wir müssens nur wissen". Sie können darauf eine Antwort bekommen oder
auch nicht. Wenn ja, und die Antwort negativ war, ist der Kreis
geschlossen&mdash;Sie werden eine andere Strategie versuchen müssen
um mit X um zu gehen. Wenn es eine positive Antwort ist, da behalten
Sie den Verlauf des Tickets im Auge, und machen Sie Anmerkungen zu den
Fortschritten die Sie sehen oder nicht sehen (jeder arbeitet besser,
wenn er weiß, dass jemand anderes seine Arbeit zu schätzen weiß). 
Wenn es nach ein paar Tagen keine Antwort gibt, fragen Sie nochmal
nach, oder schreiben Sie, dass Sie keine Antwort bekommen haben und
jetzt nach jemand anderem suchen der es erledigt. Oder machen Sie es
einfach selber, aber vergewissern Sie sich, dass Sie keine Antwort
auf die ursprüngliche Anfrage bekommen haben.</para>

<para>Der Sinn der öffentlichen Bemerkung, dass es keine Antwort gab
ist <emphasis>nicht</emphasis> um die Person zu beschämen, und Ihre
Anmerkungen sollten so formuliert sein, dass sie nicht diese Wirkung
haben. Der Sinn ist einfach zu zeigen, dass Sie dem nachgehen, wofür
Sie Anfragen gemacht haben, und dass Sie die Antworten die Sie bekommen
bemerken. Das erhöht die Wahrscheinlichkeit, dass Leute beim nächsten
mal Ja sagen, da Sie feststellen werden (wenn auch nur unbewusst) dass
Sie eher bemerken, wenn sie irgend welche Arbeit erledigen, wenn man
bedenkt, dass Sie das viel weniger sichtbare Ereignis bemerkt habe, 
dass jemand nicht geantwortet hat.</para>

</sect3>

<sect3 id="delegation-interest">
<title>Achten Sie Darauf Wofür Leute Sich Interessieren</title>

<para>Eine weitere Sache die Leute glücklich macht, ist wenn man ihre
Interessen bemerkt&mdash;allgemein, wird jemand um so gemütlicher sein,
je mehr aspekte seiner Persönlichkeit Sie bemerken und erinnern, und
je eher wird er in Gruppen arbeiten wollen, von denen Sie ein Teil
sind.</para>

<para>Es gab zum Beispiel eine scharfe Unterscheidung in dem Subversion
Projekt zwischen Personen die eine endgültige 1.0 Version erreichen
wollten (was wir letztendlich schafften), und solche die hauptsächlich
neue Funktionen hinzufügen sowie an interesanten Probleme arbeiten 
wollten, denen es aber nicht sonderlich kümmerte, wann 1.0 erscheinen
würde. Keiner dieser Positionen ist besser oder schlimmer als die 
andere; sie sind lediglich zwei unterschiedliche Arten von Entwickler,
und beide erledigen eine menge Arbeit im Projekt. Wir lernten aber
schnell, dass es wichtig war <emphasis>nicht</emphasis> anzunehmen,
dass die Aufregung um den Schub auf 1.0 von jedem geteilt wurde. 
Elektronische Medien können sehr trügerisch sein: Sie können eine
Atmosphäre einer gemeinsammen Bestimmung spüren, wenn in wirklichkeit
es nur bon den Personen geteilt wird, mit denen Sie zufällig geredet
haben, wären andere völlig unterschiedliche Prioritäten haben.</para>

<para>Je ehere Sie sich bewusst sind, was Leute von dem Projekt wollen,
desto effektiver können Sie an ihnen Anfragen stellen. Selbst ein
Verständniss dafür zu zeigen, was sie wollen, ohne eine zugehörige
Anfrage, ist in sofern nützlich, dass es jeder Person bestätigt, dass
sie nicht nur eine weiteres Teilchien in einer einheitlichen Masse ist.
</para>

</sect3>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="praise-and-criticism">
<title>Lob und Kritik</title>

<para>Lob und Kritik sind keine Gegensätze: In vielerlei Hinsicht, sind
sie sich sehr änhnlich. Beide sind vor allem Formen von Aufmerksamkeit,
und sind am effektivsten, wenn sie eher spezifisch sind als allgemein.
Beide sollten mit konkreten Zielen im Blick, angewandt werden. Beide
können durch inflation geschwächt werden: Zuviel oder zu oft zu Loben
wird seinen Wert vermindern; das gleiche gilt für Kritik, obwohl in der
Praxis, Kritik eher eine Reaktion ist und desshalb etwas weniger
anfällig für Wertminderung ist.</para>

<para>Eine wichtige Funktion, der technischen Kultur ist, dass
detailierte leidenschaftslose Kritik oft als eine Art Lob verstanden
wird (wie in <xref linkend="rudeness"/><phrase output="printed">
im Kapitel <xref linkend="communications"/></phrase> beschrieben),
aufgrund der Implikation, dass die Arbeit des Empfängers die Zeit,
welche für seine Analyse benötigt wird, es wert ist. Beide dieser
Bedingungen&mdash;<emphasis>detalliert</emphasis> und 
<emphasis>leidenschaftslos</emphasis>&mdash;müssen jedoch erfüllt sein,
damit das wahr ist. Wenn jemand zum Beispiel eine schlampige Änderung
am Code macht, ist es nutzlos (und sogar schädlich) darauf zu 
Antworten, indem man einfach sagt "Das war schlampig". Schlampigkeit
ist letztendlich die Eigenschaft einer <emphasis>Person</emphasis>,
nicht ihrer Arbeit, und es ist wichtig, ihre Reaktionen auf die Arbeit
zu konzentrieren. Es ist viel effektiver, taktvoll und ohne 
Böswilligkeit, alles zu beschreiben was an der Arbeit falsch ist. Wenn
das die dritte oder vierte sorglose Änderung nacheinander von der
selben Person ist, ist es angemesen das am Ende Ihrer Kritik zu sagen
&mdash;wieder ohne Wut&mdash; um klar zu machen, dass man das Muster
bemerkt hat.</para>

<para>Wenn jemand sich nicht in reaktion auf die Kritik bessert, ist
die Lösung nicht mehr oder stärkere Kritik. Die Läsung ist für die
Gruppe diese Person aus seiner Position von Inkompetenz zu entfernen,
so das es die verletzten Gefühle so gering wie möglich hält; siehe
<xref linkend="transitions"/><phrase output="printed"> später in
diesem Kapitel</phrase> für Beispiele. Was jedoch selten vorkommt.
Die meisten Leute reagieren ziemlich gut auf Kritik die spezifisch und
detalliert ist, sowie eine klare (wenn auch nicht ausgesprochene)
Erwartung einer Verbesserung beinhaltet.</para>

<para>Lob wird natürlich keine Gefühle verletzen, was aber nicht
bedeutet, dass sie es weniger vorsichtig nutzen sollten als Kritik.
Lob ist ein Werkzeug: Vor Sie es nutzen, fragen Sie sich, 
<emphasis>warum</emphasis> Sie es nutzen wollen. In der Regel, ist es
keine gute Idee Leute für das zu loben, was sie normalerweise machen,
oder für aktivitäten welche ein normaler und zu erwartender Bestandteil
der Teilnahme in der Gruppe sind. Wenn Sie das machen würden, wäre es
schwierig zu wissen wan man aufhören soll: Sollten Sie 
<emphasis>everyone</emphasis> für die übliche Arbeit loben? Wenn Sie
schließlich manche auslassen, werden sie sich fragen warum. Es ist viel
besser, Lob und Dankbarkeit sparsamm zum Ausdruck zu bringen, als 
Reaktuin auf ungewöhnliche oder unerwartete Anstrengungen, mit der 
Absicht mehr solcher Arbeit zu ermutigen. Wenn es scheint, dass eine
Beteiligte in einem Zustand dauerhaft erhöhter Produktivität bewegt
zu haben, sollten Sie die Grenze für Lob bei dieser Person entsprechend
anpassen. Wiederholtes Lob für normales Verhalten wird mit der Zeit
sowieso langsam bedeutungslos. Statt dessen, sollte diese Person 
spüren, dass ihr hoher Grad an produktivität als normal und natürlich
erachtet wird und nur Arbeit die darüber hinaus geht, sollte besonders
zur Kenntniss genommen werden.</para>

<para>Was natürlich nicht heißen soll, dass die Beiträge der Person
nicht gewürdigt werden sollten. Denken Sie aber daran, dass wenn das
Projekt richtig eingerichtet wurde, wird alles was diese Person macht
eh schon sichtbar sein, und die Gruppe wird wissen (und die Person
wird wissen, dass die Gruppe weiß), was sie alles macht. Es gibt auch
Möglichkeiten die Arbeit von jemand anzuerkennen, außer direkem Lob. 
Sie könnten immer im vorbeigenen erwähnen, wärend Sie ein verwandtes
Thema besprechen, dass sie eine Menge arbeit in dem entsprechenden
Bereich geleistet hat und auf dem Gebiet die Expertin ist; Sie könnten
sie öffentlich eine Frage über den Code konsultieren; oder vielleicht
am effektivsten, könnten Sie die Arbeit, die sie geleistet hat 
anderweitig nutzen, damit sie sieht, dass andere sich jetzt mit ruhigem
Gewissen auf die Ergebnisse ihrer Arbeit verlassen. Es ist 
wahrscheinlich nicht nötig das alles auf eine berechnete Art zu machen.
Jemand der regelmäßig große Beiträge in einem Projekt leistet, wird es
wissen, und wird standardmäßig eine einflussreiche Position einnehmen.
Es gibt gewöhnlich kein Bedarf explizite Schritte vorzunehmen, um das
sicherzustellen, es sei denn Sie spüren, dass ein Beteiligter aus 
irgend welchen Gründen nicht entsprechend geschätzt wird.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="territoriality">
<title>Verhindern Sie Revierabsteckung</title>

<para>Halten Sie Acht, nach Beteiligten, die versuchen exclusiven
Besitz, für bestimmte Bereiche im Projekt abzustecken, und bei denen
es scheint, als wollten Sie in den Bereichen, die ganze Arbeit
machen, sogar zu dem Grad, dass sie die Arbeit die andere anfangen
aggresiv übernehmen. Solches Verhalten mag am Anfang sogar gesund
erscheinen. Oberflächlich, sieht es aus als würde die Person mehr
Verantwortung übernehmen, und in dem gegebenen Bereich mehr Aktivität
zeigt. Auf lange Sicht ist es allerdings schädlich. Wenn Leute ein 
"nicht betreten" Schild sehen, bleiben sie weg. Das hat eine
reduzierte Überprüfung innerhalb diesem Bereich zur Folge, sowie
größere Zerbrechlichkeit, da der einzelne Entwickler zu einem 
kritischen Ausfallpunkt wird. Schlimmer noch, zerbricht es den 
gemeinschaftlichen, egalitären Geist des Projekts. Die Theorie
sollte immer sein, dass jeder Entwickler gerne bei jeder Aufgabe
und zu jeder Zeit helfen kann. In der Praxis, funktionieren die
Sachen ein wenig anders: Leute haben doch ihre Bereiche, in denen
sie mehr Einfluss haben, und nicht Experten verweisen oft auf die
Experten auf bestimmten Gebiten des Projekts. Die Hauptsach ist, dass
das alles freiwillig ist: Informelle Authorität wird aufgrund von
Kompetenz und bewiesenem Urteilsvermögen erteilt, sollte aber nie
aktiv <emphasis>genommen</emphasis> werden. Selbst wenn die Person
wirklich Kompetent ist, ist es trotzdem noch kritisch, dass sie diese
Authorität informell hällt, durch das Bewusstsein des Projekts, und
dass die Authorität sie niemals dazu bringt andere davon 
auszuschließen, in dem Bereich zu arbeiten.</para>

<para>Die Arbeit von jemand aus technischen Gründen abzuweisen oder zu
bearbeiten ist natürlich etwas föllig anderes. Dort ist die Arbeit
das entscheidende, nicht wer zufällig den Torwächter gespielt hat. Es
kann sein, dass die selbe Person für einen bestimmten Bereich die
meisten commits überprüft, so lange er aber nie versucht jemand anders
daran zu hinder auch diese Arbeit zu machen, ist wahrscheinlich alles
in Ordnung.</para>

<para>Um gegen das einsetzende entstehen von Revieren anzukämpfen,
oder gar sein auftauchen, sind viele Projekte dazu übergegangen, die
Namen der Authoren oder Zuständigen in Quellcode Dateien zu
verbieten. Ich stimme diesem Verfahren voll und ganz zu: Wir benutzen
es im Subversion Projekt, und es ist mehr oder weniger eine offizielle
Richtlinie bei der Apache Software Foundation. ASF Mitglied Sander
Striker drückt es so aus:</para>

<blockquote>
   <para><emphasis>Bei der Apache Software foundation raten wir von der
   Nutzung von Author Markierungen in dem Quellcode ab. Es gibt dafür
   verscheidene Gründe, mal abgesehen von den rechtlichen Konsequenzen.
   Bei der gemeinschaftlichen Entwicklung, geht es darum als Gruppe an
   Projekte zu arbeiten, und sich als Gruppe um das Projekt zu kümmern.
   Anerkennung ist gut und sollte gemacht werden, allerdings auf eine
   Art welche keine falsche Anerkennung erlaubt, selbt implizite. Es
   gibt keine klare Grenze, wann man eine Markierung des Authors machen
   oder entfernen soll. Fügen Sie Ihren Namen hinzu, wenn sie ein
   Kommentar bearbeiten? Wenn Sie einen einzeiligen Fix hinzufügen?
   Entfernen Sie die alten Markierungen wenn sie den Code neu
   strukturieren, und es zu 95% anders aussieht? Was machen Sie mit
   Leuten die herumgehen und jede Datei anfassen, und gerade genug
   ändern, um eine vituelle Quote erreich, damit ihr Name überall ist?
   </emphasis></para>

   <para><emphasis>Es gibt bessere möglichkeiten Anerkennung 
   zuzuweisen, und wir bevorzugen es, diese zu nutzen. Aus technischer
   Sicht, sind Author Markierungen unnötig; wenn Sie herrausfinden
   wollen, wer einen bestimmten Abschnitt im Code geschrieben hat,
   können Sie das Versionsverwaltungssystem dazu konsultieren. Diese
   Markierungen neigen auch dazu veraltet zu werden. Wollen Sie 
   wirklich privat zu einem Stück Code kontaktiert werden, welches
   Sie vor fünf Jahren geschrieben haben und froh waren vergessen zu
   haben?</emphasis></para>
</blockquote>

<para>Die Quellcode Dateien von einem Software Projekt sind der Kern
siener Identität. Sie sollten die Tatsache wiederspiegeln, dass die
Entwickler Gemeinschaft im Ganzen dafür verantwortlich ist, und nicht
in einzelne Machtbereiche aufgeteilt werden.</para>

<para>Manchmal sprechen sich Leute für die Markierung des Autors
oder eines Zuständigen in den Quellcode Dateien, mit der Begründung,
dass es eine sichtbare Anerkennung derjenigen gibt, die am meisten
Arbeit geleistet haben. Es gibt mit der Argumentation zwei Probleme.
Erstens, ergibt sich dadurch die Frage, wieviel Arbeit man leisten
muss, um seinen Namen dort auch aufgelistet zu bekommen. Zweitens,
verschmilzt dadurch die Anerkennung und die Zuständigkeit: Arbeit in
der Vergangenheit gemacht zu haben, impliziert keinen Besitz des
Bereichs, indem die Arbeit gemacht wurde, es ist aber schwierig wenn
nicht sogar unmöglich solche Andeutungen zu vermeiden, wenn die Namen
von Individuen oben in den Quellcode Dateien aufgelistet sind. So oder
so, kann die Information über Anerkennung schon aus dem Protokoll der
Versionsverwaltung sowie andere aus anderen Kanälen wie die Archive
des Email Verteilers entnommen werden. Es geht also keine Information
verloren, wenn man es in den Quellcode Dateien nicht erlaubt.</para>

<para>Wenn Ihr Projekt sich entscheidet einzelne Namen nicht in den
Quellcode Dateien zu nennen, sollten Sie es nicht übertreiben. Viele
Projekte haben zum Beispiel einen <filename>contrib/</filename> 
Bereich, in dem kleine Werkzeuge und hilfsscripte getan werden, die
oft von Personen geschrieben werden, die an sonsten nicht mit dem
Projekt im Zusammenhang stehen. Es ist völlig in Ordnung wenn diese
Dateien die Namen der Authoren beinhalten, da sie nicht wirklich von
dem Projekt als ganzes gepflegt werden. Wenn andererseits, an einem
Hilfsmittel von anderen Personen aus dem Projekt angefangen wird
gehackt zu werden, könnte es irgendwann angebracht sein, es in einen
weniger isolierten Bereich zu bewegen und, angenommen der ursprüngliche
Author hat keine Einwände, den Namen des Authors entfernen, damit der
Code wie jede andere von der Gemeinschaft gepflegte Ressource aussieht.
Wenn der Author im Bezug darauf sensibel ist, sind Kompromisslösungen
annehmbar, wie zum Beispiel:</para>

<blockquote>
<programlisting>
# indexclean.py: Entferne die alten Daten aus einem Scanley Index.
#
# Ursprünglicher Author: K. Maru &lt;kobayashi@nocheinweitereremaildienst.com&gt;
# Derzeit gepflegt von: Dem Scanley Projekt &lt;http://www.scanley.org/&gt;
#                    und K. Maru.
# 
# ...
</programlisting>
</blockquote>

<para>Es ist aber besser wenn möglich solche Kompromisse zu vermeiden,
und die meisten Authoren lassen sich überreden, da sie froh sind, dass
ihr Beitrag zu einem engeren Bestandteil des Projekts gemacht wird.
</para>

<para>Das Wichtig ist sich daran zu erinnern, dass es bei jedem
Projekt eine fließende Grenze, zwischen dem Kern und der Peripherie
gibt. Die Hauptdateien des Quellcodes der Software sind ganz klar ein
Teil des Kerns, und sollten als von der Gemeinschaft gepflegt, 
angesehen werden. Begleitende Werkzeuge oder Teile einer Dokumentation
können andererseits die Arbeit eines Einzelnen sein, der sie eim
wesentlichen alleine pflegt, auch wenn die Werke mit dem Projekt zu
tun haben, und sogar verteilt werden. Es muss keine für alle Gültige
Regel auf jede Datei angewandt werden, so lange das Prinzip aufrecht
erhalten wird, nicht zu erlauben, dass von der Gemeinschaft gepflegte
Ressourcen zu den Revieren von Individuen werden.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="automation">
<title>Das Verhältniss der Automatisierung</title>

<para>Versuchen Sie nicht Menschen Arbein machen zu lassen, die an
ihrer Stelle von Machinen gemacht werden könnten. Als Grundregel, ist
die Automatisierung einer wiederkehrenden Aufgabe, mindestens zehn mal
so viel Einsatz wert, wie das was ein Entwickler aufbringen würde, wenn
er sie ein mal macht. Bei sehr häufigen oder sehr komplexen Aufgaben,
kann dieses Verhältniss sogar leich auf das zwansigfache oder gar mehr
ansteigen.</para>

<para>Sich als ein "Projektleiter" anzusehen, im gegensatz zu noch
ein weiteren Entwickler, mag an dieser Stelle eine nützliche
Einstellung sein. Manchmal sind einzelne Entwickler zu sehr in
kleinarbeit verwickelt, um das Gesamtbild zu sehen, und zu erkennen,
dass jeder eine menge Mühe daran vergeudet, automatisierbare Aufgaben
händisch zu erledigen. Selbst diejenigen, die es erkennen, werden sich
nicht unbedingt die Zeit nehmen das Problem zu lösen: Weil jede
einzelne Durchführung der Aufgabe sich nicht wie eine riesige Last
anfühlt, keiner wird je derart davon genervt, um etwas dagegen zu
machen. Was die Automatisierung so wünschenswert macht ist, dass die
kleine Last mit der Anzahl der wiederholungen von jedem Entwickler
multipliziert wird, und <emphasis>diese</emphasis> Zahl wird wiederum
mit der Anzahl der Entwickler multipliziert.</para>

<para>Ich benutze hier den Begriff "Automatisiertung" im weiten Sinne,
nicht nur um wiederholte vorgänge zu bezeichnen, bei denen ein oder
zwei Variablen sich jedes mal ändern, sondern für jede Art von
technischer Infrastruktur die Menschen unterstützt. Das mindeste an
standardmäßiger Automatisierung die heutzutage erforderlich ist um
ein Projekt zu betreiben, wird in <xref 
linkend="technical-infrastructure"/> beschrieben, aber jedes Projekt
kann auch seine eigenen besonderen Probleme haben. Eine Gruppe die an
der Dokumentation arbeitet, könnte vielleicht eine Webseite haben
wollen, welche zu jeder Zeit die aktuellsten Versionen der Dokumente
anzeigt. Da die Dokumentation oftmals in einer Auszeichnungssprache
wie XML geschrieben, kann es einen Kompilierungsschritt, meistens
ziemlich umständlich, geben um die Dokumente für die Darstellung oder
zum herunterladen zu erstellen. Eine Webseite einzurichten, bei dem
diese Kompilierung automatisch nach jedem Commit passiert, kann sehr
kompliziert und zeitaufwendig sein&mdash;es ist es aber wert, selbst
wenn Sie mehr als einen Tag brauchen, um es einzurichten. Die 
übergreifenden Vorteile Seiten zu haben, die immer aktuell sind ist
enorm, auch wenn die Kosten sie <emphasis>nicht</emphasis> zu haben
zu einem Zeitpunkt, vielleicht nur nach einer kleinen Unbequemlichkeit,
für einen einzelnen Entwickler aussieht.</para>

<para>Solche Schritte vorzunehmen, eliminiert nicht nur die
verschwendete Zeit, sondern auch die Fesseln und Frustration die
entsteht, wenn Menschen Fehler machen (wie es zwangsläufig der Fall
sein wird), wenn sie versuchen komplizierte Vorgänge händisch
durchzuführen. Dederministische Tätigkeiten, mit mehreren Schritten
sind genau das, wofür Computer erfunden wurden; sparen Sie sich ihre
Menschen für interesanntere Sachen auf.</para>

<sect3 id="automated-testing">
<title>Automatisiertes Testen</title>

<para>Automatisierte Testläufe sind für jedes Software Projekt
hilfreich, insbesondere aber für Open Source Projekte, denn 
automatische Tests (insbesondere Regressionstests) erlauben es
Entwicklern sich bei der Änderung von ihnen unbekanntem Code sicher
zu fühlen, und ermutigt daruch experimentelle Entwicklung. Da es so
schwierig ist, eine Bruchstelle händich zu finden&mdash;man muss im
wesentlichen raten wo man etwas kapput gemacht haben könnte, und
verschiedene Versuche machen, um das Gegenteil zu beweisen&mdash;
erspart es dem Projekt eine <emphasis>Menge</emphasis> Zeit, 
möglichkeiten zu haben, um solche Bruchstellen automatisch zu
erkennen. Leute sind dadurch auch viel entspannter, wenn sie große
Schwaden von Code neu gestalten, und trägt auf lange Sicht entsprechend
zu der Wartbarkeit der Software bei.</para>

  <sidebar id="regression-testing">
  <title>Regressions Tests</title>

  <para><firstterm>Regressions Test</firstterm> (en. regression
  test) bedeutet, nach dem wiederauftauchen bereits behobener Fehler
  zu suchen. Der Sinn von Regressions Tests ist, die Wahrscheinlichkeit
  zu verinngern, dass Änderungen am Code die Software auf unerwartete
  weise kaputt machen wird. Wenn ein Software Projekt anfängt größer
  und komplizierter zu werden, nimmt die Wahrscheinlichkeit für solche
  unerwarteten Nebenwirkungen allmählich. Ein guter Aufbau kann die
  Geschwindigkeit mit der sie zunimmt veringern, kann das Problem aber
  nicht komplett beseitigen.</para>

  <para>Viele Projekte haben aufgrund dessen, eine 
  <firstterm>Testsreihe</firstterm> (en. test suite), eine separate
  Anwendung welche die Software des Projekts auf Arten aufruft, von
  denen man weiß, dass Sie in der Vergangenheit bestimmte Fehler
  aufgezeigt haben. Wenn die Testreihe es schafft einer dieser Fehler
  wieter auftauchen zu lassen, wird das als <firstterm>Regression
  </firstterm> bezeichnet, was soviel heißt wie, dass die Änderung von
  jemand einen vorher behobenen Bug wieder unbehoben gemacht hat.
  </para>

  <para>Siehe auch
  <ulink url="http://en.wikipedia.org/wiki/Regression_testing"/>.</para>

  </sidebar>

<para>Regressions Tests sind kein Allheilmittel. Zum einen, 
funktioniert es am besten, bei Anwendungen mit Schnittstellen für die
Kommandozeile. Software die vor allem durch graphische 
Benutzeroberflächen gesteuert wird, ist viel schwieriger programatisch
zu betreiben. Ein weiteres Problem ist, dass das Framework der
Testreihe oft ziemlich komplex sein kann, mit einer Lernkurve und einer
Wartungslast, für sich ganz alleine. Diese Komplexität zu reduzieren,
ist eines der nützlichsten Sachen, die Sie machen können, auch wenn es
vielleicht eine wesentliche Menge an Zeit in Anspruch nehmen kann. Je
einfacher es ist neue Tests zu der Testreihe hinzuzufügen, desto mehr
Entwickler werden es machen, und desto weniger Fehler werden es in die
fertige Version schaffen. Jede Mühe die aufgebracht wird, um das
Schreiben von Tests einfacher zu machen, wird im Verlaufe des Projekts
um ein Vielfaches zurückgezahlt werden.</para>

<para>Viele Projekte haben eine <firstterm>"Mache den Build nicht
Kaputt!"</firstterm> Regel, mit folgender Bedeutung: Machen Sie keinen
Commit, welches verhindert, dass die Software kompiliert oder läuft.
Die Person zu sein, welche den Build kaputt gemacht hat, ist meistens
eine Quelle leichter Peinlichkeit und Verippung. Projekte mit
Reihen von Regressionstests haben oft eine begleitende Regel: Mache
keinen Commit, der die Tests nicht besteht. Es ist am einfachsten zu
erkennen, wenn ein Test fehlschlägt, wenn die komplette Testreihe
automatisch, jede Nacht durchgeführt wird, und die Ergebnisse an die
Entwickler Verteiler oder einen gesonderten Verteiler für die Test
Ergebnisse, geschickt werden; was ein weiteres Beispiel für 
Automatisierung die sich lohnt.</para>

<para>Die meisten freiwilligen Entwickler sind bereit, die zusätzliche
Zeit zu investieren, um Regressionstests zu schreiben, so lange das Test
System verständlich und einfach im Umgang ist. Änderungen zusammen mit
Tests zu committen, wird als das verantwort Verhalten angesehen, und
es ist auch eine einfache Gelegenheit für die Zusammenarbeit: Oft 
teilen sich zwei Entwickler die Arbeit bei der Behebung eines Fehlers
auf, indem der eine den Fix schreibt, und der andere den Test. Der
letztere Entwickler kann oft sogar mehr Arbeit haben, und da es schon
weniger befriedigend ist einen Test zu schreiben als den Fehler
tatsächlich zu beheben, ist es zwingend notwendig, dass es nicht
schwieriger ist die Testreihe zu bearbeiten als es sein muss.</para>

<para>Manche Projekte gehen sogar noch weiter, und haben die
Anforderung, dass <emphasis>alle</emphasis> Bugfixes oder neue
Funktionen von Tests begleitet werden. Ob das eine gute Idee ist oder
nicht, hängt von vielen Faktoren ab: Die Natur der Software, die
Zusammenstellung der Entwicklermannschaft, und wie schwierig es ist die
Tests zu schreiben. Das CVS (<ulink url="http://www.cvshome.org/"/>)
Projekt, hat schon seit langem eine solche Regel. Es ist theoretisch
eine Gute Richtlinie, da CVS eine Software zur Versionsverwaltung und
desshalb sehr risikoscheu ist, in anbetracht der Möglichkeit die Daten
der Nutzer zu verunstalten oder falsch handzuhaben. In der Praxis ist
das Problem, dass die Regressions Testreihe von CVS eine einzige
riesige Shellscript Datei ist (witzigerweise mit dem Namen
<filename>sanity.sh</filename> <!-- alles klar Datei? -->), welche 
schwierig zu bearbeiten oder erweitern ist. Die schwierigkeit neue Tests
hinzu zu fügen, zusammen mit der Forderung, dass Patches von neuen Tests
begleitet werden bedeutet, dass CVS im wesentlichen vor Patches
abeschreckt. Als ich an CVS gearbeitet habe, sahe ich manche Leute die
anfingen an dem Code von CVS zu arbeiten und sogar Patches fertig zu
stellen, aber aufgaben als ihnen gesagt wurde, dass sie einen neuen Test
zu der <filename>sanity.sh</filename> mussten.</para>

<para>Es ist normal etwas mehr Zeit damit zu verbringen, einen neunen
Regressionstest zu schreiben, als an der Behebung des ursprünglichen
Fehlers. CVS trieb dieses Phänomen aber ins extreme: man konnte Stunden
bei dem Versuch verbringen, sein Test richtig zu gestalten, und es
trotzdem falsch machen, da es einfach zu viele unvorhersehbare
Komplexitäten gab, bei der Änderung einer 35.000 Zeilen lange Bourne
Shellscript Datei. Selbst langjährige Entwickler murrten, als sie einen
neuen Test hinzufügen mussten.</para>

<para>Diese Situation war weil wir alle nicht den Grad der
Automatisierung in Betracht gezogen hatten. Es stimmt zwar, dass der
wechsel auf ein echtes Test Framework&mdash;ob eine eigenanfertigung
oder eine fertige&mdash;eine riesige Anstrengung gewesen wäre
<footnote><para>Man sollte bedenken, dass es nicht notwendig gewesen
wäre alle Tests auf das neue Framework zu portieren; beide könnten
friedlich neben einander leben, und nur die geänderten Tests würden bei
Änderungen übernommen werden.</para></footnote>. Es zu unterlassen, hat
dem Projekt aber über die Jahre, viel mehr gekostet. Wieviele Bugfixes
und Funktionen sind heute <emphasis>nicht</emphasis> in CVS, aufgrund
der Behinderung durch eine umständliche Testreihe? Woe werden die genaue
Zahl nie erfahren, es sind aber sicherlich eine mehr, wie die Anzahl der
Bugfixes und Änderungen, auf denen die Entwickler hätten verzichten
müssen, um ein neues Testsystem zu entwickeln (oder ein vorher
existierendes zu integrieren). Die Aufgabe hätte eine endliche Zeit
beansprucht, wärend der Nachteil das derzeitige Testsystem weiter zu
benutzen, in alle Ewigkeit weitergehen wird, wenn nichts gemacht wird.
</para>

<para>Der Punkt ist nicht, dass die strikte Anforderungen, Tests
schreiben zu müssen schlecht ist, oder das es schlecht ist, wenn all
Ihre Tests in eine Bourne Shellscript Datei geschrieben werden. Es kann
herrlich funktionieren, je nachdem wie Sie es entwerfen und was es
testen muss. Das Wesentliche ist einfach, dass wenn das Testsystem zu
einer wesendlichen Behinderung für die Entwicklung wird, etwas getan
werden muss. Das gleiche gilt, für jede wiederkehrende Aufgabe, welches
sich zu einem Hinderniss oder Flaschenhals entwickelt.</para>

</sect3>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="users-to-volunteers">
<title>Behandeln Sie Jeden Nutzer, Wie Einen Möglichen 
Freiwilligen</title>

<para>Jede Interaktion mit einem Benutzer ist eine Gelegenheit, einen
neuen Freiwilligen zu bekommen. Wenn ein Nutzer sich die Zeit nimmt, auf
einem der Email Verteiler des Projekts, eine Nachricht zu schreiben,
oder einen Fehler zu melden, hat er sich bereits als jemand
gekennzeichnet, der ein größeres Potential zur Beteiligung hat, als die
meisten Nutzer (von denen das Projekt niemals hören wird). Greifen Sie
dieses Potential auf: Wenn er einen Fehler beschreibt, danken Sie ihn
für die Meldung und fragen Sie ihm, ob er es versuchen möchte es zu
beheben. Wenn geschrieben hat, um zu sagen, dass eine wichtige Frage in
der FAQ gefehlt hat, oder dass die Dokumentation der Anwendung auf
irgend eine Art unzureichend war, dann geben Sie das Problem zu
(angenommen, es existiert wirklich) und fragen Sie ihr ob er interesiert
wäre das fehlenden Material selber zu schreiben. Der Nutzer wird
natürlich die meiste Zeit ablehnen. Aber es kostet nicht viel zu fragen,
und jedes mal, wenn sie das tun, erinnert es die anderen Zuhörer in dem
Forum, dass eine Beteiligung an dem Projekt etwas ist, was jeder machen
kann.</para>

<para>Schränken Sie Ihre Ziele nicht darauf ein, neue Entwickler und
Authoren für die Dokumentation zu bekommen. Es zahlt sich zum Beispiel
auf lange sicht sogar aus, Leute zu trainieren, die gute Bug Meldungen
schreiben, so lange Sie nicht <emphasis>zu</emphasis> viel Zeit mit
jeder einzelnen Person verbringen, und sie in Zukunft weiterhin Bug
Meldungen schreiben&mdash;was eher wahrscheinlich ist, wenn sie bei der
ersten Meldung eine konstruktive Reaktion bekommen haben. Eine
konstruktive Reaktion muss nicht die Behebung eines Fehlers sein, auch
wenn dass immer ideal ist; es kann auch eine Anfrage nach weiteren
Informationen sein, oder gar nur eine Bestätigung, dass das Verhalten
<emphasis>tatsächlich</emphasis> ein Fehler ist. Menschen wollen
zugehört werden. Zweitrangig, wollen sie das ihre Fehler behoben werden.
Sie werden möglicherweise nicht immer letzteres zeitnahe geben können,
aber Sie (oder vielmehr das Projekt, als ganzes) kann ihnen ersteres
geben.</para>

<para>Eine Konsequenz hiervon ist, dass Enwickler keine Wut an Personen
auslassen sollten, die gut gemeinte aber vage Bug Meldungen gemacht 
haben. Sowas ärgert mich persönlich, ganz besonders; ich sehe Entwickler
die es immer wieder auf verschiedenen Open Source Email Verteilern
machen und den Schaden den es anrichtet greifbar. Irgend ein
unglückseliger Neuling schreibt eine nutzlosen Ticket:</para>

<blockquote>
   <para>Hallo, ich krieg Scanley nicht zum laufen. Jedes mal wenn
   ich es starte, gibt es einfach einen Fehler. Hat jemand schon 
   dieses Problem gehabt?</para>
</blockquote>

<para>Ein Entwickler&mdash;der diese Art von Ticket schon thausend mal
gesehen hat, und kurz bedenkt, dass das beim Neuling nicht der Fall 
ist&mdash;wird folgendermaßen antworten:</para>

<blockquote>
   <para>Was sollen wir eigentlich mit so wenig Informationen 
   machen, meine Fresse. Gib uns wenigstens ein paar Details, wie
   die Version von Scanley, dein Betriebssystem, und die
   Fehlermeldung.</para>
</blockquote>

<para>Dieser Entwickler hat es nicht geschafft, die Sache aus der Sicht
des Nutzers zu sehen, und auch zu bedenken, welche Auswirkung eine
solche Reaktion auf alle <emphasis>anderen</emphasis> Personen die dem
Wechsel zuschauen, haben könnte. Ein Nutzer der keine Programmier
Erfahrung hat, und keine vorhergehende Erfahrung mit der Meldung von
Fehler, wird nicht wissen, wie man einen Ticket schreibt. Wie behandelt
man so eine Person richtig? Schulen Sie ihn! Und machen Sie es derart,
dass sie wieder für mehr kommen:</para>

<blockquote>
   <para>Tut mir leid, dass du Probleme hast. Wir werden mehr
   Informationen brauchen, um herauszufinden, was da los ist. 
   Sag uns bitte deine Version von Scanley, dein Betriebssystem,
   und den genauen Text der Fehlermeldung. Das beste was du
   machen kannst ist, eine Abschrift der Befehle zu geben, die
   du ausgeführt hast, und die daraus resultierende Ausgabe.
   Siehe http://www.scanley.org/wie_man_einen_bug_meldet.html
   für weiteres.</para> 
</blockquote>

<para>Diese Art zu reagieren, ist sehr viel effektiver dabei, die
erforderliche Information aus dem Benutzer heraus zu bekommen, da es
entsprechend der Sicht des Nutzers geschrieben ist. Erstens drückt es
Sympathie aus: <emphasis>Du hattest ein Problem; wir leiden mit dir
</emphasis>.  (Das ist nicht nötig in jeder Rückmeldung zu einer Bug
Meldung; es hängt davon ab, wie schwerwiegend das Problem ist, und wie
verärgert er zu sein scheint.) Zweitens, sagt es ihm wie sie einen neuen
Ticket schreiben soll, damit es genügend Details enthällt, um nützlich
zu sein, anstatt ihn dafür herabzusetzen, dass er es nicht
weiß&mdash;zum Beispiel erkennen viele Nutzer nicht das "Zeige uns den
Fehler" in wirklichkeit "Zeige uns den genauen Text des Fehlers, ohne
etwas weg zu lassen oder zu kürzen" bedeutet. Wenn Sie zum ersten mal
mit einem solchen Nutzer arbeiten, müssen Sie im Bezug darauf explizit
sein. Zuletzt, gibt es einen Hinweis auf eine biel detalliertere und
komplette Anleitung, um Fehler zu melden. Wenn Sie erfolgreich mit dem
Nutzer Kontakt aufgenommen haben, wird er sich oft die Zeit nehmen,
dieses Dokument zu lesen und sich danach zu richten. Das bedeutet
natürlich, dass Sie das Dockument im voraus bereit haben müssen. Es
sollte klare Anweisungen geben, welche Art von Information Ihre
Entwicklermannschaft in jedem Ticket sehen möchte. Im Idealfall, sollte
es sich mit der Zeit auch enwickeln, entsprechend der bestimmten Art von
fehlenden Informationen und Falschmeldungen die Nutzer bei Ihrem Projekt
eher machen.</para>

<para>Die Anleitung um Fehler zu melden sind beim Subversion Projekt,
eine relativ standardmäßiges Beispiel dieser Form (siehe <xref 
linkend="bug-reporting"/>). Beachten Sie, wie sie mit einer Einladung,
einen Patch für den Bug, bereit zu stellen aufhören. Das liegt nicht
daran, dass solch eine Einladung zu einem besseren Verhältniss von
Patches zu Bugs führen wird&mdash;die meisten Nutzer die in der Lage
sind Fehler zu beheben, wissen bereits, dass ein Patch begrüßt wird, und
müssen das nicht gesagt bekommen. Der echte Sinn dieser Einladung ist,
für alle Leser, insbesondere solchen, die neu zu dem Projekt oder freier
Software im allgemeinen sind, zu betonen, dass das Projekt von
freiwilligen Beiträgen lebt. Im gewissen Sinne, sind die derzeitigen
Entwickler des Projekts, nicht mehr dafür verantwortlich, den Bug zu
beheben, als die Person, die ihn gemeldet hat. Das ist ein wichtiger
Punkt, mit dem viele neue Nutzer nicht vertraut sein werden. Wenn sie es
einmal begreifen, werden sie eher dabei helfen, den Fix zu erstellen,
wenn auch nicht indem sie Code beitragen, sondern indem sie eine
Anleitung geben, um die Fehler zu reproduzieren, oder indem sie
anbieten, die Patches welche andere einreichen Testen. Das Ziel ist,
jeden Nutzer klar zu machen, dass es keinen <emphasis>immanenten
</emphasis> Unterschied gibt, zwischen ihm und den Personen die an dem
Projekt arbeiten&mdash;dass es eine Frage davon ist, wie viel Zeit und
Mühe man hinein steckt, und keine davon wer man ist.</para>

<para>Die Mahnung dagegen, wütend zu antworten, gilt nicht für
unhöfliche Nutzer. Ab und zu werden Fehler gemeldet oder beschwerden
eingereicht, die unabhängig von ihrem Informationsgehalt, eine
spöttische Verachtung für das Projekt, aufgrund von irgend einem Mangel.
Solche Personen sind abwechselnd beleidigend und schmeichelnd, wie diese 
Person, die an dem Subversion Verteiler schrieb:</para>

<blockquote>
<para>Warum ist es, dass nach fast sechs Tagen immer noch keine
Binärdateien für Windows hochgeladen wurden?!? Es ist immer wieder das
gleiche und es ist ziemlich frustrierend. Warum werden diese sachen
nicht automatisiert, damit sie sofort verfügbar wären?? Wenn Ihr einen
"RC" Build macht, denke ich Eure Idee ist, dass Ihr wollt, dass Nutzer
den Build testen, tretzdem gebt ihr aber keine möglichkeit das zu
machen. Warum soll man überhaupt eine einweich Phase haben, wenn ihr
keine möglichkeit zum testen gibt??</para>
</blockquote>

<para>Die anfängliche Reaktion zu dieser relativ flamehaften Nachticht
war überraschend zurückhaltend: Man wies darauf hin, dass das Projekt
eine Richtlinier hatte, keine offiziellen Binärdateien zu
veröffentlichen, und man sagte ihm, mit unterschiedlichem Grad an
genervtheit, dass er sich freiwillig melden sollte sie zu erstellen,
wenn sie ihm so wichtig wären. Ob Sie es glauben oder nicht, seine
nächste Nachricht fing mit diesen Zeilen an:</para>

<blockquote>
<para>Als aller erstes, will ich sagen, dass ich Subversion klasse finde
und die Anstrenungen die damit verbunden sind wirklich zu schätzen weiß.
[...]</para>
</blockquote>

<para>...und ging dann <emphasis>wieder</emphasis> daran, das Projekt
dafür zu beschimpfen, dass es keine Binärdateien bereitstellte, wärend
er sich immer noch nicht freiwillig meldete, irgend etwas dagegen zu
machen. Danach wurde er von ca. 50 leuten auseinander genommen und ich
kann nicht sagen, dass es mir wirklich was ausmachte. Die
"Null-Toleranz" Richtlinie im bezug auf Beleidigungen die in
<xref linkend="prevent-rudeness"/><phrase output="printed"> im Kapitel 
<xref linkend="getting-started"/></phrase> verfechtet wurde, gilt für
Personen die mit dem das Projekt eine fortbestehende Interaktion hat
(oder haben möchte). Wenn jemand es aber von Anfang an klar macht, das
er ein Springbrunnen für Galle sein wird, hat es keinen Sinn ihn
wilkommen zu heißen.</para>

<para>Solche Situationen sind zum Glück relativ selten, und sie sind
wesentlich seltener bie Projekten, die sich die Mühe machen mit Nutzern
ab dem ersten Dialog, auf eine konstruktive und zuvorkommende Art zu 
befassen.</para>

</sect2>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="share-management">
<title>Teilen Sie Sowohl Verwaltungsaufgaben Als Auch Technische
Aufgaben</title>

<para>Teilen Sie sowohl die Bürde der Verwaltung als auch die technische
Bürde, beim Betrieb von dem Projekt. Wärend ein Projekt komplexer wird,
dreht sich mehr und mehr Arbeit darum Menschen und den Informationsfluss
zu verwalten. Es gibt keinen Grund diese Bürde nicht zu teilen, und sie
zu teilen, erfordert auch nicht unbedingt eine Hierarchie von oben 
herab&mdash;was in der Praxis meist passiert, ist eher eine Peer-to-Peer
Topologie, als eine militäriche Befehlsstruktur.</para>

<para>Manchmal sind die Rollen der Verwaltung formalisiert, und manchmal
passieren sie spontan. In dem Subversion Projekt, haben wir jemand der
die Patches verwaltet, jemand für Übersetzungen, die Dokumentation,
Tickets (wenn auch inoffiziell), und jemand der neue Versionen
verwaltet. Manche dieser Rollen wurden Bewusst von und eingeführt,
andere kamen von ganz alleine; wärend das Projekt wächst, erwarte ich
das mehr Rollen hinzugefügt werden. Unter werden wir diese und ein paar
andere Rollen im Detail untersuchen (außer den Versionsverwalter,
welcher bereits in <xref linkend="release-manager"/> und 
<xref linkend="release-owner"/><phrase output="printed"> im
vorhergehenden Kapitel</phrase>).</para>

<para>Wärend Sie die Rollen Beschreibungen lesen, achten Sie darauf,
dass keiner von ihnen eine exclusive Kontrotte über den entsprechenden
Bereich erfordert. Der Ticket Verwalter hindert andere nicht daran,
Änderungen in der Ticket Datenbank zu machen, der FAQ Verwalter besteht
nicht darauf, der einzige zu sein, der die FAQ bearbeitet, und so
weiter. Bei diesen Rollen geht es immer um Verantwortung, ohne eine
Monopolstellung. Ein wichtiger Teil der Arbeit eines Verwalters von
einem Bereich ist zu bemerken, wann ander in dem Bereich arbeiten, und
sie zu trainieren, sachen so zu erledigen, wie es der Verwalter macht,
damit die nebeneinander laufenden Anstrengungen einander stärken,
anstatt mit einander in Konflikt zu treten. Die Verwalter der Bereich
sollten auch die Abläufe nach denen sie ihre Arbeit erledigen
dokumentieren, damit wenn einer geht, jemand anderes sie gleich wieder
aufnehmen kann.</para>

<para>Manchmal gibt es einen Konflikt: Zwei oder mehr Personen wollen
die gleiche Rolle. Es gibt keine eine richtige Art das zu handhaben. Sie
könnten einfach vorschlagen, dass jeder Freiwillige einen Vorschlag
(eine "Bewerbung") einreicht, und alle commit Berechtigten darüber
abstimmen lassen, was am besten ist. Das ist aber umstendlich un unter
Umständen unbehaglich. Ich find es ist eine besser Technik die
Kandidaten einfach darum zu bitten, es unter sich aus zu machen. Sie
werden das meistens schaffen und mit dem Ergebnis zufriedener sein als
wenn die Entscheidung von Außen für sie getroffen worden wäre.</para>

<sect2 id="patch-manager">
<title>Patch Verwalter</title>

<para>In einem freien Software Projekt, welches eine Menge Patches
erhällt, kann es ein Albtraum sein, den Überblick darüber zu behalten,
welche Patches angekommen sind un wie über sie entschieden wurde, ganz
besonders wenn es auf eine dezentralisierte Art gemacht wird. Die
meisten Patches treffen über den Email Verteiler für Entwickler des
Projkets ein (obwohl manche zuerst in dem Ticket System auftauchen, oder
auf externen Webseiten), und es gibt mehrere Verschiedene Routen, die
ein Patch nehmen kann, nach seiner Ankunft.</para>

<para>Manchmal schaut sich jemand einen Patch an, und schickt ihn wieder
zurück an den ursprünglichen Author, um ihn aufzuräumen. Das führt
normalerweise zu einem sich wiederholenden Vorgang&mdash;alle sichtbar
auf dem Email Verteiler&mdash;bei dem der ursprüngliche Author die
überarbeiteten Versionen des Patches wieder zurück schickt, bis der
Überprüfende nichts mehr zu kritisieren hat. Es ist nicht immer leicht
zu erkennen, wann dieser Vorgang fertig ist: Wenn der Überprüfende den
Patch committed, dann ist er eindeutig vorbei. Wenn er es aber nicht
tut, kann es daran liegen, dass er einfach nicht genügend Zeit hatte,
oder er selber keine commit Berechtigung hat, und keine anderen
Entwickler dazu überreden konnte es zu machen.</para>

<para>Eine weitere häufige Antwort auf einen Patch ist eine freilaufende
Diskussion, nicht unbedingt über den Patch selber, sondern darüber, ob
das Konzept hinter dem Patch gut ist. Der Patch kann zum Beispiel, einen
Fehler beheben, wenn das Projekt es aber bevorzugt, den Fehler auf eine
andere Art zu beheben, als Teil der Lösung einer algemeineren Klasse von
Problemen. Oft ist das nicht im Vorraus bekannt, und es ist der Patch,
der die Entdeckung anregt.</para>

<para>Gelegentlich, wird ein eingereichter Patch von völliger Stille
empfangen. Normalerweise liegt das daran, dass <emphasis>at that 
moment</emphasis> kein Entwickler die Zeit hat um den Patch unter die
Lupe zu nemen, also hofft jeder, dass jemand anderes es übernimmt. Da es
keine bestimmte Grenze gibt, wie lang jede Person wartet bis jemand
anderes den Ball ins rollen bringt, und in der Zwischenzeit immer andere
Prioritäten auftauchen, passiert es sehr leicht, dass ein Patch durchs
Netz schlüpft, ohne das irgend eine einzelne Person das gewollte hat.
Das Projekt kann auf diese Art einen Nützlichen Patch verpassen, und es
gibt auch andere schädliche Nebenwirkungen: Es ist entmutigend für den
Author, der Arbeit in den Patch investiert hat, und es lässt das Projekt
ziemlich danach ausschauen, als wäre es nicht entfremdet, ganz besonders
im Bezug auf andere die Patches schreiben.</para>

<para>Die Aufgabe des Patch Verwalters ist sicherzustellen, dass Patches
nicht "durchs Netz schlüpfen". Das wird erreicht, indem jeder Patch
bis zu irgend einem stabilen Zustand verfolgt wird. Der Patch Verwalter
beobachtet jeden Thread auf den Email Verteiler, welches sich aus der
Einreichung eines Patches ergibt. Wenn es mit einem Commit vom Patch 
endet, macht er gar nichts. Wenn es in einer Schleife der Überprüfung
und Überarbeitung geht, welche in einer finalen Version endet, aber
keinen Commit, schreibt er einen Ticket, der auf die finale Version
zeigt, sowie auf dem Thread der sich darum dreht, damit es eine
permanente Aufzeichnung für Entwickler gibt, die daran später
anschließen wollen. Wenn der Patch ein bereits bestehenden Ticket
adressiert, schreibt er einen Kommentar dazu in dem Ticket, anstatt
einen neuen auf zu machen, mit der relebanten Information.</para>

<para>Wenn ein Patch überhaupt keine Reaktion bekommt, wartet der Patch
Verwalter ein paar Tage, greift es dann auf indem er fragt, ob irgen
jemand es sich anschauen wird. Darauf gibt es für gewöhnlich eine
Reaktion: Ein Entwickler kann erklären, dass er nicht denkt, dass der
Patch angewandt werden soll, und Gründe geben, warum das so ist, oder er
kann es sich anschauen, worauf einer der vorher beschriebenen Wege
eingeschlagen wird. Wenn es immer noch keine Antwort gibt, wird der
Patch verwalter unter Umständen keinen Ticket für den Patch schreiben,
je nachdem, wie er es für richtig hällt, zumindest hat der ursprüngliche
Author <emphasis>irgend eine</emphasis> Antwort erhalten.</para>

<para>Einen Patch Verwalter zu haben, hat der Entwicklermannschaft von
Subversion eine Menge Zeit und geistige Energie erspart. Ohne eine
designierte Person der die Verantwortung auf sich nimmt, müsste sich
jeder Entwickler die ganze Zeit ständig darüber sorgen machen, "Wenn ich
nicht die Zeit dazu habe, jetzt auf diesen Patch zu antworten, kann ich
mich darauf verlassen, dass jemand anderes es macht? Sollte ich
versuchen es aus irgend welchen Gründen im Auge zu behalten, dann würden
wir unnötig unsere Anstrenungen Verdoppeln". Der Patch Verwalter
entfernt die zweite Mutmaßung aus der Situation. Jeder Entwickler kann
die Entscheidung treffen, die für ihn in dem Moment wo er den Patch zum
ersten mal sieht, richtig ist. Wenn er mit einer Überprüfung daran 
anschließen möchte, kann er das tun&mdash;der Patch Verwalter wird sein
Verhalten entsprechend anpassen. Wenn er den Patch komplett ignorieren
will, ist das auch in Ordnung; der Patch Verwalter wird dafür sorgen,
dass es nicht in Vergessenheit gerät.</para>

<para>Weil dieses System nur dann funktioniert, wenn man sich darauf 
verlassen kann dass der Patch Verwalter ausnahmslos da ist, sollte die
Rolle formal vergeben werden. In Subversion, bewarben wir um die Stelle
auf die Email Verteiler für Entwickler und den für Benutzer, bekamen
mehrere Freiwillige, und nahmen den ersten der geantwortet hat. Als die
Person abtreten musste (siehe 
<xref linkend="transitions"/><phrase output="printed"> später in diesem
Kapitel</phrase>), machten wird das gleiche nochmal. Wir haben es nie
versucht mehrere Personen die Rolle teilen zu lassen, da überschüssige 
Kommunikation die zwischen ihnen nötig wäre; bei einer sehr hohen Anzahl
an Patches könnte einen mehrköpfigen Patch Verwalter aber vielleicht 
Sinn machen.</para>

</sect2>

<sect2 id="translation-manager">
<title>Übersetzungs Verwalter</title>

<para>In software projects, "translation" can refer to two very
different things.  It can mean translating the software's
documentation into other languages, or it can mean translating the
software itself&mdash;that is, having the program display errors and
help messages in the user's preferred language.  Both are complex
tasks, but once the right infrastructure is in place, they are largely
separable from other development.  Because the tasks are similar in
some ways, it may make sense (depending on your project) to have a
single translation manager handle both, or it may be better to have
two different managers.</para>

<para>In the Subversion project, we have one translation manager
handle both.  He does not actually write the translations himself, of
course&mdash;he may help out on one or two, but as of this writing, he
would need to speak ten languages (twelve counting dialects) in order
to work on all of them!  Instead, he manages teams of volunteer
translators: he helps them coordinate among each other, and he
coordinates between the teams and the rest of the project.</para>

<para>Part of the reason the translation manager is necessary is that
translators are a different demographic from developers.  They
sometimes have little or no experience working in a version control
repository, or indeed with working as part of a distributed volunteer
team at all.  But in other respects they are often the best kind of
volunteer: people with specific domain knowledge who saw a need and
chose to get involved.  They are usually willing to learn, and
enthusiastic to get to work.  All they need is someone to tell them
how.  The translation manager makes sure that the translations happen
in a way that does not interfere unnecessarily with regular
development.  He also serves as a sort of representative of the
translators as a unified body, whenever the developers must be
informed of technical changes required to support the translation
effort.</para>

<para>Thus, the position's most important skills are diplomatic, not
technical.  For example, in Subversion we have a policy that all
translations should have at least two people working on them, because
otherwise there is no way for the text to be reviewed.  When a new
volunteer shows up offering to translate Subversion to, say, Malagasy,
the translation manager has to either hook him up with someone who
posted six months ago expressing interest in doing a Malagasy
translation, or else politely ask the volunteer to go
find <emphasis>another</emphasis> Malagasy translator to work with as
a partner.  Once enough people are available, the manager sets them up
with the proper kind of commit access, informs them of the project's
conventions (such as how to write log messages), and then keeps an eye
out to make sure they adhere to those conventions.</para>

<para>Conversations between the translation manager and the
developers, or between the translation manager and translation teams,
are usually held in the project's original language&mdash;that is, the
language from which all the translations are being made.  For most
free software projects, this is English, but it doesn't matter what it
is as long as the project agrees on it.  (English is probably best for
projects that want to attract a broad international development
community, though.)</para>

<para>Conversations <emphasis>within</emphasis> a particular
translation team usually happen in their shared language, however, and
one of the other tasks of the translation manager is to set up a
dedicated mailing list for each team.  That way the translators can
discuss their work freely, without distracting people on the project's
main lists, most of whom would not be able to understand the
translation language anyway.</para>

  <sidebar id="i7n">
  <title>Internationalization Versus Localization</title>
  
  <para><firstterm>Internationalization</firstterm>
  (<firstterm>I18N</firstterm>) and <firstterm>localization</firstterm>
  (<firstterm>L10N</firstterm>) both refer to the process of adapting
  a program to work in linguistic and cultural environments other than
  the one for which it was originally written.  The terms are often
  treated as interchangeable, but in fact they are not quite the same
  thing.  As <ulink url="http://en.wikipedia.org/wiki/G11n"/>
  writes:</para>

  <blockquote>
     <para>The distinction between them is subtle but important:
     Internationalization is the adaptation of products
     for <emphasis>potential</emphasis> use virtually everywhere, while
     localization is the addition of special features for use in
     a <emphasis>specific</emphasis> locale.</para>
  </blockquote>

  <para>For example, changing your software to losslessly handle
  Unicode (<ulink url="http://en.wikipedia.org/wiki/Unicode"/>) text
  encodings is an internationalization move, since it's not about a
  particular language, but rather about accepting text from any of a
  number of languages.  On the other hand, making your software print
  all error messages in Slovenian, when it detects that it is running
  in a Slovenian environment, is a localization move.</para>

  <para>Thus, the translation manager's task is principally about
  localization, not internationalization.</para>
  
  </sidebar>

</sect2>

<sect2 id="documentation-manager">
<title>Documentation Manager</title>

<para>Keeping software documentation up-to-date is a never-ending
task.  Every new feature or enhancement that goes into the code has
the potential to cause a change in the documentation.  Also, once the
project's documentation reaches a certain level of completeness, you
will find that a lot of the patches people send in are for the
documentation, not for the code.  This is because there are many more
people competent to fix bugs in prose than in code: all users are
readers, but only a few are programmers.</para>

<para>Documentation patches are usually much easier to review and
apply than code patches.  There is little or no testing to be done,
and the quality of the change can be evaluated quickly just by review.
Since the quantity is high, but the review burden fairly low, the
ratio of administrative overhead to productive work is greater for
documentation patches than for code patches.  Furthermore, most of the
patches will probably need some sort of adjustment, in order to
maintain a consistent authorial voice in the documentation.  In many
cases, patches will overlap with or affect other patches, and need to
be adjusted with respect to each other before being committed.</para>

<para>Given the exigencies of handling documentation patches, and the
fact that the code base needs to be constantly monitored so the
documentation can be kept up-to-date, it makes sense to have one
person, or a small team, dedicated to the task.  They can keep a
record of exactly where and how the documentation lags behind the
software, and they can have practiced procedures for handling large
quantities of patches in an integrated way.</para>

<para>Of course, this does not preclude other people in the project
from applying documentation patches on the fly, especially small ones,
as time permits.  And the same patch manager (see
<xref linkend="patch-manager"/><phrase output="printed"> earlier
in this chapter</phrase>) can track both code and
documentation patches, filing them wherever the development and
documentation teams want them, respectively.  (If the total quantity of
patches ever exceeds one human's capacity to track, though, switching
to separate patch managers for code and documentation is probably a
good first step.)  The point of a documentation team is to have people
who think of themselves as responsible for keeping the documentation
organized, up-to-date, and consistent with itself.  In practice, this
means knowing the documentation intimately, watching the code base,
watching the changes
<emphasis>others</emphasis> commit to the documentation, watching for
incoming documentation patches, and using all these information
sources to do whatever is necessary to keep the documentation
healthy.</para>

</sect2>

<sect2 id="issue-manager">
<title>Issue Manager</title>

<para>The number of issues in a project's bug tracker grows in
proportion to the number of people using the software.  Therefore,
even as you fix bugs and ship an increasingly robust program, you
should still expect the number of open issues to grow essentially
without bound.  The frequency of duplicate issues will also increase,
as will the frequency of incomplete or poorly described issues.</para>

<para>Issue managers help alleviate these problems by watching what
goes into the database, and periodically sweeping through it looking
for specific problems.  Their most common action is probably to fix up
incoming issues, either because the reporter didn't set some of the
form fields correctly, or because the issue is a duplicate of one
already in the database.  Obviously, the more familiar an issue
manager is with the project's bug database, the more efficiently she
will be able to detect duplicate issues&mdash;this is one of the main
advantages of having a few people specialize in the bug database,
instead of everyone trying to do it <foreignphrase>ad
hoc</foreignphrase>.  When the group tries to do it in a decentralized
manner, no single individual acquires a deep expertise in the content
of the database.</para>

<para>Issue managers can also help map between issues and individual
developers.  When there are a lot of bug reports coming in, not every
developer may read the issue notification mailing list with equal
attention.  However, if someone who knows the development team is
keeping an eye on all incoming issues, then she can discreetly direct
certain developers' attention to specific bugs when appropriate.  Of
course, this has to be done with a sensitivity to everything else
going on in development, and to the recipient's desires and
temperament.  Therefore, it is often best for issue managers to be
developers themselves.</para>

<para>Depending on how your project uses the issue tracker, issue
managers can also shape the database to reflect the project's
priorities.  For example, in Subversion we schedule issues into
specific future releases, so that when someone asks "When will bug X
be fixed?" we can say "Two releases from now," even if we can't give
an exact date.  The releases are represented in the issue tracker as
target milestones, a field available in
IssueZilla.<footnote><para>IssueZilla is the issue tracker we use; it
is a descendant of BugZilla.</para></footnote> As a rule, every
Subversion release has one major new feature and a list of specific
bug fixes.  We assign the appropriate target milestone to all the
issues planned for that release (including the new feature&mdash;it
gets an issue too), so that people can view the bug database through
the lens of release scheduling.  These targets rarely remain static,
however.  As new bugs come in, priorities sometimes get shifted
around, and issues must be moved from one milestone to another so that
each release remains manageable.  This, again, is best done by people
who have an overall sense of what's in the database, and how various
issues relate to each other.</para>

<para>Another thing issue managers do is notice when issues become
obsolete.  Sometimes a bug is fixed accidentally as part of an
unrelated change to the software, or sometimes the project changes its
mind about whether a certain behavior is buggy.  Finding obsoleted
issues is not easy: the only way to do it systematically is by making
a sweep over all the issues in the database.  Full sweeps become less
and less feasible over time, however, as the number of issues grows.
After a certain point, the only way to keep the database sane is to use a
divide-and-conquer approach: categorize issues immediately on arrival
and direct them to the appropriate developer's or team's attention.
The recipient then takes charge of the issue for the rest of its
lifetime, shepherding it to resolution or oblivion as necessary.  When
the database is that large, the issue manager becomes more of an
overall coordinator, spending less time looking at each issue herself
and more time getting it into the right person's hands.</para>

</sect2>

<sect2 id="faq-manager">
<title>FAQ Manager</title>

<para>FAQ maintenance is a surprisingly difficult problem.  Unlike
most other documents in a project, whose content is planned out in
advance by the authors, a FAQ is a wholly reactive document (see
<xref linkend="starting-a-faq"/>).  No matter how big it gets, you
still never know what the next addition will be.  And because it is
always added to piecemeal, it is very easy for the document as a whole
to become incoherent and disorganized, and even to contain duplicate
or semi-duplicate entries.  Even when it does not have any obvious
problems like that, there are often unnoticed interdependencies
between items&mdash;links that should be made but aren't&mdash;because
the related items were added a year apart.</para>

<para>The role of a FAQ manager is twofold.  First, she maintains the
overall quality of the FAQ by staying familiar with at least the
topics of all the questions in it, so that when people add new items
that are duplicates of, or related to, existing items, the appropriate
adjustments can be made.  Second, she watches the project mailing
lists and other forums for recurring problems or questions, and to
write new FAQ entries based on this input.  This latter task can be
quite complex: one must be able to follow a thread, recognize the core
questions raised in it, post a proposed FAQ entry, incorporate
comments from others (since it's impossible for the FAQ manager to be
an expert in every topic covered by the FAQ), and sense when the
process is finished so the item can at last be added.</para>

<para>The FAQ manager usually also becomes the default expert in FAQ
formatting.  There are a lot of little details involved in keeping a
FAQ in shape (see
<xref linkend="all-as-archives"/><phrase output="printed"> in
<xref linkend="communications"/></phrase>); when random
people edit the FAQ, they will sometimes forget some of these details.
That's okay, as long as the FAQ manager is there to clean up after
them.</para>

<para>Various free software is available to help with the process of
FAQ maintenance.  It's fine to use it, as long as it doesn't
compromise the quality of the FAQ, but beware of over-automation.
Some projects try to fully automate the process of FAQ maintenance,
allowing everyone to contribute and edit FAQ items in a manner similar
to a wiki (see <xref linkend="wikis"/><phrase output="printed">
in <xref linkend="technical-infrastructure"/></phrase>).  I've
seen this happen particularly with Faq-O-Matic
(<ulink url="http://faqomatic.sourceforge.net/"/>), though it may be
that the cases I saw were simply abuses that went beyond what
Faq-O-Matic was originally intended for.  In any case, while complete
decentralization of FAQ maintenance does reduce the workload for the
project, it also results in a poorer FAQ.  There's no one person with
a broad view of the entire FAQ, no one to notice when certain items
need updating or become obsolete entirely, and no one keeping watch for
interdependencies between items.  The result is a FAQ that often fails
to provide users what they were looking for, and in the worst cases
misleads them.  Use whatever tools you need to to maintain your
project's FAQ, but never let the convenience of the tools seduce you
into compromising the quality of the FAQ.</para>

<para>See Sean Michael Kerner's article, <citetitle>The FAQs on
FAQs</citetitle>, at
<ulink url="http://osdir.com/Article1722.phtml"/>, for descriptions
and evaluations of open source FAQ maintenance tools.</para>

</sect2>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="transitions">
<title>Transitions</title>

<para>From time to time, a volunteer in a position of ongoing
responsibility (e.g., patch manager, translation manager, etc.) will
become unable to perform the duties of the position.  It may be
because the job turned out to be more work than he anticipated, or it
may be due to completely external factors: marriage, a new baby, a new
employer, or whatever.</para>

<para>When a volunteer gets swamped like this, he usually doesn't
notice it right away.  It happens by slow degrees, and there's no
point at which he consciously realizes that he can no longer fulfill
the duties of the role.  Instead, the rest of the project just doesn't
hear much from him for a while.  Then there will suddenly be a flurry
of activity, as he feels guilty for neglecting the project for so long
and sets aside a night to catch up.  Then you won't hear from him for
a while longer, and then there might or might not be another flurry.
But there's rarely an unsolicited formal resignation.  The volunteer
was doing the job in his spare time, so resigning would mean openly
acknowledging to himself that his spare time is permanently reduced.
People are often reluctant to do that.</para>

<para>Therefore, it's up to you and the others in the project to
notice what's happening&mdash;or rather, not happening&mdash;and to
ask the volunteer what's going on.  The inquiry should be friendly and
100% guilt-free.  Your purpose is to find out a piece
of information, not to make the person feel bad.  Generally, the
inquiry should be visible to the rest of the project, but if you know
of some special reason why a private inquiry would be better, that's
fine too.  The main reason to do it publicly is so that if the
volunteer responds by saying that he won't be able to do the job
anymore, there's a context established for your
<emphasis>next</emphasis> public post: a request for a new volunteer
to fill that role.</para>

<para>Sometimes, a volunteer is unable to do the job he's taken on,
but is either unaware or unwilling to admit that fact.  Of course,
anyone may have trouble at first, especially if the responsibility is
complex.  However, if someone just isn't working out in the task he's
taken on, even after everyone else has given all the help and
suggestions they can, then the only solution is for him to step aside
and let someone new have a try.  And if the person doesn't see this
himself, he'll need to be told.  There's basically only one way to
handle this, I think, but it's a multistep process and each step is
important.</para>

<para>First, make sure you're not crazy.  Privately talk to others in
the project to see if they agree that the problem is as serious as you
think it is.  Even if you're already positive, this serves the purpose
of letting others know that you're considering asking the person to
step aside.  Usually no one will object to that&mdash;they'll just be
happy you're taking on the awkward task, so they don't have to!</para>

<para>Next, <emphasis>privately</emphasis> contact the volunteer in
question and tell him, kindly but directly, about the problems you
see.  Be specific, giving as many examples as possible.  Make sure to
point out how people had tried to help, but that the problems
persisted without improving.  You should expect this email to take a
long time to write, but with this sort of message, if you don't back
up what you're saying, you shouldn't say it at all.  Say that you
would like to find a new volunteer to fill the role, but also point
out that there are many other ways to contribute to the project.  At
this stage, don't say that you've talked to others about it; nobody
likes to be told that people were conspiring behind his back.</para>

<para>There are a few different ways things can go after that.  The
most likely reaction is that he'll agree with you, or at any rate not
want to argue, and be willing to step down.  In that case, suggest
that he make the announcement himself, and then you can follow up with
a post seeking a replacement.</para>

<para>Or, he may agree that there have been problems, but ask for a
little more time (or for one more chance, in the case of discrete-task
roles like release manager).  How you react to that is a judgement
call, but whatever you do, don't agree to it just because you feel
like you can't refuse such a reasonable request.  That would prolong
the agony, not lessen it.  There is often a very good reason to refuse
the request, namely, that there have already been plenty of chances,
and that's how things got to where they are now.  Here's how I put it
in a mail to someone who was filling the release manager role but was
not really suited for it:</para>

<blockquote>
<screen>
&gt; If you wish to replace me with some one else, I will gracefully
&gt; pass on the role to who comes next.  I have one request, which
&gt; I hope is not unreasonable.  I would like to attempt one more
&gt;  release in an effort to prove myself.

I totally understand the desire (been there myself!), but in
this case, we shouldn't do the "one more try" thing.

This isn't the first or second release, it's the sixth or
seventh... And for all of those, I know you've been dissatisfied
with the results too (because we've talked about it before).  So
we've effectively already been down the one-more-try route.
Eventually, one of the tries has to be the last one... I think
[this past release] should be it.
</screen>
</blockquote>

<para>In the worst case, the volunteer may disagree outright.  Then
you have to accept that things are going to be awkward and plow ahead
anyway.  Now is the time to say that you talked to other people about
it (but still don't say who until you have their permission, since
those conversations were confidential), and that you don't think it's
good for the project to continue as things are.  Be insistent, but
never threatening.  Keep in mind that with most roles, the transition
really happens the moment someone new starts doing the job,
<emphasis>not</emphasis> the moment the old person stops doing it.
For example, if the contention is over the role of, say, issue
manager, at any point you and other influential people in the project
can solicit for a new issue manager.  It's not actually necessary that
the person who was previously doing it stop doing it, as long as he
does not sabotage (deliberately or otherwise) the efforts of the new
volunteer.</para>

<para>Which leads to a tempting thought: instead of asking the person
to resign, why not just frame it as a matter of getting him some help?
Why not just have two issue managers, or patch managers, or whatever
the role is?</para>

<para>Although that may sound nice in theory, it is generally not a
good idea.  What makes the manager roles work&mdash;what makes them
useful, in fact&mdash;is their centralization.  Those things that can
be done in a decentralized fashion are usually already being done that
way.  Having two people fill one managerial role introduces
communications overhead between those two people, as well as the
potential for slippery displacement of responsibility ("I thought you
brought the first aid kit!"  "Me?  No, I thought
<emphasis>you</emphasis> brought the first aid kit!").  Of course,
there are exceptions.  Sometimes two people work extremely well
together, or the nature of the role is such that it can easily be
spread across multiple people.  But these are not likely to be of much
use when you see someone flailing in a role he is not suited for.  If
he'd appreciated the problem in the first place, he would have sought
such help before now.  In any case, it would be disrespectful to let
someone waste time continuing to do a job no one will pay attention
to.</para>

<para>The most important factor in asking someone to step down is
privacy: giving him the space to make a decision without feeling like
others are watching and waiting.  I once made the mistake&mdash;an
obvious mistake, in retrospect&mdash;of mailing all three parties at
once in order to ask Subversion's release manager to step aside in
favor of two other volunteers.  I'd already talked to the two new
people privately, and knew that they were willing to take on the
responsibility.  So I thought, na&iuml;vely and somewhat
insensitively, that I'd save some time and hassle by sending one mail
to all of them to initiate the transition.  I assumed that the current
release manager was already fully aware of the problems and would see
the reasonableness of my point immediately.</para>

<para>I was wrong.  The current release manager was very offended, and
rightly so.  It's one thing to be asked to hand off the job; it's
another thing to be asked that <emphasis>in front of</emphasis> the
people you'll hand it off to.  Once I got it through my head why he
was offended, I apologized.  He eventually did step aside gracefully,
and continues to be involved with the project today.  But his
feelings were hurt, and needless to say, this was not the most
auspicious of beginnings for the new volunteers either.</para>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="committers">
<title>Committers</title>

<para>As the only formally distinct class of people found in all open
source projects, committers deserve special attention here.
Committers are an unavoidable concession to discrimination in a system
which is otherwise as non-discriminatory as possible.  But
"discrimination" is not meant as a pejorative here.  The function
committers perform is utterly necessary, and I do not think a project
could succeed without it.  Quality control requires, well, control.
There are always many people who feel competent to make changes to a
program, and some smaller number who actually are.  The project cannot
rely on people's own judgement; it must impose standards and grant
commit access only to those who meet them<footnote><para>Note that the
commit access means something a bit different in decentralized version
control systems, where anyone can set up a repository that is linked
into the project, and give themselves commit access to that
repository.  Nevertheless, the <emphasis>concept</emphasis> of commit
access still applies: "commit access" is shorthand for "the
right to make changes to the code that will ship in the group's next
release of the software."  In centralized version control systems,
this means having direct commit access; in decentralized ones, it
means having one's changes pulled into the main distribution by
default.  It is the same idea either way; the mechanics by which it is
realized are not terribly important.</para></footnote>.  On the other
hand, having people who can commit changes directly working
side-by-side with people who cannot sets up an obvious power dynamic.
That dynamic must be managed so that it does not harm the
project.</para>

<para>In <xref linkend="electorate"/><phrase output="printed">
in <xref linkend="social-infrastructure"/></phrase>, we already
discussed the mechanics of considering new committers.  Here we will
look at the standards by which potential new committers should be
judged, and how this process should be presented to the larger
community.</para>

<!-- ======================== subsection ============================== -->
<sect2 id="choosing-committers">
<title>Choosing Committers</title>

<para>In the Subversion project, we choose committers primarily on the
Hippocratic Principle: <emphasis>first, do no harm</emphasis>.  Our
main criterion is not technical skill or even knowledge of the code,
but merely that the committer show good judgement.  Judgement can mean
simply knowing what not to take on.  A person might post only small
patches, fixing fairly simple problems in the code; but if the patches
apply cleanly, do not contain bugs, and are mostly in accord with the
project's log message and coding conventions, and there are enough
patches to show a clear pattern, then an existing committer will
usually propose that person for commit access.  If at least three
people say yes, and no one objects, then the offer is made.  True, we
might have no evidence that the person is able to solve complex
problems in all areas of the code base, but that does not matter: the
person has made it clear that he is capable of at least judging
his own abilities.  Technical skills can be learned (and taught),
but judgement, for the most part, cannot.  Therefore, it is the one
thing you want to make sure a person has before you give him commit
access.</para>

<para>When a new committer proposal does provoke a discussion, it is
usually not about technical ability, but rather about the person's
behavior on the mailing lists or in IRC.  Sometimes someone shows
technical skill and an ability to work within the project's formal
guidelines, yet is also consistently belligerent or uncooperative in
public forums.  That's a serious concern; if the person doesn't
seem to shape up over time, even in response to hints, then we won't
add him as a committer no matter how skilled he is.  In a
volunteer group, social skills, or the ability to "play well in the
sandbox", are as important as raw technical ability.  Because
everything is under version control, the penalty for adding a
committer you shouldn't have is not so much the problems it could
cause in the code (review would spot those quickly anyway), but that
it might eventually force the project to revoke the person's commit
access&mdash;an action that is never pleasant and can sometimes be
confrontational.</para>

<para>Many projects insist that the potential committer demonstrate a
certain level of technical expertise and persistence, by submitting
some number of nontrivial patches&mdash;that is, not only do these
projects want to know that the person will do no harm, they want to
know that she is likely to do good across the code base.  This is
fine, but be careful that it doesn't start to turn committership into
a matter of membership in an exclusive club.  The question to keep in
everyone's mind should be "What will bring the best results for the
code?" not "Will we devalue the social status associated with
committership by admitting this person?"  The point of commit access
is not to reinforce people's self-worth, it's to allow good changes to
enter the code with a minimum of fuss.  If you have 100
committers, 10 of whom make large changes on a regular basis, and the
other 90 of whom just fix typos and small bugs a few times a year,
that's still better than having only the 10.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="revoking-committers">
<title>Revoking Commit Access</title>

<para>The first thing to be said about revoking commit access is: try
not to be in that situation in the first place.  Depending on whose
access is being revoked, and why, the discussions around such an
action can be very divisive.  Even when not divisive, they will be a
time-consuming distraction from productive work.</para>

<para>However, if you must do it, the discussion should be had
privately among the same people who would be in a position to vote for
<emphasis>granting</emphasis> that person whatever flavor of commit
access they currently have.  The person herself should not be
included.  This contradicts the usual injunction against secrecy, but
in this case it's necessary.  First, no one would be able to speak
freely otherwise.  Second, if the motion fails, you don't necessarily
want the person to know it was ever considered, because that could
open up questions ("Who was on my side?  Who was against me?") that
lead to the worst sort of factionalism.  In certain rare
circumstances, the group may want someone to know that revocation of
commit access is or was being considered, as a warning, but this
openness should be a decision the group makes.  No one should ever, on
her own initiative, reveal information from a discussion and ballot
that others assumed were secret.</para>

<para>Once someone's access is revoked, that fact is unavoidably
public (see
<xref linkend="commit-access-openness"/><phrase output="printed">
later in this chapter</phrase>), so try to be as tactful as you can in
how it is presented to the outside world.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="partial-committers">
<title>Partial Commit Access</title>

<para>Some projects offer gradations of commit access.  For example,
there might be contributors whose commit access gives them free rein
in the documentation, but who do not commit to the code itself.
Common areas for partial commit access include documentation,
translations, binding code to other programming languages,
specification files for packaging (e.g., RedHat RPM spec files,
etc.), and other places where a mistake will not result in a problem for
the core project.</para>

<para>Since commit access is not only about committing, but about
being part of an electorate (see
<xref linkend="electorate"/><phrase output="printed"> in
<xref linkend="social-infrastructure"/></phrase>),
the question naturally arises: what can the partial committers vote
on?  There is no one right answer; it depends on what sorts of partial
commit domains your project has.  In Subversion we've kept things
fairly simple: a partial committer can vote on matters confined
exclusively to that committer's domain, and not on anything else.
Importantly, we do have a mechanism for casting advisory votes
(essentially, the committer writes "+0" or "+1&nbsp;(non-binding)"
instead of just "+1" on the ballot).  There's no reason to silence
people entirely just because their vote isn't formally binding.</para>

<para>Full committers can vote on anything, just as they can commit
anywhere, and only full committers vote on adding new committers of
any kind.  In practice, though, the ability to add new partial
committers is usually delegated: any full committer can "sponsor" a
new partial committer, and partial committers in a domain can often
essentially choose new committers for that same domain (this is
especially helpful in making translation work run smoothly).</para>

<para>Your project may need a slightly different arrangement,
depending on the nature of the work, but the same general principles
apply to all projects.  Each committer should be able to vote on
matters that fall within the scope of her commit access, and not on
matters outside that, and votes on procedural questions should default
to the full committers, unless there's some reason (as decided by the
full committers) to widen the electorate.</para>

<para>Regarding enforcement of partial commit access: it's often
best <emphasis>not</emphasis> to have the version control system
enforce partial commit domains, even if it can.  See
<xref linkend="vc-authz"/><phrase output="printed"> in
<xref linkend="technical-infrastructure"/></phrase> for the
reasons why.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="dormant-committers">
<title>Dormant Committers</title>

<para>Some projects automatically remove people's commit access if
they go a certain amount of time (say, a year) without committing
anything.  I think this is usually unhelpful and even
counterproductive, for two reasons.</para>

<para>First, it may tempt some people into committing acceptable but
unnecessary changes, just to prevent their commit access from
expiring.  Second, it doesn't really serve any purpose.  If the
main criterion for granting commit access is good judgement, then why
assume someone's judgement would deteriorate just because he's away
from the project for a while?  Even if he completely vanishes for
years, not looking at the code or following development discussions,
when he reappears he'll <emphasis>know</emphasis> how out of touch
he is, and act accordingly.  You trusted his judgement before, so
why not trust it always?  If high school diplomas do not expire, then
commit access certainly shouldn't.</para>

<para>Sometimes a committer may ask to be removed, or to be explicitly
marked as dormant in the list of committers (see
<xref linkend="commit-access-openness"/><phrase output="printed">
below</phrase> for more about that list).  In these cases, the project
should accede to the person's wishes, of course.</para>

</sect2>

<!-- ======================== subsection ============================== -->
<sect2 id="commit-access-openness">
<title>Avoid Mystery</title>

<para>Although the discussions around adding any particular new
committer must be confidential, the rules and procedures themselves
need not be secret.  In fact, it's best to publish them, so people
realize that the committers are not some mysterious Star Chamber,
closed off to mere mortals, but that anyone can join simply by posting
good patches and knowing how to handle herself in the community.
In the Subversion project, we put this information right in the
developer guidelines document, since the people most likely to be
interested in how commit access is granted are those thinking of
contributing code to the project.</para>

<para>In addition to publishing the procedures, publish the
actual <emphasis>list</emphasis> of committers.  The traditional place
for this is a file called <filename>MAINTAINERS</filename>
or <filename>COMMITTERS</filename> in the top level of the project's
source code tree.  It should list all the full committers first,
followed by the various partial commit domains and the members of each
domain.  Each person should be listed by name and email address,
though the address can be encoded to prevent spam (see
<xref linkend="address-hiding"/><phrase output="printed"> in
<xref linkend="technical-infrastructure"/></phrase>) if the
person prefers that.</para>

<para>Since the distinction between full commit and partial commit
access is obvious and well defined, it is proper for the list to make
that distinction too.  Beyond that, the list should not try to
indicate the informal distinctions that inevitably arise in a project,
such as who is particularly influential and how.  It is a public
record, not an acknowledgments file.  List committers either in
alphabetical order, or in the order in which they arrived.</para>

</sect2>

</sect1>


<!-- ======================== SECTION ============================== -->
<sect1 id="credit">
<title>Credit</title>

<para>Credit is the primary currency of the free software world.
Whatever people may say about their motivations for participating in a
project, I don't know any developers who would be happy doing all
their work anonymously, or under someone else's name.  There are
tangible reasons for this: one's reputation in a project roughly
governs how much influence one has, and participation in an open
source project can also indirectly have monetary value, because
some employers now look for it on resum&eacute;s.  There are also
intangible reasons, perhaps even more powerful: people simply want to
be appreciated, and instinctively look for signs that their work was
recognized by others.  The promise of credit is therefore one of best
motivators the project has.  When small contributions are
acknowledged, people come back to do more.</para>

<para>One of the most important features of collaborative development
software (see <xref linkend="technical-infrastructure"/>) is that
it keeps accurate records of who did what, when.  Wherever possible,
use these existing mechanisms to make sure that credit is distributed
accurately, and be specific about the nature of the contribution.
Don't just write "Thanks to J. Random &lt;jrandom@example.com&gt;" if
instead you can write "Thanks to J. Random &lt;jrandom@example.com&gt;
for the bug report and reproduction recipe" in a log message.</para>

<para>In Subversion, we have an informal but consistent policy of
crediting the reporter of a bug in either the issue filed, if there is
one, or the log message of the commit that fixes the bug, if not.  A
quick survey of Subversion commit logs up to commit number 14525 shows
that about 10% of commits give credit to someone by name and email
address, usually the person who reported or analyzed the bug fixed by
that commit.  Note that this person is different from the developer
who actually made the commit, whose name is already recorded
automatically by the version control system.  Of the 80-odd full and
partial committers Subversion has today, 55 were credited in the
commit logs (usually multiple times) before they became committers
themselves.  This does not, of course, prove that being credited was a
factor in their continued involvement, but it at least sets up an
atmosphere in which people know they can count on their contributions
being acknowledged.</para>

<para>It is important to distinguish between routine acknowledgment
and special thanks.  When discussing a particular piece of code, or
some other contribution someone made, it is fine to acknowledge their
work.  For example, saying "Daniel's recent changes to the delta code
mean we can now implement feature X" simultaneously helps people
identify which changes you're talking about and acknowledges Daniel's
work.  On the other hand, posting solely to thank Daniel for the delta
code changes serves no immediate practical purpose.  It doesn't add
any information, since the version control system and other mechanisms
have already recorded the fact that he made the changes.  Thanking
everyone for everything would be distracting and ultimately
information-free, since thanks are effective largely by how much they
stand out from the default, background level of favorable comment
going on all the time.  This does not mean, of course, that you should
never thank people.  Just make sure to do it in ways that tend not to
lead to credit inflation.  Following these guidelines will
help:</para>

<itemizedlist>
  <listitem><para>The more ephemeral the forum, the more free you
            should feel to express thanks there.  For example,
            thanking someone for their bugfix in passing during an IRC
            conversation is fine, as is an aside in an email devoted
            mainly to other topics.  But don't post an email solely to
            thank someone, unless it's for a truly unusual feat.
            Likewise, don't clutter the project's web pages with
            expressions of gratitude.  Once you start that, it'll
            never be clear when or where to stop. And
            <emphasis>never</emphasis> put thanks into comments in the
            code; that would only be a distraction from the primary
            purpose of comments, which is to help the reader
            understand the code.</para> 
  </listitem>
  <listitem><para>The less involved someone is in the project, the
            more appropriate it is to thank her for something she
            did.  This may sound counterintuitive, but it fits with
            the attitude that expressing thanks is something you do
            when someone contributes even more than you thought she
            would.  Thus, to constantly thank regular contributors for
            doing what they normally do would be to express a lower
            expectation of them than they have of themselves.  If
            anything, you want to aim for the opposite effect!</para>

            <para>There are occasional exceptions to this rule.  It's
            acceptable to thank someone for fulfilling his expected
            role when that role involves temporary, intense efforts
            from time to time.  The canonical example is the release
            manager, who goes into high gear around the time of each
            release, but otherwise lies dormant (dormant as a release
            manager, in any case&mdash;he may also be an active
            developer, but that's a different matter).
            </para>
  </listitem>
  <listitem><para>As with criticism and crediting, gratitude should
            be specific.  Don't thank people just for being great,
            even if they are.  Thank them for something they did that
            was out of the ordinary, and for bonus points, say
            exactly why what they did was so great.</para> 
  </listitem>
</itemizedlist>

<para>In general, there is always a tension between making sure that
people's individual contributions are recognized, and making sure the
project is a group effort rather than a collection of individual
glories.  Just remain aware of this tension and try to err on the
side of group, and things won't get out of hand.</para>

</sect1>

<!-- ======================== SECTION ============================== -->
<sect1 id="forks">
<title>Forks</title>

<para>In <xref linkend="forkability"/><phrase output="printed">
in <xref linkend="social-infrastructure"/></phrase>, we saw how
the <emphasis>potential</emphasis> to fork has important effects on
how projects are governed.  But what happens when a fork actually
occurs?  How should you handle it, and what effects can you expect it
to have?  Conversely, when should you <emphasis>initiate</emphasis> a
fork?</para>

<para>The answers depend on what kind of fork it is.  Some forks are
due to amicable but irreconcilable disagreements about the direction
of the project; perhaps more are due to both technical disagreements
and interpersonal conflicts.  Of course, it's not always possible to
tell the difference between the two, as technical arguments may
involve personal elements as well.  What all forks have in common is
that one group of developers (or sometimes even just one developer)
has decided that the costs of working with some or all of the others
now outweigh the benefits.</para>

<para>Once a project forks, there is no definitive answer to the
question of which fork is the "true" or "original" project.  People
will colloquially talk of fork F coming out of project P, as though P
is continuing unchanged down some natural path while F diverges into
new territory, but this is, in effect, a declaration of how that
particular observer feels about it.  It is fundamentally a matter of
perception: when a large enough percentage of observers agree, the
assertion starts to become true.  It is not the case that there is an
objective truth from the outset, one that we are only imperfectly able to
perceive at first.  Rather, the perceptions <emphasis>are</emphasis>
the objective truth, since ultimately a project&mdash;or a
fork&mdash;is an entity that exists only in people's minds
anyway.</para>

<para>If those initiating the fork feel that they are
sprouting a new branch off the main project, the perception question
is resolved immediately and easily.  Everyone, both developers and
users, will treat the fork as a new project, with a new name (perhaps
based on the old name, but easily distinguishable from it), a separate
web site, and a separate philosophy or goal.  Things get messier,
however, when both sides feel they are the legitimate guardians of the
original project and therefore have the right to continue using the
original name.  If there is some organization with trademark rights to
the name, or legal control over the domain or web pages, that usually
resolves the issue by fiat: that organization will decide who is the
project and who is the fork, because it holds all the cards in a
public relations war.  Naturally, things rarely get that far: since
everyone already knows what the power dynamics are, they will avoid
fighting a battle whose outcome is known in advance, and just jump
straight to the end.</para>

<para>Fortunately, in most cases there is little doubt as to which is
the project and which is the fork, because a fork is, in essence, a vote
of confidence.  If more than half of the developers are in favor of
whatever course the fork proposes to take, usually there is no need to
fork&mdash;the project can simply go that way itself, unless it is run
as a dictatorship with a particularly stubborn dictator.  On the other
hand, if fewer than half of the developers are in favor, the fork is a
clearly minority rebellion, and both courtesy and common sense
indicate that it should think of itself as the divergent branch rather
than the main line.</para>

<sect2 id="forks-handling">
<title>Handling a Fork</title>

<para>If someone threatens a fork in your project, keep calm and
remember your long-term goals.  The mere
<emphasis>existence</emphasis> of a fork isn't what hurts a project;
rather, it's the loss of developers and users.  Your real aim,
therefore, is not to squelch the fork, but to minimize these harmful
effects.  You may be mad, you may feel that the fork was unjust and
uncalled for, but expressing that publicly can only alienate undecided
developers.  Instead, don't force people to make exclusive choices,
and be as cooperative as is practicable with the fork.  To start with,
don't remove someone's commit access in your project just because he
decided to work on the fork.  Work on the fork doesn't mean that
person has suddenly lost his competence to work on the original
project; committers before should remain committers afterward.  Beyond
that, you should express your desire to remain as compatible as
possible with the fork, and say that you hope developers will port
changes between the two whenever appropriate.  If you have
administrative access to the project's servers, publicly offer the
forkers infrastructure help at startup time.  For example, offer them
a complete, deep-history copy of the version control repository, if
there's no other way for them to get it, so that they don't have to
start off without historical data (this may not be necessary depending
on the version control system).  Ask them if there's anything else
they need, and provide it if you can.  Bend over backward to show
that you are not standing in the way, and that you want the fork to
succeed or fail on its own merits and nothing else.</para>

<para>The reason to do all this&mdash;and do it publicly&mdash;is not
to actually help the fork, but to persuade developers that your side
is a safe bet, by appearing as non-vindictive as possible.  In war it
sometimes makes sense (strategic sense, if not human sense) to force
people to choose sides, but in free software it almost never does.  In
fact, after a fork some developers often openly work on both projects,
and do their best to keep the two compatible.  These developers help
keep the lines of communication open after the fork.  They allow your
project to benefit from interesting new features in the fork (yes, the
fork may have things you want), and also increase the chances of a
merger down the road.</para>

<para>Sometimes a fork becomes so successful that, even though it was
regarded even by its own instigators as a fork at the outset, it
becomes the version everybody prefers, and eventually supplants the
original by popular demand.  A famous instance of this was the
GCC/EGCS fork.  The <firstterm>GNU Compiler Collection</firstterm>
(<firstterm>GCC</firstterm>, formerly the <firstterm>GNU C
Compiler</firstterm>) is the most popular open source native-code
compiler, and also one of the 
most portable compilers in the world.  Due to disagreements between the GCC's
official maintainers and Cygnus Software,<footnote><para>Now part of
RedHat (<ulink url="http://www.redhat.com/"/>).</para></footnote> one
of GCC's most active developer groups, Cygnus created a fork of GCC
called <firstterm>EGCS</firstterm>.  The fork was deliberately
non-adversarial: the EGCS developers did not, at any point, try to
portray their version of GCC as a new official version.  Instead, they
concentrated on making EGCS as good as possible, incorporating patches
at a faster rate than the official GCC maintainers.  EGCS gained in
popularity, and eventually some major operating system distributors
decided to package EGCS as their default compiler instead of GCC.  At
this point, it became clear to the GCC maintainers that holding on to
the "GCC" name while everyone switched to the EGCS fork would burden
everyone with a needless name change, yet do nothing to prevent the
switchover.  So GCC adopted the EGCS codebase, and there is once again
a single GCC, but greatly improved because of the fork.</para>

<para>This example shows why you cannot always regard a fork as an
unadulteratedly bad thing.  A fork may be painful and unwelcome at the
time, but you cannot necessarily know whether it will succeed.
Therefore, you and the rest of the project should keep an eye on it,
and be prepared not only to absorb features and code where possible,
but in the most extreme case to even join the fork if it gains the
bulk of the project's mindshare.  Of course, you will often be able to
predict a fork's likelihood of success by seeing who joins it.  If the
fork is started by the project's biggest complainer and joined by a
handful of disgruntled developers who weren't behaving constructively
anyway, they've essentially solved a problem for you by forking, and
you probably don't need to worry about the fork taking momentum away
from the original project.  But if you see influential and respected
developers supporting the fork, you should ask yourself why.  Perhaps
the project was being overly restrictive, and the best solution is to
adopt into the mainline project some or all of the actions
contemplated by the fork&mdash;in essence, to avoid the fork by
becoming it.</para>

</sect2>

<sect2 id="forks-initiating">
<title>Initiating a Fork</title>

<para>All the advice here assumes that you are forking as a last
resort.  Exhaust all other possibilities before starting a fork.
Forking almost always means losing developers, with only an uncertain
promise of gaining new ones later.  It also means starting out with
competition for users' attention: everyone who's about to download the
software has to ask themselves: "Hmm, do I want that one or the other
one?"  Whichever one you are, the situation is messy, because a
question has been introduced that wasn't there before.  Some people
maintain that forks are healthy for the software ecosystem as a whole,
by a standard natural selection argument: the fittest will survive,
which means that, in the end, everyone gets better software.  This may
be true from the ecosystem's point of view, but it's not true from the
point of view of any individual project.  Most forks do not succeed,
and most projects are not happy to be forked.</para>

<para>A corollary is that you should not use the threat of a fork as
an extremist debating technique&mdash;"Do things my way or I'll fork
the project!"&mdash;because everyone is aware that a fork that fails
to attract developers away from the original project is unlikely to
survive long.  All observers&mdash;not just developers, but users and
operating system packagers too&mdash;will make their own judgement about
which side to choose.  You should therefore appear extremely reluctant
to fork, so that if you finally do it, you can credibly claim it was
the only route left.</para>

<para>Do not neglect to take <emphasis>all</emphasis> factors into
account in evaluating the potential success of your fork.  For
example, if many of the developers on a project have the same
employer, then even if they are disgruntled and privately in favor of
a fork, they are unlikely to say so out loud if they know that their
employer is against it.  Many free software programmers like to think
that having a free license on the code means no one company can
dominate development.  It is true that the license is, in an ultimate
sense, a guarantor of freedom&mdash;if others want badly enough to
fork the project, and have the resources to do so, they can.  But in
practice, some projects' development teams are mostly funded by one
entity, and there is no point pretending that that entity's support
doesn't matter.  If it is opposed to the fork, its developers are
unlikely to take part, even if they secretly want to.</para>

<para>If you still conclude that you must fork, line up support
privately first, then announce the fork in a non-hostile tone.  Even
if you are angry at, or disappointed with, the current maintainers,
don't say that in the message.  Just dispassionately state what led
you to the decision to fork, and that you mean no ill will toward the
project from which you're forking.  Assuming that you do consider it a
fork (as opposed to an emergency preservation of the original
project), emphasize that you're forking the code and not the name, and
choose a name that does not conflict with the project's name.  You can
use a name that contains or refers to the original name, as long as it
does not open the door to identity confusion.  Of course it's fine to
explain prominently on the fork's home page that it descends from the
original program, and even that it hopes to supplant it.  Just don't
make users' lives harder by forcing them to untangle an identity
dispute.</para>

<para>Finally, you can get things started on the right foot by
automatically granting all committers of the original project commit
access to the fork, including even those who openly disagreed with the
need for a fork.  Even if they never use the access, your message is
clear: there are disagreements here, but no enemies, and you welcome
code contributions from any competent source.</para>

</sect2>

</sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->

# vim: tw=72
